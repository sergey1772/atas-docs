ИНДИКАТОРЫ ИЗ ОФИЦИАЛЬНОЙ ДИРЕКТОРИИ АТАС НА ГИТХАБЕ  : 



https://github.com/AtasPlatform/Indicators/blob/Develop/Technical/MaxLevels.cs



namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Linq;
	using System.Reflection;

	using OFT.Attributes;
    using OFT.Attributes.Editors;
    using OFT.Localization;
    using OFT.Rendering.Context;
    using OFT.Rendering.Tools;
    [DisplayName("Maximum Levels")]
	[Category(IndicatorCategories.VolumeOrderFlow)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MaxLevelsIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602426")]
    public class MaxLevels : Indicator
	{
		#region Nested types

		[Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
		public enum MaxLevelType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
			Bid,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
			Ask,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PositiveDelta))]
			PositiveDelta,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.NegativeDelta))]
			NegativeDelta,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
			Volume,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Tick,

			[Obsolete]
			[Browsable(false)]
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Time))]
			Time
		}

		private sealed class TradingSessionsSource(MaxLevels indicator)
			: Collection<TradingSessionDescription>(indicator.DataProvider?.ChartInfo?.TradingSessionDescriptions?.ToList() ?? [])
		{
		}

        #endregion

        #region Fields

        private RenderFont _axisFont = new("Arial", 11F, FontStyle.Regular, GraphicsUnit.Point, 204);
		private Color _axisTextColor = System.Drawing.Color.White;
		private IndicatorCandle _candle;
		private bool _candleRequested;
		private string _description = "Current Day";
		private RenderFont _font = new("Arial", 10);
		private int _lastAlert;
		private int _lastSession;
		private Color _lineColor = System.Drawing.Color.CornflowerBlue;
		private FixedProfilePeriods _period = FixedProfilePeriods.CurrentDay;
		private long? _tradingSession;
		private decimal _prevClose;
		private RenderPen _renderPen = new(System.Drawing.Color.CornflowerBlue, 2);

		private RenderStringFormat _stringRightFormat = new()
		{
			Alignment = StringAlignment.Far,
			LineAlignment = StringAlignment.Center,
			Trimming = StringTrimming.EllipsisCharacter,
			FormatFlags = StringFormatFlags.NoWrap
		};

		private Color _textColor = System.Drawing.Color.Black;
		private int _width = 2;

        #endregion

        #region Properties

        #region Calculation

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.Period), Description = nameof(Strings.ProfilePeriodDescription), Order = 10)]
		public FixedProfilePeriods Period
		{
			get => _period;
			set
			{
				_period = value;
				_description = GetPeriodDescription(_period);
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			GroupName = nameof(Strings.Calculation),
			Name = nameof(Strings.TradingSession),
			Description = nameof(Strings.TradingSessionDescription),
            Order = 15)]
		[ComboBoxEditor(typeof(TradingSessionsSource), 
			DisplayMember = nameof(TradingSessionDescription.Name), 
			ValueMember = nameof(TradingSessionDescription.Id),
			SelectItemWithNullValue = true)]
        public long? TradingSession
        {
			get => _tradingSession;
			set
			{
				if (_tradingSession == value)
					return;

				_tradingSession = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.Type), Description = nameof(Strings.SourceTypeDescription), Order = 20)]
		public MaxLevelType Type { get; set; } = MaxLevelType.Volume;

        #endregion

        #region Visualization

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Color), Description = nameof(Strings.LineColorDescription), Order = 30)]
		public CrossColor Color
		{
			get => _lineColor.Convert();
			set
			{
				_lineColor = value.Convert();
				_renderPen = new RenderPen(_lineColor, _width);
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Width), Description = nameof(Strings.LineWidthDescription), Order = 40)]
		[Range(1, 100)]
		public int Width
		{
			get => _width;
			set
			{
				_width = value;
				_renderPen = new RenderPen(_lineColor, _width);
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Length), Description = nameof(Strings.LineLengthDescription), Order = 45)]
		[Range(1, 10000)]
		public int Length { get; set; } = 300;

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.AxisTextColor), Description = nameof(Strings.AxisTextColorDescription), Order = 50)]
		public CrossColor AxisTextColor
		{
			get => _axisTextColor.Convert();
			set => _axisTextColor = value.Convert();
		}

        #endregion

        #region Label

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.LabelOffset), Description = nameof(Strings.LabelOffsetXDescription), Order = 51)]
		[Range(0, 10000)]
        public int LabelOffset { get; set; }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Text), Description = nameof(Strings.IsNeedShowLabelDescription), Order = 52)]
		public bool ShowText { get; set; } = true;

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.CustomLabel), Description = nameof(Strings.LabelTextDescription), Order = 54)]
		public String CustomLabel { get; set; }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Value), Description = nameof(Strings.ShowValueOnLabelDescription), Order = 55)]
		public bool ShowValue { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Color), Description = nameof(Strings.LabelTextColorDescription), Order = 60)]
		public CrossColor TextColor
		{
			get => _textColor.Convert();
			set => _textColor = value.Convert();
		}

        [Range(7, 100)]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Size), Description = nameof(Strings.FontSizeDescription), Order = 70)]
		public int FontSize
		{
			get => (int)_font.Size;
			set => _font = new RenderFont("Arial", value);
		}

        #endregion

        #region Alerts

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertDescription), Order = 100)]
		public bool UseAlert { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 110)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 120)]
		public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 130)]
		public CrossColor AlertBgColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

        #endregion

        #endregion

        #region ctor

        public MaxLevels()
			: base(true)
		{
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.LatestBar | DrawingLayouts.Historical);
			DrawAbovePrice = true;
		}

		#endregion

		#region Protected methods
		
		protected override void OnApplyDefaultColors()
		{
			if (ChartInfo is null)
				return;

			AxisTextColor = ChartInfo.ColorsStore.AxisTextColor.Convert();
			TextColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor.Convert();
        }
		
		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_lastAlert = 0;
				_prevClose = GetCandle(CurrentBar - 1).Close;
			}

			if (bar == 0 || IsNewSession(bar) && _lastSession != bar)
				_candleRequested = false;

			if (bar != CurrentBar - 1)
				return;

			if (!_candleRequested)
			{
				_candleRequested = true;
				GetFixedProfile(new FixedProfileRequest(Period, TradingSession));
				_lastSession = bar;
			}

			var candle = GetCandle(bar);

			if (UseAlert && _lastAlert != bar && _candle is not null)
			{
				var priceInfo = GetPriceVolumeInfo(_candle, Type);

				if (candle.Close >= priceInfo.Price && _prevClose < priceInfo.Price
				    ||
				    candle.Close <= priceInfo.Price && _prevClose > priceInfo.Price)
				{
					AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached maximum level: {priceInfo.Price}", AlertBgColor, AlertForeColor);
					_lastAlert = bar;
				}
			}

			_prevClose = candle.Close;
		}

		protected override void OnFixedProfilesResponse(IndicatorCandle fixedProfileScaled, IndicatorCandle fixedProfileOriginScale, FixedProfilePeriods period)
		{
			_candle = fixedProfileOriginScale;
			RedrawChart();
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			if(ChartInfo is null || InstrumentInfo is null)
				return;

			if (_candle == null)
				return;

			var priceInfo = GetPriceVolumeInfo(_candle, Type);

			if (priceInfo == null)
				return;

			var y = ChartInfo.GetYByPrice(priceInfo.Price, false);
			var firstX = ChartInfo.PriceChartContainer.Region.Width - Length;
			var secondX = ChartInfo.PriceChartContainer.Region.Width;

			context.DrawLine(_renderPen, firstX, y, secondX, y);

			this.DrawLabelOnPriceAxis(context, string.Format(ChartInfo.StringFormat, priceInfo.Price), y, _axisFont, _lineColor, _axisTextColor);

			if (!ShowText && !ShowValue)
				return;

			var renderText = "";

			if (ShowText)
				renderText += string.IsNullOrWhiteSpace(CustomLabel) ? _description : CustomLabel;

            if (ShowValue)
			{
				var value = Type switch
				{
					MaxLevelType.Bid => priceInfo.Bid,
					MaxLevelType.Ask => priceInfo.Ask,
					MaxLevelType.PositiveDelta => priceInfo.Ask - priceInfo.Bid,
					MaxLevelType.NegativeDelta => priceInfo.Ask - priceInfo.Bid,
					MaxLevelType.Tick => priceInfo.Ticks,
					MaxLevelType.Time => priceInfo.Time,
					_ => priceInfo.Volume
				};

				var stringValue = CutValue(value);

				if (ShowText)
					renderText += " " + stringValue;
			}

			var size = context.MeasureString(renderText, _font);

			var textRect = new Rectangle(new Point(ChartInfo.PriceChartContainer.Region.Width - size.Width - 20 - LabelOffset, y - size.Height - Width / 2),
				new Size(size.Width + 20, size.Height));

			context.SetTextRenderingHint(RenderTextRenderingHint.Aliased);
			context.DrawString(renderText, _font, _textColor, textRect, _stringRightFormat);
			context.SetTextRenderingHint(RenderTextRenderingHint.AntiAlias);
		}

		#endregion

		#region Private methods

		private string CutValue(decimal value)
		{
			var kValue = value / 1000;
			var mValue = value / 1000000;

			if (kValue < 1)
				return $"{value:0.##}";

			return mValue < 1
				? $"{kValue:0.##}K"
				: $"{mValue:0.##}M";
		}

		private string GetPeriodDescription(FixedProfilePeriods period)
		{
			return period switch
			{
				FixedProfilePeriods.CurrentDay => "Current day",
				FixedProfilePeriods.LastDay => "Last day",
				FixedProfilePeriods.CurrentWeek => "Current week",
				FixedProfilePeriods.LastWeek => "Last week",
				FixedProfilePeriods.CurrentMonth => "Current month",
				FixedProfilePeriods.LastMonth => "Last month",
				FixedProfilePeriods.Contract => "Contract",
				_ => throw new ArgumentOutOfRangeException(nameof(period), period, null)
			};
		}

		private PriceVolumeInfo GetPriceVolumeInfo(IndicatorCandle candle, MaxLevelType levelType)
		{
			return Type switch
			{
				MaxLevelType.Bid => _candle.MaxBidPriceInfo,
				MaxLevelType.Ask => _candle.MaxAskPriceInfo,
				MaxLevelType.PositiveDelta => _candle.MaxPositiveDeltaPriceInfo,
				MaxLevelType.NegativeDelta => _candle.MaxNegativeDeltaPriceInfo,
				MaxLevelType.Volume => _candle.MaxVolumePriceInfo,
				MaxLevelType.Tick => _candle.MaxTickPriceInfo,
				MaxLevelType.Time => _candle.MaxTimePriceInfo,
				_ => throw new ArgumentOutOfRangeException()
			};
		}

		#endregion
	}
}






Technical/DomV3/Function.cs



using System.Drawing;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

namespace DomV10;

using System;

public partial class MainIndicator
{
    private RenderFont _font = new RenderFont("Arial", 0);
    private decimal _cacheMaxHeight;
    private (float fontSize, float fontWidth) _cacheFontSize;

    private RenderStringFormat _stringCenterFormat = new()
    {
        Alignment = StringAlignment.Center,
        LineAlignment = StringAlignment.Center,
        Trimming = StringTrimming.EllipsisCharacter,
        FormatFlags = StringFormatFlags.NoWrap
    };

    private readonly RenderStringFormat _stringLeftFormat = new RenderStringFormat()
    {
        Alignment = StringAlignment.Near,
        LineAlignment = StringAlignment.Center,
        Trimming = StringTrimming.EllipsisCharacter,
        FormatFlags = StringFormatFlags.NoWrap
    };

    private readonly RenderStringFormat _stringRightFormat = new RenderStringFormat()
    {
        Alignment = StringAlignment.Far,
        LineAlignment = StringAlignment.Center,
        Trimming = StringTrimming.EllipsisCharacter,
        FormatFlags = StringFormatFlags.NoWrap
    };

    private int ItemWidthCalculation(decimal currentVol, decimal totalVolume, int maxScreenSize, int itemCount,
        int space, decimal fontWidth)
    {
        var eachPic = ((decimal)maxScreenSize / totalVolume);
        var w = (int)(eachPic * currentVol);
        if (w < fontWidth) return (int)Math.Max(fontWidth, 1);
        return w;
    }

    private (float fontSize, float fontWidth) SetFontSize(RenderContext context, decimal maxHeight)
    {
	    var maxFontSize = 15;

        if (maxHeight < 2) 
	        return (0, 0);

        if (maxHeight == _cacheMaxHeight)
	        return _cacheFontSize;

        var direction = 0;
        var bestSize = (float)maxFontSize;
        var bestW = 0;
        var increment = 0.1m;

        var x = 0;

        var indicate = maxHeight - 2;
        
        if (indicate > maxFontSize) 
	        indicate = maxFontSize;

        _font = new RenderFont("Arial", (float)bestSize);
        do
        {
            var size = context.MeasureString("#", _font);
            var textSize = size.Height;

            if (size.Height == indicate)
            {
                bestSize = _font.Size;
                bestW = size.Width;
                break;
            }

            if (textSize < indicate)
            {
                if (direction == 0) direction = 1;
                if (direction == -1) break;

                bestSize = _font.Size;
                bestW = size.Width;

                _font = new RenderFont(_font.FontFamily, (float)((decimal)_font.Size + increment));
                continue;
            }

            if (textSize > indicate)
            {
                if (direction == 0) direction = -1;
                if (direction == 1) break;

                _font = new RenderFont(_font.FontFamily, (float)((decimal)_font.Size - increment));

                bestSize = _font.Size;
                bestW = size.Width;

                continue;
            }
        } while (x++ <= 100);

       _cacheFontSize = (bestSize, bestW);
        _cacheMaxHeight = maxHeight;

        return (bestSize, bestW);
    }

    private decimal GetFixPrice(decimal value, bool isTop)
    {
        if (InstrumentInfo == null) return value;
        var tick = InstrumentInfo.TickSize;
        var left = value % tick;
        value = value - left;
        if (isTop) value += tick;
        else value -= tick;
        if (isTop) value += tick;
        else value -= tick;
        return value;
    }
}





Technical/DomV3/MainIndicator.cs




using System.ComponentModel;
using System.Drawing;
using System.Timers;
using ATAS.DataFeedsCore;
using ATAS.Indicators;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;
using Utils.Common.Logging;
using MarketDataType = ATAS.DataFeedsCore.MarketDataType;
using Timer = System.Timers.Timer;

namespace DomV10;

using System;
using System.Collections.Generic;

using OFT.Attributes;

[DisplayName("MBO DOM")]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000633231")]
[Category(IndicatorCategories.OrderBook)]
public partial class MainIndicator : Indicator
{
    private MboGridController _gridController = new();
    private Timer _timer = new();
    private readonly object _renderLock = new();
    private MarketDataArg? _lastAsk = null;
    private MarketDataArg? _lastBid = null;
    private decimal _lastPrice = 0;

    public MainIndicator() : base(true)
    {
	    ((ValueDataSeries)DataSeries[0]).IsHidden = true;
	    EnableCustomDrawing = true;
        SubscribeToDrawingEvents(DrawingLayouts.Final);
        DenyToChangePanel = true;
    }

    protected override void OnDispose()
    {
        base.OnDispose();
        try
        {
            _timer.Enabled = false;
            _timer.Stop();
            _timer.Dispose();
        }
        catch
        {
            //ignored
        }
    }

    private void TickTok(object? sender, ElapsedEventArgs e)
    {
        _timer?.Stop();
        _gridController?.Tick();
        _timer?.Start();
    }

    protected override async void OnInitialize()
    {
        await SubscribeMarketByOrderData();
        _gridController = new();
        _timer = new Timer();
        _timer.Elapsed += TickTok;
        _timer.Interval = 1000;
        _timer.Enabled = true;
        _timer.Start();

        OrderSizeFilter.PropertyChanged += UpdateUi;
        MinBlockSize.PropertyChanged += UpdateUi;
        RowOrderVolume.PropertyChanged += UpdateUi;
        RowOrderCount.PropertyChanged += UpdateUi;
    }

    public override void Dispose()
    {
        base.Dispose();
        OrderSizeFilter.PropertyChanged -= UpdateUi;
        MinBlockSize.PropertyChanged -= UpdateUi;
        RowOrderVolume.PropertyChanged -= UpdateUi;
        RowOrderCount.PropertyChanged -= UpdateUi;
    }

    private void UpdateUi(object? sender, PropertyChangedEventArgs e) => RedrawChart(_emptyRedrawArg);

    protected override void OnApplyDefaultColors()
    {
        if (ChartInfo == null) 
	        return;

        _bidColor = ChartInfo.ColorsStore.UpCandleColor;
        _askColor = ChartInfo.ColorsStore.DownCandleColor;
        _textColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor;

        RedrawChart();
    }

    protected override void OnMarketByOrdersChanged(IEnumerable<MarketByOrder> orders)
    {
        if (!_gridController.Update(orders)) _gridController.Load(MarketByOrders);
    }

    protected override void MarketDepthChanged(MarketDataArg depth)
    {
        if (MarketDepthInfo == null) return;
        if (!_gridController.Update(depth)) _gridController.Load(MarketDepthInfo.GetMarketDepthSnapshot());
    }

    protected override void OnNewTrade(MarketDataArg trade)
    {
        _gridController.UpdateTrade(trade);
    }

    protected override void OnBestBidAskChanged(MarketDataArg depth)
    {
        base.OnBestBidAskChanged(depth);
        if (depth.IsAsk) _lastAsk = depth;
        if (depth.IsBid) _lastBid = depth;
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        _lastPrice = GetCandle(bar).Close;
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
	    try
	    {
		    lock (_renderLock)
		    {
			    if (ChartInfo == null)
				    return;

			    if (Container == null)
				    return;

			    if (InstrumentInfo == null)
				    return;

			    if (_lastAsk is null || _lastBid is null)
				    return;

			    var tickSize = InstrumentInfo.TickSize;
			    var fixHigh = GetFixPrice(ChartInfo.PriceChartContainer.High, true);
			    var fixLow = GetFixPrice(ChartInfo.PriceChartContainer.Low, false);

			    if (fixLow >= fixHigh)
				    return;

			    var yy1 = ChartInfo.GetYByPrice(ChartInfo.PriceChartContainer.High);
			    var yy2 = ChartInfo.GetYByPrice(ChartInfo.PriceChartContainer.Low);

			    var height = Math.Abs(yy2 - yy1) / ((ChartInfo.PriceChartContainer.High - ChartInfo.PriceChartContainer.Low) / InstrumentInfo.TickSize);

                var (fontSize, fontWidth) =
				    SetFontSize(context, ChartInfo.PriceChartContainer.PriceRowHeight);

			    var showSeparately = height >= 4.5m;

				var showText = fontSize >= 5;

                var maxScreenSize = Container.RelativeRegion.Width * 0.5m;
			    var (maxVol, maxCount) = _gridController.MaxInView(fixHigh, fixLow, tickSize, true);

			    var aggregationBaseRow = new Rectangle() { X = Container.RelativeRegion.Right - 1, Width = 0, };

			    if (showText && (ShowSum || ShowCount))
			    {
				    var maxWidth = (int)(((ShowSum ? 1 : 0) + (ShowCount ? 1 : 0)) * 6 * fontWidth);

				    if (maxWidth > 0)
				    {
					    aggregationBaseRow.X -= maxWidth;
					    aggregationBaseRow.Width = maxWidth;
				    }
			    }

			    var prevY = 0;
			    Dictionary<decimal, int> tempSize = new();
			    Rectangle selectedRectangle = new();
			    string tooltip = "";
				
                for (var price = fixHigh; price >= fixLow; price -= tickSize)
			    {
				    var y1 = 0;

				    if (price == fixHigh)
					    y1 = ChartInfo.GetYByPrice(price);
				    else
					    y1 = prevY;

				    var y2 = ChartInfo.GetYByPrice(price - tickSize);
				    
				    if (showSeparately)
				    {
					    y1 += 1;
                    }

				    var realHeight = y2 - y1;

				    prevY = y2;

                    var blockInRow = _gridController.GetItemInRow(price, _lastAsk, _lastBid, !showSeparately&& !showText);

                    var (rowVol, dataType) = _gridController.Volume(price, _lastAsk, _lastBid, _lastPrice);

                    if (dataType == DataType.Lvl2)
				    {
					    aggregationBaseRow.X += aggregationBaseRow.Width;
					    aggregationBaseRow.Width = 0;
				    }

				    if (blockInRow.Orders.Length == 0 && rowVol == 0)
					    continue;

				    if (rowVol > 0 && blockInRow.Orders.Length == 0)
					    rowVol = 0;

				    var pen = RenderPens.Transparent;

				    if (blockInRow.Type is MarketDataType.Ask)
				    {
					    pen = new RenderPen(AskBlockColor);
				    }

				    if (blockInRow.Type is MarketDataType.Bid)
				    {
					    pen = new RenderPen(BidBlockColor);
				    }

				    if (blockInRow.Type is MarketDataType.Trade)
					    pen = new RenderPen(TextColor);

				    var aggregationRow = aggregationBaseRow with { Y = y1, Height = realHeight };

				    if (aggregationRow.Height < 1)
				    {
					    aggregationRow.Height = 1;
				    }

				    if (aggregationRow.Width > 0)
				    {
					    context.DrawRectangle(pen, aggregationRow);

					    var pw = 0;

					    if (ShowSum)
					    {
						    var text = $"V {ChartInfo.TryGetMinimizedVolumeString(rowVol)}";

						    var aggVolBox = aggregationRow with
						    {
							    Width = ShowCount ? (aggregationRow.Width / 2) : aggregationRow.Width
						    };
						    pw = aggVolBox.Width;

						    if (RowOrderVolume.Enabled && blockInRow.Type != MarketDataType.Trade)
						    {
							    if (RowOrderVolume.Value <= rowVol)
								    context.FillRectangle(pen.Color, aggVolBox);
						    }

						    context.DrawString(text, _font, TextColor, aggVolBox, _stringCenterFormat);
					    }

					    if (ShowCount)
					    {
						    var text = $"C {blockInRow.Orders.Length}";

						    var aggCountBox = aggregationRow with
						    {
							    X = aggregationRow.X + pw, Width = aggregationRow.Width - pw
						    };

						    if (RowOrderCount.Enabled && blockInRow.Type != MarketDataType.Trade)
						    {
							    if (RowOrderCount.Value <= blockInRow.Orders.Length)
								    context.FillRectangle(pen.Color, aggCountBox);
						    }

						    context.DrawString(text, _font, TextColor, aggCountBox, _stringCenterFormat);
					    }
				    }

				    var availableArea = maxScreenSize - aggregationRow.Width;

				    var availableForThisRow =
					    maxCount == 0 ? 0 : (int)((availableArea / maxCount) * blockInRow.Orders.Length);

				    if (blockInRow.Type is not MarketDataType.Trade && blockInRow.Orders.Length > 0)
				    {
					    var minW = (int)Math.Max(height, 6 );
					    var lastX = aggregationRow.X - 2;

					    foreach (var order in blockInRow.Orders)
					    {
						    var vol = order.Order.Volume;

						    var needToFilterBlockSize = (MinBlockSize.Enabled && MinBlockSize.Value > vol &&
							    blockInRow.Type != MarketDataType.Trade);

						    var needToFillBox = (OrderSizeFilter.Enabled && OrderSizeFilter.Value <= vol &&
							    blockInRow.Type != MarketDataType.Trade);

						    if (needToFilterBlockSize)
							    continue;

						    var width = ItemWidthCalculation(vol, maxVol, (int)maxScreenSize/2, maxCount, 0, minW);

						    tempSize[vol] = width;
						    
						    var ww = tempSize[vol];

						    if (needToFilterBlockSize)
							    ww = (int)fontSize;

						    var orderBlockRow = aggregationRow with
						    {
							    X = lastX - ww, Width = ww, Height = realHeight
                            };

						    if (showSeparately)
						    {
							    if (!needToFilterBlockSize)
							    {
								    var textColor = TextColor;

                                    if (IsPointInRectangle(orderBlockRow, MouseLocationInfo.LastPosition))
                                    {
	                                    selectedRectangle = orderBlockRow;
                                        context.FillRectangle(ChartInfo.ColorsStore.MouseBackground, orderBlockRow);
									    textColor = ChartInfo.ColorsStore.MouseTextColor;

									    if (ChartInfo.KeyboardInfo.PressedKey != null && ChartInfo.KeyboardInfo.PressedKey.Key == CrossKey.LeftCtrl)
									    {
										    var text = $"Price\t\t{ChartInfo.GetPriceString(order.Order.Price)}{Environment.NewLine}";
										    text += $"Volume\t{order.Order.Volume}{Environment.NewLine}";
                                            text += $"Time\t\t{order.Order.Time:HH:mm:ss.fff}{Environment.NewLine}";
										    text += $"Id\t\t{order.Order.ExchangeOrderId}{Environment.NewLine}";
										    text += $"Priority\t{order.Order.Priority}{Environment.NewLine}";

                                            tooltip = text;
                                        }
								    }
								    else if (needToFillBox)
									    context.FillRectangle(pen.Color, orderBlockRow);
								    else
									    context.DrawRectangle(pen, orderBlockRow);

								    if (showText)
								    {
									    context.DrawString(ChartInfo.TryGetMinimizedVolumeString(vol), _font,
										    textColor, orderBlockRow,
										    dataType is DataType.Lvl3 ? _stringCenterFormat : _stringRightFormat);
                                    }
							    }
						    }

						    lastX = orderBlockRow.X - 1;
					    }

					    if (!showSeparately)
					    {
						    var end = aggregationRow.X - 1;

						    var orderBlockRow = aggregationRow with
						    {
							    X = lastX, Width = end - lastX
						    };

						    context.FillRectangle(pen.Color, orderBlockRow);
					    }
				    }

				    y1 = y2;
			    }

                if (!string.IsNullOrWhiteSpace(tooltip))
                {
	                var tooltipFont = new RenderFont("Arial", 8);
                    var size = context.MeasureString(tooltip, tooltipFont);

                    size = new Size(size.Width + 20, size.Height);
	                var rectangle = new Rectangle(new Point(selectedRectangle.X, selectedRectangle.Bottom + 1), size);

                    if (rectangle.Right > Container.RelativeRegion.Right)
	                {
		                rectangle.X += (Container.RelativeRegion.Right - rectangle.Right);
	                }
	                if (rectangle.Bottom > Container.RelativeRegion.Bottom)
	                {
		                rectangle.Y = selectedRectangle.Y - rectangle.Height - 1;
	                }

                    context.FillRectangle(ChartInfo.ColorsStore.MouseBackground, rectangle, 10);
	                rectangle.X += 10;
	                rectangle.Y += 9;
                    context.DrawString(tooltip, tooltipFont, ChartInfo.ColorsStore.MouseTextColor, rectangle, _stringLeftFormat);
                }
		    }
	    }
	    catch (Exception es)
	    {
		    this.LogWarn(es.ToString());
	    }
    }

    private bool IsPointInRectangle(Rectangle rectangle, Point e)
    {
	    if (rectangle.Width == 0 || rectangle.Height == 0)
		    return false;
	    if (e.X >= rectangle.X && e.Y >= rectangle.Y && e.X <= rectangle.X + rectangle.Width && e.Y <= rectangle.Y + rectangle.Height)
		    return true;
	    return false;
    }
}






Technical/DomV3/MboGridController.cs




namespace DomV10;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;

using ATAS.DataFeedsCore;
using ATAS.Indicators;

using Utils.Common.Collections;

using MarketDataType = ATAS.DataFeedsCore.MarketDataType;

public class OrderInfo
{
	#region Fields

	public bool IsNeedToBeRemove;
	public MarketByOrder Order;
	public MarketDataType Type;

	#endregion

	#region ctor

	public OrderInfo(MarketByOrder order)
	{
		Order = order;
	}

	#endregion

	#region Public methods

	public void Update(MarketByOrder order)
	{
		Order = order;
	}

	public void RemoveFlag(bool state)
	{
		IsNeedToBeRemove = true;
	}

	public decimal MaxVol()
	{
		return Order.Volume;
	}

	#endregion
}

public class RowItem
{
	#region Fields

	private readonly ConcurrentDictionary<long, OrderInfo> _orders = new();

	#endregion

	#region Properties

	public MarketDataType Type { get; private set; } = MarketDataType.Trade;

	#endregion

	#region Public methods

	public (decimal vol, int count) UpdateOrder(MarketByOrder order)
	{
		if (order.Side is MarketDataType.Bid or MarketDataType.Ask)
		{
			var clearFlag = false;

			if (order.Side != Type)
			{
				if (order.Type is MarketByOrderUpdateTypes.New or MarketByOrderUpdateTypes.Snapshot)
				{
					clearFlag = true;
				}
				else if (order.Type is MarketByOrderUpdateTypes.Change)
				{
					if (order.Volume != 0)
						clearFlag = true;
				}
			}

			if (clearFlag)
			{
				RemoveAllAgain(order.Side);
				Type = order.Side;
			}

			if (order.Type is MarketByOrderUpdateTypes.Delete ||
			    (order.Type is MarketByOrderUpdateTypes.Change && order.Volume == 0))
				SetRemoveFlag(order.ExchangeOrderId);
			else
			{
				if (!_orders.ContainsKey(order.ExchangeOrderId))
					_orders.TryAdd(order.ExchangeOrderId, new OrderInfo(order));
				
				_orders[order.ExchangeOrderId].Update(order);

            }
        }

		RemoveExpireOrder();

		var vol = _orders.Sum(e => e.Value.MaxVol());
		var count = _orders.Count;
		return (count > 0 ? vol : 0, count);
	}

	public void UpdateTrade(MarketDataArg trade)
	{
	}

	public IEnumerable<OrderInfo> GetOrderedData()
	{
		return _orders.OrderBy(e => e.Value.Order.Priority).Select(e => e.Value);
	}

	public void RemoveExpireOrder()
	{
		if (_orders.Any())
		{
			_orders.RemoveWhere(e => e.Value.IsNeedToBeRemove);
		}
	}

	#endregion

	#region Private methods

	private void RemoveAllAgain(MarketDataType type)
	{
		if (_orders.Count > 0)
			_orders.RemoveWhere(e => e.Value.Type != type);
	}

	private void SetRemoveFlag(long orderExchangeOrderId)
	{
		if (_orders.TryGetValue(orderExchangeOrderId, out var order))
		{
			order.RemoveFlag(true);
		}
	}

	#endregion
}

public enum DataType
{
	Lvl2,
	Lvl3
}

public class MboGridController
{
    #region Fields

    private readonly ConcurrentDictionary<long, MarketByOrder> _mboHistory = new ConcurrentDictionary<long, MarketByOrder>();
    private readonly ConcurrentDictionary<decimal, RowItem> _grid = new();
	private readonly object _level2UpdateLock = new();
	private readonly Dictionary<decimal, (decimal vol, int count)> _priceVolume = new();
	private readonly object _updateLock = new();
	private readonly ConcurrentDictionary<decimal, MarketDataArg> _level2Data = new();

	#endregion

	#region ctor

	#endregion

	#region Public methods

	public bool Update(IEnumerable<MarketByOrder> orders)
	{
		lock (_updateLock)
		{
			if (_grid.IsEmpty)
				return false;

			UpdateList(orders);
		}

		return true;
	}

	public void Load(IEnumerable<MarketByOrder> marketByOrders)
	{
		lock (_updateLock)
		{
			Reset();
			UpdateList(marketByOrders);
		}
	}

	public void UpdateTrade(MarketDataArg trade)
	{
		lock (_updateLock)
		{
			if (trade.ExchangeOrderId == null || trade.AggressorExchangeOrderId == null)
				return;

			if (trade?.ExchangeOrderId <= 0 || trade?.AggressorExchangeOrderId <= 0)
				return;

			if (trade == null)
				return;

			if (_grid.IsEmpty)
				return;

			if (_grid.TryGetValue(trade.Price, out var value))
				value?.UpdateTrade(trade);
		}
	}

	public void Tick()
	{
		lock (_updateLock)
		{
			if (_grid.Any())
				foreach (var item in _grid)
					item.Value.RemoveExpireOrder();
		}
	}

	public (OrderInfo[] Orders, MarketDataType Type) GetItemInRow(decimal price, MarketDataArg lastAsk, MarketDataArg lastBid, bool forceReturnLevel2)
	{
		var nullItem = (Array.Empty<OrderInfo>(), MarketDataType.Trade);

		lock (_updateLock)
		{
			if (!forceReturnLevel2 && _grid.Count > 0)
			{
				if (_grid.TryGetValue(price, out var value))
				{
					if (value.Type is MarketDataType.Ask && price < lastAsk.Price)
						return nullItem;

					if (value.Type is MarketDataType.Bid && price > lastBid.Price)
						return nullItem;

					return (value.GetOrderedData().ToArray(), value.Type);
				}
			}
			else
			{
				lock (_level2Data)
				{
					if (!_level2Data.IsEmpty)
					{
						if (_level2Data.TryGetValue(price, out var value))
						{
							if (value.DataType is ATAS.Indicators.MarketDataType.Ask && price < lastAsk.Price)
								return nullItem;

							if (value.DataType is ATAS.Indicators.MarketDataType.Bid && price > lastBid.Price)
								return nullItem;

							var type = value.DataType is ATAS.Indicators.MarketDataType.Ask
								? MarketDataType.Ask
								: MarketDataType.Bid;

							if (value.Volume > 0)
							{
								var order = new OrderInfo(new MarketByOrder
								{
									Price = value.Price, Volume = value.Volume,
									Type = MarketByOrderUpdateTypes.Snapshot,
									ExchangeOrderId = 0, Priority = 0, Side = type,
									Security = new Security(), Time = value.Time
								});

								return (new[] { order },

								type);
							}
						}
					}
				}
			}
		}

		return nullItem;
	}

	public (decimal MaxVol, int MaxCount) MaxInView(decimal fixHigh, decimal fixLow, decimal tickSize,
		bool useWeight = false)
	{
		(decimal MaxVol, int MaxCount) max = (0, 0);
		var w = 0m;

		for (var price = fixHigh; price >= fixLow; price -= tickSize)
		{
			if (_priceVolume.Count > 0)
			{
				if (_priceVolume.TryGetValue(price, out var value))
				{
					if (useWeight)
					{
						var a = value.vol * value.count;

						if (a > w)
						{
							w = a;
							max = value;
						}
					}
					else
					{
						if (value.vol > max.MaxVol)
							max.MaxVol = value.vol;

						if (value.count > max.MaxCount)
							max.MaxCount = value.count;
					}
				}
			}
			else
			{
				lock (_level2Data)
				{
					if (!_level2Data.IsEmpty)
					{
						if (_level2Data.TryGetValue(price, out var value))
						{
							max.MaxCount = 1;

							if (value.Volume > max.MaxVol)
								max.MaxVol = value.Volume;
						}
					}
				}
			}
		}

		return max;
	}

	public (decimal volume, DataType dataType) Volume(decimal price,
		MarketDataArg lastAsk,
		MarketDataArg lastBid, decimal lastPrice)
	{
		var type = DataType.Lvl3;

		lock (_updateLock)
		{
			if (_priceVolume.Count == 0 && _grid.IsEmpty)
			{
				type = DataType.Lvl2;

				lock (_level2UpdateLock)
				{
					if (_level2Data.TryGetValue(price, out var value))
					{
						if (value.DataType is ATAS.Indicators.MarketDataType.Ask && price < lastAsk.Price)
							return (0, type);

						if (value.DataType is ATAS.Indicators.MarketDataType.Bid && price > lastBid.Price)
							return (0, type);

						return (value.Volume, type);
					}
				}
			}
			else
			{
				if (_priceVolume.TryGetValue(price, out var value))
					return (value.vol, type);
			}

			return (0, type);
		}
	}

	public bool Update(MarketDataArg depth)
	{
		lock (_level2UpdateLock)
		{
			if (_level2Data.IsEmpty)
				return false;

			if ((depth.IsAsk || depth.IsBid) &&
			    depth.DataType is ATAS.Indicators.MarketDataType.Ask or ATAS.Indicators.MarketDataType.Bid)
			{
				if (!_level2Data.ContainsKey(depth.Price))
					_level2Data.TryAdd(depth.Price, depth);
				_level2Data[depth.Price] = depth;

				return true;
			}

			return true;
		}
	}

	public void Load(IEnumerable<MarketDataArg>? getMarketDepthSnapshot)
	{
		lock (_level2UpdateLock)
		{
			_level2Data.Clear();

			if (getMarketDepthSnapshot == null)
				return;

			var marketDepthSnapshot = getMarketDepthSnapshot as MarketDataArg[] ?? getMarketDepthSnapshot.ToArray();
			var array = marketDepthSnapshot.ToArray();

			if (marketDepthSnapshot.Any())
			{
				foreach (var depth in array)
				{
					if (!_level2Data.ContainsKey(depth.Price))
						_level2Data.TryAdd(depth.Price, depth);
					_level2Data[depth.Price] = depth;
				}
			}
		}
	}

	#endregion

	#region Private methods

	private void Reset()
	{
		_grid.Clear();
		_priceVolume.Clear();
		_level2Data.Clear();
	}

	private void UpdateList(IEnumerable<MarketByOrder> orders)
	{
		foreach (var order in orders)
		{
			if (!_mboHistory.TryGetValue(order.ExchangeOrderId, out var existedOrder))
			{
				existedOrder = order;
				_mboHistory[order.ExchangeOrderId] = existedOrder;
            }

			if(order.Type == MarketByOrderUpdateTypes.Change)
			{
				if (existedOrder.Price != order.Price)
				{
					var orderToDelete = new MarketByOrder()
					{
						ExchangeOrderId = order.ExchangeOrderId,
						Priority = order.Priority,
						Security = order.Security,
						Side = order.Side,
						Volume = order.Volume,
						Type = MarketByOrderUpdateTypes.Delete,
						Time = order.Time,
						Price = existedOrder.Price
                    };

					_priceVolume[existedOrder.Price] = _grid[existedOrder.Price].UpdateOrder(orderToDelete);
                }
			}

			_mboHistory[order.ExchangeOrderId] = order;

			if (order.Type == MarketByOrderUpdateTypes.Delete)
				_mboHistory.Remove(order.ExchangeOrderId, out _);

            if (!_grid.ContainsKey(order.Price))
				_grid.TryAdd(order.Price, new RowItem());

            _priceVolume[order.Price] = _grid[order.Price].UpdateOrder(order);
		}
	}

	#endregion
}





Technical/DomV3/Setting.cs




namespace DomV10;

using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators;

using OFT.Attributes.Editors;
using OFT.Localization;

public partial class MainIndicator
{
	#region Fields

	private readonly RedrawArg _emptyRedrawArg = new(new Rectangle(0, 0, 0, 0));
	private Color _askColor;
	private Color _bidColor;
	private bool _showCount = true;
	private bool _showSum = true;
	private Color _textColor;

    #endregion

    #region Properties

    #region Colors

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bids), GroupName = nameof(Strings.Colors),Order = 2)]
    public Color BidBlockColor
    {
	    get => _bidColor;
	    set
	    {
		    _bidColor = value;
		    RedrawChart(_emptyRedrawArg);
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Asks), GroupName = nameof(Strings.Colors), Order = 4)]
    public Color AskBlockColor
    {
	    get => _askColor;
	    set
	    {
		    _askColor = value;
		    RedrawChart(_emptyRedrawArg);
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.Colors), Order = 6)]
    public Color TextColor
    {
	    get => _textColor;
	    set
	    {
		    _textColor = value;
		    RedrawChart(_emptyRedrawArg);
	    }
    }

    #endregion

    #region Filters

    [NumericEditor(0, EditorType = NumericEditorTypes.Spin, Step = 1, DisplayFormat = "F0")]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColorFilter), GroupName = nameof(Strings.MBOFilters), Order = 100)]
    public FilterInt OrderSizeFilter { set; get; } = new() { Enabled = true, Value = 2 };

    [NumericEditor(0, EditorType = NumericEditorTypes.Spin, Step = 1, DisplayFormat = "F0")]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TotalVolumeFilter), GroupName = nameof(Strings.MBOFilters), Order = 110)]
    public FilterInt MinBlockSize { set; get; } = new() { Enabled = true, Value = 2 };

    #endregion

    #region Aggregation settings

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolume), GroupName = nameof(Strings.Summary), Order = 210)]
    public bool ShowSum
    {
	    set
	    {
		    _showSum = value;
		    RedrawChart(_emptyRedrawArg);
	    }
	    get => _showSum;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowOrdersCount), GroupName = nameof(Strings.Summary), Order = 220)]
    public bool ShowCount
    {
	    set
	    {
		    _showCount = value;
		    RedrawChart(_emptyRedrawArg);
	    }
	    get => _showCount;
    }

    [NumericEditor(0, EditorType = NumericEditorTypes.Spin, Step = 1, DisplayFormat = "F0")]

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OrdersCountFilter), GroupName = nameof(Strings.Summary), Order = 230)]
    public FilterInt RowOrderCount { set; get; } = new() { Enabled = true, Value = 1 };

    [NumericEditor(0, EditorType = NumericEditorTypes.Spin, Step = 1, DisplayFormat = "F0")]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TotalVolumeFilter), GroupName = nameof(Strings.Summary), Order = 240)]
    public FilterInt RowOrderVolume { set; get; } = new() { Enabled = true, Value = 1 };

    #endregion

    #endregion
}






Technical/Editors/CustomView.Common.cs





namespace ATAS.Indicators.Technical.Editors;

public partial class CustomView;






Technical/Editors/CustomView.xaml






<UserControl x:Class="ATAS.Indicators.Technical.Editors.CustomView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:local="clr-namespace:ATAS.Indicators.Technical.Editors"
             xmlns:technical="clr-namespace:ATAS.Indicators.Technical"
             xmlns:localization="clr-namespace:OFT.Localization;assembly=OFT.Localization"
             xmlns:indicators="clr-namespace:ATAS.Indicators;assembly=ATAS.Indicators"
             mc:Ignorable="d" 
             d:DataContext="{d:DesignInstance technical:SampleCustomViewIndicator}"
             Padding="5"
             d:DesignHeight="450" d:DesignWidth="800">

	<UserControl.Resources>
		<GridLength x:Key="Spacing">5</GridLength>
		<local:WpfColorToColorConverter x:Key="WpfColorToColorConverter"/>

		<Style TargetType="Expander">
			<Setter Property="Padding" Value="5"/>
			<Setter Property="IsExpanded" Value="True"/>
		</Style>

		<Style TargetType="Label">
			<Setter Property="VerticalContentAlignment" Value="Center"/>
			<Setter Property="HorizontalContentAlignment" Value="Right"/>
		</Style>

		<Style TargetType="CheckBox">
			<Setter Property="VerticalAlignment" Value="Center"/>
			<Setter Property="ContentTemplate">
				<Setter.Value>
					<DataTemplate>
						<TextBlock Text="{Binding}"
								   VerticalAlignment="Center"
						           TextWrapping="WrapWithOverflow"/>
					</DataTemplate>
				</Setter.Value>
			</Setter>
		</Style>

		<DataTemplate x:Key="ColorItemTemplate">
			<Grid>
				<Grid.ColumnDefinitions>
					<ColumnDefinition Width="Auto"/>
					<ColumnDefinition Width="{StaticResource Spacing}"/>
					<ColumnDefinition Width="*"/>
				</Grid.ColumnDefinitions>
				<Rectangle Width="16" 
				           Height="16" 
				           Fill="{Binding}"/>
					
				<TextBlock Grid.Column="2"
				           Text="{Binding Color}"/>
			</Grid>
		</DataTemplate>

		<CollectionViewSource x:Key="DefaultColorsSource">
			<CollectionViewSource.Source>
				<x:Array Type="SolidColorBrush">
					<SolidColorBrush>Blue</SolidColorBrush>
					<SolidColorBrush>Green</SolidColorBrush>
					<SolidColorBrush>LightBlue</SolidColorBrush>
					<SolidColorBrush>Black</SolidColorBrush>
					<SolidColorBrush>White</SolidColorBrush>
					<SolidColorBrush>Gray</SolidColorBrush>
				</x:Array>
			</CollectionViewSource.Source>
		</CollectionViewSource>

		<Style TargetType="ComboBox"
		       x:Key="ColorSelectorStyle">
			<Setter Property="SelectedValuePath" Value="Color"/>
			<Setter Property="ItemsSource" Value="{Binding Source={StaticResource DefaultColorsSource}}"/>
			<Setter Property="ItemTemplate" Value="{StaticResource ColorItemTemplate}"/>
			<Setter Property="IsSynchronizedWithCurrentItem" Value="False"/>
		</Style>
	</UserControl.Resources>

	<StackPanel Orientation="Vertical">
		<Expander Header="Custom properties">
			<Grid>
				<Grid.ColumnDefinitions>
					<ColumnDefinition Width="Auto"/>
					<ColumnDefinition Width="{StaticResource Spacing}"/>
					<ColumnDefinition Width="*"/>
				</Grid.ColumnDefinitions>

				<Grid.RowDefinitions>
					<RowDefinition Height="Auto"/>
					<RowDefinition Height="{StaticResource Spacing}"/>
					<RowDefinition Height="Auto"/>
				</Grid.RowDefinitions>

				<Label Grid.Row="0"
				       Grid.Column="0"
				       Content="String"/>

				<TextBox Grid.Row="0"
				         Grid.Column="2"
				         Text="{Binding StringValue}"/>

				<Label Grid.Row="2"
				       Grid.Column="0"
				       Content="Number"/>

				<Slider Grid.Row="2"
				        Grid.Column="2"
				        Value="{Binding NumberValue}"/>
			</Grid>
		</Expander>

		<Expander Header="{x:Static localization:Strings.Drawing}">
	        <Grid>
		        <Grid.ColumnDefinitions>
			        <ColumnDefinition Width="Auto"/>
					<ColumnDefinition Width="{StaticResource Spacing}"/>
			        <ColumnDefinition Width="*"/>
		        </Grid.ColumnDefinitions>
		        <Grid.RowDefinitions>
			        <RowDefinition Height="Auto"/>
					<RowDefinition Height="{StaticResource Spacing}"/>
					<RowDefinition Height="Auto"/>
					<RowDefinition Height="{StaticResource Spacing}"/>
					<RowDefinition Height="Auto"/>
					<RowDefinition Height="{StaticResource Spacing}"/>
					<RowDefinition Height="Auto"/>
			        <RowDefinition Height="{StaticResource Spacing}"/>
			        <RowDefinition Height="Auto"/>
			        <RowDefinition Height="{StaticResource Spacing}"/>
			        <RowDefinition Height="Auto"/>
			        <RowDefinition Height="{StaticResource Spacing}"/>
			        <RowDefinition Height="Auto"/>
		        </Grid.RowDefinitions>

		        <Label Content="{x:Static localization:Strings.Panel}"/>

		        <ComboBox Grid.Row="0"
		                  Grid.Column="2"
		                  IsTextSearchEnabled="False"
		                  SelectedValue="{Binding Panel, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
		                  ItemsSource="{Binding DataProvider.Panels}"/>

				<Label Grid.Row="2"
				       Grid.Column="0"
				       Content="{x:Static localization:Strings.VisualMode}"/>

				<ComboBox Grid.Row="2"
				          Grid.Column="2"
						  x:Name="VisualTypeSelector"
				          SelectedValue="{Binding DataSeries[0].VisualType, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>

				<Label Grid.Row="4"
				       Grid.Column="0"
				       Content="{x:Static localization:Strings.LineStyle}"/>

				<ComboBox Grid.Row="4"
				          Grid.Column="2"
						  x:Name="LineStyleSelector"
				          SelectedValue="{Binding DataSeries[0].LineDashStyle, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>

				<Label Grid.Row="6"
				       Grid.Column="0"
				       Content="{x:Static localization:Strings.Width}"/>
		        
		        <Slider Grid.Row="6" 
		                Grid.Column="2" 
		                AutoToolTipPlacement="TopLeft"
						TickPlacement="BottomRight"
						Value="{Binding DataSeries[0].Width}"
						TickFrequency="10" 
		                Minimum="1"
		                Maximum="100"/>

				<Label Grid.Row="8"
				       Grid.Column="0"
				       Content="{x:Static localization:Strings.ColorValueLabel}"/>

		        <ComboBox Grid.Row="8"
		                  Grid.Column="2" 
						  SelectedValue="{Binding DataSeries[0].Color}"
		                  Style="{StaticResource ColorSelectorStyle}"/>

		        <Label Grid.Row="10"
		               Grid.Column="0"
		               Content="{x:Static localization:Strings.TextColor}"/>

		        <ComboBox Grid.Row="10"
		                  Grid.Column="2" 
		                  SelectedValue="{Binding DataSeries[0].ValuesColor, Converter={StaticResource WpfColorToColorConverter}}"
		                  Style="{StaticResource ColorSelectorStyle}"/>

				<UniformGrid Grid.Row="12"
				             Grid.Column="0"
				             Grid.ColumnSpan="3"
				             Columns="2">
					<CheckBox Content="{x:Static localization:Strings.ShowValue}"
					          IsChecked="{Binding DataSeries[0].ShowCurrentValue}"/>

					<CheckBox Content="{x:Static localization:Strings.Scale}"
					          IsChecked="{Binding DataSeries[0].ScaleIt}"/>

					<CheckBox Content="Draw above price"
					          IsChecked="{Binding DataSeries[0].DrawAbovePrice}"/>

					<CheckBox Content="Ignored by alerts"
					          IsChecked="{Binding DataSeries[0].IgnoredByAlerts}"/>

					<CheckBox Content="{x:Static localization:Strings.ShowZeroValue}"
					          IsChecked="{Binding DataSeries[0].ShowZeroValue}"/>
				</UniformGrid>
	        </Grid>
        </Expander>
    </StackPanel>
</UserControl>





Technical/Editors/CustomView.xaml.cs




using System.Windows.Controls;

namespace ATAS.Indicators.Technical.Editors
{
	using System;
	using System.Globalization;
	using System.Windows.Data;

	using OFT.Rendering.Settings;

	using WpfColor = System.Windows.Media.Color;
	using SysColor = System.Drawing.Color;

	public partial class CustomView
	{
		public CustomView()
		{
			InitializeComponent();

			VisualTypeSelector.ItemsSource = Enum.GetValues(typeof(VisualMode));
			LineStyleSelector.ItemsSource = Enum.GetValues(typeof(LineDashStyle));
		}
	}

	class WpfColorToColorConverter : IValueConverter
	{
		private static object Convert(object value) => value switch
		{
			WpfColor w => SysColor.FromArgb(w.A, w.R, w.G, w.B),
			SysColor s => WpfColor.FromArgb(s.A, s.R, s.G, s.B),

			_ => value
		};

		#region Implementation of IValueConverter

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
		{
			return Convert(value);
		}
		
		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
		{
			return Convert(value);
		}

		#endregion
	}
}







Technical/Editors/RangeEditor.Common.cs




namespace ATAS.Indicators.Technical.Editors;

public partial class RangeEditor;





Technical/Editors/RangeEditor.xaml




<UserControl x:Class="ATAS.Indicators.Technical.Editors.RangeEditor"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             mc:Ignorable="d"
             d:DesignHeight="450" d:DesignWidth="800">
    <TextBlock>
        <Run Text="{Binding From}" />-<Run Text="{Binding To}" />
    </TextBlock>
</UserControl>






Technical/Editors/RangeEditor.xaml.cs





namespace ATAS.Indicators.Technical.Editors
{
	public partial class RangeEditor
	{
		#region ctor

		public RangeEditor()
		{
			InitializeComponent();
		}

		#endregion
	}
}





Technical/Editors/SampleEditor.Common.cs




namespace ATAS.Indicators.Technical.Editors;

public partial class SampleEditor;




Technical/Editors/SampleEditor.xaml





<UserControl x:Class="ATAS.Indicators.Technical.Editors.SampleEditor"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:technical="clr-namespace:ATAS.Indicators.Technical"
             xmlns:converters="clr-namespace:Utils.Windows.Converters;assembly=Utils.Windows"
             mc:Ignorable="d"
             d:DesignHeight="450" d:DesignWidth="800">

    <UserControl.Resources>
        <converters:ColorToBrushConverter x:Key="ColorToBrushConverter" />
        <converters:LocalizedEnumValueConverter x:Key="EnumToLocalizedStringConverter" />
        <SolidColorBrush x:Key="FailBrush" Color="#C0C0C0" />
        <DataTemplate x:Key="Figure1Template" DataType="technical:CustomClass">
            <Viewbox Stretch="Uniform">
                <Canvas Height="24" Width="24">
                    <Path
                        Data="M9 3H4C3.44772 3 3 3.44772 3 4V9C3 9.55228 3.44772 10 4 10H9C9.55228 10 10 9.55228 10 9V4C10 3.44772 9.55228 3 9 3Z"
                        StrokeThickness="1.5"
                        StrokeStartLineCap="round"
                        StrokeEndLineCap="round"
                        StrokeLineJoin="round">
                        <Path.Stroke>
                            <Binding Path="ColorProperty"
                                     FallbackValue="{StaticResource FailBrush}"
                                     Converter="{StaticResource ColorToBrushConverter}" />
                        </Path.Stroke>
                    </Path>

                    <Path
                        Data="M9 14H4C3.44772 14 3 14.4477 3 15V20C3 20.5523 3.44772 21 4 21H9C9.55228 21 10 20.5523 10 20V15C10 14.4477 9.55228 14 9 14Z"
                        StrokeThickness="1.5" StrokeStartLineCap="round" StrokeEndLineCap="round"
                        StrokeLineJoin="round">
                        <Path.Stroke>
                            <Binding Path="ColorProperty"
                                     FallbackValue="{StaticResource FailBrush}"
                                     Converter="{StaticResource ColorToBrushConverter}" />
                        </Path.Stroke>
                    </Path>

                    <Path Data="M14 4H21" StrokeThickness="1.5" StrokeStartLineCap="round" StrokeEndLineCap="round"
                          StrokeLineJoin="round">
                        <Path.Stroke>
                            <Binding Path="ColorProperty"
                                     FallbackValue="{StaticResource FailBrush}"
                                     Converter="{StaticResource ColorToBrushConverter}" />
                        </Path.Stroke>
                    </Path>
                    <Path Data="M14 9H21" StrokeThickness="1.5" StrokeStartLineCap="round" StrokeEndLineCap="round"
                          StrokeLineJoin="round">
                        <Path.Stroke>
                            <Binding Path="ColorProperty"
                                     FallbackValue="{StaticResource FailBrush}"
                                     Converter="{StaticResource ColorToBrushConverter}" />
                        </Path.Stroke>
                    </Path>
                    <Path Data="M14 15H21" StrokeThickness="1.5" StrokeStartLineCap="round" StrokeEndLineCap="round"
                          StrokeLineJoin="round">
                        <Path.Stroke>
                            <Binding Path="ColorProperty"
                                     FallbackValue="{StaticResource FailBrush}"
                                     Converter="{StaticResource ColorToBrushConverter}" />
                        </Path.Stroke>
                    </Path>
                    <Path Data="M14 20H21" StrokeThickness="1.5" StrokeStartLineCap="round" StrokeEndLineCap="round"
                          StrokeLineJoin="round">
                        <Path.Stroke>
                            <Binding Path="ColorProperty"
                                     FallbackValue="{StaticResource FailBrush}"
                                     Converter="{StaticResource ColorToBrushConverter}" />
                        </Path.Stroke>
                    </Path>
                </Canvas>
            </Viewbox>
        </DataTemplate>

        <DataTemplate x:Key="Figure2Template" DataType="technical:CustomClass">
            <Path
                Data="M20.25 3.75H6.75C6.35218 3.75 5.97064 3.90804 5.68934 4.18934C5.40804 4.47064 5.25 4.85218 5.25 5.25V6.75H3.75C3.35218 6.75 2.97064 6.90804 2.68934 7.18934C2.40804 7.47064 2.25 7.85218 2.25 8.25V18.75C2.25 19.1478 2.40804 19.5294 2.68934 19.8107C2.97064 20.092 3.35218 20.25 3.75 20.25H17.25C17.6478 20.25 18.0294 20.092 18.3107 19.8107C18.592 19.5294 18.75 19.1478 18.75 18.75V17.25H20.25C20.6478 17.25 21.0294 17.092 21.3107 16.8107C21.592 16.5294 21.75 16.1478 21.75 15.75V5.25C21.75 4.85218 21.592 4.47064 21.3107 4.18934C21.0294 3.90804 20.6478 3.75 20.25 3.75ZM17.25 8.25V9.75H3.75V8.25H17.25ZM17.25 18.75H3.75V11.25H17.25V18.75ZM20.25 15.75H18.75V8.25C18.75 7.85218 18.592 7.47064 18.3107 7.18934C18.0294 6.90804 17.6478 6.75 17.25 6.75H6.75V5.25H20.25V15.75Z"
                Width="12"
                Margin="2"
                Stretch="Fill"
                StrokeThickness="0.5">
                <Path.Stroke>
                    <Binding Path="ColorProperty"
                             FallbackValue="{StaticResource FailBrush}"
                             Converter="{StaticResource ColorToBrushConverter}" />
                </Path.Stroke>
            </Path>
        </DataTemplate>

    </UserControl.Resources>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto" />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>

        <Border Grid.Column="0" BorderBrush="#C0C0C0" BorderThickness="1" Width="23" Height="17">
            <ContentControl Content="{Binding}">
                <ContentControl.Style>
                    <Style TargetType="ContentControl">
                        <Style.Triggers>
                            <DataTrigger Binding="{Binding EnumProperty}" Value="Picture1">
                                <Setter Property="ContentTemplate" Value="{StaticResource Figure1Template}" />
                            </DataTrigger>

                            <DataTrigger Binding="{Binding EnumProperty}" Value="Picture2">
                                <Setter Property="ContentTemplate" Value="{StaticResource Figure2Template}" />
                            </DataTrigger>
                        </Style.Triggers>
                    </Style>
                </ContentControl.Style>
            </ContentControl>
        </Border>
        <StackPanel Orientation="Horizontal"
                    Grid.Column="1"
                    Margin="3,0,0,0"
                    VerticalAlignment="Center">
            <Label Content="{Binding EnumProperty, Converter={StaticResource EnumToLocalizedStringConverter}}"
                   ContentStringFormat="{}{0}; " />
            <Label Content="{Binding Number}"
                   ContentStringFormat="{}{0}; " />
            <Label Content="{Binding Str}"
                   ContentStringFormat="{}{0}; " />
        </StackPanel>
    </Grid>

</UserControl>




Technical/Editors/SampleEditor.xaml.cs




using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace ATAS.Indicators.Technical.Editors
{
    /// <summary>
    /// Interaction logic for SampleEditor.xaml
    /// </summary>
    public partial class SampleEditor : UserControl
    {
	    public SampleEditor()
        {
            InitializeComponent();
        }
    }
}





Technical/Extensions/CrossColorExtensions.Common.cs




namespace ATAS.Indicators.Technical.Extensions;

public partial class CrossColorExtensions
{
	public static partial CrossColor SetAlpha(this CrossColor color, byte alpha) => CrossColor.FromArgb(alpha, color);

	public static partial CrossColor FromRgb(byte r, byte g, byte b) => FromArgb(255, r, g, b);

	public static partial CrossColor FromArgb(byte a, byte r, byte g, byte b) => CrossColor.FromArgb(a, r, g, b);
}




Technical/Extensions/CrossColorExtensions.Windows.cs




namespace ATAS.Indicators.Technical.Extensions;

public partial class CrossColorExtensions
{
	public static partial CrossColor SetAlpha(this CrossColor color, byte alpha)
	{
		color.A = alpha;

		return color;
	}

	public static partial CrossColor FromRgb(byte r, byte g, byte b) => FromArgb(255, r, g, b);

	public static partial CrossColor FromArgb(byte a, byte r, byte g, byte b) => CrossColor.FromArgb(a, r, g, b);
}



Technical/Extensions/CrossColorExtensions.cs




namespace ATAS.Indicators.Technical.Extensions;

public static partial class CrossColorExtensions
{
	public static partial CrossColor SetAlpha(this CrossColor color, byte alpha);

	public static partial CrossColor FromRgb(byte  r, byte g, byte b);

	public static partial CrossColor FromArgb(byte a, byte r, byte g, byte b);
}




Technical/Properties/AssemblyInfo.cs




using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Technical Indicators")]
[assembly: AssemblyDescription("")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("38926823-8d53-4ed1-8d11-a88a82ceba34")]






Technical/Properties/Resources.Designer.cs



//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ATAS.Indicators.Technical.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ATAS.Indicators.Technical.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Absolute Price.
        /// </summary>
        public static string AbsolutePrice {
            get {
                return ResourceManager.GetString("AbsolutePrice", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Acceleration Max.
        /// </summary>
        public static string AccelMax {
            get {
                return ResourceManager.GetString("AccelMax", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Acceleration Start.
        /// </summary>
        public static string AccelStart {
            get {
                return ResourceManager.GetString("AccelStart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Acceleration Step.
        /// </summary>
        public static string AccelStep {
            get {
                return ResourceManager.GetString("AccelStep", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Accumulated.
        /// </summary>
        public static string Accumulated {
            get {
                return ResourceManager.GetString("Accumulated", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Average Daily Range.
        /// </summary>
        public static string ADR {
            get {
                return ResourceManager.GetString("ADR", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Average Directional Movement Index.
        /// </summary>
        public static string ADX {
            get {
                return ResourceManager.GetString("ADX", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ADX Period.
        /// </summary>
        public static string AdxPeriod {
            get {
                return ResourceManager.GetString("AdxPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Alert Before New Candle.
        /// </summary>
        public static string AlertBeforeCandle {
            get {
                return ResourceManager.GetString("AlertBeforeCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Alert File.
        /// </summary>
        public static string AlertFile {
            get {
                return ResourceManager.GetString("AlertFile", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Alert Filter.
        /// </summary>
        public static string AlertFilter {
            get {
                return ResourceManager.GetString("AlertFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Alert On New Candle.
        /// </summary>
        public static string AlertNewCandle {
            get {
                return ResourceManager.GetString("AlertNewCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Only One Alert Per Bar.
        /// </summary>
        public static string AlertPerBar {
            get {
                return ResourceManager.GetString("AlertPerBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Alerts.
        /// </summary>
        public static string Alerts {
            get {
                return ResourceManager.GetString("Alerts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Starting Point Mode.
        /// </summary>
        public static string AllowCustomStartPoint {
            get {
                return ResourceManager.GetString("AllowCustomStartPoint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All Period.
        /// </summary>
        public static string AllPeriodtxt {
            get {
                return ResourceManager.GetString("AllPeriodtxt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Retrospective Analysis Period.
        /// </summary>
        public static string AnalysisPeriod {
            get {
                return ResourceManager.GetString("AnalysisPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Any.
        /// </summary>
        public static string Any {
            get {
                return ResourceManager.GetString("Any", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Approximation Alert.
        /// </summary>
        public static string ApproximationAlert {
            get {
                return ResourceManager.GetString("ApproximationAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Approximation Filter.
        /// </summary>
        public static string ApproximationFilter {
            get {
                return ResourceManager.GetString("ApproximationFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Area Color.
        /// </summary>
        public static string AreaColor {
            get {
                return ResourceManager.GetString("AreaColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Area Transparency.
        /// </summary>
        public static string AreaTransparency {
            get {
                return ResourceManager.GetString("AreaTransparency", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask.
        /// </summary>
        public static string Ask {
            get {
                return ResourceManager.GetString("Ask", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to AskBid.
        /// </summary>
        public static string AskBid {
            get {
                return ResourceManager.GetString("AskBid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask/Bid Imbalance Color.
        /// </summary>
        public static string AskBidImbalanceColor {
            get {
                return ResourceManager.GetString("AskBidImbalanceColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask/Bid Volume.
        /// </summary>
        public static string AskBidVolume {
            get {
                return ResourceManager.GetString("AskBidVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask Color.
        /// </summary>
        public static string AskColor {
            get {
                return ResourceManager.GetString("AskColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask Filter.
        /// </summary>
        public static string AskFilter {
            get {
                return ResourceManager.GetString("AskFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ask Rows.
        /// </summary>
        public static string AskRows {
            get {
                return ResourceManager.GetString("AskRows", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Asks Background.
        /// </summary>
        public static string AsksBackGround {
            get {
                return ResourceManager.GetString("AsksBackGround", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At High.
        /// </summary>
        public static string AtHigh {
            get {
                return ResourceManager.GetString("AtHigh", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At High Or Low.
        /// </summary>
        public static string AtHighOrLow {
            get {
                return ResourceManager.GetString("AtHighOrLow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At Low.
        /// </summary>
        public static string AtLow {
            get {
                return ResourceManager.GetString("AtLow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Average True Range.
        /// </summary>
        public static string ATR {
            get {
                return ResourceManager.GetString("ATR", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to At Start.
        /// </summary>
        public static string AtStart {
            get {
                return ResourceManager.GetString("AtStart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Author.
        /// </summary>
        public static string Author {
            get {
                return ResourceManager.GetString("Author", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Auto.
        /// </summary>
        public static string Auto {
            get {
                return ResourceManager.GetString("Auto", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Automatic Calculation.
        /// </summary>
        public static string AutoCalculation {
            get {
                return ResourceManager.GetString("AutoCalculation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Auto Filter.
        /// </summary>
        public static string AutoFilter {
            get {
                return ResourceManager.GetString("AutoFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Auto Filter Period.
        /// </summary>
        public static string AutoFilterPeriod {
            get {
                return ResourceManager.GetString("AutoFilterPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Average.
        /// </summary>
        public static string Average {
            get {
                return ResourceManager.GetString("Average", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Average Period.
        /// </summary>
        public static string AveragePeriod {
            get {
                return ResourceManager.GetString("AveragePeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text On Axis.
        /// </summary>
        public static string AxisTextColor {
            get {
                return ResourceManager.GetString("AxisTextColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Background.
        /// </summary>
        public static string BackGround {
            get {
                return ResourceManager.GetString("BackGround", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Background Bearlish.
        /// </summary>
        public static string BackgroundBearlish {
            get {
                return ResourceManager.GetString("BackgroundBearlish", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Background Bullish.
        /// </summary>
        public static string BackgroundBullish {
            get {
                return ResourceManager.GetString("BackgroundBullish", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Background Buy Color.
        /// </summary>
        public static string BackGroundBuyColor {
            get {
                return ResourceManager.GetString("BackGroundBuyColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Background Sell Color.
        /// </summary>
        public static string BackGroundSellColor {
            get {
                return ResourceManager.GetString("BackGroundSellColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bars.
        /// </summary>
        public static string Bars {
            get {
                return ResourceManager.GetString("Bars", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bars Count Filter.
        /// </summary>
        public static string BarsCountFilter {
            get {
                return ResourceManager.GetString("BarsCountFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bars Direction.
        /// </summary>
        public static string BarsDirection {
            get {
                return ResourceManager.GetString("BarsDirection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bars Range.
        /// </summary>
        public static string BarsRange {
            get {
                return ResourceManager.GetString("BarsRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property is used to specify the number of candles that should be aggregated before the main calculation takes place..
        /// </summary>
        public static string BarsRangeDescription {
            get {
                return ResourceManager.GetString("BarsRangeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Base Line.
        /// </summary>
        public static string BaseLine {
            get {
                return ResourceManager.GetString("BaseLine", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Channel Width.
        /// </summary>
        public static string BBandsWidth {
            get {
                return ResourceManager.GetString("BBandsWidth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bollinger Bands Multiplier Factor.
        /// </summary>
        public static string BBMultFactor {
            get {
                return ResourceManager.GetString("BBMultFactor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bollinger Bands Period.
        /// </summary>
        public static string BBPeriod {
            get {
                return ResourceManager.GetString("BBPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bearish.
        /// </summary>
        public static string Bearlish {
            get {
                return ResourceManager.GetString("Bearlish", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bearlish Color.
        /// </summary>
        public static string BearlishColor {
            get {
                return ResourceManager.GetString("BearlishColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Best Ask Background.
        /// </summary>
        public static string BestAskBackGround {
            get {
                return ResourceManager.GetString("BestAskBackGround", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Best Bid Background.
        /// </summary>
        public static string BestBidBackGround {
            get {
                return ResourceManager.GetString("BestBidBackGround", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Between.
        /// </summary>
        public static string Between {
            get {
                return ResourceManager.GetString("Between", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Between Color.
        /// </summary>
        public static string BetweenColor {
            get {
                return ResourceManager.GetString("BetweenColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid.
        /// </summary>
        public static string Bid {
            get {
                return ResourceManager.GetString("Bid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid And Ask.
        /// </summary>
        public static string BidAndAsk {
            get {
                return ResourceManager.GetString("BidAndAsk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to BidAsk.
        /// </summary>
        public static string BidAsk {
            get {
                return ResourceManager.GetString("BidAsk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid/Ask Imbalance Color.
        /// </summary>
        public static string BidAskImbalanceColor {
            get {
                return ResourceManager.GetString("BidAskImbalanceColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid Color.
        /// </summary>
        public static string BidColor {
            get {
                return ResourceManager.GetString("BidColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid Filter.
        /// </summary>
        public static string BidFilter {
            get {
                return ResourceManager.GetString("BidFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid Or Ask.
        /// </summary>
        public static string BidOrAsk {
            get {
                return ResourceManager.GetString("BidOrAsk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid Rows.
        /// </summary>
        public static string BidRows {
            get {
                return ResourceManager.GetString("BidRows", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bids Background.
        /// </summary>
        public static string BidsBackGround {
            get {
                return ResourceManager.GetString("BidsBackGround", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Body.
        /// </summary>
        public static string Body {
            get {
                return ResourceManager.GetString("Body", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bollinger Bands.
        /// </summary>
        public static string BollingerBands {
            get {
                return ResourceManager.GetString("BollingerBands", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Border.
        /// </summary>
        public static string Border {
            get {
                return ResourceManager.GetString("Border", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Border Color.
        /// </summary>
        public static string BorderColor {
            get {
                return ResourceManager.GetString("BorderColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Border Width.
        /// </summary>
        public static string BorderWidth {
            get {
                return ResourceManager.GetString("BorderWidth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Both.
        /// </summary>
        public static string Both {
            get {
                return ResourceManager.GetString("Both", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bottom Band.
        /// </summary>
        public static string BottomBand {
            get {
                return ResourceManager.GetString("BottomBand", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bottom - Left.
        /// </summary>
        public static string BottomLeft {
            get {
                return ResourceManager.GetString("BottomLeft", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bottom - Right.
        /// </summary>
        public static string BottomRight {
            get {
                return ResourceManager.GetString("BottomRight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Break Down Color.
        /// </summary>
        public static string BreakDnColor {
            get {
                return ResourceManager.GetString("BreakDnColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Break Up Color.
        /// </summary>
        public static string BreakUpColor {
            get {
                return ResourceManager.GetString("BreakUpColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Broken Channel Color.
        /// </summary>
        public static string BrokenChannelColor {
            get {
                return ResourceManager.GetString("BrokenChannelColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bullish.
        /// </summary>
        public static string Bullish {
            get {
                return ResourceManager.GetString("Bullish", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bullish Color.
        /// </summary>
        public static string BullishColor {
            get {
                return ResourceManager.GetString("BullishColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buy Color.
        /// </summary>
        public static string BuyColor {
            get {
                return ResourceManager.GetString("BuyColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buy Overshoot 1 Color.
        /// </summary>
        public static string BuyOvershoot1Color {
            get {
                return ResourceManager.GetString("BuyOvershoot1Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buy Overshoot 2 Color.
        /// </summary>
        public static string BuyOvershoot2Color {
            get {
                return ResourceManager.GetString("BuyOvershoot2Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buy Overshoot 3 Color.
        /// </summary>
        public static string BuyOvershoot3Color {
            get {
                return ResourceManager.GetString("BuyOvershoot3Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buy Overshoot Color.
        /// </summary>
        public static string BuyOvershootColor {
            get {
                return ResourceManager.GetString("BuyOvershootColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buys.
        /// </summary>
        public static string Buys {
            get {
                return ResourceManager.GetString("Buys", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buy/Sell Power.
        /// </summary>
        public static string BuySellPower {
            get {
                return ResourceManager.GetString("BuySellPower", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bill Williams Moving Average.
        /// </summary>
        public static string BWMA {
            get {
                return ResourceManager.GetString("BWMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By Bar.
        /// </summary>
        public static string ByBar {
            get {
                return ResourceManager.GetString("ByBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calculation.
        /// </summary>
        public static string Calculation {
            get {
                return ResourceManager.GetString("Calculation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calculation Mode.
        /// </summary>
        public static string CalculationMode {
            get {
                return ResourceManager.GetString("CalculationMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Calculation Settings.
        /// </summary>
        public static string CalculationSettings {
            get {
                return ResourceManager.GetString("CalculationSettings", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Candle Body Height.
        /// </summary>
        public static string CandleBodyHeight {
            get {
                return ResourceManager.GetString("CandleBodyHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Candle Body Height Filter.
        /// </summary>
        public static string CandleBodyHeightFilter {
            get {
                return ResourceManager.GetString("CandleBodyHeightFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Candle Direction.
        /// </summary>
        public static string CandleDirection {
            get {
                return ResourceManager.GetString("CandleDirection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Candle Height.
        /// </summary>
        public static string CandleHeight {
            get {
                return ResourceManager.GetString("CandleHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Candle Height Filter.
        /// </summary>
        public static string CandleHeightFilter {
            get {
                return ResourceManager.GetString("CandleHeightFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Candles.
        /// </summary>
        public static string Candles {
            get {
                return ResourceManager.GetString("Candles", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Commodity Channel Index.
        /// </summary>
        public static string CCI {
            get {
                return ResourceManager.GetString("CCI", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Center.
        /// </summary>
        public static string Center {
            get {
                return ResourceManager.GetString("Center", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Center Align.
        /// </summary>
        public static string CenterAlign {
            get {
                return ResourceManager.GetString("CenterAlign", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Changing Level Alert.
        /// </summary>
        public static string ChangingLevelAlert {
            get {
                return ResourceManager.GetString("ChangingLevelAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Circles.
        /// </summary>
        public static string Circles {
            get {
                return ResourceManager.GetString("Circles", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Close.
        /// </summary>
        public static string Close {
            get {
                return ResourceManager.GetString("Close", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Close Partially.
        /// </summary>
        public static string ClosePartially {
            get {
                return ResourceManager.GetString("ClosePartially", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Previous Day Close.
        /// </summary>
        public static string ClosePrevDay {
            get {
                return ResourceManager.GetString("ClosePrevDay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cluster Selection Transparency.
        /// </summary>
        public static string ClusterSelectionTransparency {
            get {
                return ResourceManager.GetString("ClusterSelectionTransparency", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Clusters Mode.
        /// </summary>
        public static string ClustersMode {
            get {
                return ResourceManager.GetString("ClustersMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Color.
        /// </summary>
        public static string Color {
            get {
                return ResourceManager.GetString("Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 20% Color.
        /// </summary>
        public static string Color20 {
            get {
                return ResourceManager.GetString("Color20", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 50% Color.
        /// </summary>
        public static string Color50 {
            get {
                return ResourceManager.GetString("Color50", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 80% Color.
        /// </summary>
        public static string Color80 {
            get {
                return ResourceManager.GetString("Color80", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change Color Before New Candle.
        /// </summary>
        public static string ColorBeforeCandle {
            get {
                return ResourceManager.GetString("ColorBeforeCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Colored Direction.
        /// </summary>
        public static string ColoredDirection {
            get {
                return ResourceManager.GetString("ColoredDirection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -20% Color.
        /// </summary>
        public static string ColorMinus20 {
            get {
                return ResourceManager.GetString("ColorMinus20", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -50% Color.
        /// </summary>
        public static string ColorMinus50 {
            get {
                return ResourceManager.GetString("ColorMinus50", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -80% Color.
        /// </summary>
        public static string ColorMinus80 {
            get {
                return ResourceManager.GetString("ColorMinus80", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Colors.
        /// </summary>
        public static string Colors {
            get {
                return ResourceManager.GetString("Colors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Color Scheme.
        /// </summary>
        public static string ColorScheme {
            get {
                return ResourceManager.GetString("ColorScheme", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Combined.
        /// </summary>
        public static string Combined {
            get {
                return ResourceManager.GetString("Combined", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Combine Small Trades.
        /// </summary>
        public static string CombineSmallTrades {
            get {
                return ResourceManager.GetString("CombineSmallTrades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Common.
        /// </summary>
        public static string Common {
            get {
                return ResourceManager.GetString("Common", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cool down period (seconds).
        /// </summary>
        public static string CoolDownPeriod {
            get {
                return ResourceManager.GetString("CoolDownPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Copyright.
        /// </summary>
        public static string Copyright {
            get {
                return ResourceManager.GetString("Copyright", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cumulative.
        /// </summary>
        public static string Cumulative {
            get {
                return ResourceManager.GetString("Cumulative", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cumulative Mode.
        /// </summary>
        public static string CumulativeMode {
            get {
                return ResourceManager.GetString("CumulativeMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cumulative Trades.
        /// </summary>
        public static string CumulativeTrades {
            get {
                return ResourceManager.GetString("CumulativeTrades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Current Day.
        /// </summary>
        public static string CurrentDay {
            get {
                return ResourceManager.GetString("CurrentDay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Current Month.
        /// </summary>
        public static string CurrentMonth {
            get {
                return ResourceManager.GetString("CurrentMonth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Current Time.
        /// </summary>
        public static string CurrentTime {
            get {
                return ResourceManager.GetString("CurrentTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Current Timeframe.
        /// </summary>
        public static string CurrentTimeFrame {
            get {
                return ResourceManager.GetString("CurrentTimeFrame", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Current Week.
        /// </summary>
        public static string CurrentWeek {
            get {
                return ResourceManager.GetString("CurrentWeek", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Range.
        /// </summary>
        public static string CustomDiapason {
            get {
                return ResourceManager.GetString("CustomDiapason", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Price.
        /// </summary>
        public static string CustomPrice {
            get {
                return ResourceManager.GetString("CustomPrice", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Height Of Price Levels.
        /// </summary>
        public static string CustomPriceLevelsHeight {
            get {
                return ResourceManager.GetString("CustomPriceLevelsHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Scale.
        /// </summary>
        public static string CustomScale {
            get {
                return ResourceManager.GetString("CustomScale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Session.
        /// </summary>
        public static string CustomSession {
            get {
                return ResourceManager.GetString("CustomSession", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Session Start.
        /// </summary>
        public static string CustomSessionStart {
            get {
                return ResourceManager.GetString("CustomSessionStart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Current Time Timezone.
        /// </summary>
        public static string CustomTimeZone {
            get {
                return ResourceManager.GetString("CustomTimeZone", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom VWAP Starting Point.
        /// </summary>
        public static string CustomVWAP {
            get {
                return ResourceManager.GetString("CustomVWAP", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Daily.
        /// </summary>
        public static string Daily {
            get {
                return ResourceManager.GetString("Daily", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Style.
        /// </summary>
        public static string DashStyle {
            get {
                return ResourceManager.GetString("DashStyle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data.
        /// </summary>
        public static string Data {
            get {
                return ResourceManager.GetString("Data", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Days.
        /// </summary>
        public static string Days {
            get {
                return ResourceManager.GetString("Days", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Days Look Back.
        /// </summary>
        public static string DaysLookBack {
            get {
                return ResourceManager.GetString("DaysLookBack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Refers to the number of previous days taken into account when calculating an indicator.
        /// </summary>
        public static string DaysLookBackDescription {
            get {
                return ResourceManager.GetString("DaysLookBackDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Days Period.
        /// </summary>
        public static string DaysPeriod {
            get {
                return ResourceManager.GetString("DaysPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Default.
        /// </summary>
        public static string Default {
            get {
                return ResourceManager.GetString("Default", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delete Starting Point.
        /// </summary>
        public static string DeleteStartPoint {
            get {
                return ResourceManager.GetString("DeleteStartPoint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delta.
        /// </summary>
        public static string Delta {
            get {
                return ResourceManager.GetString("Delta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delta Alert.
        /// </summary>
        public static string DeltaAlert {
            get {
                return ResourceManager.GetString("DeltaAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delta Coloring.
        /// </summary>
        public static string DeltaColored {
            get {
                return ResourceManager.GetString("DeltaColored", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delta Filter.
        /// </summary>
        public static string DeltaFilter {
            get {
                return ResourceManager.GetString("DeltaFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property is used to set a filter on the delta for a specific price level. If the value is positive, the filter will only allow price levels where the delta is greater than or equal to the value. If the value is negative, the filter will only allow price levels where the delta is less than or equal to the value..
        /// </summary>
        public static string DeltaFilterDescription {
            get {
                return ResourceManager.GetString("DeltaFilterDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delta Filters.
        /// </summary>
        public static string DeltaFilters {
            get {
                return ResourceManager.GetString("DeltaFilters", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Bid Ask Imbalance,%.
        /// </summary>
        public static string DeltaImbalance {
            get {
                return ResourceManager.GetString("DeltaImbalance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property is used to filter out price levels based on the difference between the percentage of ask volume and the percentage of bid volume. If the value is positive, the filter will only allow price levels where the percentage of ask volume is greater than or equal to the value. If the value is negative, the filter will only allow price levels where the percentage of bid volume is greater than or equal to the absolute value..
        /// </summary>
        public static string DeltaImbalanceDescription {
            get {
                return ResourceManager.GetString("DeltaImbalanceDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Delta Type.
        /// </summary>
        public static string DeltaType {
            get {
                return ResourceManager.GetString("DeltaType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Double Exponential Moving Average.
        /// </summary>
        public static string DEMA {
            get {
                return ResourceManager.GetString("DEMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Depth Of Market.
        /// </summary>
        public static string DepthMarket {
            get {
                return ResourceManager.GetString("DepthMarket", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Depth Of Market Filter.
        /// </summary>
        public static string DepthMarketFilter {
            get {
                return ResourceManager.GetString("DepthMarketFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Description.
        /// </summary>
        public static string Description {
            get {
                return ResourceManager.GetString("Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Deviation.
        /// </summary>
        public static string Deviation {
            get {
                return ResourceManager.GetString("Deviation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Digits After The Decimal Point In Volume Values.
        /// </summary>
        public static string DigitsAfterComma {
            get {
                return ResourceManager.GetString("DigitsAfterComma", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Negative Directional Indicator.
        /// </summary>
        public static string DINeg {
            get {
                return ResourceManager.GetString("DINeg", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Positive Directional Indicator.
        /// </summary>
        public static string DIPos {
            get {
                return ResourceManager.GetString("DIPos", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Direction Filter.
        /// </summary>
        public static string DirectionFilter {
            get {
                return ResourceManager.GetString("DirectionFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Direction Of Zone.
        /// </summary>
        public static string DirectionOfZone {
            get {
                return ResourceManager.GetString("DirectionOfZone", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disabled.
        /// </summary>
        public static string Disabled {
            get {
                return ResourceManager.GetString("Disabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Display At Bottom.
        /// </summary>
        public static string DisplayBottom {
            get {
                return ResourceManager.GetString("DisplayBottom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Display Mode.
        /// </summary>
        public static string DisplayMode {
            get {
                return ResourceManager.GetString("DisplayMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Divisor.
        /// </summary>
        public static string Divisor {
            get {
                return ResourceManager.GetString("Divisor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dodge.
        /// </summary>
        public static string Dodge {
            get {
                return ResourceManager.GetString("Dodge", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Doji Candle Bear.
        /// </summary>
        public static string DojiCandleBear {
            get {
                return ResourceManager.GetString("DojiCandleBear", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Doji Candle Bull.
        /// </summary>
        public static string DojiCandleBull {
            get {
                return ResourceManager.GetString("DojiCandleBull", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Doji Empty Color.
        /// </summary>
        public static string DojiEmptyColor {
            get {
                return ResourceManager.GetString("DojiEmptyColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do Not Show Above Chart.
        /// </summary>
        public static string DoNotShowAboveChart {
            get {
                return ResourceManager.GetString("DoNotShowAboveChart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Down.
        /// </summary>
        public static string Down {
            get {
                return ResourceManager.GetString("Down", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Down Alert.
        /// </summary>
        public static string DownAlert {
            get {
                return ResourceManager.GetString("DownAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Drawing.
        /// </summary>
        public static string Drawing {
            get {
                return ResourceManager.GetString("Drawing", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Directional Movement Index.
        /// </summary>
        public static string DX {
            get {
                return ResourceManager.GetString("DX", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Efficiency Ratio Period.
        /// </summary>
        public static string EfficiencyRatioPeriod {
            get {
                return ResourceManager.GetString("EfficiencyRatioPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average (EMA).
        /// </summary>
        public static string EMA {
            get {
                return ResourceManager.GetString("EMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to EMA Period.
        /// </summary>
        public static string EMAPeriod {
            get {
                return ResourceManager.GetString("EMAPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average Period 1.
        /// </summary>
        public static string EmaPeriod1 {
            get {
                return ResourceManager.GetString("EmaPeriod1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average Period 2.
        /// </summary>
        public static string EmaPeriod2 {
            get {
                return ResourceManager.GetString("EmaPeriod2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average Period 3.
        /// </summary>
        public static string EmaPeriod3 {
            get {
                return ResourceManager.GetString("EmaPeriod3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average Period 4.
        /// </summary>
        public static string EmaPeriod4 {
            get {
                return ResourceManager.GetString("EmaPeriod4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average Period 5.
        /// </summary>
        public static string EmaPeriod5 {
            get {
                return ResourceManager.GetString("EmaPeriod5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exponential Moving Average Period 6.
        /// </summary>
        public static string EmaPeriod6 {
            get {
                return ResourceManager.GetString("EmaPeriod6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enabled.
        /// </summary>
        public static string Enabled {
            get {
                return ResourceManager.GetString("Enabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to End Time.
        /// </summary>
        public static string EndTime {
            get {
                return ResourceManager.GetString("EndTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Equilibrium Bottom Candle.
        /// </summary>
        public static string EquilibriumBottomCandle {
            get {
                return ResourceManager.GetString("EquilibriumBottomCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Equilibrium Top Candle.
        /// </summary>
        public static string EquilibriumTopCandle {
            get {
                return ResourceManager.GetString("EquilibriumTopCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Estimator.
        /// </summary>
        public static string Estimator {
            get {
                return ResourceManager.GetString("Estimator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exact.
        /// </summary>
        public static string Exact {
            get {
                return ResourceManager.GetString("Exact", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extend Last.
        /// </summary>
        public static string ExtendLast {
            get {
                return ResourceManager.GetString("ExtendLast", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extend Lines.
        /// </summary>
        public static string ExtendLines {
            get {
                return ResourceManager.GetString("ExtendLines", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Extend Previous.
        /// </summary>
        public static string ExtendPrevious {
            get {
                return ResourceManager.GetString("ExtendPrevious", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to External Period.
        /// </summary>
        public static string ExternalPeriod {
            get {
                return ResourceManager.GetString("ExternalPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fake Series.
        /// </summary>
        public static string FakeSeries {
            get {
                return ResourceManager.GetString("FakeSeries", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fake Series Color.
        /// </summary>
        public static string FakeSeriesColor {
            get {
                return ResourceManager.GetString("FakeSeriesColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fast Smoothing Constant.
        /// </summary>
        public static string FastConst {
            get {
                return ResourceManager.GetString("FastConst", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fast Line.
        /// </summary>
        public static string FastLine {
            get {
                return ResourceManager.GetString("FastLine", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fill Candles.
        /// </summary>
        public static string FillCandles {
            get {
                return ResourceManager.GetString("FillCandles", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fill Color.
        /// </summary>
        public static string FillColor {
            get {
                return ResourceManager.GetString("FillColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter.
        /// </summary>
        public static string Filter {
            get {
                return ResourceManager.GetString("Filter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter №1.
        /// </summary>
        public static string Filter1 {
            get {
                return ResourceManager.GetString("Filter1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter №2.
        /// </summary>
        public static string Filter2 {
            get {
                return ResourceManager.GetString("Filter2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter №3.
        /// </summary>
        public static string Filter3 {
            get {
                return ResourceManager.GetString("Filter3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter №4.
        /// </summary>
        public static string Filter4 {
            get {
                return ResourceManager.GetString("Filter4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter №5.
        /// </summary>
        public static string Filter5 {
            get {
                return ResourceManager.GetString("Filter5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter Color.
        /// </summary>
        public static string FilterColor {
            get {
                return ResourceManager.GetString("FilterColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filter is empty.
        /// </summary>
        public static string FilterEmptyMsg {
            get {
                return ResourceManager.GetString("FilterEmptyMsg", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Filters.
        /// </summary>
        public static string Filters {
            get {
                return ResourceManager.GetString("Filters", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to First Bar.
        /// </summary>
        public static string FirstBar {
            get {
                return ResourceManager.GetString("FirstBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to First Dev..
        /// </summary>
        public static string FirstDev {
            get {
                return ResourceManager.GetString("FirstDev", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to First Line.
        /// </summary>
        public static string FirstLine {
            get {
                return ResourceManager.GetString("FirstLine", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fixed Sizes.
        /// </summary>
        public static string FixedSizes {
            get {
                return ResourceManager.GetString("FixedSizes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Fixed Value.
        /// </summary>
        public static string FixedValue {
            get {
                return ResourceManager.GetString("FixedValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Flat Color.
        /// </summary>
        public static string FlatColor {
            get {
                return ResourceManager.GetString("FlatColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Font.
        /// </summary>
        public static string Font {
            get {
                return ResourceManager.GetString("Font", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Font Color.
        /// </summary>
        public static string FontColor {
            get {
                return ResourceManager.GetString("FontColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Font Size.
        /// </summary>
        public static string FontSize {
            get {
                return ResourceManager.GetString("FontSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Frame Multiplier.
        /// </summary>
        public static string FrameMultiplier {
            get {
                return ResourceManager.GetString("FrameMultiplier", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Frame Size.
        /// </summary>
        public static string FrameSize {
            get {
                return ResourceManager.GetString("FrameSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to General.
        /// </summary>
        public static string General {
            get {
                return ResourceManager.GetString("General", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Green Series.
        /// </summary>
        public static string GreenSeries {
            get {
                return ResourceManager.GetString("GreenSeries", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Green Series Color.
        /// </summary>
        public static string GreenSeriesColor {
            get {
                return ResourceManager.GetString("GreenSeriesColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Grid.
        /// </summary>
        public static string Grid {
            get {
                return ResourceManager.GetString("Grid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Grid Color.
        /// </summary>
        public static string GridColor {
            get {
                return ResourceManager.GetString("GridColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Grid Step.
        /// </summary>
        public static string GridStep {
            get {
                return ResourceManager.GetString("GridStep", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Grid Style.
        /// </summary>
        public static string GridStyle {
            get {
                return ResourceManager.GetString("GridStyle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to H2.
        /// </summary>
        public static string H2 {
            get {
                return ResourceManager.GetString("H2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to H4.
        /// </summary>
        public static string H4 {
            get {
                return ResourceManager.GetString("H4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to H6.
        /// </summary>
        public static string H6 {
            get {
                return ResourceManager.GetString("H6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Headers Background.
        /// </summary>
        public static string HeaderBackground {
            get {
                return ResourceManager.GetString("HeaderBackground", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Headers.
        /// </summary>
        public static string Headers {
            get {
                return ResourceManager.GetString("Headers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Height.
        /// </summary>
        public static string Height {
            get {
                return ResourceManager.GetString("Height", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HHMMSS.
        /// </summary>
        public static string HHMMSS {
            get {
                return ResourceManager.GetString("HHMMSS", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HHMMSSPM.
        /// </summary>
        public static string HHMMSSPM {
            get {
                return ResourceManager.GetString("HHMMSSPM", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hide All.
        /// </summary>
        public static string HideAll {
            get {
                return ResourceManager.GetString("HideAll", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hide Border.
        /// </summary>
        public static string HideBorder {
            get {
                return ResourceManager.GetString("HideBorder", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hide Gaps.
        /// </summary>
        public static string HideGaps {
            get {
                return ResourceManager.GetString("HideGaps", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hide Olds.
        /// </summary>
        public static string HideOlds {
            get {
                return ResourceManager.GetString("HideOlds", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hide Headers.
        /// </summary>
        public static string HideRowsDescription {
            get {
                return ResourceManager.GetString("HideRowsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High.
        /// </summary>
        public static string High {
            get {
                return ResourceManager.GetString("High", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High Color.
        /// </summary>
        public static string HighColor {
            get {
                return ResourceManager.GetString("HighColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Higher Timeframe.
        /// </summary>
        public static string HigherTimeFrame {
            get {
                return ResourceManager.GetString("HigherTimeFrame", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Highest.
        /// </summary>
        public static string Highest {
            get {
                return ResourceManager.GetString("Highest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Highlight Signal Bars.
        /// </summary>
        public static string HighlightSignalBars {
            get {
                return ResourceManager.GetString("HighlightSignalBars", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High Line Color.
        /// </summary>
        public static string HighLineColor {
            get {
                return ResourceManager.GetString("HighLineColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High / Low.
        /// </summary>
        public static string HighLow {
            get {
                return ResourceManager.GetString("HighLow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to (High + Low)/2.
        /// </summary>
        public static string HighLow2 {
            get {
                return ResourceManager.GetString("HighLow2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to (High + Low + 2*Close)/4.
        /// </summary>
        public static string HighLow2Close4 {
            get {
                return ResourceManager.GetString("HighLow2Close4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to (High + Low + Close)/3.
        /// </summary>
        public static string HighLowClose3 {
            get {
                return ResourceManager.GetString("HighLowClose3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High Low Color.
        /// </summary>
        public static string HighLowColor {
            get {
                return ResourceManager.GetString("HighLowColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High Ratio.
        /// </summary>
        public static string HighRatio {
            get {
                return ResourceManager.GetString("HighRatio", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to High Session.
        /// </summary>
        public static string HighSession {
            get {
                return ResourceManager.GetString("HighSession", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Histogram.
        /// </summary>
        public static string Histogram {
            get {
                return ResourceManager.GetString("Histogram", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Histogram Size.
        /// </summary>
        public static string HistogramSize {
            get {
                return ResourceManager.GetString("HistogramSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HL Average.
        /// </summary>
        public static string HLAverage {
            get {
                return ResourceManager.GetString("HLAverage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HLC Average.
        /// </summary>
        public static string HLCAverage {
            get {
                return ResourceManager.GetString("HLCAverage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hull Moving Average (HMA).
        /// </summary>
        public static string HMA {
            get {
                return ResourceManager.GetString("HMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Horizontal Offset.
        /// </summary>
        public static string HorizontalOffset {
            get {
                return ResourceManager.GetString("HorizontalOffset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hourly.
        /// </summary>
        public static string Hourly {
            get {
                return ResourceManager.GetString("Hourly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBH-IBM.
        /// </summary>
        public static string IBHM {
            get {
                return ResourceManager.GetString("IBHM", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBHX1-IBH.
        /// </summary>
        public static string IBHX1H {
            get {
                return ResourceManager.GetString("IBHX1H", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBHX2-1.
        /// </summary>
        public static string IBHX21 {
            get {
                return ResourceManager.GetString("IBHX21", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBHX3-2.
        /// </summary>
        public static string IBHX32 {
            get {
                return ResourceManager.GetString("IBHX32", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBL-IBLX1.
        /// </summary>
        public static string IBL1 {
            get {
                return ResourceManager.GetString("IBL1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBLX1-2.
        /// </summary>
        public static string IBLX12 {
            get {
                return ResourceManager.GetString("IBLX12", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBLX2-3.
        /// </summary>
        public static string IBLX23 {
            get {
                return ResourceManager.GetString("IBLX23", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IBM-IBL.
        /// </summary>
        public static string IBML {
            get {
                return ResourceManager.GetString("IBML", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ignore Wicks.
        /// </summary>
        public static string IgnoreWicks {
            get {
                return ResourceManager.GetString("IgnoreWicks", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ignore Zero Values.
        /// </summary>
        public static string IgnoreZeroValues {
            get {
                return ResourceManager.GetString("IgnoreZeroValues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Image Location.
        /// </summary>
        public static string ImageLocation {
            get {
                return ResourceManager.GetString("ImageLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Imbalance Range.
        /// </summary>
        public static string ImbalanceRange {
            get {
                return ResourceManager.GetString("ImbalanceRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Imbalance Ratio.
        /// </summary>
        public static string ImbalanceRatio {
            get {
                return ResourceManager.GetString("ImbalanceRatio", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Imbalance Volume.
        /// </summary>
        public static string ImbalanceVolume {
            get {
                return ResourceManager.GetString("ImbalanceVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Include Equal High Low.
        /// </summary>
        public static string IncludeEqualHighLow {
            get {
                return ResourceManager.GetString("IncludeEqualHighLow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Indicator.
        /// </summary>
        public static string Indicator {
            get {
                return ResourceManager.GetString("Indicator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Inside Bar.
        /// </summary>
        public static string InsideBar {
            get {
                return ResourceManager.GetString("InsideBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Inside Or Equals Bar.
        /// </summary>
        public static string InsideEqualBar {
            get {
                return ResourceManager.GetString("InsideEqualBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Instrument Paramethers.
        /// </summary>
        public static string InstrumentParameters {
            get {
                return ResourceManager.GetString("InstrumentParameters", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invert Output.
        /// </summary>
        public static string InvertOutput {
            get {
                return ResourceManager.GetString("InvertOutput", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Jaw Alligator.
        /// </summary>
        public static string JawAlligator {
            get {
                return ResourceManager.GetString("JawAlligator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Keltner Channel Multiplier Factor.
        /// </summary>
        public static string KCMultFactor {
            get {
                return ResourceManager.GetString("KCMultFactor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Keltner Channel Period.
        /// </summary>
        public static string KCPeriod {
            get {
                return ResourceManager.GetString("KCPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Keltner Channel.
        /// </summary>
        public static string KeltnerChannel {
            get {
                return ResourceManager.GetString("KeltnerChannel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Label.
        /// </summary>
        public static string Label {
            get {
                return ResourceManager.GetString("Label", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Label Location.
        /// </summary>
        public static string LabelLocation {
            get {
                return ResourceManager.GetString("LabelLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last Bar.
        /// </summary>
        public static string LastBar {
            get {
                return ResourceManager.GetString("LastBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Left.
        /// </summary>
        public static string Left {
            get {
                return ResourceManager.GetString("Left", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Length.
        /// </summary>
        public static string Length {
            get {
                return ResourceManager.GetString("Length", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Levels.
        /// </summary>
        public static string Levels {
            get {
                return ResourceManager.GetString("Levels", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Levels Mode.
        /// </summary>
        public static string LevelsMode {
            get {
                return ResourceManager.GetString("LevelsMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Limit Max Gap Body Length.
        /// </summary>
        public static string LimitMaxGapBodyLength {
            get {
                return ResourceManager.GetString("LimitMaxGapBodyLength", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Line.
        /// </summary>
        public static string Line {
            get {
                return ResourceManager.GetString("Line", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Linear Regression.
        /// </summary>
        public static string LinearReg {
            get {
                return ResourceManager.GetString("LinearReg", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Line Style.
        /// </summary>
        public static string LineStyle {
            get {
                return ResourceManager.GetString("LineStyle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Line Till Touch.
        /// </summary>
        public static string LineTillTouch {
            get {
                return ResourceManager.GetString("LineTillTouch", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Line Width.
        /// </summary>
        public static string LineWidth {
            get {
                return ResourceManager.GetString("LineWidth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Linked To Bar.
        /// </summary>
        public static string LinkingToBar {
            get {
                return ResourceManager.GetString("LinkingToBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lips Alligator.
        /// </summary>
        public static string LipsAlligator {
            get {
                return ResourceManager.GetString("LipsAlligator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Location.
        /// </summary>
        public static string Location {
            get {
                return ResourceManager.GetString("Location", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Location Filters.
        /// </summary>
        public static string LocationFilters {
            get {
                return ResourceManager.GetString("LocationFilters", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Image Files (*.bmp, *.gif, *.jpeg, *.jpg, *.png, *.tiff).
        /// </summary>
        public static string LogoFilePathDescription {
            get {
                return ResourceManager.GetString("LogoFilePathDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Location.
        /// </summary>
        public static string LogoLocation {
            get {
                return ResourceManager.GetString("LogoLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Long Period.
        /// </summary>
        public static string LongPeriod {
            get {
                return ResourceManager.GetString("LongPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lookback Period.
        /// </summary>
        public static string LookBack {
            get {
                return ResourceManager.GetString("LookBack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Low.
        /// </summary>
        public static string Low {
            get {
                return ResourceManager.GetString("Low", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Low Color.
        /// </summary>
        public static string LowColor {
            get {
                return ResourceManager.GetString("LowColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lower.
        /// </summary>
        public static string Lower {
            get {
                return ResourceManager.GetString("Lower", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lower Fill.
        /// </summary>
        public static string LowerFill {
            get {
                return ResourceManager.GetString("LowerFill", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lower Fill 2.
        /// </summary>
        public static string LowerFill2 {
            get {
                return ResourceManager.GetString("LowerFill2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lover Deviation 1.
        /// </summary>
        public static string LowerStd1 {
            get {
                return ResourceManager.GetString("LowerStd1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lover Deviation 2.
        /// </summary>
        public static string LowerStd2 {
            get {
                return ResourceManager.GetString("LowerStd2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lover Deviation 3.
        /// </summary>
        public static string LowerStd3 {
            get {
                return ResourceManager.GetString("LowerStd3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lower Wick.
        /// </summary>
        public static string LowerWick {
            get {
                return ResourceManager.GetString("LowerWick", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Lowest.
        /// </summary>
        public static string Lowest {
            get {
                return ResourceManager.GetString("Lowest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Low Line Color.
        /// </summary>
        public static string LowLineColor {
            get {
                return ResourceManager.GetString("LowLineColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Low Ratio.
        /// </summary>
        public static string LowRatio {
            get {
                return ResourceManager.GetString("LowRatio", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Low Session.
        /// </summary>
        public static string LowSession {
            get {
                return ResourceManager.GetString("LowSession", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -100.
        /// </summary>
        public static string m100 {
            get {
                return ResourceManager.GetString("m100", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -200.
        /// </summary>
        public static string m200 {
            get {
                return ResourceManager.GetString("m200", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -300.
        /// </summary>
        public static string m300 {
            get {
                return ResourceManager.GetString("m300", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Moving Average Convergence/Divergence.
        /// </summary>
        public static string MACD {
            get {
                return ResourceManager.GetString("MACD", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Margin.
        /// </summary>
        public static string Margin {
            get {
                return ResourceManager.GetString("Margin", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property is used to determine the maximum average trade required for a price level to be considered valid. The average trade is calculated by dividing the volume of a price level by the number of ticks on that level. If the resulting value is greater than this property, the price level will be excluded from consideration..
        /// </summary>
        public static string MaxAvgTradeDescription {
            get {
                return ResourceManager.GetString("MaxAvgTradeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Max Cumulative Volume.
        /// </summary>
        public static string MaxCumulativeVolume {
            get {
                return ResourceManager.GetString("MaxCumulativeVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximal Dynamic Period.
        /// </summary>
        public static string MaxDynamicPeriod {
            get {
                return ResourceManager.GetString("MaxDynamicPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Max Gap Body Length (bars).
        /// </summary>
        public static string MaxGapBodyLength {
            get {
                return ResourceManager.GetString("MaxGapBodyLength", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum.
        /// </summary>
        public static string Maximum {
            get {
                return ResourceManager.GetString("Maximum", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Ask.
        /// </summary>
        public static string MaximumAsk {
            get {
                return ResourceManager.GetString("MaximumAsk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Average Trade.
        /// </summary>
        public static string MaximumAverageTrade {
            get {
                return ResourceManager.GetString("MaximumAverageTrade", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Bid.
        /// </summary>
        public static string MaximumBid {
            get {
                return ResourceManager.GetString("MaximumBid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Candle Body Height.
        /// </summary>
        public static string MaximumCandleBodyHeight {
            get {
                return ResourceManager.GetString("MaximumCandleBodyHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Candle Height.
        /// </summary>
        public static string MaximumCandleHeight {
            get {
                return ResourceManager.GetString("MaximumCandleHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum trades Count.
        /// </summary>
        public static string MaximumCount {
            get {
                return ResourceManager.GetString("MaximumCount", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Delta.
        /// </summary>
        public static string MaximumDelta {
            get {
                return ResourceManager.GetString("MaximumDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Size.
        /// </summary>
        public static string MaximumSize {
            get {
                return ResourceManager.GetString("MaximumSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Trades.
        /// </summary>
        public static string MaximumTrades {
            get {
                return ResourceManager.GetString("MaximumTrades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Volume.
        /// </summary>
        public static string MaximumVolume {
            get {
                return ResourceManager.GetString("MaximumVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Shows line of maximum value of volume for specifyed amount of bars.
        /// </summary>
        public static string MaximumVolumeDescription {
            get {
                return ResourceManager.GetString("MaximumVolumeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Volume Filter.
        /// </summary>
        public static string MaximumVolumeFilter {
            get {
                return ResourceManager.GetString("MaximumVolumeFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Open Interest.
        /// </summary>
        public static string MaxOpenInterest {
            get {
                return ResourceManager.GetString("MaxOpenInterest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property is used to set the maximum volume percentage allowed for a price level to be considered valid. The volume percentage is calculated by dividing the volume of a price level by the total volume of the candle and multiplying by 100. If the resulting value is greater than this property, the price level will be excluded from consideration. If the property is set to 0, it will not be used in the validation check..
        /// </summary>
        public static string MaxPercentDescription {
            get {
                return ResourceManager.GetString("MaxPercentDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximal Period.
        /// </summary>
        public static string MaxPeriod {
            get {
                return ResourceManager.GetString("MaxPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Max Print Volume.
        /// </summary>
        public static string MaxPrintVolume {
            get {
                return ResourceManager.GetString("MaxPrintVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximum Value.
        /// </summary>
        public static string MaxValue {
            get {
                return ResourceManager.GetString("MaxValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximal Volume Color.
        /// </summary>
        public static string MaxVolColor {
            get {
                return ResourceManager.GetString("MaxVolColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Maximal Candle Volume Percent.
        /// </summary>
        public static string MaxVolPercent {
            get {
                return ResourceManager.GetString("MaxVolPercent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mean Deviation.
        /// </summary>
        public static string MeanDeviation {
            get {
                return ResourceManager.GetString("MeanDeviation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Middle.
        /// </summary>
        public static string Middle {
            get {
                return ResourceManager.GetString("Middle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Middle Band.
        /// </summary>
        public static string MiddleBand {
            get {
                return ResourceManager.GetString("MiddleBand", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Middle Fill Down.
        /// </summary>
        public static string MiddleFillDown {
            get {
                return ResourceManager.GetString("MiddleFillDown", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Middle Fill Up.
        /// </summary>
        public static string MiddleFillUp {
            get {
                return ResourceManager.GetString("MiddleFillUp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Midpoint.
        /// </summary>
        public static string Midpoint {
            get {
                return ResourceManager.GetString("Midpoint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Midpoint Touch.
        /// </summary>
        public static string MidpointTouch {
            get {
                return ResourceManager.GetString("MidpointTouch", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property is used to determine the minimum average trade required for a price level to be considered valid. The average trade is calculated by dividing the volume of a price level by the number of ticks on that level. If the resulting value is less than this property, the price level will be excluded from consideration..
        /// </summary>
        public static string MinAvgTradeDescription {
            get {
                return ResourceManager.GetString("MinAvgTradeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Min Cumulative Volume.
        /// </summary>
        public static string MinCumulativeVolume {
            get {
                return ResourceManager.GetString("MinCumulativeVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimal Deviation (%).
        /// </summary>
        public static string MinimalDeviation {
            get {
                return ResourceManager.GetString("MinimalDeviation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimize Mode.
        /// </summary>
        public static string Minimizedmode {
            get {
                return ResourceManager.GetString("Minimizedmode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum.
        /// </summary>
        public static string Minimum {
            get {
                return ResourceManager.GetString("Minimum", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Ask.
        /// </summary>
        public static string MinimumAsk {
            get {
                return ResourceManager.GetString("MinimumAsk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Average Trade.
        /// </summary>
        public static string MinimumAverageTrade {
            get {
                return ResourceManager.GetString("MinimumAverageTrade", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Bid.
        /// </summary>
        public static string MinimumBid {
            get {
                return ResourceManager.GetString("MinimumBid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Candle Body Height.
        /// </summary>
        public static string MinimumCandleBodyHeight {
            get {
                return ResourceManager.GetString("MinimumCandleBodyHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Candle Height.
        /// </summary>
        public static string MinimumCandleHeight {
            get {
                return ResourceManager.GetString("MinimumCandleHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Trades Count.
        /// </summary>
        public static string MinimumCount {
            get {
                return ResourceManager.GetString("MinimumCount", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Delta.
        /// </summary>
        public static string MinimumDelta {
            get {
                return ResourceManager.GetString("MinimumDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Size.
        /// </summary>
        public static string MinimumSize {
            get {
                return ResourceManager.GetString("MinimumSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Trades.
        /// </summary>
        public static string MinimumTrades {
            get {
                return ResourceManager.GetString("MinimumTrades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Volume.
        /// </summary>
        public static string MinimumVolume {
            get {
                return ResourceManager.GetString("MinimumVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Open Interest.
        /// </summary>
        public static string MinOpenInterest {
            get {
                return ResourceManager.GetString("MinOpenInterest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property is used to set the minimum volume percentage required for a price level to be considered valid. The volume percentage is calculated by dividing the volume of a price level by the total volume of the candle and multiplying by 100. If the resulting value is less than this property, the price level will be excluded from consideration. If the property is set to 0, it will not be used in the validation check..
        /// </summary>
        public static string MinPercentDescription {
            get {
                return ResourceManager.GetString("MinPercentDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimal Period.
        /// </summary>
        public static string MinPeriod {
            get {
                return ResourceManager.GetString("MinPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Min Print Volume.
        /// </summary>
        public static string MinPrintVolume {
            get {
                return ResourceManager.GetString("MinPrintVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -20.
        /// </summary>
        public static string minus20 {
            get {
                return ResourceManager.GetString("minus20", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to -80.
        /// </summary>
        public static string minus80 {
            get {
                return ResourceManager.GetString("minus80", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minutes.
        /// </summary>
        public static string Minutes {
            get {
                return ResourceManager.GetString("Minutes", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimum Value.
        /// </summary>
        public static string MinValue {
            get {
                return ResourceManager.GetString("MinValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Minimal Candle Volume Percent.
        /// </summary>
        public static string MinVolPercent {
            get {
                return ResourceManager.GetString("MinVolPercent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to MMSS.
        /// </summary>
        public static string MMSS {
            get {
                return ResourceManager.GetString("MMSS", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mode.
        /// </summary>
        public static string Mode {
            get {
                return ResourceManager.GetString("Mode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Momentum.
        /// </summary>
        public static string Momentum {
            get {
                return ResourceManager.GetString("Momentum", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Monthly.
        /// </summary>
        public static string Monthly {
            get {
                return ResourceManager.GetString("Monthly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move Candle Bear.
        /// </summary>
        public static string MoveCandleBear {
            get {
                return ResourceManager.GetString("MoveCandleBear", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move Candle Bull.
        /// </summary>
        public static string MoveCandleBull {
            get {
                return ResourceManager.GetString("MoveCandleBull", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Moving Average Type.
        /// </summary>
        public static string MovingType {
            get {
                return ResourceManager.GetString("MovingType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Multiplier.
        /// </summary>
        public static string Multiplier {
            get {
                return ResourceManager.GetString("Multiplier", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Multiplier 1.
        /// </summary>
        public static string Multiplier1 {
            get {
                return ResourceManager.GetString("Multiplier1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Multiplier 2.
        /// </summary>
        public static string Multiplier2 {
            get {
                return ResourceManager.GetString("Multiplier2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Multiplier 3.
        /// </summary>
        public static string Multiplier3 {
            get {
                return ResourceManager.GetString("Multiplier3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Negative.
        /// </summary>
        public static string Negative {
            get {
                return ResourceManager.GetString("Negative", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Negative Delta.
        /// </summary>
        public static string NegativeDelta {
            get {
                return ResourceManager.GetString("NegativeDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Neutral.
        /// </summary>
        public static string Neutral {
            get {
                return ResourceManager.GetString("Neutral", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Neutral/Border Color.
        /// </summary>
        public static string NeutralBorderColor {
            get {
                return ResourceManager.GetString("NeutralBorderColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Neutral Color.
        /// </summary>
        public static string NeutralColor {
            get {
                return ResourceManager.GetString("NeutralColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Neutral Ratio.
        /// </summary>
        public static string NeutralRatio {
            get {
                return ResourceManager.GetString("NeutralRatio", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to None.
        /// </summary>
        public static string None {
            get {
                return ResourceManager.GetString("None", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Objects Color.
        /// </summary>
        public static string ObjectsColor {
            get {
                return ResourceManager.GetString("ObjectsColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Offset.
        /// </summary>
        public static string Offset {
            get {
                return ResourceManager.GetString("Offset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Offset Multiplier.
        /// </summary>
        public static string OffsetMultiplier {
            get {
                return ResourceManager.GetString("OffsetMultiplier", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to X Offset.
        /// </summary>
        public static string OffsetX {
            get {
                return ResourceManager.GetString("OffsetX", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Y Offset.
        /// </summary>
        public static string OffsetY {
            get {
                return ResourceManager.GetString("OffsetY", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to OHLC Average.
        /// </summary>
        public static string OHLCAverage {
            get {
                return ResourceManager.GetString("OHLCAverage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Only Alerts Are Supported.
        /// </summary>
        public static string OnlyAlertsSupported {
            get {
                return ResourceManager.GetString("OnlyAlertsSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Only One Selection Per Bar.
        /// </summary>
        public static string OnlyOneSelectionPerBar {
            get {
                return ResourceManager.GetString("OnlyOneSelectionPerBar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Open.
        /// </summary>
        public static string Open {
            get {
                return ResourceManager.GetString("Open", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Open / Close.
        /// </summary>
        public static string OpenClose {
            get {
                return ResourceManager.GetString("OpenClose", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Current Day Open.
        /// </summary>
        public static string OpenCurDay {
            get {
                return ResourceManager.GetString("OpenCurDay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to (Open + High + Low + Close)/4.
        /// </summary>
        public static string OpenHighLowClose4 {
            get {
                return ResourceManager.GetString("OpenHighLowClose4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Open Line.
        /// </summary>
        public static string OpenLine {
            get {
                return ResourceManager.GetString("OpenLine", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Open Range.
        /// </summary>
        public static string OpenRange {
            get {
                return ResourceManager.GetString("OpenRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Open Session.
        /// </summary>
        public static string OpenSession {
            get {
                return ResourceManager.GetString("OpenSession", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Other.
        /// </summary>
        public static string Other {
            get {
                return ResourceManager.GetString("Other", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overbought.
        /// </summary>
        public static string Overbought {
            get {
                return ResourceManager.GetString("Overbought", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overbought Level 1.
        /// </summary>
        public static string Overbought1 {
            get {
                return ResourceManager.GetString("Overbought1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overbought Level 2.
        /// </summary>
        public static string Overbought2 {
            get {
                return ResourceManager.GetString("Overbought2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overbought Level 3.
        /// </summary>
        public static string Overbought3 {
            get {
                return ResourceManager.GetString("Overbought3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Oversold.
        /// </summary>
        public static string Oversold {
            get {
                return ResourceManager.GetString("Oversold", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Oversold Level 1.
        /// </summary>
        public static string Oversold1 {
            get {
                return ResourceManager.GetString("Oversold1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Oversold Level 2.
        /// </summary>
        public static string Oversold2 {
            get {
                return ResourceManager.GetString("Oversold2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Oversold Level 3.
        /// </summary>
        public static string Oversold3 {
            get {
                return ResourceManager.GetString("Oversold3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 100.
        /// </summary>
        public static string p100 {
            get {
                return ResourceManager.GetString("p100", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 200.
        /// </summary>
        public static string p200 {
            get {
                return ResourceManager.GetString("p200", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 300.
        /// </summary>
        public static string p300 {
            get {
                return ResourceManager.GetString("p300", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Paint Bars.
        /// </summary>
        public static string PaintBars {
            get {
                return ResourceManager.GetString("PaintBars", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parabolic SAR.
        /// </summary>
        public static string ParabolicSAR {
            get {
                return ResourceManager.GetString("ParabolicSAR", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Percent.
        /// </summary>
        public static string Percent {
            get {
                return ResourceManager.GetString("Percent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period.
        /// </summary>
        public static string Period {
            get {
                return ResourceManager.GetString("Period", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period 1.
        /// </summary>
        public static string Period1 {
            get {
                return ResourceManager.GetString("Period1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period 2.
        /// </summary>
        public static string Period2 {
            get {
                return ResourceManager.GetString("Period2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period 3.
        /// </summary>
        public static string Period3 {
            get {
                return ResourceManager.GetString("Period3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period 4.
        /// </summary>
        public static string Period4 {
            get {
                return ResourceManager.GetString("Period4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period 5.
        /// </summary>
        public static string Period5 {
            get {
                return ResourceManager.GetString("Period5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period %D.
        /// </summary>
        public static string PeriodD {
            get {
                return ResourceManager.GetString("PeriodD", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period %K.
        /// </summary>
        public static string PeriodK {
            get {
                return ResourceManager.GetString("PeriodK", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Period Type.
        /// </summary>
        public static string PeriodType {
            get {
                return ResourceManager.GetString("PeriodType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ticks From High.
        /// </summary>
        public static string PipsFromHigh {
            get {
                return ResourceManager.GetString("PipsFromHigh", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property sets the maximum distance in ticks from the candle&apos;s high price that a level can be considered as valid. If the distance between the level and the candle&apos;s high price exceeds the value of this property the level will not be considered as valid..
        /// </summary>
        public static string PipsFromHighDescription {
            get {
                return ResourceManager.GetString("PipsFromHighDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ticks From Low.
        /// </summary>
        public static string PipsFromLow {
            get {
                return ResourceManager.GetString("PipsFromLow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This property sets the maximum distance in ticks from the candle&apos;s low price that a level can be considered as valid. If the distance between the level and the candle&apos;s low price exceeds the value of this property the level will not be considered as valid..
        /// </summary>
        public static string PipsFromLowDescription {
            get {
                return ResourceManager.GetString("PipsFromLowDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pivot Range.
        /// </summary>
        public static string PivotRange {
            get {
                return ResourceManager.GetString("PivotRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to POC Level Change Alert.
        /// </summary>
        public static string PocChangeAlert {
            get {
                return ResourceManager.GetString("PocChangeAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to POC Touch Alert.
        /// </summary>
        public static string PocTouchAlert {
            get {
                return ResourceManager.GetString("PocTouchAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Positive.
        /// </summary>
        public static string Positive {
            get {
                return ResourceManager.GetString("Positive", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Positive Delta.
        /// </summary>
        public static string PositiveDelta {
            get {
                return ResourceManager.GetString("PositiveDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Predict.
        /// </summary>
        public static string Predict {
            get {
                return ResourceManager.GetString("Predict", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last Day.
        /// </summary>
        public static string PreviousDay {
            get {
                return ResourceManager.GetString("PreviousDay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last Month.
        /// </summary>
        public static string PreviousMonth {
            get {
                return ResourceManager.GetString("PreviousMonth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Last Week.
        /// </summary>
        public static string PreviousWeek {
            get {
                return ResourceManager.GetString("PreviousWeek", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price Change.
        /// </summary>
        public static string PriceChange {
            get {
                return ResourceManager.GetString("PriceChange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price Location.
        /// </summary>
        public static string PriceLocation {
            get {
                return ResourceManager.GetString("PriceLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price Offset.
        /// </summary>
        public static string PriceOffset {
            get {
                return ResourceManager.GetString("PriceOffset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price Range.
        /// </summary>
        public static string PriceRange {
            get {
                return ResourceManager.GetString("PriceRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It determines the range of prices that will be aggregated in the calculation. The range is defined by the number of ticks specified in the parameter..
        /// </summary>
        public static string PriceRangeDescription {
            get {
                return ResourceManager.GetString("PriceRangeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price Selection Color.
        /// </summary>
        public static string PriceSelectionColor {
            get {
                return ResourceManager.GetString("PriceSelectionColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Print Line For X Bars.
        /// </summary>
        public static string PrintLineForXBars {
            get {
                return ResourceManager.GetString("PrintLineForXBars", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Profile.
        /// </summary>
        public static string Profile {
            get {
                return ResourceManager.GetString("Profile", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Proportion Volume.
        /// </summary>
        public static string ProportionVolume {
            get {
                return ResourceManager.GetString("ProportionVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pullback Candle Bear.
        /// </summary>
        public static string PullbackCandleBear {
            get {
                return ResourceManager.GetString("PullbackCandleBear", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pullback Candle Bull.
        /// </summary>
        public static string PullbackCandleBull {
            get {
                return ResourceManager.GetString("PullbackCandleBull", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Range.
        /// </summary>
        public static string Range {
            get {
                return ResourceManager.GetString("Range", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Range Filter.
        /// </summary>
        public static string RangeFilter {
            get {
                return ResourceManager.GetString("RangeFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rectangles.
        /// </summary>
        public static string Rectangles {
            get {
                return ResourceManager.GetString("Rectangles", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Relative In %.
        /// </summary>
        public static string RelativeInPercent {
            get {
                return ResourceManager.GetString("RelativeInPercent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Render Periods.
        /// </summary>
        public static string RenderPeriods {
            get {
                return ResourceManager.GetString("RenderPeriods", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Repeat Alert.
        /// </summary>
        public static string RepeatAlert {
            get {
                return ResourceManager.GetString("RepeatAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Required Change.
        /// </summary>
        public static string RequiredChange {
            get {
                return ResourceManager.GetString("RequiredChange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reset On New Session.
        /// </summary>
        public static string ResetOnSession {
            get {
                return ResourceManager.GetString("ResetOnSession", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Resistance Color.
        /// </summary>
        public static string ResistanceColor {
            get {
                return ResourceManager.GetString("ResistanceColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Resistance Level.
        /// </summary>
        public static string ResistanceLevel {
            get {
                return ResourceManager.GetString("ResistanceLevel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Retrospective Analysis.
        /// </summary>
        public static string RetrospectiveAnalysis {
            get {
                return ResourceManager.GetString("RetrospectiveAnalysis", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reverse Alert.
        /// </summary>
        public static string ReverseAlert {
            get {
                return ResourceManager.GetString("ReverseAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Appears on divergences(candle is positive and delta is negative or visa versa).
        /// </summary>
        public static string ReverseAlertDescription {
            get {
                return ResourceManager.GetString("ReverseAlertDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Right.
        /// </summary>
        public static string Right {
            get {
                return ResourceManager.GetString("Right", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Right To Left.
        /// </summary>
        public static string RightToLeft {
            get {
                return ResourceManager.GetString("RightToLeft", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rows.
        /// </summary>
        public static string Rows {
            get {
                return ResourceManager.GetString("Rows", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Row Width.
        /// </summary>
        public static string RowWidth {
            get {
                return ResourceManager.GetString("RowWidth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Relative Strength Index.
        /// </summary>
        public static string RSI {
            get {
                return ResourceManager.GetString("RSI", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Relative Vigor Index.
        /// </summary>
        public static string RVI {
            get {
                return ResourceManager.GetString("RVI", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Save Custom Starting Point.
        /// </summary>
        public static string SaveStartPoint {
            get {
                return ResourceManager.GetString("SaveStartPoint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scale.
        /// </summary>
        public static string Scale {
            get {
                return ResourceManager.GetString("Scale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search Prints Inside Time Filter.
        /// </summary>
        public static string SearchPrintsInsideTimeFilter {
            get {
                return ResourceManager.GetString("SearchPrintsInsideTimeFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Second Dev..
        /// </summary>
        public static string SecondDev {
            get {
                return ResourceManager.GetString("SecondDev", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Second Line.
        /// </summary>
        public static string SecondLine {
            get {
                return ResourceManager.GetString("SecondLine", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Seconds.
        /// </summary>
        public static string Seconds {
            get {
                return ResourceManager.GetString("Seconds", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sell Color.
        /// </summary>
        public static string SellColor {
            get {
                return ResourceManager.GetString("SellColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sell Overshoot 1 Color.
        /// </summary>
        public static string SellOvershoot1Color {
            get {
                return ResourceManager.GetString("SellOvershoot1Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sell Overshoot 2 Color.
        /// </summary>
        public static string SellOvershoot2Color {
            get {
                return ResourceManager.GetString("SellOvershoot2Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sell Overshoot 3 Color.
        /// </summary>
        public static string SellOvershoot3Color {
            get {
                return ResourceManager.GetString("SellOvershoot3Color", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sell Overshoot Color.
        /// </summary>
        public static string SellOvershootColor {
            get {
                return ResourceManager.GetString("SellOvershootColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sells.
        /// </summary>
        public static string Sells {
            get {
                return ResourceManager.GetString("Sells", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Separated Trades.
        /// </summary>
        public static string SeparatedTrades {
            get {
                return ResourceManager.GetString("SeparatedTrades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session.
        /// </summary>
        public static string Session {
            get {
                return ResourceManager.GetString("Session", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session Begin.
        /// </summary>
        public static string SessionBegin {
            get {
                return ResourceManager.GetString("SessionBegin", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session Delta Mode.
        /// </summary>
        public static string SessionDeltaMode {
            get {
                return ResourceManager.GetString("SessionDeltaMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session End.
        /// </summary>
        public static string SessionEnd {
            get {
                return ResourceManager.GetString("SessionEnd", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session Time.
        /// </summary>
        public static string SessionTime {
            get {
                return ResourceManager.GetString("SessionTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Set Starting Point.
        /// </summary>
        public static string SetStartPoint {
            get {
                return ResourceManager.GetString("SetStartPoint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Settings.
        /// </summary>
        public static string Settings {
            get {
                return ResourceManager.GetString("Settings", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Shift.
        /// </summary>
        public static string Shift {
            get {
                return ResourceManager.GetString("Shift", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Short Period.
        /// </summary>
        public static string ShortPeriod {
            get {
                return ResourceManager.GetString("ShortPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Short Values.
        /// </summary>
        public static string ShortValues {
            get {
                return ResourceManager.GetString("ShortValues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show.
        /// </summary>
        public static string Show {
            get {
                return ResourceManager.GetString("Show", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Above Chart.
        /// </summary>
        public static string ShowAboveChart {
            get {
                return ResourceManager.GetString("ShowAboveChart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Area.
        /// </summary>
        public static string ShowArea {
            get {
                return ResourceManager.GetString("ShowArea", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show As Candle.
        /// </summary>
        public static string ShowAsCandle {
            get {
                return ResourceManager.GetString("ShowAsCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Asks.
        /// </summary>
        public static string ShowAsk {
            get {
                return ResourceManager.GetString("ShowAsk", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Average.
        /// </summary>
        public static string ShowAverage {
            get {
                return ResourceManager.GetString("ShowAverage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Bars.
        /// </summary>
        public static string ShowBars {
            get {
                return ResourceManager.GetString("ShowBars", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Bids.
        /// </summary>
        public static string ShowBid {
            get {
                return ResourceManager.GetString("ShowBid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Bot Block.
        /// </summary>
        public static string ShowBotBlock {
            get {
                return ResourceManager.GetString("ShowBotBlock", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Broken Channel.
        /// </summary>
        public static string ShowBrokenChannel {
            get {
                return ResourceManager.GetString("ShowBrokenChannel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Cumulative.
        /// </summary>
        public static string ShowCumulative {
            get {
                return ResourceManager.GetString("ShowCumulative", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Cumulative Values.
        /// </summary>
        public static string ShowCumulativeValues {
            get {
                return ResourceManager.GetString("ShowCumulativeValues", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Current Value.
        /// </summary>
        public static string ShowCurrentValue {
            get {
                return ResourceManager.GetString("ShowCurrentValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Delta.
        /// </summary>
        public static string ShowDelta {
            get {
                return ResourceManager.GetString("ShowDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Delta Change.
        /// </summary>
        public static string ShowDeltaChange {
            get {
                return ResourceManager.GetString("ShowDeltaChange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Delta/Volume.
        /// </summary>
        public static string ShowDeltaPerVolume {
            get {
                return ResourceManager.GetString("ShowDeltaPerVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Divergence.
        /// </summary>
        public static string ShowDivergence {
            get {
                return ResourceManager.GetString("ShowDivergence", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Duration.
        /// </summary>
        public static string ShowDuration {
            get {
                return ResourceManager.GetString("ShowDuration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Fibonacci Levels.
        /// </summary>
        public static string ShowFibonacci {
            get {
                return ResourceManager.GetString("ShowFibonacci", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show First Partial Period.
        /// </summary>
        public static string ShowFirstPartialPeriod {
            get {
                return ResourceManager.GetString("ShowFirstPartialPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Grid.
        /// </summary>
        public static string ShowGrid {
            get {
                return ResourceManager.GetString("ShowGrid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Height.
        /// </summary>
        public static string ShowHeight {
            get {
                return ResourceManager.GetString("ShowHeight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show High/Low.
        /// </summary>
        public static string ShowHighLow {
            get {
                return ResourceManager.GetString("ShowHighLow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show High/Low Current Value.
        /// </summary>
        public static string ShowHighLowValue {
            get {
                return ResourceManager.GetString("ShowHighLowValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Instrument.
        /// </summary>
        public static string ShowInstrument {
            get {
                return ResourceManager.GetString("ShowInstrument", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Lines.
        /// </summary>
        public static string ShowLines {
            get {
                return ResourceManager.GetString("ShowLines", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Maximum Delta.
        /// </summary>
        public static string ShowMaximumDelta {
            get {
                return ResourceManager.GetString("ShowMaximumDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Minimum Delta.
        /// </summary>
        public static string ShowMinimumDelta {
            get {
                return ResourceManager.GetString("ShowMinimumDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show on chart.
        /// </summary>
        public static string ShowOnChart {
            get {
                return ResourceManager.GetString("ShowOnChart", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Period.
        /// </summary>
        public static string ShowPeriod {
            get {
                return ResourceManager.GetString("ShowPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Price Selection.
        /// </summary>
        public static string ShowPriceSelection {
            get {
                return ResourceManager.GetString("ShowPriceSelection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Session Delta.
        /// </summary>
        public static string ShowSessionDelta {
            get {
                return ResourceManager.GetString("ShowSessionDelta", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Session Delta/Volume.
        /// </summary>
        public static string ShowSessionDeltaPerVolume {
            get {
                return ResourceManager.GetString("ShowSessionDeltaPerVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Session Volume.
        /// </summary>
        public static string ShowSessionVolume {
            get {
                return ResourceManager.GetString("ShowSessionVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Signal Numbers.
        /// </summary>
        public static string ShowSignalNumbers {
            get {
                return ResourceManager.GetString("ShowSignalNumbers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show SMA.
        /// </summary>
        public static string ShowSMA {
            get {
                return ResourceManager.GetString("ShowSMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Small Trades.
        /// </summary>
        public static string ShowSmallTrades {
            get {
                return ResourceManager.GetString("ShowSmallTrades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Ticks.
        /// </summary>
        public static string ShowTicks {
            get {
                return ResourceManager.GetString("ShowTicks", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Time.
        /// </summary>
        public static string ShowTime {
            get {
                return ResourceManager.GetString("ShowTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Timeframe Label.
        /// </summary>
        public static string ShowTimeFrameLabel {
            get {
                return ResourceManager.GetString("ShowTimeFrameLabel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Top Blocks.
        /// </summary>
        public static string ShowTopBlock {
            get {
                return ResourceManager.GetString("ShowTopBlock", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Trades Count.
        /// </summary>
        public static string ShowTradesCount {
            get {
                return ResourceManager.GetString("ShowTradesCount", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Volume.
        /// </summary>
        public static string ShowVolume {
            get {
                return ResourceManager.GetString("ShowVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Show Volume/Second.
        /// </summary>
        public static string ShowVolumePerSecond {
            get {
                return ResourceManager.GetString("ShowVolumePerSecond", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Signal.
        /// </summary>
        public static string Signal {
            get {
                return ResourceManager.GetString("Signal", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Signal Period.
        /// </summary>
        public static string SignalPeriod {
            get {
                return ResourceManager.GetString("SignalPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Singal Alert.
        /// </summary>
        public static string SingalAlert {
            get {
                return ResourceManager.GetString("SingalAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sit Series.
        /// </summary>
        public static string SitSeries {
            get {
                return ResourceManager.GetString("SitSeries", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sit Series Color.
        /// </summary>
        public static string SitSeriesColor {
            get {
                return ResourceManager.GetString("SitSeriesColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Size.
        /// </summary>
        public static string Size {
            get {
                return ResourceManager.GetString("Size", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Slow Smoothing Constant.
        /// </summary>
        public static string SlowConst {
            get {
                return ResourceManager.GetString("SlowConst", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Slow Factor.
        /// </summary>
        public static string SlowFactor {
            get {
                return ResourceManager.GetString("SlowFactor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Slow Line.
        /// </summary>
        public static string SlowLine {
            get {
                return ResourceManager.GetString("SlowLine", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Simple Moving Average (SMA).
        /// </summary>
        public static string SMA {
            get {
                return ResourceManager.GetString("SMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Simple Moving Average 1.
        /// </summary>
        public static string SMA1 {
            get {
                return ResourceManager.GetString("SMA1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Simple Moving Average 2.
        /// </summary>
        public static string SMA2 {
            get {
                return ResourceManager.GetString("SMA2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMA Color.
        /// </summary>
        public static string SMAColor {
            get {
                return ResourceManager.GetString("SMAColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMA Period.
        /// </summary>
        public static string SMAPeriod {
            get {
                return ResourceManager.GetString("SMAPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMA Period 1.
        /// </summary>
        public static string SMAPeriod1 {
            get {
                return ResourceManager.GetString("SMAPeriod1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMA Period 2.
        /// </summary>
        public static string SMAPeriod2 {
            get {
                return ResourceManager.GetString("SMAPeriod2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMA Period 3.
        /// </summary>
        public static string SMAPeriod3 {
            get {
                return ResourceManager.GetString("SMAPeriod3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SMA Period 4.
        /// </summary>
        public static string SMAPeriod4 {
            get {
                return ResourceManager.GetString("SMAPeriod4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Smoothed Moving Average (SMMA).
        /// </summary>
        public static string SMMA {
            get {
                return ResourceManager.GetString("SMMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Smooth.
        /// </summary>
        public static string Smooth {
            get {
                return ResourceManager.GetString("Smooth", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Spacing.
        /// </summary>
        public static string Spacing {
            get {
                return ResourceManager.GetString("Spacing", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Speed Interval.
        /// </summary>
        public static string SpeedInterval {
            get {
                return ResourceManager.GetString("SpeedInterval", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Support/Resistance Levels.
        /// </summary>
        public static string SRLevels {
            get {
                return ResourceManager.GetString("SRLevels", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Start Price.
        /// </summary>
        public static string StartPrice {
            get {
                return ResourceManager.GetString("StartPrice", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Start Time.
        /// </summary>
        public static string StartTime {
            get {
                return ResourceManager.GetString("StartTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Start Time(GMT).
        /// </summary>
        public static string StartTimeGmt {
            get {
                return ResourceManager.GetString("StartTimeGmt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Standard Deviation.
        /// </summary>
        public static string StdDev {
            get {
                return ResourceManager.GetString("StdDev", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Step.
        /// </summary>
        public static string Step {
            get {
                return ResourceManager.GetString("Step", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stochastic.
        /// </summary>
        public static string Stochastic {
            get {
                return ResourceManager.GetString("Stochastic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Strings.
        /// </summary>
        public static string Strings {
            get {
                return ResourceManager.GetString("Strings", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Strong Candle Bear.
        /// </summary>
        public static string StrongCandleBear {
            get {
                return ResourceManager.GetString("StrongCandleBear", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Strong Candle Bull.
        /// </summary>
        public static string StrongCandleBull {
            get {
                return ResourceManager.GetString("StrongCandleBull", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Support Color.
        /// </summary>
        public static string SupportColor {
            get {
                return ResourceManager.GetString("SupportColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Support Level.
        /// </summary>
        public static string SupportLevel {
            get {
                return ResourceManager.GetString("SupportLevel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sine-Wave Weighted Moving Average.
        /// </summary>
        public static string SWWMA {
            get {
                return ResourceManager.GetString("SWWMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Simple Moving Average - Skip Zeros.
        /// </summary>
        public static string SZMA {
            get {
                return ResourceManager.GetString("SZMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Teeth Alligator.
        /// </summary>
        public static string TeethAlligator {
            get {
                return ResourceManager.GetString("TeethAlligator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Triple Exponential Moving Average.
        /// </summary>
        public static string TEMA {
            get {
                return ResourceManager.GetString("TEMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text.
        /// </summary>
        public static string Text {
            get {
                return ResourceManager.GetString("Text", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text Color.
        /// </summary>
        public static string TextColor {
            get {
                return ResourceManager.GetString("TextColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text Location.
        /// </summary>
        public static string TextLocation {
            get {
                return ResourceManager.GetString("TextLocation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text Settings.
        /// </summary>
        public static string TextSettings {
            get {
                return ResourceManager.GetString("TextSettings", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Text Size.
        /// </summary>
        public static string TextSize {
            get {
                return ResourceManager.GetString("TextSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Third Dev..
        /// </summary>
        public static string ThirdDev {
            get {
                return ResourceManager.GetString("ThirdDev", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 3rd Formula.
        /// </summary>
        public static string ThirdFormula {
            get {
                return ResourceManager.GetString("ThirdFormula", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tick Cost.
        /// </summary>
        public static string TickCost {
            get {
                return ResourceManager.GetString("TickCost", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ticks.
        /// </summary>
        public static string Ticks {
            get {
                return ResourceManager.GetString("Ticks", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time.
        /// </summary>
        public static string Time {
            get {
                return ResourceManager.GetString("Time", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Filter.
        /// </summary>
        public static string TimeFilter {
            get {
                return ResourceManager.GetString("TimeFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Filter, Sec.
        /// </summary>
        public static string TimeFilterSec {
            get {
                return ResourceManager.GetString("TimeFilterSec", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Filtration.
        /// </summary>
        public static string TimeFiltration {
            get {
                return ResourceManager.GetString("TimeFiltration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Format.
        /// </summary>
        public static string TimeFormat {
            get {
                return ResourceManager.GetString("TimeFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Timeframe.
        /// </summary>
        public static string TimeFrame {
            get {
                return ResourceManager.GetString("TimeFrame", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Frame 1.
        /// </summary>
        public static string TimeFrame1 {
            get {
                return ResourceManager.GetString("TimeFrame1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Frame 2.
        /// </summary>
        public static string TimeFrame2 {
            get {
                return ResourceManager.GetString("TimeFrame2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Frame 3.
        /// </summary>
        public static string TimeFrame3 {
            get {
                return ResourceManager.GetString("TimeFrame3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Frame 4.
        /// </summary>
        public static string TimeFrame4 {
            get {
                return ResourceManager.GetString("TimeFrame4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time From.
        /// </summary>
        public static string TimeFrom {
            get {
                return ResourceManager.GetString("TimeFrom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Settings.
        /// </summary>
        public static string TimeSettings {
            get {
                return ResourceManager.GetString("TimeSettings", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time To.
        /// </summary>
        public static string TimeTo {
            get {
                return ResourceManager.GetString("TimeTo", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time Until Bar Closes.
        /// </summary>
        public static string TimeToEndOfCandle {
            get {
                return ResourceManager.GetString("TimeToEndOfCandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Triangular Moving Average.
        /// </summary>
        public static string TMA {
            get {
                return ResourceManager.GetString("TMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Tolerance.
        /// </summary>
        public static string Tolerance {
            get {
                return ResourceManager.GetString("Tolerance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Price Rows Height Too Small For Render.
        /// </summary>
        public static string TooSmallRows {
            get {
                return ResourceManager.GetString("TooSmallRows", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Top Band.
        /// </summary>
        public static string TopBand {
            get {
                return ResourceManager.GetString("TopBand", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Top - Left.
        /// </summary>
        public static string TopLeft {
            get {
                return ResourceManager.GetString("TopLeft", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Top - Right.
        /// </summary>
        public static string TopRight {
            get {
                return ResourceManager.GetString("TopRight", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Total.
        /// </summary>
        public static string Total {
            get {
                return ResourceManager.GetString("Total", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trades.
        /// </summary>
        public static string Trades {
            get {
                return ResourceManager.GetString("Trades", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Trades Filter.
        /// </summary>
        public static string TradesFilter {
            get {
                return ResourceManager.GetString("TradesFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Transparency.
        /// </summary>
        public static string Transparency {
            get {
                return ResourceManager.GetString("Transparency", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TWAP Period.
        /// </summary>
        public static string TwapPeriod {
            get {
                return ResourceManager.GetString("TwapPeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type.
        /// </summary>
        public static string Type {
            get {
                return ResourceManager.GetString("Type", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unsupported TimeFrame.
        /// </summary>
        public static string UnsupportedTimeFrame {
            get {
                return ResourceManager.GetString("UnsupportedTimeFrame", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Up.
        /// </summary>
        public static string Up {
            get {
                return ResourceManager.GetString("Up", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Up Alert.
        /// </summary>
        public static string UpAlert {
            get {
                return ResourceManager.GetString("UpAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Up/Down Candle Volume.
        /// </summary>
        public static string UpDownVolume {
            get {
                return ResourceManager.GetString("UpDownVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper.
        /// </summary>
        public static string Upper {
            get {
                return ResourceManager.GetString("Upper", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper Fill.
        /// </summary>
        public static string UpperFill {
            get {
                return ResourceManager.GetString("UpperFill", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper Fill 2.
        /// </summary>
        public static string UpperFill2 {
            get {
                return ResourceManager.GetString("UpperFill2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper Deviation 1.
        /// </summary>
        public static string UpperStd1 {
            get {
                return ResourceManager.GetString("UpperStd1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper Deviation 2.
        /// </summary>
        public static string UpperStd2 {
            get {
                return ResourceManager.GetString("UpperStd2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper Deviation 3.
        /// </summary>
        public static string UpperStd3 {
            get {
                return ResourceManager.GetString("UpperStd3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Upper Wick.
        /// </summary>
        public static string UpperWick {
            get {
                return ResourceManager.GetString("UpperWick", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use ABS Value.
        /// </summary>
        public static string UseAbsValue {
            get {
                return ResourceManager.GetString("UseAbsValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Alerts.
        /// </summary>
        public static string UseAlerts {
            get {
                return ResourceManager.GetString("UseAlerts", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Auto Size.
        /// </summary>
        public static string UseAutoSize {
            get {
                return ResourceManager.GetString("UseAutoSize", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Filter.
        /// </summary>
        public static string UseFilter {
            get {
                return ResourceManager.GetString("UseFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Moving Average.
        /// </summary>
        public static string UseMA {
            get {
                return ResourceManager.GetString("UseMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Previous Close.
        /// </summary>
        public static string UsePreviousClose {
            get {
                return ResourceManager.GetString("UsePreviousClose", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Scale.
        /// </summary>
        public static string UseScale {
            get {
                return ResourceManager.GetString("UseScale", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Time Filter.
        /// </summary>
        public static string UseTimeFilter {
            get {
                return ResourceManager.GetString("UseTimeFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use TrueRange (KC).
        /// </summary>
        public static string UseTrueRangeKc {
            get {
                return ResourceManager.GetString("UseTrueRangeKc", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to VAH Touch Alert.
        /// </summary>
        public static string VahTouchAlert {
            get {
                return ResourceManager.GetString("VahTouchAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to VAL Touch Alert.
        /// </summary>
        public static string ValTouchAlert {
            get {
                return ResourceManager.GetString("ValTouchAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Value.
        /// </summary>
        public static string Value {
            get {
                return ResourceManager.GetString("Value", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Values.
        /// </summary>
        public static string Values {
            get {
                return ResourceManager.GetString("Values", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Vertical Offset.
        /// </summary>
        public static string VerticalOffset {
            get {
                return ResourceManager.GetString("VerticalOffset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Proportion By Visible Part Of The Chart.
        /// </summary>
        public static string VisibleProportion {
            get {
                return ResourceManager.GetString("VisibleProportion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Visualization.
        /// </summary>
        public static string Visualization {
            get {
                return ResourceManager.GetString("Visualization", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mode.
        /// </summary>
        public static string VisualMode {
            get {
                return ResourceManager.GetString("VisualMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Visual Objects Transparency.
        /// </summary>
        public static string VisualObjectsTransparency {
            get {
                return ResourceManager.GetString("VisualObjectsTransparency", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume.
        /// </summary>
        public static string Volume {
            get {
                return ResourceManager.GetString("Volume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume Alert.
        /// </summary>
        public static string VolumeAlert {
            get {
                return ResourceManager.GetString("VolumeAlert", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume Color.
        /// </summary>
        public static string VolumeColor {
            get {
                return ResourceManager.GetString("VolumeColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume Filter.
        /// </summary>
        public static string VolumeFilter {
            get {
                return ResourceManager.GetString("VolumeFilter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume Label.
        /// </summary>
        public static string VolumeLabel {
            get {
                return ResourceManager.GetString("VolumeLabel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When bars are wide, shows values of volumes on each bar.
        /// </summary>
        public static string VolumeLabelDescription {
            get {
                return ResourceManager.GetString("VolumeLabelDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume Type.
        /// </summary>
        public static string VolumeType {
            get {
                return ResourceManager.GetString("VolumeType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Volume Visualization Type.
        /// </summary>
        public static string VolumeVisualizationType {
            get {
                return ResourceManager.GetString("VolumeVisualizationType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to VWAP Only.
        /// </summary>
        public static string VWAPOnly {
            get {
                return ResourceManager.GetString("VWAPOnly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Waiting For New Tick.
        /// </summary>
        public static string WaitingForNewTick {
            get {
                return ResourceManager.GetString("WaitingForNewTick", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Wave Period.
        /// </summary>
        public static string WavePeriod {
            get {
                return ResourceManager.GetString("WavePeriod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Series.
        /// </summary>
        public static string WeakSeries {
            get {
                return ResourceManager.GetString("WeakSeries", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Series Color.
        /// </summary>
        public static string WeakSeriesColor {
            get {
                return ResourceManager.GetString("WeakSeriesColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weekly.
        /// </summary>
        public static string Weekly {
            get {
                return ResourceManager.GetString("Weekly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Width.
        /// </summary>
        public static string Width {
            get {
                return ResourceManager.GetString("Width", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weighted Moving Average (WMA).
        /// </summary>
        public static string WMA {
            get {
                return ResourceManager.GetString("WMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Welles Wilders Moving Average.
        /// </summary>
        public static string WWMA {
            get {
                return ResourceManager.GetString("WWMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zero Value.
        /// </summary>
        public static string ZeroValue {
            get {
                return ResourceManager.GetString("ZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zero Lag Exponential Moving Average.
        /// </summary>
        public static string ZLEMA {
            get {
                return ResourceManager.GetString("ZLEMA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zone.
        /// </summary>
        public static string Zone {
            get {
                return ResourceManager.GetString("Zone", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 100% Zone.
        /// </summary>
        public static string Zone100 {
            get {
                return ResourceManager.GetString("Zone100", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 150% Zone.
        /// </summary>
        public static string Zone150 {
            get {
                return ResourceManager.GetString("Zone150", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 200% Zone.
        /// </summary>
        public static string Zone200 {
            get {
                return ResourceManager.GetString("Zone200", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 25% Zone.
        /// </summary>
        public static string Zone25 {
            get {
                return ResourceManager.GetString("Zone25", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 50% Zone.
        /// </summary>
        public static string Zone50 {
            get {
                return ResourceManager.GetString("Zone50", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 75% Zone.
        /// </summary>
        public static string Zone75 {
            get {
                return ResourceManager.GetString("Zone75", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Zone Width (Days).
        /// </summary>
        public static string ZoneWidth {
            get {
                return ResourceManager.GetString("ZoneWidth", resourceCulture);
            }
        }
    }
}





Technical/Properties/Resources.de-DE.resx





<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DaysLookBackDescription" xml:space="preserve">
    <value>"Days look back" bezieht sich auf die Anzahl der zurückliegenden Tage, die bei der Berechnung eines Indikators berücksichtigt werden.</value>
  </data>
</root>





Technical/Properties/Resources.resx




<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ADX" xml:space="preserve">
    <value>Average Directional Movement Index</value>
  </data>
  <data name="ATR" xml:space="preserve">
    <value>Average True Range</value>
  </data>
  <data name="BollingerBands" xml:space="preserve">
    <value>Bollinger Bands</value>
  </data>
  <data name="CCI" xml:space="preserve">
    <value>Commodity Channel Index</value>
  </data>
  <data name="Common" xml:space="preserve">
    <value>Common</value>
  </data>
  <data name="DINeg" xml:space="preserve">
    <value>Negative Directional Indicator</value>
  </data>
  <data name="DIPos" xml:space="preserve">
    <value>Positive Directional Indicator</value>
  </data>
  <data name="DX" xml:space="preserve">
    <value>Directional Movement Index</value>
  </data>
  <data name="EMA" xml:space="preserve">
    <value>Exponential Moving Average (EMA)</value>
  </data>
  <data name="Highest" xml:space="preserve">
    <value>Highest</value>
  </data>
  <data name="LinearReg" xml:space="preserve">
    <value>Linear Regression</value>
  </data>
  <data name="Lowest" xml:space="preserve">
    <value>Lowest</value>
  </data>
  <data name="MACD" xml:space="preserve">
    <value>Moving Average Convergence/Divergence</value>
  </data>
  <data name="MeanDeviation" xml:space="preserve">
    <value>Mean Deviation</value>
  </data>
  <data name="Momentum" xml:space="preserve">
    <value>Momentum</value>
  </data>
  <data name="ParabolicSAR" xml:space="preserve">
    <value>Parabolic SAR</value>
  </data>
  <data name="Period" xml:space="preserve">
    <value>Period</value>
  </data>
  <data name="RSI" xml:space="preserve">
    <value>Relative Strength Index</value>
  </data>
  <data name="RVI" xml:space="preserve">
    <value>Relative Vigor Index</value>
  </data>
  <data name="SMA" xml:space="preserve">
    <value>Simple Moving Average (SMA)</value>
  </data>
  <data name="SMMA" xml:space="preserve">
    <value>Smoothed Moving Average (SMMA)</value>
  </data>
  <data name="StdDev" xml:space="preserve">
    <value>Standard Deviation</value>
  </data>
  <data name="Stochastic" xml:space="preserve">
    <value>Stochastic</value>
  </data>
  <data name="WMA" xml:space="preserve">
    <value>Weighted Moving Average (WMA)</value>
  </data>
  <data name="Color" xml:space="preserve">
    <value>Color</value>
  </data>
  <data name="Width" xml:space="preserve">
    <value>Width</value>
  </data>
  <data name="Mode" xml:space="preserve">
    <value>Mode</value>
  </data>
  <data name="Ask" xml:space="preserve">
    <value>Ask</value>
  </data>
  <data name="Bid" xml:space="preserve">
    <value>Bid</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Text</value>
  </data>
  <data name="Colors" xml:space="preserve">
    <value>Colors</value>
  </data>
  <data name="Filters" xml:space="preserve">
    <value>Filters</value>
  </data>
  <data name="DeltaColored" xml:space="preserve">
    <value>Delta Coloring</value>
  </data>
  <data name="Calculation" xml:space="preserve">
    <value>Calculation</value>
  </data>
  <data name="Filter" xml:space="preserve">
    <value>Filter</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Type</value>
  </data>
  <data name="UseFilter" xml:space="preserve">
    <value>Use Filter</value>
  </data>
  <data name="PivotRange" xml:space="preserve">
    <value>Pivot Range</value>
  </data>
  <data name="Candles" xml:space="preserve">
    <value>Candles</value>
  </data>
  <data name="Line" xml:space="preserve">
    <value>Line</value>
  </data>
  <data name="SessionDeltaMode" xml:space="preserve">
    <value>Session Delta Mode</value>
  </data>
  <data name="VisualMode" xml:space="preserve">
    <value>Mode</value>
  </data>
  <data name="Minimizedmode" xml:space="preserve">
    <value>Minimize Mode</value>
  </data>
  <data name="HighLow" xml:space="preserve">
    <value>High / Low</value>
  </data>
  <data name="FirstDev" xml:space="preserve">
    <value>First Dev.</value>
  </data>
  <data name="SecondDev" xml:space="preserve">
    <value>Second Dev.</value>
  </data>
  <data name="Accumulated" xml:space="preserve">
    <value>Accumulated</value>
  </data>
  <data name="AlertFile" xml:space="preserve">
    <value>Alert File</value>
  </data>
  <data name="Alerts" xml:space="preserve">
    <value>Alerts</value>
  </data>
  <data name="AllPeriodtxt" xml:space="preserve">
    <value>All Period</value>
  </data>
  <data name="ApproximationAlert" xml:space="preserve">
    <value>Approximation Alert</value>
  </data>
  <data name="ApproximationFilter" xml:space="preserve">
    <value>Approximation Filter</value>
  </data>
  <data name="AtStart" xml:space="preserve">
    <value>At Start</value>
  </data>
  <data name="BackGround" xml:space="preserve">
    <value>Background</value>
  </data>
  <data name="ChangingLevelAlert" xml:space="preserve">
    <value>Changing Level Alert</value>
  </data>
  <data name="Daily" xml:space="preserve">
    <value>Daily</value>
  </data>
  <data name="Delta" xml:space="preserve">
    <value>Delta</value>
  </data>
  <data name="FontColor" xml:space="preserve">
    <value>Font Color</value>
  </data>
  <data name="Hourly" xml:space="preserve">
    <value>Hourly</value>
  </data>
  <data name="Monthly" xml:space="preserve">
    <value>Monthly</value>
  </data>
  <data name="Other" xml:space="preserve">
    <value>Other</value>
  </data>
  <data name="ShowVolume" xml:space="preserve">
    <value>Show Volume</value>
  </data>
  <data name="Ticks" xml:space="preserve">
    <value>Ticks</value>
  </data>
  <data name="Time" xml:space="preserve">
    <value>Time</value>
  </data>
  <data name="Volume" xml:space="preserve">
    <value>Volume</value>
  </data>
  <data name="VolumeVisualizationType" xml:space="preserve">
    <value>Volume Visualization Type</value>
  </data>
  <data name="Weekly" xml:space="preserve">
    <value>Weekly</value>
  </data>
  <data name="Multiplier" xml:space="preserve">
    <value>Multiplier</value>
  </data>
  <data name="Any" xml:space="preserve">
    <value>Any</value>
  </data>
  <data name="BarsDirection" xml:space="preserve">
    <value>Bars Direction</value>
  </data>
  <data name="Bearlish" xml:space="preserve">
    <value>Bearish</value>
  </data>
  <data name="Bullish" xml:space="preserve">
    <value>Bullish</value>
  </data>
  <data name="UseAlerts" xml:space="preserve">
    <value>Use Alerts</value>
  </data>
  <data name="AutoFilterPeriod" xml:space="preserve">
    <value>Auto Filter Period</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="Buys" xml:space="preserve">
    <value>Buys</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="CalculationMode" xml:space="preserve">
    <value>Calculation Mode</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="Sells" xml:space="preserve">
    <value>Sells</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="TimeFilterSec" xml:space="preserve">
    <value>Time Filter, Sec</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="TradesFilter" xml:space="preserve">
    <value>Trades Filter</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="AutoFilter" xml:space="preserve">
    <value>Auto Filter</value>
  </data>
  <data name="CurrentDay" xml:space="preserve">
    <value>Current Day</value>
  </data>
  <data name="CurrentMonth" xml:space="preserve">
    <value>Current Month</value>
  </data>
  <data name="CurrentWeek" xml:space="preserve">
    <value>Current Week</value>
  </data>
  <data name="PreviousDay" xml:space="preserve">
    <value>Last Day</value>
  </data>
  <data name="PreviousMonth" xml:space="preserve">
    <value>Last Month</value>
  </data>
  <data name="PreviousWeek" xml:space="preserve">
    <value>Last Week</value>
  </data>
  <data name="Left" xml:space="preserve">
    <value>Left</value>
    <comment>Pivots</comment>
  </data>
  <data name="Right" xml:space="preserve">
    <value>Right</value>
    <comment>Pivots</comment>
  </data>
  <data name="Show" xml:space="preserve">
    <value>Show</value>
    <comment>Pivots</comment>
  </data>
  <data name="TextLocation" xml:space="preserve">
    <value>Text Location</value>
    <comment>Pivots</comment>
  </data>
  <data name="TextSize" xml:space="preserve">
    <value>Text Size</value>
    <comment>Pivots</comment>
  </data>
  <data name="AbsolutePrice" xml:space="preserve">
    <value>Absolute Price</value>
  </data>
  <data name="RelativeInPercent" xml:space="preserve">
    <value>Relative In %</value>
  </data>
  <data name="FontSize" xml:space="preserve">
    <value>Font Size</value>
  </data>
  <data name="Height" xml:space="preserve">
    <value>Height</value>
  </data>
  <data name="TextColor" xml:space="preserve">
    <value>Text Color</value>
  </data>
  <data name="TimeFormat" xml:space="preserve">
    <value>Time Format</value>
  </data>
  <data name="ThirdDev" xml:space="preserve">
    <value>Third Dev.</value>
  </data>
  <data name="Maximum" xml:space="preserve">
    <value>Maximum</value>
  </data>
  <data name="Minimum" xml:space="preserve">
    <value>Minimum</value>
  </data>
  <data name="Size" xml:space="preserve">
    <value>Size</value>
  </data>
  <data name="BottomLeft" xml:space="preserve">
    <value>Bottom - Left</value>
  </data>
  <data name="BottomRight" xml:space="preserve">
    <value>Bottom - Right</value>
  </data>
  <data name="Center" xml:space="preserve">
    <value>Center</value>
  </data>
  <data name="FirstLine" xml:space="preserve">
    <value>First Line</value>
  </data>
  <data name="Font" xml:space="preserve">
    <value>Font</value>
  </data>
  <data name="HorizontalOffset" xml:space="preserve">
    <value>Horizontal Offset</value>
  </data>
  <data name="SecondLine" xml:space="preserve">
    <value>Second Line</value>
  </data>
  <data name="ShowInstrument" xml:space="preserve">
    <value>Show Instrument</value>
  </data>
  <data name="ShowPeriod" xml:space="preserve">
    <value>Show Period</value>
  </data>
  <data name="TopLeft" xml:space="preserve">
    <value>Top - Left</value>
  </data>
  <data name="TopRight" xml:space="preserve">
    <value>Top - Right</value>
  </data>
  <data name="VerticalOffset" xml:space="preserve">
    <value>Vertical Offset</value>
  </data>
  <data name="Visualization" xml:space="preserve">
    <value>Visualization</value>
    <comment>BigTradesSettings</comment>
  </data>
  <data name="AxisTextColor" xml:space="preserve">
    <value>Text On Axis</value>
  </data>
  <data name="NegativeDelta" xml:space="preserve">
    <value>Negative Delta</value>
  </data>
  <data name="PositiveDelta" xml:space="preserve">
    <value>Positive Delta</value>
  </data>
  <data name="ByBar" xml:space="preserve">
    <value>By Bar</value>
  </data>
  <data name="Cumulative" xml:space="preserve">
    <value>Cumulative</value>
  </data>
  <data name="DeltaType" xml:space="preserve">
    <value>Delta Type</value>
  </data>
  <data name="Negative" xml:space="preserve">
    <value>Negative</value>
  </data>
  <data name="Positive" xml:space="preserve">
    <value>Positive</value>
  </data>
  <data name="Session" xml:space="preserve">
    <value>Session</value>
  </data>
  <data name="PaintBars" xml:space="preserve">
    <value>Paint Bars</value>
  </data>
  <data name="Settings" xml:space="preserve">
    <value>Settings</value>
  </data>
  <data name="Bars" xml:space="preserve">
    <value>Bars</value>
  </data>
  <data name="BBandsWidth" xml:space="preserve">
    <value>Channel Width</value>
  </data>
  <data name="AccelMax" xml:space="preserve">
    <value>Acceleration Max</value>
  </data>
  <data name="AccelStart" xml:space="preserve">
    <value>Acceleration Start</value>
  </data>
  <data name="AccelStep" xml:space="preserve">
    <value>Acceleration Step</value>
  </data>
  <data name="AreaColor" xml:space="preserve">
    <value>Area Color</value>
  </data>
  <data name="AveragePeriod" xml:space="preserve">
    <value>Average Period</value>
  </data>
  <data name="EndTime" xml:space="preserve">
    <value>End Time</value>
  </data>
  <data name="LongPeriod" xml:space="preserve">
    <value>Long Period</value>
  </data>
  <data name="OffsetMultiplier" xml:space="preserve">
    <value>Offset Multiplier</value>
  </data>
  <data name="ShortPeriod" xml:space="preserve">
    <value>Short Period</value>
  </data>
  <data name="SignalPeriod" xml:space="preserve">
    <value>Signal Period</value>
  </data>
  <data name="Smooth" xml:space="preserve">
    <value>Smooth</value>
  </data>
  <data name="StartTime" xml:space="preserve">
    <value>Start Time</value>
  </data>
  <data name="LookBack" xml:space="preserve">
    <value>Lookback Period</value>
    <comment>RelativeVolume</comment>
  </data>
  <data name="Divisor" xml:space="preserve">
    <value>Divisor</value>
  </data>
  <data name="FrameMultiplier" xml:space="preserve">
    <value>Frame Multiplier</value>
  </data>
  <data name="FrameSize" xml:space="preserve">
    <value>Frame Size</value>
  </data>
  <data name="IgnoreWicks" xml:space="preserve">
    <value>Ignore Wicks</value>
  </data>
  <data name="Overbought" xml:space="preserve">
    <value>Overbought</value>
    <comment>MFI</comment>
  </data>
  <data name="Oversold" xml:space="preserve">
    <value>Oversold</value>
    <comment>MFI</comment>
  </data>
  <data name="DaysPeriod" xml:space="preserve">
    <value>Days Period</value>
    <comment>ADR</comment>
  </data>
  <data name="EfficiencyRatioPeriod" xml:space="preserve">
    <value>Efficiency Ratio Period</value>
  </data>
  <data name="RenderPeriods" xml:space="preserve">
    <value>Render Periods</value>
  </data>
  <data name="HighSession" xml:space="preserve">
    <value>High Session</value>
    <comment>ADR</comment>
  </data>
  <data name="LowSession" xml:space="preserve">
    <value>Low Session</value>
    <comment>ADR</comment>
  </data>
  <data name="OpenSession" xml:space="preserve">
    <value>Open Session</value>
    <comment>ADR</comment>
  </data>
  <data name="WavePeriod" xml:space="preserve">
    <value>Wave Period</value>
  </data>
  <data name="Histogram" xml:space="preserve">
    <value>Histogram</value>
    <comment>Delta</comment>
  </data>
  <data name="UseScale" xml:space="preserve">
    <value>Use Scale</value>
  </data>
  <data name="Body" xml:space="preserve">
    <value>Body</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleBodyHeight" xml:space="preserve">
    <value>Candle Body Height</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleBodyHeightFilter" xml:space="preserve">
    <value>Candle Body Height Filter</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleHeight" xml:space="preserve">
    <value>Candle Height</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleHeightFilter" xml:space="preserve">
    <value>Candle Height Filter</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="DepthMarket" xml:space="preserve">
    <value>Depth Of Market</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="DepthMarketFilter" xml:space="preserve">
    <value>Depth Of Market Filter</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="DirectionFilter" xml:space="preserve">
    <value>Direction Filter</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Disabled" xml:space="preserve">
    <value>Disabled</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Dodge" xml:space="preserve">
    <value>Dodge</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="LowerWick" xml:space="preserve">
    <value>Lower Wick</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumAsk" xml:space="preserve">
    <value>Maximum Ask</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumBid" xml:space="preserve">
    <value>Maximum Bid</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumCandleBodyHeight" xml:space="preserve">
    <value>Maximum Candle Body Height</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumCandleHeight" xml:space="preserve">
    <value>Maximum Candle Height</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumDelta" xml:space="preserve">
    <value>Maximum Delta</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumTrades" xml:space="preserve">
    <value>Maximum Trades</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumVolume" xml:space="preserve">
    <value>Maximum Volume</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumVolumeFilter" xml:space="preserve">
    <value>Maximum Volume Filter</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumAsk" xml:space="preserve">
    <value>Minimum Ask</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumBid" xml:space="preserve">
    <value>Minimum Bid</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumCandleBodyHeight" xml:space="preserve">
    <value>Minimum Candle Body Height</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumCandleHeight" xml:space="preserve">
    <value>Minimum Candle Height</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumDelta" xml:space="preserve">
    <value>Minimum Delta</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumTrades" xml:space="preserve">
    <value>Minimum Trades</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumVolume" xml:space="preserve">
    <value>Minimum Volume</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Trades" xml:space="preserve">
    <value>Trades</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="UpperWick" xml:space="preserve">
    <value>Upper Wick</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="VolumeFilter" xml:space="preserve">
    <value>Volume Filter</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Predict" xml:space="preserve">
    <value>Predict</value>
    <comment>VPF</comment>
  </data>
  <data name="SlowFactor" xml:space="preserve">
    <value>Slow Factor</value>
    <comment>QQE</comment>
  </data>
  <data name="BBPeriod" xml:space="preserve">
    <value>Bollinger Bands Period</value>
    <comment>SqueezeMomentum</comment>
  </data>
  <data name="BBMultFactor" xml:space="preserve">
    <value>Bollinger Bands Multiplier Factor</value>
    <comment>Squeeze Momentum</comment>
  </data>
  <data name="KCMultFactor" xml:space="preserve">
    <value>Keltner Channel Multiplier Factor</value>
    <comment>Squeeze Momentum</comment>
  </data>
  <data name="KCPeriod" xml:space="preserve">
    <value>Keltner Channel Period</value>
    <comment>Squeeze Momentum</comment>
  </data>
  <data name="UseTrueRangeKc" xml:space="preserve">
    <value>Use TrueRange (KC)</value>
    <comment>Squeeze Momentum</comment>
  </data>
  <data name="JawAlligator" xml:space="preserve">
    <value>Jaw Alligator</value>
    <comment>Alligator</comment>
  </data>
  <data name="LipsAlligator" xml:space="preserve">
    <value>Lips Alligator</value>
    <comment>Alligator</comment>
  </data>
  <data name="Shift" xml:space="preserve">
    <value>Shift</value>
  </data>
  <data name="TeethAlligator" xml:space="preserve">
    <value>Teeth Alligator</value>
    <comment>Alligator</comment>
  </data>
  <data name="BuyColor" xml:space="preserve">
    <value>Buy Color</value>
  </data>
  <data name="SellColor" xml:space="preserve">
    <value>Sell Color</value>
  </data>
  <data name="AnalysisPeriod" xml:space="preserve">
    <value>Retrospective Analysis Period</value>
    <comment>RelativeVolume</comment>
  </data>
  <data name="Percent" xml:space="preserve">
    <value>Percent</value>
    <comment>DailyChange</comment>
  </data>
  <data name="BackGroundBuyColor" xml:space="preserve">
    <value>Background Buy Color</value>
    <comment>DailyChange</comment>
  </data>
  <data name="BackGroundSellColor" xml:space="preserve">
    <value>Background Sell Color</value>
    <comment>DailyChange</comment>
  </data>
  <data name="RetrospectiveAnalysis" xml:space="preserve">
    <value>Retrospective Analysis</value>
    <comment>VsaBetterVolume</comment>
  </data>
  <data name="Spacing" xml:space="preserve">
    <value>Spacing</value>
    <comment>SpreadVolume</comment>
  </data>
  <data name="BreakDnColor" xml:space="preserve">
    <value>Break Down Color</value>
    <comment>HRanges</comment>
  </data>
  <data name="BreakUpColor" xml:space="preserve">
    <value>Break Up Color</value>
    <comment>HRanges</comment>
  </data>
  <data name="FlatColor" xml:space="preserve">
    <value>Flat Color</value>
    <comment>HRanges</comment>
  </data>
  <data name="MaxVolColor" xml:space="preserve">
    <value>Maximal Volume Color</value>
    <comment>HRanges</comment>
  </data>
  <data name="TimeFrame" xml:space="preserve">
    <value>Timeframe</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="Offset" xml:space="preserve">
    <value>Offset</value>
  </data>
  <data name="ClosePrevDay" xml:space="preserve">
    <value>Previous Day Close</value>
    <comment>DailyChange</comment>
  </data>
  <data name="OpenCurDay" xml:space="preserve">
    <value>Current Day Open</value>
    <comment>DailyChange</comment>
  </data>
  <data name="PriceChange" xml:space="preserve">
    <value>Price Change</value>
  </data>
  <data name="CustomSessionStart" xml:space="preserve">
    <value>Custom Session Start</value>
  </data>
  <data name="OffsetY" xml:space="preserve">
    <value>Y Offset</value>
    <comment>OpenLine</comment>
  </data>
  <data name="OpenLine" xml:space="preserve">
    <value>Open Line</value>
    <comment>OpenLine</comment>
  </data>
  <data name="SessionTime" xml:space="preserve">
    <value>Session Time</value>
  </data>
  <data name="StartTimeGmt" xml:space="preserve">
    <value>Start Time(GMT)</value>
  </data>
  <data name="TextSettings" xml:space="preserve">
    <value>Text Settings</value>
  </data>
  <data name="AutoCalculation" xml:space="preserve">
    <value>Automatic Calculation</value>
  </data>
  <data name="BaseLine" xml:space="preserve">
    <value>Base Line</value>
    <comment>MarginZones</comment>
  </data>
  <data name="CustomPrice" xml:space="preserve">
    <value>Custom Price</value>
  </data>
  <data name="DirectionOfZone" xml:space="preserve">
    <value>Direction Of Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Down" xml:space="preserve">
    <value>Down</value>
  </data>
  <data name="InstrumentParameters" xml:space="preserve">
    <value>Instrument Paramethers</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Margin" xml:space="preserve">
    <value>Margin</value>
    <comment>MarginZones</comment>
  </data>
  <data name="StartPrice" xml:space="preserve">
    <value>Start Price</value>
  </data>
  <data name="TickCost" xml:space="preserve">
    <value>Tick Cost</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Up" xml:space="preserve">
    <value>Up</value>
  </data>
  <data name="Zone100" xml:space="preserve">
    <value>100% Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone150" xml:space="preserve">
    <value>150% Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone200" xml:space="preserve">
    <value>200% Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone25" xml:space="preserve">
    <value>25% Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone50" xml:space="preserve">
    <value>50% Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone75" xml:space="preserve">
    <value>75% Zone</value>
    <comment>MarginZones</comment>
  </data>
  <data name="ZoneWidth" xml:space="preserve">
    <value>Zone Width (Days)</value>
    <comment>MarginZones</comment>
  </data>
  <data name="AreaTransparency" xml:space="preserve">
    <value>Area Transparency</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="BearlishColor" xml:space="preserve">
    <value>Bearlish Color</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="BorderColor" xml:space="preserve">
    <value>Border Color</value>
  </data>
  <data name="BorderWidth" xml:space="preserve">
    <value>Border Width</value>
  </data>
  <data name="BullishColor" xml:space="preserve">
    <value>Bullish Color</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="DashStyle" xml:space="preserve">
    <value>Style</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="ExternalPeriod" xml:space="preserve">
    <value>External Period</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="FillColor" xml:space="preserve">
    <value>Fill Color</value>
  </data>
  <data name="Grid" xml:space="preserve">
    <value>Grid</value>
  </data>
  <data name="GridStyle" xml:space="preserve">
    <value>Grid Style</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="Multiplier1" xml:space="preserve">
    <value>Multiplier 1</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="Multiplier2" xml:space="preserve">
    <value>Multiplier 2</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="Multiplier3" xml:space="preserve">
    <value>Multiplier 3</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="OpenRange" xml:space="preserve">
    <value>Open Range</value>
  </data>
  <data name="ShowAsCandle" xml:space="preserve">
    <value>Show As Candle</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="ShowAverage" xml:space="preserve">
    <value>Show Average</value>
  </data>
  <data name="ShowGrid" xml:space="preserve">
    <value>Show Grid</value>
  </data>
  <data name="AskColor" xml:space="preserve">
    <value>Ask Color</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="BidColor" xml:space="preserve">
    <value>Bid Color</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="HideRowsDescription" xml:space="preserve">
    <value>Hide Headers</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowAsk" xml:space="preserve">
    <value>Show Asks</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowBid" xml:space="preserve">
    <value>Show Bids</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowDelta" xml:space="preserve">
    <value>Show Delta</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowDeltaPerVolume" xml:space="preserve">
    <value>Show Delta/Volume</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowDuration" xml:space="preserve">
    <value>Show Duration</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowMaximumDelta" xml:space="preserve">
    <value>Show Maximum Delta</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowMinimumDelta" xml:space="preserve">
    <value>Show Minimum Delta</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowSessionDelta" xml:space="preserve">
    <value>Show Session Delta</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowSessionDeltaPerVolume" xml:space="preserve">
    <value>Show Session Delta/Volume</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowSessionVolume" xml:space="preserve">
    <value>Show Session Volume</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowTime" xml:space="preserve">
    <value>Show Time</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowVolumePerSecond" xml:space="preserve">
    <value>Show Volume/Second</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="VolumeColor" xml:space="preserve">
    <value>Volume Color</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="Strings" xml:space="preserve">
    <value>Strings</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="DoNotShowAboveChart" xml:space="preserve">
    <value>Do Not Show Above Chart</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="SpeedInterval" xml:space="preserve">
    <value>Speed Interval</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="AlertFilter" xml:space="preserve">
    <value>Alert Filter</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="CombineSmallTrades" xml:space="preserve">
    <value>Combine Small Trades</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="DigitsAfterComma" xml:space="preserve">
    <value>Digits After The Decimal Point In Volume Values</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="LinkingToBar" xml:space="preserve">
    <value>Linked To Bar</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="Location" xml:space="preserve">
    <value>Location</value>
  </data>
  <data name="ShowSmallTrades" xml:space="preserve">
    <value>Show Small Trades</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="Circles" xml:space="preserve">
    <value>Circles</value>
  </data>
  <data name="Rectangles" xml:space="preserve">
    <value>Rectangles</value>
  </data>
  <data name="HighColor" xml:space="preserve">
    <value>High Color</value>
    <comment>Ratio</comment>
  </data>
  <data name="LowColor" xml:space="preserve">
    <value>Low Color</value>
    <comment>Ratio</comment>
  </data>
  <data name="LowRatio" xml:space="preserve">
    <value>Low Ratio</value>
    <comment>Ratio</comment>
  </data>
  <data name="NeutralColor" xml:space="preserve">
    <value>Neutral Color</value>
    <comment>Ratio</comment>
  </data>
  <data name="NeutralRatio" xml:space="preserve">
    <value>Neutral Ratio</value>
    <comment>Ratio</comment>
  </data>
  <data name="Values" xml:space="preserve">
    <value>Values</value>
  </data>
  <data name="H4" xml:space="preserve">
    <value>H4</value>
    <comment>Pivots</comment>
  </data>
  <data name="H2" xml:space="preserve">
    <value>H2</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="H6" xml:space="preserve">
    <value>H6</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="AtHigh" xml:space="preserve">
    <value>At High</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="AtHighOrLow" xml:space="preserve">
    <value>At High Or Low</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="AtLow" xml:space="preserve">
    <value>At Low</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="BarsRange" xml:space="preserve">
    <value>Bars Range</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="CandleDirection" xml:space="preserve">
    <value>Candle Direction</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="ClusterSelectionTransparency" xml:space="preserve">
    <value>Cluster Selection Transparency</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="DeltaFilter" xml:space="preserve">
    <value>Delta Filter</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="DeltaFilters" xml:space="preserve">
    <value>Delta Filters</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="DeltaImbalance" xml:space="preserve">
    <value>Bid Ask Imbalance,%</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="FixedSizes" xml:space="preserve">
    <value>Fixed Sizes</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MaximumAverageTrade" xml:space="preserve">
    <value>Maximum Average Trade</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MaximumSize" xml:space="preserve">
    <value>Maximum Size</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MaxValue" xml:space="preserve">
    <value>Maximum Value</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinimumAverageTrade" xml:space="preserve">
    <value>Minimum Average Trade</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinimumSize" xml:space="preserve">
    <value>Minimum Size</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinValue" xml:space="preserve">
    <value>Minimum Value</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="OnlyOneSelectionPerBar" xml:space="preserve">
    <value>Only One Selection Per Bar</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PipsFromHigh" xml:space="preserve">
    <value>Ticks From High</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PipsFromLow" xml:space="preserve">
    <value>Ticks From Low</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PriceLocation" xml:space="preserve">
    <value>Price Location</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PriceRange" xml:space="preserve">
    <value>Price Range</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="TimeFiltration" xml:space="preserve">
    <value>Time Filtration</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="TimeFrom" xml:space="preserve">
    <value>Time From</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="TimeTo" xml:space="preserve">
    <value>Time To</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="UseTimeFilter" xml:space="preserve">
    <value>Use Time Filter</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="VisualObjectsTransparency" xml:space="preserve">
    <value>Visual Objects Transparency</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="GridColor" xml:space="preserve">
    <value>Grid Color</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="Border" xml:space="preserve">
    <value>Border</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="HeaderBackground" xml:space="preserve">
    <value>Headers Background</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="VisibleProportion" xml:space="preserve">
    <value>Proportion By Visible Part Of The Chart</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="Auto" xml:space="preserve">
    <value>Auto</value>
    <comment>BarTimer</comment>
  </data>
  <data name="CurrentTime" xml:space="preserve">
    <value>Current Time</value>
    <comment>BarTimer</comment>
  </data>
  <data name="HHMMSS" xml:space="preserve">
    <value>HHMMSS</value>
    <comment>BarTimer</comment>
  </data>
  <data name="HHMMSSPM" xml:space="preserve">
    <value>HHMMSSPM</value>
    <comment>BarTimer</comment>
  </data>
  <data name="MMSS" xml:space="preserve">
    <value>MMSS</value>
    <comment>BarTimer</comment>
  </data>
  <data name="OffsetX" xml:space="preserve">
    <value>X Offset</value>
  </data>
  <data name="TimeSettings" xml:space="preserve">
    <value>Time Settings</value>
    <comment>BarTimer</comment>
  </data>
  <data name="TimeToEndOfCandle" xml:space="preserve">
    <value>Time Until Bar Closes</value>
    <comment>BarTimer</comment>
  </data>
  <data name="UnsupportedTimeFrame" xml:space="preserve">
    <value>Unsupported TimeFrame</value>
    <comment>BarTimer</comment>
  </data>
  <data name="WaitingForNewTick" xml:space="preserve">
    <value>Waiting For New Tick</value>
    <comment>BarTimer</comment>
  </data>
  <data name="AskBidImbalanceColor" xml:space="preserve">
    <value>Ask/Bid Imbalance Color</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="AskFilter" xml:space="preserve">
    <value>Ask Filter</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="Between" xml:space="preserve">
    <value>Between</value>
    <comment>TapePattern</comment>
  </data>
  <data name="BetweenColor" xml:space="preserve">
    <value>Between Color</value>
    <comment>TapePattern</comment>
  </data>
  <data name="BidAndAsk" xml:space="preserve">
    <value>Bid And Ask</value>
    <comment>TapePattern</comment>
  </data>
  <data name="BidAskImbalanceColor" xml:space="preserve">
    <value>Bid/Ask Imbalance Color</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="BidFilter" xml:space="preserve">
    <value>Bid Filter</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="BidOrAsk" xml:space="preserve">
    <value>Bid Or Ask</value>
    <comment>TapePattern</comment>
  </data>
  <data name="CalculationSettings" xml:space="preserve">
    <value>Calculation Settings</value>
    <comment>ZigZag</comment>
  </data>
  <data name="CumulativeTrades" xml:space="preserve">
    <value>Cumulative Trades</value>
    <comment>TapePattern</comment>
  </data>
  <data name="Data" xml:space="preserve">
    <value>Data</value>
    <comment>ZigZag</comment>
  </data>
  <data name="Days" xml:space="preserve">
    <value>Days</value>
    <comment>ZigZag</comment>
  </data>
  <data name="Exact" xml:space="preserve">
    <value>Exact</value>
    <comment>ZigZag</comment>
  </data>
  <data name="HighLineColor" xml:space="preserve">
    <value>High Line Color</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="ImbalanceRange" xml:space="preserve">
    <value>Imbalance Range</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="ImbalanceRatio" xml:space="preserve">
    <value>Imbalance Ratio</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="ImbalanceVolume" xml:space="preserve">
    <value>Imbalance Volume</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="LineWidth" xml:space="preserve">
    <value>Line Width</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="LowLineColor" xml:space="preserve">
    <value>Low Line Color</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="MaxCumulativeVolume" xml:space="preserve">
    <value>Max Cumulative Volume</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MaximumCount" xml:space="preserve">
    <value>Maximum trades Count</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MaxPrintVolume" xml:space="preserve">
    <value>Max Print Volume</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MinCumulativeVolume" xml:space="preserve">
    <value>Min Cumulative Volume</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MinimumCount" xml:space="preserve">
    <value>Minimum Trades Count</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MinPrintVolume" xml:space="preserve">
    <value>Min Print Volume</value>
    <comment>TapePattern</comment>
  </data>
  <data name="None" xml:space="preserve">
    <value>None</value>
    <comment>ZigZag</comment>
  </data>
  <data name="PrintLineForXBars" xml:space="preserve">
    <value>Print Line For X Bars</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="RangeFilter" xml:space="preserve">
    <value>Range Filter</value>
    <comment>TapePattern</comment>
  </data>
  <data name="RequiredChange" xml:space="preserve">
    <value>Required Change</value>
    <comment>ZigZag</comment>
  </data>
  <data name="SearchPrintsInsideTimeFilter" xml:space="preserve">
    <value>Search Prints Inside Time Filter</value>
    <comment>TapePattern</comment>
  </data>
  <data name="ShowBars" xml:space="preserve">
    <value>Show Bars</value>
    <comment>ZigZag</comment>
  </data>
  <data name="ShowTicks" xml:space="preserve">
    <value>Show Ticks</value>
    <comment>ZigZag</comment>
  </data>
  <data name="TimeFilter" xml:space="preserve">
    <value>Time Filter</value>
    <comment>TapePattern</comment>
  </data>
  <data name="AskRows" xml:space="preserve">
    <value>Ask Rows</value>
    <comment>DOM</comment>
  </data>
  <data name="AsksBackGround" xml:space="preserve">
    <value>Asks Background</value>
    <comment>DOM</comment>
  </data>
  <data name="BestAskBackGround" xml:space="preserve">
    <value>Best Ask Background</value>
    <comment>DOM</comment>
  </data>
  <data name="BestBidBackGround" xml:space="preserve">
    <value>Best Bid Background</value>
    <comment>DOM</comment>
  </data>
  <data name="BidRows" xml:space="preserve">
    <value>Bid Rows</value>
    <comment>DOM</comment>
  </data>
  <data name="BidsBackGround" xml:space="preserve">
    <value>Bids Background</value>
    <comment>DOM</comment>
  </data>
  <data name="CustomPriceLevelsHeight" xml:space="preserve">
    <value>Custom Height Of Price Levels</value>
    <comment>DOM</comment>
  </data>
  <data name="CustomScale" xml:space="preserve">
    <value>Custom Scale</value>
    <comment>DOM</comment>
  </data>
  <data name="HistogramSize" xml:space="preserve">
    <value>Histogram Size</value>
    <comment>DOM</comment>
  </data>
  <data name="ProportionVolume" xml:space="preserve">
    <value>Proportion Volume</value>
    <comment>DOM</comment>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Right To Left</value>
    <comment>DOM</comment>
  </data>
  <data name="Scale" xml:space="preserve">
    <value>Scale</value>
    <comment>DOM</comment>
  </data>
  <data name="ShowCumulativeValues" xml:space="preserve">
    <value>Show Cumulative Values</value>
    <comment>DOM</comment>
  </data>
  <data name="UseAutoSize" xml:space="preserve">
    <value>Use Auto Size</value>
    <comment>DOM</comment>
  </data>
  <data name="HighLowColor" xml:space="preserve">
    <value>High Low Color</value>
    <comment>MarketPower</comment>
  </data>
  <data name="ShowCumulative" xml:space="preserve">
    <value>Show Cumulative</value>
    <comment>MarketPower</comment>
  </data>
  <data name="ShowHighLow" xml:space="preserve">
    <value>Show High/Low</value>
    <comment>MarketPower</comment>
  </data>
  <data name="ShowSMA" xml:space="preserve">
    <value>Show SMA</value>
    <comment>MarketPower</comment>
  </data>
  <data name="SMAColor" xml:space="preserve">
    <value>SMA Color</value>
    <comment>MarketPower</comment>
  </data>
  <data name="SMAPeriod" xml:space="preserve">
    <value>SMA Period</value>
    <comment>MarketPower</comment>
  </data>
  <data name="Enabled" xml:space="preserve">
    <value>Enabled</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter1" xml:space="preserve">
    <value>Filter №1</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter2" xml:space="preserve">
    <value>Filter №2</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter3" xml:space="preserve">
    <value>Filter №3</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter4" xml:space="preserve">
    <value>Filter №4</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter5" xml:space="preserve">
    <value>Filter №5</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="ShowAboveChart" xml:space="preserve">
    <value>Show Above Chart</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="IgnoreZeroValues" xml:space="preserve">
    <value>Ignore Zero Values</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="Author" xml:space="preserve">
    <value>Author</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="ClustersMode" xml:space="preserve">
    <value>Clusters Mode</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="Copyright" xml:space="preserve">
    <value>Copyright</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="CumulativeMode" xml:space="preserve">
    <value>Cumulative Mode</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="CustomDiapason" xml:space="preserve">
    <value>Custom Range</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="GridStep" xml:space="preserve">
    <value>Grid Step</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="SeparatedTrades" xml:space="preserve">
    <value>Separated Trades</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="UseAbsValue" xml:space="preserve">
    <value>Use ABS Value</value>
    <comment>McClellanOscillator</comment>
  </data>
  <data name="Signal" xml:space="preserve">
    <value>Signal</value>
    <comment>RelativeVigorIndex</comment>
  </data>
  <data name="MaxPeriod" xml:space="preserve">
    <value>Maximal Period</value>
    <comment>DMI</comment>
  </data>
  <data name="MinPeriod" xml:space="preserve">
    <value>Minimal Period</value>
    <comment>DMI</comment>
  </data>
  <data name="EmaPeriod1" xml:space="preserve">
    <value>Exponential Moving Average Period 1</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod2" xml:space="preserve">
    <value>Exponential Moving Average Period 2</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod3" xml:space="preserve">
    <value>Exponential Moving Average Period 3</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod4" xml:space="preserve">
    <value>Exponential Moving Average Period 4</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod5" xml:space="preserve">
    <value>Exponential Moving Average Period 5</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod6" xml:space="preserve">
    <value>Exponential Moving Average Period 6</value>
    <comment>GMMA</comment>
  </data>
  <data name="SMAPeriod1" xml:space="preserve">
    <value>SMA Period 1</value>
    <comment>ACDC</comment>
  </data>
  <data name="SMAPeriod2" xml:space="preserve">
    <value>SMA Period 2</value>
    <comment>ACDC</comment>
  </data>
  <data name="SMAPeriod3" xml:space="preserve">
    <value>SMA Period 3</value>
    <comment>ACDC</comment>
  </data>
  <data name="SMAPeriod4" xml:space="preserve">
    <value>SMA Period 4</value>
    <comment>ACDC</comment>
  </data>
  <data name="AdxPeriod" xml:space="preserve">
    <value>ADX Period</value>
    <comment>ADXR</comment>
  </data>
  <data name="EMAPeriod" xml:space="preserve">
    <value>EMA Period</value>
    <comment>EMV</comment>
  </data>
  <data name="MovingType" xml:space="preserve">
    <value>Moving Average Type</value>
    <comment>EMV</comment>
  </data>
  <data name="UsePreviousClose" xml:space="preserve">
    <value>Use Previous Close</value>
    <comment>ADF</comment>
  </data>
  <data name="HighLow2" xml:space="preserve">
    <value>(High + Low)/2</value>
    <comment>AveragePriceBar</comment>
  </data>
  <data name="HighLow2Close4" xml:space="preserve">
    <value>(High + Low + 2*Close)/4</value>
    <comment>AveragePriceBar</comment>
  </data>
  <data name="HighLowClose3" xml:space="preserve">
    <value>(High + Low + Close)/3</value>
    <comment>AveragePriceBar</comment>
  </data>
  <data name="OpenHighLowClose4" xml:space="preserve">
    <value>(Open + High + Low + Close)/4</value>
    <comment>AveragePriceBar</comment>
  </data>
  <data name="AskBid" xml:space="preserve">
    <value>AskBid</value>
    <comment>BidAskVR</comment>
  </data>
  <data name="BidAsk" xml:space="preserve">
    <value>BidAsk</value>
    <comment>BidAskVR</comment>
  </data>
  <data name="BottomBand" xml:space="preserve">
    <value>Bottom Band</value>
    <comment>BollingerBandsPercent</comment>
  </data>
  <data name="MiddleBand" xml:space="preserve">
    <value>Middle Band</value>
    <comment>BollingerBandsPercent</comment>
  </data>
  <data name="KeltnerChannel" xml:space="preserve">
    <value>Keltner Channel</value>
    <comment>BollingerSqueeze</comment>
  </data>
  <data name="HighRatio" xml:space="preserve">
    <value>High Ratio</value>
    <comment>BollingerSqueeze</comment>
  </data>
  <data name="UseMA" xml:space="preserve">
    <value>Use Moving Average</value>
    <comment>ForceIndex</comment>
  </data>
  <data name="MaxOpenInterest" xml:space="preserve">
    <value>Maximum Open Interest</value>
    <comment>HerrickPayoff</comment>
  </data>
  <data name="MinOpenInterest" xml:space="preserve">
    <value>Minimum Open Interest</value>
    <comment>HerrickPayoff</comment>
  </data>
  <data name="Step" xml:space="preserve">
    <value>Step</value>
    <comment>HerrickPayoff</comment>
  </data>
  <data name="InsideBar" xml:space="preserve">
    <value>Inside Bar</value>
    <comment>InsideEqualsBar</comment>
  </data>
  <data name="InsideEqualBar" xml:space="preserve">
    <value>Inside Or Equals Bar</value>
    <comment>InsideEqualsBar</comment>
  </data>
  <data name="PeriodD" xml:space="preserve">
    <value>Period %D</value>
    <comment>KdFast</comment>
  </data>
  <data name="PeriodK" xml:space="preserve">
    <value>Period %K</value>
    <comment>KdFast</comment>
  </data>
  <data name="Estimator" xml:space="preserve">
    <value>Estimator</value>
    <comment>Kurtosis</comment>
  </data>
  <data name="Indicator" xml:space="preserve">
    <value>Indicator</value>
  </data>
  <data name="TopBand" xml:space="preserve">
    <value>Top Band</value>
    <comment>MacdBbStandart</comment>
  </data>
  <data name="FirstBar" xml:space="preserve">
    <value>First Bar</value>
    <comment>VolumeIndex</comment>
  </data>
  <data name="LastBar" xml:space="preserve">
    <value>Last Bar</value>
    <comment>VolumeIndex</comment>
  </data>
  <data name="SessionBegin" xml:space="preserve">
    <value>Session Begin</value>
    <comment>VolumeIndex</comment>
  </data>
  <data name="SMA1" xml:space="preserve">
    <value>Simple Moving Average 1</value>
    <comment>StdDevBands</comment>
  </data>
  <data name="SMA2" xml:space="preserve">
    <value>Simple Moving Average 2</value>
    <comment>StdDevBands</comment>
  </data>
  <data name="Period1" xml:space="preserve">
    <value>Period 1</value>
    <comment>UltimateOscillator</comment>
  </data>
  <data name="Period2" xml:space="preserve">
    <value>Period 2</value>
    <comment>UltimateOscillator</comment>
  </data>
  <data name="Period3" xml:space="preserve">
    <value>Period 3</value>
    <comment>UltimateOscillator</comment>
  </data>
  <data name="Neutral" xml:space="preserve">
    <value>Neutral</value>
    <comment>ACBW</comment>
  </data>
  <data name="ZeroValue" xml:space="preserve">
    <value>Zero Value</value>
    <comment>CAV</comment>
  </data>
  <data name="BuySellPower" xml:space="preserve">
    <value>Buy/Sell Power</value>
    <comment>Demand</comment>
  </data>
  <data name="Period4" xml:space="preserve">
    <value>Period 4</value>
    <comment>HurstExponent</comment>
  </data>
  <data name="Period5" xml:space="preserve">
    <value>Period 5</value>
    <comment>HurstExponent</comment>
  </data>
  <data name="IncludeEqualHighLow" xml:space="preserve">
    <value>Include Equal High Low</value>
    <comment>OutsideBars</comment>
  </data>
  <data name="FixedValue" xml:space="preserve">
    <value>Fixed Value</value>
    <comment>MaEnvelope</comment>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Value</value>
    <comment>MaEnvelope</comment>
  </data>
  <data name="MaxDynamicPeriod" xml:space="preserve">
    <value>Maximal Dynamic Period</value>
    <comment>VolatilityTrend</comment>
  </data>
  <data name="Overbought1" xml:space="preserve">
    <value>Overbought Level 1</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Overbought2" xml:space="preserve">
    <value>Overbought Level 2</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Overbought3" xml:space="preserve">
    <value>Overbought Level 3</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Oversold1" xml:space="preserve">
    <value>Oversold Level 1</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Oversold2" xml:space="preserve">
    <value>Oversold Level 2</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Oversold3" xml:space="preserve">
    <value>Oversold Level 3</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="FastLine" xml:space="preserve">
    <value>Fast Line</value>
    <comment>StochasticDiNapoli</comment>
  </data>
  <data name="SlowLine" xml:space="preserve">
    <value>Slow Line</value>
    <comment>StochasticDiNapoli</comment>
  </data>
  <data name="InvertOutput" xml:space="preserve">
    <value>Invert Output</value>
    <comment>WilliamsR</comment>
  </data>
  <data name="Range" xml:space="preserve">
    <value>Range</value>
  </data>
  <data name="Drawing" xml:space="preserve">
    <value>Drawing</value>
  </data>
  <data name="ImageLocation" xml:space="preserve">
    <value>Image Location</value>
    <comment>Logo</comment>
  </data>
  <data name="LogoLocation" xml:space="preserve">
    <value>Location</value>
    <comment>Logo</comment>
  </data>
  <data name="ShowDeltaChange" xml:space="preserve">
    <value>Show Delta Change</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="SessionEnd" xml:space="preserve">
    <value>Session End</value>
  </data>
  <data name="Length" xml:space="preserve">
    <value>Length</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="CustomVWAP" xml:space="preserve">
    <value>Custom VWAP Starting Point</value>
    <comment>VWAP</comment>
  </data>
  <data name="DeleteStartPoint" xml:space="preserve">
    <value>Delete Starting Point</value>
    <comment>VWAP</comment>
  </data>
  <data name="ResetOnSession" xml:space="preserve">
    <value>Reset On New Session</value>
    <comment>VWAP</comment>
  </data>
  <data name="SaveStartPoint" xml:space="preserve">
    <value>Save Custom Starting Point</value>
    <comment>VWAP</comment>
  </data>
  <data name="SetStartPoint" xml:space="preserve">
    <value>Set Starting Point</value>
    <comment>VWAP</comment>
  </data>
  <data name="AllowCustomStartPoint" xml:space="preserve">
    <value>Custom Starting Point Mode</value>
  </data>
  <data name="Transparency" xml:space="preserve">
    <value>Transparency</value>
  </data>
  <data name="LogoFilePathDescription" xml:space="preserve">
    <value>Image Files (*.bmp, *.gif, *.jpeg, *.jpg, *.png, *.tiff)</value>
    <comment>Logo</comment>
  </data>
  <data name="FastConst" xml:space="preserve">
    <value>Fast Smoothing Constant</value>
    <comment>AMA</comment>
  </data>
  <data name="SlowConst" xml:space="preserve">
    <value>Slow Smoothing Constant</value>
    <comment>AMA</comment>
  </data>
  <data name="ShortValues" xml:space="preserve">
    <value>Show Short Values</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="LineTillTouch" xml:space="preserve">
    <value>Line Till Touch</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="Close" xml:space="preserve">
    <value>Close</value>
  </data>
  <data name="High" xml:space="preserve">
    <value>High</value>
  </data>
  <data name="Low" xml:space="preserve">
    <value>Low</value>
  </data>
  <data name="Open" xml:space="preserve">
    <value>Open</value>
  </data>
  <data name="ShowArea" xml:space="preserve">
    <value>Show Area</value>
  </data>
  <data name="CustomSession" xml:space="preserve">
    <value>Custom Session</value>
  </data>
  <data name="RepeatAlert" xml:space="preserve">
    <value>Repeat Alert</value>
  </data>
  <data name="Tolerance" xml:space="preserve">
    <value>Tolerance</value>
    <comment>InsideBars</comment>
  </data>
  <data name="CustomTimeZone" xml:space="preserve">
    <value>Custom Current Time Timezone</value>
    <comment>BarTimer</comment>
  </data>
  <data name="MaxVolPercent" xml:space="preserve">
    <value>Maximal Candle Volume Percent</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinVolPercent" xml:space="preserve">
    <value>Minimal Candle Volume Percent</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="ShowTradesCount" xml:space="preserve">
    <value>Show Trades Count</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="FakeSeries" xml:space="preserve">
    <value>Fake Series</value>
    <comment>MFI</comment>
  </data>
  <data name="FakeSeriesColor" xml:space="preserve">
    <value>Fake Series Color</value>
    <comment>MFI</comment>
  </data>
  <data name="GreenSeries" xml:space="preserve">
    <value>Green Series</value>
    <comment>MFI</comment>
  </data>
  <data name="GreenSeriesColor" xml:space="preserve">
    <value>Green Series Color</value>
    <comment>MFI</comment>
  </data>
  <data name="SitSeries" xml:space="preserve">
    <value>Sit Series</value>
    <comment>MFI</comment>
  </data>
  <data name="SitSeriesColor" xml:space="preserve">
    <value>Sit Series Color</value>
    <comment>MFI</comment>
  </data>
  <data name="WeakSeries" xml:space="preserve">
    <value>Weak Series</value>
    <comment>MFI</comment>
  </data>
  <data name="WeakSeriesColor" xml:space="preserve">
    <value>Weak Series Color</value>
    <comment>MFI</comment>
  </data>
  <data name="ReverseAlert" xml:space="preserve">
    <value>Reverse Alert</value>
    <comment>Volume</comment>
  </data>
  <data name="VolumeAlert" xml:space="preserve">
    <value>Volume Alert</value>
    <comment>Volume</comment>
  </data>
  <data name="HideAll" xml:space="preserve">
    <value>Hide All</value>
    <comment>HRanges</comment>
  </data>
  <data name="Minutes" xml:space="preserve">
    <value>Minutes</value>
  </data>
  <data name="PeriodType" xml:space="preserve">
    <value>Period Type</value>
  </data>
  <data name="ShowHeight" xml:space="preserve">
    <value>Show Height</value>
  </data>
  <data name="ShowDivergence" xml:space="preserve">
    <value>Show Divergence</value>
  </data>
  <data name="BarsCountFilter" xml:space="preserve">
    <value>Bars Count Filter</value>
  </data>
  <data name="Color20" xml:space="preserve">
    <value>20% Color</value>
    <comment>DomStrength</comment>
  </data>
  <data name="Color50" xml:space="preserve">
    <value>50% Color</value>
    <comment>DomStrength</comment>
  </data>
  <data name="Color80" xml:space="preserve">
    <value>80% Color</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ColorMinus20" xml:space="preserve">
    <value>-20% Color</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ColorMinus50" xml:space="preserve">
    <value>-50% Color</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ColorMinus80" xml:space="preserve">
    <value>-80% Color</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ShowCurrentValue" xml:space="preserve">
    <value>Show Current Value</value>
  </data>
  <data name="Middle" xml:space="preserve">
    <value>Middle</value>
  </data>
  <data name="PocChangeAlert" xml:space="preserve">
    <value>POC Level Change Alert</value>
  </data>
  <data name="PocTouchAlert" xml:space="preserve">
    <value>POC Touch Alert</value>
  </data>
  <data name="VahTouchAlert" xml:space="preserve">
    <value>VAH Touch Alert</value>
  </data>
  <data name="ValTouchAlert" xml:space="preserve">
    <value>VAL Touch Alert</value>
  </data>
  <data name="PriceSelectionColor" xml:space="preserve">
    <value>Price Selection Color</value>
  </data>
  <data name="ShowPriceSelection" xml:space="preserve">
    <value>Show Price Selection</value>
  </data>
  <data name="SingalAlert" xml:space="preserve">
    <value>Singal Alert</value>
  </data>
  <data name="UpAlert" xml:space="preserve">
    <value>Up Alert</value>
  </data>
  <data name="DownAlert" xml:space="preserve">
    <value>Down Alert</value>
  </data>
  <data name="CenterAlign" xml:space="preserve">
    <value>Center Align</value>
  </data>
  <data name="ShowBotBlock" xml:space="preserve">
    <value>Show Bot Block</value>
  </data>
  <data name="ShowTopBlock" xml:space="preserve">
    <value>Show Top Blocks</value>
  </data>
  <data name="FilterColor" xml:space="preserve">
    <value>Filter Color</value>
  </data>
  <data name="FillCandles" xml:space="preserve">
    <value>Fill Candles</value>
    <comment>ExternalChart</comment>
  </data>
  <data name="AlertBeforeCandle" xml:space="preserve">
    <value>Alert Before New Candle</value>
  </data>
  <data name="Seconds" xml:space="preserve">
    <value>Seconds</value>
  </data>
  <data name="ShowFirstPartialPeriod" xml:space="preserve">
    <value>Show First Partial Period</value>
    <comment>VWAP</comment>
  </data>
  <data name="AlertNewCandle" xml:space="preserve">
    <value>Alert On New Candle</value>
  </data>
  <data name="BackgroundBearlish" xml:space="preserve">
    <value>Background Bearlish</value>
  </data>
  <data name="BackgroundBullish" xml:space="preserve">
    <value>Background Bullish</value>
  </data>
  <data name="ColorBeforeCandle" xml:space="preserve">
    <value>Change Color Before New Candle</value>
  </data>
  <data name="TooSmallRows" xml:space="preserve">
    <value>Price Rows Height Too Small For Render</value>
    <comment>ActiveVolume</comment>
  </data>
  <data name="minus20" xml:space="preserve">
    <value>-20</value>
  </data>
  <data name="minus80" xml:space="preserve">
    <value>-80</value>
  </data>
  <data name="m100" xml:space="preserve">
    <value>-100</value>
  </data>
  <data name="m200" xml:space="preserve">
    <value>-200</value>
  </data>
  <data name="m300" xml:space="preserve">
    <value>-300</value>
  </data>
  <data name="p100" xml:space="preserve">
    <value>100</value>
  </data>
  <data name="p200" xml:space="preserve">
    <value>200</value>
  </data>
  <data name="p300" xml:space="preserve">
    <value>300</value>
  </data>
  <data name="ShowHighLowValue" xml:space="preserve">
    <value>Show High/Low Current Value</value>
    <comment>Delta</comment>
  </data>
  <data name="LowerFill" xml:space="preserve">
    <value>Lower Fill</value>
  </data>
  <data name="LowerFill2" xml:space="preserve">
    <value>Lower Fill 2</value>
  </data>
  <data name="LowerStd1" xml:space="preserve">
    <value>Lover Deviation 1</value>
  </data>
  <data name="LowerStd2" xml:space="preserve">
    <value>Lover Deviation 2</value>
  </data>
  <data name="LowerStd3" xml:space="preserve">
    <value>Lover Deviation 3</value>
  </data>
  <data name="MiddleFillDown" xml:space="preserve">
    <value>Middle Fill Down</value>
  </data>
  <data name="MiddleFillUp" xml:space="preserve">
    <value>Middle Fill Up</value>
  </data>
  <data name="UpperFill" xml:space="preserve">
    <value>Upper Fill</value>
  </data>
  <data name="UpperFill2" xml:space="preserve">
    <value>Upper Fill 2</value>
  </data>
  <data name="UpperStd1" xml:space="preserve">
    <value>Upper Deviation 1</value>
  </data>
  <data name="UpperStd2" xml:space="preserve">
    <value>Upper Deviation 2</value>
  </data>
  <data name="UpperStd3" xml:space="preserve">
    <value>Upper Deviation 3</value>
  </data>
  <data name="NeutralBorderColor" xml:space="preserve">
    <value>Neutral/Border Color</value>
    <comment>Delta</comment>
  </data>
  <data name="Combined" xml:space="preserve">
    <value>Combined</value>
  </data>
  <data name="Both" xml:space="preserve">
    <value>Both</value>
  </data>
  <data name="Levels" xml:space="preserve">
    <value>Levels</value>
  </data>
  <data name="LevelsMode" xml:space="preserve">
    <value>Levels Mode</value>
  </data>
  <data name="IBHM" xml:space="preserve">
    <value>IBH-IBM</value>
  </data>
  <data name="IBHX1H" xml:space="preserve">
    <value>IBHX1-IBH</value>
  </data>
  <data name="IBHX21" xml:space="preserve">
    <value>IBHX2-1</value>
  </data>
  <data name="IBHX32" xml:space="preserve">
    <value>IBHX3-2</value>
  </data>
  <data name="IBL1" xml:space="preserve">
    <value>IBL-IBLX1</value>
  </data>
  <data name="IBLX12" xml:space="preserve">
    <value>IBLX1-2</value>
  </data>
  <data name="IBLX23" xml:space="preserve">
    <value>IBLX2-3</value>
  </data>
  <data name="IBML" xml:space="preserve">
    <value>IBM-IBL</value>
  </data>
  <data name="Average" xml:space="preserve">
    <value>Average</value>
  </data>
  <data name="DisplayBottom" xml:space="preserve">
    <value>Display At Bottom</value>
  </data>
  <data name="TwapPeriod" xml:space="preserve">
    <value>TWAP Period</value>
  </data>
  <data name="Lower" xml:space="preserve">
    <value>Lower</value>
  </data>
  <data name="Upper" xml:space="preserve">
    <value>Upper</value>
  </data>
  <data name="Total" xml:space="preserve">
    <value>Total</value>
  </data>
  <data name="VolumeType" xml:space="preserve">
    <value>Volume Type</value>
  </data>
  <data name="ColoredDirection" xml:space="preserve">
    <value>Colored Direction</value>
  </data>
  <data name="DaysLookBack" xml:space="preserve">
    <value>Days Look Back</value>
  </data>
  <data name="DaysLookBackDescription" xml:space="preserve">
    <value>Refers to the number of previous days taken into account when calculating an indicator</value>
  </data>
  <data name="LocationFilters" xml:space="preserve">
    <value>Location Filters</value>
  </data>
  <data name="ObjectsColor" xml:space="preserve">
    <value>Objects Color</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="BarsRangeDescription" xml:space="preserve">
    <value>This property is used to specify the number of candles that should be aggregated before the main calculation takes place.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="DeltaFilterDescription" xml:space="preserve">
    <value>This property is used to set a filter on the delta for a specific price level. If the value is positive, the filter will only allow price levels where the delta is greater than or equal to the value. If the value is negative, the filter will only allow price levels where the delta is less than or equal to the value.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="DeltaImbalanceDescription" xml:space="preserve">
    <value>This property is used to filter out price levels based on the difference between the percentage of ask volume and the percentage of bid volume. If the value is positive, the filter will only allow price levels where the percentage of ask volume is greater than or equal to the value. If the value is negative, the filter will only allow price levels where the percentage of bid volume is greater than or equal to the absolute value.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="MaxAvgTradeDescription" xml:space="preserve">
    <value>This property is used to determine the maximum average trade required for a price level to be considered valid. The average trade is calculated by dividing the volume of a price level by the number of ticks on that level. If the resulting value is greater than this property, the price level will be excluded from consideration.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="MaxPercentDescription" xml:space="preserve">
    <value>Property is used to set the maximum volume percentage allowed for a price level to be considered valid. The volume percentage is calculated by dividing the volume of a price level by the total volume of the candle and multiplying by 100. If the resulting value is greater than this property, the price level will be excluded from consideration. If the property is set to 0, it will not be used in the validation check.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="MinAvgTradeDescription" xml:space="preserve">
    <value>This property is used to determine the minimum average trade required for a price level to be considered valid. The average trade is calculated by dividing the volume of a price level by the number of ticks on that level. If the resulting value is less than this property, the price level will be excluded from consideration.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="MinPercentDescription" xml:space="preserve">
    <value>Property is used to set the minimum volume percentage required for a price level to be considered valid. The volume percentage is calculated by dividing the volume of a price level by the total volume of the candle and multiplying by 100. If the resulting value is less than this property, the price level will be excluded from consideration. If the property is set to 0, it will not be used in the validation check.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="PipsFromHighDescription" xml:space="preserve">
    <value>This property sets the maximum distance in ticks from the candle's high price that a level can be considered as valid. If the distance between the level and the candle's high price exceeds the value of this property the level will not be considered as valid.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="PipsFromLowDescription" xml:space="preserve">
    <value>This property sets the maximum distance in ticks from the candle's low price that a level can be considered as valid. If the distance between the level and the candle's low price exceeds the value of this property the level will not be considered as valid.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="PriceRangeDescription" xml:space="preserve">
    <value>It determines the range of prices that will be aggregated in the calculation. The range is defined by the number of ticks specified in the parameter.</value>
    <comment>Cluster search</comment>
  </data>
  <data name="DojiCandleBear" xml:space="preserve">
    <value>Doji Candle Bear</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="DojiCandleBull" xml:space="preserve">
    <value>Doji Candle Bull</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="DojiEmptyColor" xml:space="preserve">
    <value>Doji Empty Color</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="EquilibriumBottomCandle" xml:space="preserve">
    <value>Equilibrium Bottom Candle</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="EquilibriumTopCandle" xml:space="preserve">
    <value>Equilibrium Top Candle</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="MoveCandleBear" xml:space="preserve">
    <value>Move Candle Bear</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="MoveCandleBull" xml:space="preserve">
    <value>Move Candle Bull</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="PullbackCandleBear" xml:space="preserve">
    <value>Pullback Candle Bear</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="PullbackCandleBull" xml:space="preserve">
    <value>Pullback Candle Bull</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="StrongCandleBear" xml:space="preserve">
    <value>Strong Candle Bear</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="StrongCandleBull" xml:space="preserve">
    <value>Strong Candle Bull</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="OnlyAlertsSupported" xml:space="preserve">
    <value>Only Alerts Are Supported</value>
    <comment>BarTimer</comment>
  </data>
  <data name="ThirdFormula" xml:space="preserve">
    <value>3rd Formula</value>
    <comment>Pivots</comment>
  </data>
  <data name="AlertPerBar" xml:space="preserve">
    <value>Only One Alert Per Bar</value>
  </data>
  <data name="DeltaAlert" xml:space="preserve">
    <value>Delta Alert</value>
  </data>
  <data name="Headers" xml:space="preserve">
    <value>Headers</value>
  </data>
  <data name="MaximumVolumeDescription" xml:space="preserve">
    <value>Shows line of maximum value of volume for specifyed amount of bars</value>
  </data>
  <data name="ReverseAlertDescription" xml:space="preserve">
    <value>Appears on divergences(candle is positive and delta is negative or visa versa)</value>
  </data>
  <data name="Rows" xml:space="preserve">
    <value>Rows</value>
  </data>
  <data name="VolumeLabel" xml:space="preserve">
    <value>Volume Label</value>
  </data>
  <data name="VolumeLabelDescription" xml:space="preserve">
    <value>When bars are wide, shows values of volumes on each bar</value>
  </data>
  <data name="ADR" xml:space="preserve">
    <value>Average Daily Range</value>
  </data>
  <data name="BuyOvershoot1Color" xml:space="preserve">
    <value>Buy Overshoot 1 Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="BuyOvershoot2Color" xml:space="preserve">
    <value>Buy Overshoot 2 Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="BuyOvershoot3Color" xml:space="preserve">
    <value>Buy Overshoot 3 Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="BuyOvershootColor" xml:space="preserve">
    <value>Buy Overshoot Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="HighlightSignalBars" xml:space="preserve">
    <value>Highlight Signal Bars</value>
  </data>
  <data name="ResistanceLevel" xml:space="preserve">
    <value>Resistance Level</value>
  </data>
  <data name="SellOvershoot1Color" xml:space="preserve">
    <value>Sell Overshoot 1 Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="SellOvershoot2Color" xml:space="preserve">
    <value>Sell Overshoot 2 Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="SellOvershoot3Color" xml:space="preserve">
    <value>Sell Overshoot 3 Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="SellOvershootColor" xml:space="preserve">
    <value>Sell Overshoot Color</value>
    <comment>TDSequential</comment>
  </data>
  <data name="ShowSignalNumbers" xml:space="preserve">
    <value>Show Signal Numbers</value>
  </data>
  <data name="SRLevels" xml:space="preserve">
    <value>Support/Resistance Levels</value>
  </data>
  <data name="SupportLevel" xml:space="preserve">
    <value>Support Level</value>
  </data>
  <data name="AskBidVolume" xml:space="preserve">
    <value>Ask/Bid Volume</value>
    <comment>Up/Down Volume Ratio</comment>
  </data>
  <data name="SZMA" xml:space="preserve">
    <value>Simple Moving Average - Skip Zeros</value>
  </data>
  <data name="UpDownVolume" xml:space="preserve">
    <value>Up/Down Candle Volume</value>
    <comment>Up/Down Volume Ratio</comment>
  </data>
  <data name="WWMA" xml:space="preserve">
    <value>Welles Wilders Moving Average</value>
  </data>
  <data name="HLAverage" xml:space="preserve">
    <value>HL Average</value>
    <comment>Vertical Horizontal Filter</comment>
  </data>
  <data name="HLCAverage" xml:space="preserve">
    <value>HLC Average</value>
    <comment>Vertical Horizontal Filter</comment>
  </data>
  <data name="OHLCAverage" xml:space="preserve">
    <value>OHLC Average</value>
    <comment>Vertical Horizontal Filter</comment>
  </data>
  <data name="Profile" xml:space="preserve">
    <value>Profile</value>
  </data>
  <data name="RowWidth" xml:space="preserve">
    <value>Row Width</value>
  </data>
  <data name="ClosePartially" xml:space="preserve">
    <value>Close Partially</value>
    <comment>Gaps</comment>
  </data>
  <data name="HideBorder" xml:space="preserve">
    <value>Hide Border</value>
  </data>
  <data name="HideGaps" xml:space="preserve">
    <value>Hide Gaps</value>
    <comment>Gaps</comment>
  </data>
  <data name="LimitMaxGapBodyLength" xml:space="preserve">
    <value>Limit Max Gap Body Length</value>
    <comment>Gaps</comment>
  </data>
  <data name="MaxGapBodyLength" xml:space="preserve">
    <value>Max Gap Body Length (bars)</value>
    <comment>Gaps</comment>
  </data>
  <data name="MinimalDeviation" xml:space="preserve">
    <value>Minimal Deviation (%)</value>
    <comment>Gaps</comment>
  </data>
  <data name="BrokenChannelColor" xml:space="preserve">
    <value>Broken Channel Color</value>
  </data>
  <data name="Deviation" xml:space="preserve">
    <value>Deviation</value>
  </data>
  <data name="ExtendLines" xml:space="preserve">
    <value>Extend Lines</value>
  </data>
  <data name="ShowBrokenChannel" xml:space="preserve">
    <value>Show Broken Channel</value>
  </data>
  <data name="ShowFibonacci" xml:space="preserve">
    <value>Show Fibonacci Levels</value>
  </data>
  <data name="ExtendLast" xml:space="preserve">
    <value>Extend Last</value>
  </data>
  <data name="ExtendPrevious" xml:space="preserve">
    <value>Extend Previous</value>
  </data>
  <data name="Zone" xml:space="preserve">
    <value>Zone</value>
  </data>
  <data name="DisplayMode" xml:space="preserve">
    <value>Display Mode</value>
  </data>
  <data name="General" xml:space="preserve">
    <value>General</value>
  </data>
  <data name="LabelLocation" xml:space="preserve">
    <value>Label Location</value>
  </data>
  <data name="LineStyle" xml:space="preserve">
    <value>Line Style</value>
  </data>
  <data name="OpenClose" xml:space="preserve">
    <value>Open / Close</value>
  </data>
  <data name="ResistanceColor" xml:space="preserve">
    <value>Resistance Color</value>
  </data>
  <data name="ShowLines" xml:space="preserve">
    <value>Show Lines</value>
  </data>
  <data name="ShowTimeFrameLabel" xml:space="preserve">
    <value>Show Timeframe Label</value>
  </data>
  <data name="SupportColor" xml:space="preserve">
    <value>Support Color</value>
  </data>
  <data name="TimeFrame1" xml:space="preserve">
    <value>Time Frame 1</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="TimeFrame2" xml:space="preserve">
    <value>Time Frame 2</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="TimeFrame3" xml:space="preserve">
    <value>Time Frame 3</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="TimeFrame4" xml:space="preserve">
    <value>Time Frame 4</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="ColorScheme" xml:space="preserve">
    <value>Color Scheme</value>
  </data>
  <data name="CoolDownPeriod" xml:space="preserve">
    <value>Cool down period (seconds)</value>
    <comment>Order Book Alerts</comment>
  </data>
  <data name="PriceOffset" xml:space="preserve">
    <value>Price Offset</value>
  </data>
  <data name="ShowOnChart" xml:space="preserve">
    <value>Show on chart</value>
  </data>
  <data name="BWMA" xml:space="preserve">
    <value>Bill Williams Moving Average</value>
  </data>
  <data name="DEMA" xml:space="preserve">
    <value>Double Exponential Moving Average</value>
  </data>
  <data name="SWWMA" xml:space="preserve">
    <value>Sine-Wave Weighted Moving Average</value>
  </data>
  <data name="TEMA" xml:space="preserve">
    <value>Triple Exponential Moving Average</value>
  </data>
  <data name="TMA" xml:space="preserve">
    <value>Triangular Moving Average</value>
  </data>
  <data name="ZLEMA" xml:space="preserve">
    <value>Zero Lag Exponential Moving Average</value>
  </data>
  <data name="CurrentTimeFrame" xml:space="preserve">
    <value>Current Timeframe</value>
  </data>
  <data name="HideOlds" xml:space="preserve">
    <value>Hide Olds</value>
  </data>
  <data name="HigherTimeFrame" xml:space="preserve">
    <value>Higher Timeframe</value>
  </data>
  <data name="Label" xml:space="preserve">
    <value>Label</value>
  </data>
  <data name="Midpoint" xml:space="preserve">
    <value>Midpoint</value>
  </data>
  <data name="MidpointTouch" xml:space="preserve">
    <value>Midpoint Touch</value>
  </data>
  <data name="HMA" xml:space="preserve">
    <value>Hull Moving Average (HMA)</value>
  </data>
  <data name="VWAPOnly" xml:space="preserve">
    <value>VWAP Only</value>
    <comment>VWAP</comment>
  </data>
  <data name="Default" xml:space="preserve">
    <value>Default</value>
  </data>
  <data name="FilterEmptyMsg" xml:space="preserve">
    <value>Filter is empty</value>
  </data>
</root>




Technical/Properties/Resources.ru-ru.resx



<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ADX" xml:space="preserve">
    <value>Индекс Среднего Направления Движения</value>
  </data>
  <data name="ATR" xml:space="preserve">
    <value>Средний Истинный Диапазон</value>
  </data>
  <data name="BollingerBands" xml:space="preserve">
    <value>Полосы Боллинджера</value>
  </data>
  <data name="CCI" xml:space="preserve">
    <value>Индекс Товарного Канала</value>
  </data>
  <data name="Common" xml:space="preserve">
    <value>Общее</value>
  </data>
  <data name="DINeg" xml:space="preserve">
    <value>Индикатор Направленности DI-</value>
  </data>
  <data name="DIPos" xml:space="preserve">
    <value>Индикатор Направленности DI+</value>
  </data>
  <data name="DX" xml:space="preserve">
    <value>Индекс Направленного Движения</value>
  </data>
  <data name="EMA" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя (EMA)</value>
  </data>
  <data name="Highest" xml:space="preserve">
    <value>Максимальное Значение</value>
  </data>
  <data name="LinearReg" xml:space="preserve">
    <value>Линейная Регрессия</value>
  </data>
  <data name="Lowest" xml:space="preserve">
    <value>Минимальное Значение</value>
  </data>
  <data name="MACD" xml:space="preserve">
    <value>Схождение/Расхождение Скользящих Средних</value>
  </data>
  <data name="MeanDeviation" xml:space="preserve">
    <value>Среднее Отклонение</value>
  </data>
  <data name="Momentum" xml:space="preserve">
    <value>Момент</value>
  </data>
  <data name="ParabolicSAR" xml:space="preserve">
    <value>Параболическая Система SAR</value>
  </data>
  <data name="Period" xml:space="preserve">
    <value>Период</value>
  </data>
  <data name="RSI" xml:space="preserve">
    <value>Индекс Относительной Силы</value>
  </data>
  <data name="RVI" xml:space="preserve">
    <value>Индекс Относительной Энергии</value>
  </data>
  <data name="SMA" xml:space="preserve">
    <value>Простая Скользящая Средняя (SMA)</value>
  </data>
  <data name="SMMA" xml:space="preserve">
    <value>Сглаженная Скользящая Средняя (SMMA)</value>
  </data>
  <data name="StdDev" xml:space="preserve">
    <value>Стандартное Отклонение</value>
  </data>
  <data name="Stochastic" xml:space="preserve">
    <value>Стохастик</value>
  </data>
  <data name="WMA" xml:space="preserve">
    <value>Взвешанная Скользящая Средняя (WMA)</value>
  </data>
  <data name="Color" xml:space="preserve">
    <value>Цвет</value>
  </data>
  <data name="Width" xml:space="preserve">
    <value>Толщина</value>
  </data>
  <data name="Mode" xml:space="preserve">
    <value>Режим</value>
  </data>
  <data name="Ask" xml:space="preserve">
    <value>Аск</value>
  </data>
  <data name="Bid" xml:space="preserve">
    <value>Бид</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Текст</value>
  </data>
  <data name="Colors" xml:space="preserve">
    <value>Цвета</value>
  </data>
  <data name="Filters" xml:space="preserve">
    <value>Фильтры</value>
  </data>
  <data name="DeltaColored" xml:space="preserve">
    <value>Раскраска По Дельте</value>
  </data>
  <data name="Calculation" xml:space="preserve">
    <value>Вычисления</value>
  </data>
  <data name="Filter" xml:space="preserve">
    <value>Фильтр</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Тип</value>
  </data>
  <data name="UseFilter" xml:space="preserve">
    <value>Использовать Фильтр</value>
  </data>
  <data name="PivotRange" xml:space="preserve">
    <value>Pivot Диапазон</value>
  </data>
  <data name="Candles" xml:space="preserve">
    <value>Свечи</value>
  </data>
  <data name="Line" xml:space="preserve">
    <value>Линия</value>
  </data>
  <data name="SessionDeltaMode" xml:space="preserve">
    <value>Режим Сессионной Дельты</value>
  </data>
  <data name="VisualMode" xml:space="preserve">
    <value>Режим</value>
  </data>
  <data name="Minimizedmode" xml:space="preserve">
    <value>Режим Минимизации</value>
  </data>
  <data name="HighLow" xml:space="preserve">
    <value>Макс / Мин</value>
  </data>
  <data name="FirstDev" xml:space="preserve">
    <value>Отклонение №1</value>
  </data>
  <data name="SecondDev" xml:space="preserve">
    <value>Отклонение №2</value>
  </data>
  <data name="Accumulated" xml:space="preserve">
    <value>Накопительно</value>
  </data>
  <data name="AlertFile" xml:space="preserve">
    <value>Звук</value>
  </data>
  <data name="Alerts" xml:space="preserve">
    <value>Алерты</value>
  </data>
  <data name="AllPeriodtxt" xml:space="preserve">
    <value>Весь Период</value>
  </data>
  <data name="ApproximationAlert" xml:space="preserve">
    <value>Алерт Приближения Цены К Уровню</value>
  </data>
  <data name="ApproximationFilter" xml:space="preserve">
    <value>Расстояние До Цены Для Алерта</value>
  </data>
  <data name="AtStart" xml:space="preserve">
    <value>От Начала</value>
  </data>
  <data name="BackGround" xml:space="preserve">
    <value>Фон</value>
  </data>
  <data name="ChangingLevelAlert" xml:space="preserve">
    <value>Алерт Смены Уровня</value>
  </data>
  <data name="Daily" xml:space="preserve">
    <value>День</value>
  </data>
  <data name="Delta" xml:space="preserve">
    <value>Дельта</value>
  </data>
  <data name="FontColor" xml:space="preserve">
    <value>Цвет Текста</value>
  </data>
  <data name="Hourly" xml:space="preserve">
    <value>Час</value>
  </data>
  <data name="Monthly" xml:space="preserve">
    <value>Месяц</value>
  </data>
  <data name="Other" xml:space="preserve">
    <value>Остальное</value>
  </data>
  <data name="ShowVolume" xml:space="preserve">
    <value>Отображать Объем</value>
  </data>
  <data name="Ticks" xml:space="preserve">
    <value>Тики</value>
  </data>
  <data name="Time" xml:space="preserve">
    <value>Время</value>
  </data>
  <data name="Volume" xml:space="preserve">
    <value>Объем</value>
  </data>
  <data name="VolumeVisualizationType" xml:space="preserve">
    <value>Тип Визуализации</value>
  </data>
  <data name="Weekly" xml:space="preserve">
    <value>Неделя</value>
  </data>
  <data name="Multiplier" xml:space="preserve">
    <value>Множитель</value>
  </data>
  <data name="Any" xml:space="preserve">
    <value>Любое</value>
  </data>
  <data name="BarsDirection" xml:space="preserve">
    <value>Направление Баров</value>
  </data>
  <data name="Bearlish" xml:space="preserve">
    <value>Медвежье</value>
  </data>
  <data name="Bullish" xml:space="preserve">
    <value>Бычье</value>
  </data>
  <data name="DeltaType" xml:space="preserve">
    <value>Тип Дельты</value>
  </data>
  <data name="Negative" xml:space="preserve">
    <value>Отрицательная</value>
  </data>
  <data name="Positive" xml:space="preserve">
    <value>Положительная</value>
  </data>
  <data name="AutoFilterPeriod" xml:space="preserve">
    <value>Период Автофильтра</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="Buys" xml:space="preserve">
    <value>Покупки</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="CalculationMode" xml:space="preserve">
    <value>Тип Расчетов</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="Sells" xml:space="preserve">
    <value>Продажи</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="TimeFilterSec" xml:space="preserve">
    <value>Фильтр Времени, Сек</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="TradesFilter" xml:space="preserve">
    <value>Фильтр Трейдов</value>
    <comment>Speed of tape</comment>
  </data>
  <data name="AutoFilter" xml:space="preserve">
    <value>Автофильтр</value>
  </data>
  <data name="CurrentDay" xml:space="preserve">
    <value>Текущий День</value>
  </data>
  <data name="CurrentMonth" xml:space="preserve">
    <value>Текущий Месяц</value>
  </data>
  <data name="CurrentWeek" xml:space="preserve">
    <value>Текущая Неделя</value>
  </data>
  <data name="PreviousDay" xml:space="preserve">
    <value>Прошлый День</value>
  </data>
  <data name="PreviousMonth" xml:space="preserve">
    <value>Прошлый Месяц</value>
  </data>
  <data name="PreviousWeek" xml:space="preserve">
    <value>Прошлая Неделя</value>
  </data>
  <data name="Left" xml:space="preserve">
    <value>Слева</value>
    <comment>Pivots</comment>
  </data>
  <data name="Right" xml:space="preserve">
    <value>Справа</value>
    <comment>Pivots</comment>
  </data>
  <data name="Show" xml:space="preserve">
    <value>Отображать</value>
    <comment>Pivots</comment>
  </data>
  <data name="TextLocation" xml:space="preserve">
    <value>Расположение Текста</value>
    <comment>Pivots</comment>
  </data>
  <data name="TextSize" xml:space="preserve">
    <value>Размер Текста</value>
    <comment>Pivots</comment>
  </data>
  <data name="AbsolutePrice" xml:space="preserve">
    <value>Абсолютная Величина</value>
  </data>
  <data name="RelativeInPercent" xml:space="preserve">
    <value>Относительная Величина</value>
  </data>
  <data name="FontSize" xml:space="preserve">
    <value>Размер Шрифта</value>
  </data>
  <data name="Height" xml:space="preserve">
    <value>Высота</value>
  </data>
  <data name="TextColor" xml:space="preserve">
    <value>Цвет Текста</value>
  </data>
  <data name="TimeFormat" xml:space="preserve">
    <value>Формат Времени</value>
  </data>
  <data name="ThirdDev" xml:space="preserve">
    <value>Отклонение №3</value>
  </data>
  <data name="Maximum" xml:space="preserve">
    <value>Максимум</value>
  </data>
  <data name="Minimum" xml:space="preserve">
    <value>Минимум</value>
  </data>
  <data name="Size" xml:space="preserve">
    <value>Размер</value>
  </data>
  <data name="BottomLeft" xml:space="preserve">
    <value>Снизу Слева</value>
  </data>
  <data name="BottomRight" xml:space="preserve">
    <value>Снизу Справа</value>
  </data>
  <data name="Center" xml:space="preserve">
    <value>По Центру</value>
  </data>
  <data name="FirstLine" xml:space="preserve">
    <value>Первая Строка</value>
  </data>
  <data name="Font" xml:space="preserve">
    <value>Шрифт</value>
  </data>
  <data name="HorizontalOffset" xml:space="preserve">
    <value>Отступ По Горизонтали</value>
  </data>
  <data name="SecondLine" xml:space="preserve">
    <value>Вторая Строка</value>
  </data>
  <data name="ShowInstrument" xml:space="preserve">
    <value>Отображать Инструмент</value>
  </data>
  <data name="ShowPeriod" xml:space="preserve">
    <value>Отображать Период</value>
  </data>
  <data name="TopLeft" xml:space="preserve">
    <value>Сверху Слева</value>
  </data>
  <data name="TopRight" xml:space="preserve">
    <value>Сверху Справа</value>
  </data>
  <data name="VerticalOffset" xml:space="preserve">
    <value>Отступ по вертикали</value>
  </data>
  <data name="Visualization" xml:space="preserve">
    <value>Визуализация</value>
    <comment>BigTradesSettings</comment>
  </data>
  <data name="AxisTextColor" xml:space="preserve">
    <value>Цвет текста На Оси</value>
  </data>
  <data name="NegativeDelta" xml:space="preserve">
    <value>Отрицательная Дельта</value>
  </data>
  <data name="PositiveDelta" xml:space="preserve">
    <value>Положительная Дельта</value>
  </data>
  <data name="ByBar" xml:space="preserve">
    <value>Каждый Бар</value>
  </data>
  <data name="Cumulative" xml:space="preserve">
    <value>Накопительно</value>
  </data>
  <data name="Session" xml:space="preserve">
    <value>Сессия</value>
  </data>
  <data name="PaintBars" xml:space="preserve">
    <value>Раскрашивать Бары</value>
  </data>
  <data name="Bars" xml:space="preserve">
    <value>Бары</value>
  </data>
  <data name="BBandsWidth" xml:space="preserve">
    <value>Ширина Канала</value>
  </data>
  <data name="AccelMax" xml:space="preserve">
    <value>Макс. Ускорение</value>
  </data>
  <data name="AccelStart" xml:space="preserve">
    <value>Начальное Ускорение</value>
  </data>
  <data name="AccelStep" xml:space="preserve">
    <value>Шаг Ускорения</value>
  </data>
  <data name="AreaColor" xml:space="preserve">
    <value>Цвет</value>
  </data>
  <data name="AveragePeriod" xml:space="preserve">
    <value>Период Сглаживания</value>
  </data>
  <data name="EndTime" xml:space="preserve">
    <value>Конечное Время</value>
  </data>
  <data name="LongPeriod" xml:space="preserve">
    <value>Период Длинный</value>
  </data>
  <data name="OffsetMultiplier" xml:space="preserve">
    <value>Коэффициент Отклонения</value>
  </data>
  <data name="ShortPeriod" xml:space="preserve">
    <value>Период Короткий</value>
  </data>
  <data name="SignalPeriod" xml:space="preserve">
    <value>Период Сигнала</value>
  </data>
  <data name="Smooth" xml:space="preserve">
    <value>Сглаживание</value>
  </data>
  <data name="StartTime" xml:space="preserve">
    <value>Начальное Время</value>
  </data>
  <data name="LookBack" xml:space="preserve">
    <value>Период</value>
    <comment>RelativeVolume</comment>
  </data>
  <data name="RenderPeriods" xml:space="preserve">
    <value>Отображаемое Количество Периодов</value>
  </data>
  <data name="Overbought" xml:space="preserve">
    <value>Перекупленность</value>
    <comment>MFI</comment>
  </data>
  <data name="Oversold" xml:space="preserve">
    <value>Перепроданность</value>
    <comment>MFI</comment>
  </data>
  <data name="HighSession" xml:space="preserve">
    <value>Максимум Сессии</value>
    <comment>ADR</comment>
  </data>
  <data name="LowSession" xml:space="preserve">
    <value>Минимум Сессии</value>
    <comment>ADR</comment>
  </data>
  <data name="OpenSession" xml:space="preserve">
    <value>Начало Сессии</value>
    <comment>ADR</comment>
  </data>
  <data name="WavePeriod" xml:space="preserve">
    <value>Длина Волны</value>
  </data>
  <data name="Histogram" xml:space="preserve">
    <value>Гистограмма</value>
    <comment>Delta</comment>
  </data>
  <data name="UseScale" xml:space="preserve">
    <value>Масштабировать</value>
  </data>
  <data name="Body" xml:space="preserve">
    <value>Тело</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleBodyHeight" xml:space="preserve">
    <value>Высота Тела Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleBodyHeightFilter" xml:space="preserve">
    <value>Фильтр По Высоте Тела Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleHeight" xml:space="preserve">
    <value>Высота Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="CandleHeightFilter" xml:space="preserve">
    <value>Фильтр По Высоте Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="DepthMarket" xml:space="preserve">
    <value>Bid/Ask/Delta</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="DepthMarketFilter" xml:space="preserve">
    <value>Фильтр По Bid/Ask/Delta</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="DirectionFilter" xml:space="preserve">
    <value>Фильтр По Направлению</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Disabled" xml:space="preserve">
    <value>Выключен</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Dodge" xml:space="preserve">
    <value>Нейтральный</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="LowerWick" xml:space="preserve">
    <value>Нижняя Тень</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumAsk" xml:space="preserve">
    <value>Максимальный Аск</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumBid" xml:space="preserve">
    <value>Максимальный Бид</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumCandleBodyHeight" xml:space="preserve">
    <value>Максимальная Высота Тела Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumCandleHeight" xml:space="preserve">
    <value>Максимальная Высота Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumDelta" xml:space="preserve">
    <value>Максимальная Дельта</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumTrades" xml:space="preserve">
    <value>Максимум Сделок</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumVolume" xml:space="preserve">
    <value>Максимальный Объем</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MaximumVolumeFilter" xml:space="preserve">
    <value>Расположение Максимального Объема</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumAsk" xml:space="preserve">
    <value>Минимальный Аск</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumBid" xml:space="preserve">
    <value>Минимальный Бид</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumCandleBodyHeight" xml:space="preserve">
    <value>Минимальная Высота Тела Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumCandleHeight" xml:space="preserve">
    <value>Минимальная Высота Свечи</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumDelta" xml:space="preserve">
    <value>Минимальная Дельта</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumTrades" xml:space="preserve">
    <value>Минимум Сделок</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="MinimumVolume" xml:space="preserve">
    <value>Минимальный Объем</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Trades" xml:space="preserve">
    <value>Сделки</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="UpperWick" xml:space="preserve">
    <value>Верхняя Тень</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="VolumeFilter" xml:space="preserve">
    <value>Фильтр По Объему</value>
    <comment>BarsPattern</comment>
  </data>
  <data name="Predict" xml:space="preserve">
    <value>Задержка</value>
    <comment>VPF</comment>
  </data>
  <data name="SlowFactor" xml:space="preserve">
    <value>Задержка</value>
    <comment>QQE</comment>
  </data>
  <data name="BBMultFactor" xml:space="preserve">
    <value>Bollinger Bands Множитель</value>
    <comment>SqueezeMomentum</comment>
  </data>
  <data name="BBPeriod" xml:space="preserve">
    <value>Bollinger Bands Период</value>
    <comment>SqueezeMomentum</comment>
  </data>
  <data name="KCMultFactor" xml:space="preserve">
    <value>Keltner Channel Множитель</value>
    <comment>SqueezeMomentum</comment>
  </data>
  <data name="KCPeriod" xml:space="preserve">
    <value>Keltner Channel Период</value>
    <comment>SqueezeMomentum</comment>
  </data>
  <data name="UseTrueRangeKc" xml:space="preserve">
    <value>Применить TrueRange (KC)</value>
    <comment>SqueezeMomentum</comment>
  </data>
  <data name="JawAlligator" xml:space="preserve">
    <value>Челюсть Аллигатора</value>
    <comment>Alligator</comment>
  </data>
  <data name="LipsAlligator" xml:space="preserve">
    <value>Губы Аллигатора</value>
    <comment>Alligator</comment>
  </data>
  <data name="Shift" xml:space="preserve">
    <value>Сдвиг</value>
  </data>
  <data name="TeethAlligator" xml:space="preserve">
    <value>Зубы Аллигатора</value>
    <comment>Alligator</comment>
  </data>
  <data name="BuyColor" xml:space="preserve">
    <value>Цвет Покупки</value>
  </data>
  <data name="SellColor" xml:space="preserve">
    <value>Цвет Продажи</value>
  </data>
  <data name="AnalysisPeriod" xml:space="preserve">
    <value>Период Ретроспективного Анализа</value>
    <comment>RelativeVolume</comment>
  </data>
  <data name="Percent" xml:space="preserve">
    <value>Процент</value>
    <comment>DailyChange</comment>
  </data>
  <data name="BackGroundBuyColor" xml:space="preserve">
    <value>Фон Повышающегося Дня</value>
    <comment>DailyChange</comment>
  </data>
  <data name="BackGroundSellColor" xml:space="preserve">
    <value>Фон Понижающегося Дня</value>
    <comment>DailyChange</comment>
  </data>
  <data name="RetrospectiveAnalysis" xml:space="preserve">
    <value>Ретроспективный Анализ</value>
    <comment>VsaBetterVolume</comment>
  </data>
  <data name="Spacing" xml:space="preserve">
    <value>Интервал</value>
    <comment>SpreadVolume</comment>
  </data>
  <data name="BreakDnColor" xml:space="preserve">
    <value>Пробой Вниз</value>
    <comment>HRanges</comment>
  </data>
  <data name="BreakUpColor" xml:space="preserve">
    <value>Пробой Вверх</value>
    <comment>HRanges</comment>
  </data>
  <data name="FlatColor" xml:space="preserve">
    <value>Флэт</value>
    <comment>HRanges</comment>
  </data>
  <data name="MaxVolColor" xml:space="preserve">
    <value>Максимальный Объем</value>
    <comment>HRanges</comment>
  </data>
  <data name="TimeFrame" xml:space="preserve">
    <value>Период Свечи</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="Offset" xml:space="preserve">
    <value>Отступ</value>
  </data>
  <data name="ClosePrevDay" xml:space="preserve">
    <value>Закрытие Предыдущего Дня</value>
    <comment>DailyChange</comment>
  </data>
  <data name="OpenCurDay" xml:space="preserve">
    <value>Открытие Текущего Дня</value>
    <comment>DailyChange</comment>
  </data>
  <data name="PriceChange" xml:space="preserve">
    <value>Изменение Цены</value>
  </data>
  <data name="CustomSessionStart" xml:space="preserve">
    <value>Произвольное Время Начала Сессии</value>
  </data>
  <data name="FrameMultiplier" xml:space="preserve">
    <value>Кратность Блока</value>
    <comment>MurrayMath</comment>
  </data>
  <data name="FrameSize" xml:space="preserve">
    <value>Размер Блока</value>
    <comment>MurrayMath</comment>
  </data>
  <data name="IgnoreWicks" xml:space="preserve">
    <value>Не Учитывать Тени Свечей</value>
  </data>
  <data name="OffsetY" xml:space="preserve">
    <value>Смещение По Оси Y</value>
    <comment>OpenLine</comment>
  </data>
  <data name="OpenLine" xml:space="preserve">
    <value>Уровень Открытия</value>
    <comment>OpenLine</comment>
  </data>
  <data name="SessionTime" xml:space="preserve">
    <value>Время Сессии</value>
  </data>
  <data name="StartTimeGmt" xml:space="preserve">
    <value>Время Начала Сессии(GMT)</value>
  </data>
  <data name="TextSettings" xml:space="preserve">
    <value>Настройки Текста</value>
  </data>
  <data name="AutoCalculation" xml:space="preserve">
    <value>Автоматический Расчет</value>
  </data>
  <data name="BaseLine" xml:space="preserve">
    <value>Базовый Уровень</value>
    <comment>MarginZones</comment>
  </data>
  <data name="CustomPrice" xml:space="preserve">
    <value>Произвольная Цена</value>
  </data>
  <data name="DirectionOfZone" xml:space="preserve">
    <value>Направление Зоны</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Down" xml:space="preserve">
    <value>Вниз</value>
  </data>
  <data name="EfficiencyRatioPeriod" xml:space="preserve">
    <value>Период Эффективного Соотношения</value>
  </data>
  <data name="InstrumentParameters" xml:space="preserve">
    <value>Параметры Инструмента</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Margin" xml:space="preserve">
    <value>Маржинальный Уровень</value>
    <comment>MarginZones</comment>
  </data>
  <data name="StartPrice" xml:space="preserve">
    <value>Начальная Цена</value>
  </data>
  <data name="TickCost" xml:space="preserve">
    <value>Цена Тика</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Up" xml:space="preserve">
    <value>Вверх</value>
  </data>
  <data name="Zone100" xml:space="preserve">
    <value>100% Зона</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone150" xml:space="preserve">
    <value>150% Зона</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone200" xml:space="preserve">
    <value>200% Зона</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone25" xml:space="preserve">
    <value>25% Зона</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone50" xml:space="preserve">
    <value>50% Зона</value>
    <comment>MarginZones</comment>
  </data>
  <data name="Zone75" xml:space="preserve">
    <value>75% Зона</value>
    <comment>MarginZones</comment>
  </data>
  <data name="ZoneWidth" xml:space="preserve">
    <value>Длина Зоны (Дни)</value>
    <comment>MarginZones</comment>
  </data>
  <data name="BorderColor" xml:space="preserve">
    <value>Цвет Границы</value>
  </data>
  <data name="BorderWidth" xml:space="preserve">
    <value>Ширина Границы</value>
  </data>
  <data name="FillColor" xml:space="preserve">
    <value>Цвет Заливки</value>
  </data>
  <data name="Grid" xml:space="preserve">
    <value>Сетка</value>
  </data>
  <data name="Multiplier1" xml:space="preserve">
    <value>Множитель 1</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="Multiplier2" xml:space="preserve">
    <value>Множитель 2</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="Multiplier3" xml:space="preserve">
    <value>Множитель 3</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="OpenRange" xml:space="preserve">
    <value>Диапазон Открытия</value>
    <comment>InitialBalance</comment>
  </data>
  <data name="Settings" xml:space="preserve">
    <value>Настройки</value>
  </data>
  <data name="ShowAverage" xml:space="preserve">
    <value>Отображать Скользящую Среднюю</value>
  </data>
  <data name="ShowGrid" xml:space="preserve">
    <value>Отображать Сетку</value>
  </data>
  <data name="AreaTransparency" xml:space="preserve">
    <value>Прозрачность Фона</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="BearlishColor" xml:space="preserve">
    <value>Направление Вниз</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="BullishColor" xml:space="preserve">
    <value>Направление Вверх</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="ExternalPeriod" xml:space="preserve">
    <value>Внешний Период</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="GridStyle" xml:space="preserve">
    <value>Стиль Сетки</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="ShowAsCandle" xml:space="preserve">
    <value>Отображать В Виде Свечей</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="DashStyle" xml:space="preserve">
    <value>Стиль</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="AskColor" xml:space="preserve">
    <value>Цвет Асков</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="BidColor" xml:space="preserve">
    <value>Цвет Бидов</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="HideRowsDescription" xml:space="preserve">
    <value>Скрыть Заголовки</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowAsk" xml:space="preserve">
    <value>Отображать Аски</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowBid" xml:space="preserve">
    <value>Отображать Биды</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowDelta" xml:space="preserve">
    <value>Отображать Дельту</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowDeltaPerVolume" xml:space="preserve">
    <value>Отображать Дельту/Объем</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowDuration" xml:space="preserve">
    <value>Длительность Свечки, Сек</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowMaximumDelta" xml:space="preserve">
    <value>Отображать Максимальную Дельту</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowMinimumDelta" xml:space="preserve">
    <value>Отображать Минимальную Дельту</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowSessionDelta" xml:space="preserve">
    <value>Отображать Сессионную Дельту</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowSessionDeltaPerVolume" xml:space="preserve">
    <value>Отображать Сессионную Дельту/Объем</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowSessionVolume" xml:space="preserve">
    <value>Отображать Сессионный Объем</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowTime" xml:space="preserve">
    <value>Отображать Время</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="ShowVolumePerSecond" xml:space="preserve">
    <value>Отображать Объем/Секунды</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="Strings" xml:space="preserve">
    <value>Строчки</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="VolumeColor" xml:space="preserve">
    <value>Объем</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="DoNotShowAboveChart" xml:space="preserve">
    <value>Не Отображать Над Графиком</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="SpeedInterval" xml:space="preserve">
    <value>Интервал Индикации Скорости</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="AlertFilter" xml:space="preserve">
    <value>Фильтр Для Алерта</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="CombineSmallTrades" xml:space="preserve">
    <value>Объединять Маленькие Сделки</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="DigitsAfterComma" xml:space="preserve">
    <value>Количество Знаков После Запятой В Значениях Объема</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="LinkingToBar" xml:space="preserve">
    <value>Привязка К Бару</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="Location" xml:space="preserve">
    <value>Расположение</value>
  </data>
  <data name="ShowSmallTrades" xml:space="preserve">
    <value>Отображать Маленькие Сделки</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="Circles" xml:space="preserve">
    <value>Круги</value>
  </data>
  <data name="Rectangles" xml:space="preserve">
    <value>Прямоугольники</value>
  </data>
  <data name="HighColor" xml:space="preserve">
    <value>Цвет Максимума</value>
    <comment>Ratio</comment>
  </data>
  <data name="LowColor" xml:space="preserve">
    <value>Цвет Минимума</value>
    <comment>Ratio</comment>
  </data>
  <data name="LowRatio" xml:space="preserve">
    <value>Минимальное Соотношение</value>
    <comment>Ratio</comment>
  </data>
  <data name="NeutralColor" xml:space="preserve">
    <value>Нейтральный Цвет</value>
    <comment>Ratio</comment>
  </data>
  <data name="NeutralRatio" xml:space="preserve">
    <value>Нейтральное Соотношение</value>
    <comment>Ratio</comment>
  </data>
  <data name="Values" xml:space="preserve">
    <value>Значения</value>
  </data>
  <data name="H4" xml:space="preserve">
    <value>4 Часа</value>
    <comment>Pivots</comment>
  </data>
  <data name="H2" xml:space="preserve">
    <value>2 Часа</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="H6" xml:space="preserve">
    <value>6 Часов</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="Misc" xml:space="preserve">
    <value>Разное</value>
  </data>
  <data name="AtHigh" xml:space="preserve">
    <value>Максимум Свечи</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="AtHighOrLow" xml:space="preserve">
    <value>На Максимуме Или Минимуме</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="AtLow" xml:space="preserve">
    <value>Минимум Свечи</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="BarsRange" xml:space="preserve">
    <value>Объединение Баров</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="CandleDirection" xml:space="preserve">
    <value>Направление Баров</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="ClusterSelectionTransparency" xml:space="preserve">
    <value>Прозрачность Выделений В Кластерах</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="DeltaFilter" xml:space="preserve">
    <value>Дельта Фильтр</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="DeltaFilters" xml:space="preserve">
    <value>Дельта Фильтры</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="DeltaImbalance" xml:space="preserve">
    <value>Перевес Бид-Аск,%</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="FixedSizes" xml:space="preserve">
    <value>Фиксированные Размеры</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MaximumAverageTrade" xml:space="preserve">
    <value>Макс. Средняя Сделка В Уровне</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MaximumSize" xml:space="preserve">
    <value>Максимальный Размер</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MaxValue" xml:space="preserve">
    <value>Максимальное Значение</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinimumAverageTrade" xml:space="preserve">
    <value>Мин. Средняя Сделка В Уровне</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinimumSize" xml:space="preserve">
    <value>Минимальный Размер</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinValue" xml:space="preserve">
    <value>Минимальное Значение</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="OnlyOneSelectionPerBar" xml:space="preserve">
    <value>Только Одно Выделение В Баре</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PipsFromHigh" xml:space="preserve">
    <value>Тиков От Максимума Баров</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PipsFromLow" xml:space="preserve">
    <value>Тиков От Минимума Баров</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PriceLocation" xml:space="preserve">
    <value>Расположение Цены</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="PriceRange" xml:space="preserve">
    <value>Объединение Ценовых Уровней</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="TimeFiltration" xml:space="preserve">
    <value>Фильтр По Времени</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="TimeFrom" xml:space="preserve">
    <value>Начальное Время</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="TimeTo" xml:space="preserve">
    <value>Конечное Время</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="UseTimeFilter" xml:space="preserve">
    <value>Использовать Фильтр По Времени</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="VisualObjectsTransparency" xml:space="preserve">
    <value>Прозрачность Визуальных Объектов</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="GridColor" xml:space="preserve">
    <value>Цвет Сетки</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="HeaderBackground" xml:space="preserve">
    <value>Цвет Заголовков</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="Border" xml:space="preserve">
    <value>Границы</value>
    <comment>OrderFlow</comment>
  </data>
  <data name="UseAlerts" xml:space="preserve">
    <value>Использовать Алерты</value>
  </data>
  <data name="VisibleProportion" xml:space="preserve">
    <value>Отображать По Градиенту</value>
    <comment>ClusterStatistics</comment>
  </data>
  <data name="Auto" xml:space="preserve">
    <value>Авто</value>
    <comment>BarTimer</comment>
  </data>
  <data name="CurrentTime" xml:space="preserve">
    <value>Текущее Время</value>
    <comment>BarTimer</comment>
  </data>
  <data name="HHMMSS" xml:space="preserve">
    <value>HHMMSS</value>
    <comment>BarTimer</comment>
  </data>
  <data name="HHMMSSPM" xml:space="preserve">
    <value>ЧЧММСС PM</value>
    <comment>BarTimer</comment>
  </data>
  <data name="MMSS" xml:space="preserve">
    <value>ММСС</value>
    <comment>BarTimer</comment>
  </data>
  <data name="OffsetX" xml:space="preserve">
    <value>Смещение По Оси X</value>
  </data>
  <data name="TimeSettings" xml:space="preserve">
    <value>Настройки Времени</value>
    <comment>BarTimer</comment>
  </data>
  <data name="TimeToEndOfCandle" xml:space="preserve">
    <value>Время До Окончания Свечи</value>
    <comment>BarTimer</comment>
  </data>
  <data name="UnsupportedTimeFrame" xml:space="preserve">
    <value>Таймфрейм Не Поддерживается</value>
    <comment>BarTimer</comment>
  </data>
  <data name="WaitingForNewTick" xml:space="preserve">
    <value>Ожидаем Новый Тик</value>
    <comment>BarTimer</comment>
  </data>
  <data name="AskBidImbalanceColor" xml:space="preserve">
    <value>Цвет Перевеса Ask/Bid</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="AskFilter" xml:space="preserve">
    <value>Фильтр По Аск</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="Between" xml:space="preserve">
    <value>Внутри Спреда</value>
    <comment>TapePattern</comment>
  </data>
  <data name="BetweenColor" xml:space="preserve">
    <value>Промежуточный Цвет</value>
    <comment>TapePattern</comment>
  </data>
  <data name="BidAndAsk" xml:space="preserve">
    <value>Покупки И Продажи</value>
    <comment>TapePattern</comment>
  </data>
  <data name="BidAskImbalanceColor" xml:space="preserve">
    <value>Цвет Перевеса Bid/Ask</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="BidFilter" xml:space="preserve">
    <value>Фильтр По Бид</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="BidOrAsk" xml:space="preserve">
    <value>Покупка Или Продажа</value>
    <comment>TapePattern</comment>
  </data>
  <data name="CalculationSettings" xml:space="preserve">
    <value>Настройки Вычисления</value>
    <comment>ZigZag</comment>
  </data>
  <data name="CumulativeTrades" xml:space="preserve">
    <value>Агрегированные Сделки</value>
    <comment>TapePattern</comment>
  </data>
  <data name="Data" xml:space="preserve">
    <value>Данные</value>
    <comment>ZigZag</comment>
  </data>
  <data name="Days" xml:space="preserve">
    <value>Дни</value>
    <comment>ZigZag</comment>
  </data>
  <data name="Exact" xml:space="preserve">
    <value>Точное</value>
    <comment>ZigZag</comment>
  </data>
  <data name="HighLineColor" xml:space="preserve">
    <value>Цвет Уровня Максимума</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="ImbalanceRange" xml:space="preserve">
    <value>Диапазон Дисбаланса</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="ImbalanceRatio" xml:space="preserve">
    <value>Соотношение Дисбаланса</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="ImbalanceVolume" xml:space="preserve">
    <value>Объём Дисбаланса</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="LineWidth" xml:space="preserve">
    <value>Толщина Линии</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="LowLineColor" xml:space="preserve">
    <value>Цвет Уровня Минимума</value>
    <comment>UnfinishedAuction</comment>
  </data>
  <data name="MaxCumulativeVolume" xml:space="preserve">
    <value>Максимальный Общий Объем</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MaximumCount" xml:space="preserve">
    <value>Максимальное Лол-во Трейдов</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MaxPrintVolume" xml:space="preserve">
    <value>Максимальный Объем Тика</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MinCumulativeVolume" xml:space="preserve">
    <value>Минимальный Общий Объем</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MinimumCount" xml:space="preserve">
    <value>Минимальное Кол-во Трейдов</value>
    <comment>TapePattern</comment>
  </data>
  <data name="MinPrintVolume" xml:space="preserve">
    <value>Минимальный Объем Тика</value>
    <comment>TapePattern</comment>
  </data>
  <data name="None" xml:space="preserve">
    <value>Нет</value>
    <comment>ZigZag</comment>
  </data>
  <data name="PrintLineForXBars" xml:space="preserve">
    <value>Рисовать Линию Х Баров</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="RangeFilter" xml:space="preserve">
    <value>Тиков В Диапазоне</value>
    <comment>TapePattern</comment>
  </data>
  <data name="RequiredChange" xml:space="preserve">
    <value>Требуемое Изменение</value>
    <comment>ZigZag</comment>
  </data>
  <data name="SearchPrintsInsideTimeFilter" xml:space="preserve">
    <value>Искать Принты Внутри Временного Фильтра</value>
    <comment>TapePattern</comment>
  </data>
  <data name="ShowBars" xml:space="preserve">
    <value>Показывать Бары</value>
    <comment>ZigZag</comment>
  </data>
  <data name="ShowTicks" xml:space="preserve">
    <value>Показывать Тики</value>
    <comment>ZigZag</comment>
  </data>
  <data name="TimeFilter" xml:space="preserve">
    <value>Временной Фильтр, Миллисек</value>
    <comment>TapePattern</comment>
  </data>
  <data name="AskRows" xml:space="preserve">
    <value>Аски</value>
    <comment>DOM</comment>
  </data>
  <data name="AsksBackGround" xml:space="preserve">
    <value>Фон Асков</value>
    <comment>DOM</comment>
  </data>
  <data name="BestAskBackGround" xml:space="preserve">
    <value>Фон BestAsk</value>
    <comment>DOM</comment>
  </data>
  <data name="BestBidBackGround" xml:space="preserve">
    <value>Фон BestBid</value>
    <comment>DOM</comment>
  </data>
  <data name="BidRows" xml:space="preserve">
    <value>Биды</value>
    <comment>DOM</comment>
  </data>
  <data name="BidsBackGround" xml:space="preserve">
    <value>Фон Бидов</value>
    <comment>DOM</comment>
  </data>
  <data name="CustomPriceLevelsHeight" xml:space="preserve">
    <value>Высота Ценовых Уровней (Вручную)</value>
    <comment>DOM</comment>
  </data>
  <data name="CustomScale" xml:space="preserve">
    <value>Отступ От Границ Графика</value>
    <comment>DOM</comment>
  </data>
  <data name="HistogramSize" xml:space="preserve">
    <value>Размер Гистограммы</value>
    <comment>DOM</comment>
  </data>
  <data name="ProportionVolume" xml:space="preserve">
    <value>Объем Пропорции</value>
    <comment>DOM</comment>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Справа Налево</value>
    <comment>DOM</comment>
  </data>
  <data name="Scale" xml:space="preserve">
    <value>Масштаб</value>
    <comment>DOM</comment>
  </data>
  <data name="ShowCumulativeValues" xml:space="preserve">
    <value>Отображать Суммарные Значения</value>
    <comment>DOM</comment>
  </data>
  <data name="UseAutoSize" xml:space="preserve">
    <value>Автоматическая Пропорция</value>
    <comment>DOM</comment>
  </data>
  <data name="HighLowColor" xml:space="preserve">
    <value>Цвет High/Low</value>
    <comment>MarketPower</comment>
  </data>
  <data name="ShowCumulative" xml:space="preserve">
    <value>Кумулятивное Отображение</value>
    <comment>MarketPower</comment>
  </data>
  <data name="ShowHighLow" xml:space="preserve">
    <value>Отображать High/Low</value>
    <comment>MarketPower</comment>
  </data>
  <data name="ShowSMA" xml:space="preserve">
    <value>Отображать Скользящую Среднюю</value>
    <comment>MarketPower</comment>
  </data>
  <data name="SMAColor" xml:space="preserve">
    <value>Цвет Скользящей Средней</value>
    <comment>MarketPower</comment>
  </data>
  <data name="SMAPeriod" xml:space="preserve">
    <value>Период Скользящей Средней</value>
    <comment>MarketPower</comment>
  </data>
  <data name="Enabled" xml:space="preserve">
    <value>Включен</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter1" xml:space="preserve">
    <value>Фильтр №1</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter2" xml:space="preserve">
    <value>Фильтр №2</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter3" xml:space="preserve">
    <value>Фильтр №3</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter4" xml:space="preserve">
    <value>Фильтр №4</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="Filter5" xml:space="preserve">
    <value>Фильтр №5</value>
    <comment>MuliMarketPower</comment>
  </data>
  <data name="ShowAboveChart" xml:space="preserve">
    <value>Отображать Над Графиком</value>
    <comment>ExternalCharts</comment>
  </data>
  <data name="IgnoreZeroValues" xml:space="preserve">
    <value>Игнорировать Нулевые Значения</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="Author" xml:space="preserve">
    <value>Автор</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="ClustersMode" xml:space="preserve">
    <value>Кластерный Режим Отображения</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="Copyright" xml:space="preserve">
    <value>Авторские Права</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="CumulativeMode" xml:space="preserve">
    <value>Кумулятивный Режим</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="CustomDiapason" xml:space="preserve">
    <value>Ограничить Диапазон</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="GridStep" xml:space="preserve">
    <value>Шаг Сетки</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="SeparatedTrades" xml:space="preserve">
    <value>Отдельные Сделки</value>
    <comment>OIAnalyzer</comment>
  </data>
  <data name="UseAbsValue" xml:space="preserve">
    <value>Использовать Значения По Модулю</value>
    <comment>McClellanOscillator</comment>
  </data>
  <data name="MaxPeriod" xml:space="preserve">
    <value>Максимальный Период</value>
    <comment>DMI</comment>
  </data>
  <data name="MinPeriod" xml:space="preserve">
    <value>Минимальный Период</value>
    <comment>DMI</comment>
  </data>
  <data name="EmaPeriod1" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя 1</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod2" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя 2</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod3" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя 3</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod4" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя 4</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod5" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя 5</value>
    <comment>GMMA</comment>
  </data>
  <data name="EmaPeriod6" xml:space="preserve">
    <value>Экспоненциальная Скользящая Средняя 6</value>
    <comment>GMMA</comment>
  </data>
  <data name="SMAPeriod1" xml:space="preserve">
    <value>Период Скользящей Средней 1</value>
    <comment>ACDC</comment>
  </data>
  <data name="SMAPeriod2" xml:space="preserve">
    <value>Период Скользящей Средней 2</value>
    <comment>ACDC</comment>
  </data>
  <data name="SMAPeriod3" xml:space="preserve">
    <value>Период Скользящей Средней 3</value>
    <comment>ACDC</comment>
  </data>
  <data name="SMAPeriod4" xml:space="preserve">
    <value>Период Скользящей Средней 4</value>
    <comment>ACDC</comment>
  </data>
  <data name="AdxPeriod" xml:space="preserve">
    <value>Период ADX</value>
    <comment>ADXR</comment>
  </data>
  <data name="EMAPeriod" xml:space="preserve">
    <value>Период Экспоненциальной Скользящей Средней</value>
    <comment>EMV</comment>
  </data>
  <data name="MovingType" xml:space="preserve">
    <value>Тип Скользящей Средней</value>
    <comment>EMV</comment>
  </data>
  <data name="UsePreviousClose" xml:space="preserve">
    <value>Учитывать Закрытие Прошлой Свечи</value>
    <comment>ADF</comment>
  </data>
  <data name="AskBid" xml:space="preserve">
    <value>АскБид</value>
    <comment>BidAskVR</comment>
  </data>
  <data name="BidAsk" xml:space="preserve">
    <value>БидАск</value>
    <comment>BidAskVR</comment>
  </data>
  <data name="BottomBand" xml:space="preserve">
    <value>Нижняя Граница Канала</value>
    <comment>BollingerBandsPercent</comment>
  </data>
  <data name="MiddleBand" xml:space="preserve">
    <value>Середина Канала</value>
    <comment>BollingerBandsPercent</comment>
  </data>
  <data name="KeltnerChannel" xml:space="preserve">
    <value>Канал Кельтнера</value>
    <comment>BollingerSqueeze</comment>
  </data>
  <data name="HighRatio" xml:space="preserve">
    <value>Максимальное Соотношение</value>
    <comment>BollingerSqueeze</comment>
  </data>
  <data name="UseMA" xml:space="preserve">
    <value>Использовать Скользящую Среднюю</value>
    <comment>ForceIndex</comment>
  </data>
  <data name="MaxOpenInterest" xml:space="preserve">
    <value>Максимальный Открытый Интерес</value>
    <comment>HerrickPayoff</comment>
  </data>
  <data name="MinOpenInterest" xml:space="preserve">
    <value>Минимальный Открытый Интерес</value>
    <comment>HerrickPayoff</comment>
  </data>
  <data name="Step" xml:space="preserve">
    <value>Шаг</value>
    <comment>HerrickPayoff</comment>
  </data>
  <data name="InsideBar" xml:space="preserve">
    <value>Внутри Бара</value>
    <comment>InsideEqualsBar</comment>
  </data>
  <data name="InsideEqualBar" xml:space="preserve">
    <value>Внутри Бара Или Равный Бар</value>
    <comment>InsideEqualsBar</comment>
  </data>
  <data name="PeriodD" xml:space="preserve">
    <value>Период %D</value>
    <comment>KdFast</comment>
  </data>
  <data name="PeriodK" xml:space="preserve">
    <value>Период %K</value>
    <comment>KdFast</comment>
  </data>
  <data name="Estimator" xml:space="preserve">
    <value>Оценка</value>
    <comment>Kurtosis</comment>
  </data>
  <data name="Indicator" xml:space="preserve">
    <value>Индикатор</value>
  </data>
  <data name="TopBand" xml:space="preserve">
    <value>Верхняя Граница Канала</value>
    <comment>MacdBbStandart</comment>
  </data>
  <data name="FirstBar" xml:space="preserve">
    <value>Первый Бар</value>
    <comment>VolumeIndex</comment>
  </data>
  <data name="LastBar" xml:space="preserve">
    <value>Последний Бар</value>
    <comment>VolumeIndex</comment>
  </data>
  <data name="SessionBegin" xml:space="preserve">
    <value>Начало Сессии</value>
    <comment>VolumeIndex</comment>
  </data>
  <data name="SMA1" xml:space="preserve">
    <value>Простая Скользящая Средняя 1</value>
    <comment>StdDevBands</comment>
  </data>
  <data name="SMA2" xml:space="preserve">
    <value>Простая Скользящая Средняя 2</value>
    <comment>StdDevBands</comment>
  </data>
  <data name="Period1" xml:space="preserve">
    <value>Период 1</value>
    <comment>UltimateOscillator</comment>
  </data>
  <data name="Period2" xml:space="preserve">
    <value>Период 2</value>
    <comment>UltimateOscillator</comment>
  </data>
  <data name="Period3" xml:space="preserve">
    <value>Период 3</value>
    <comment>UltimateOscillator</comment>
  </data>
  <data name="Neutral" xml:space="preserve">
    <value>Нейтральный</value>
    <comment>ACBW</comment>
  </data>
  <data name="ZeroValue" xml:space="preserve">
    <value>Нулевое Значение</value>
    <comment>CAV</comment>
  </data>
  <data name="BuySellPower" xml:space="preserve">
    <value>Сила Покупок/Продаж</value>
    <comment>Demand</comment>
  </data>
  <data name="Period4" xml:space="preserve">
    <value>Период 4</value>
    <comment>HurstExponent</comment>
  </data>
  <data name="Period5" xml:space="preserve">
    <value>Период 5</value>
    <comment>HurstExponent</comment>
  </data>
  <data name="IncludeEqualHighLow" xml:space="preserve">
    <value>Учитывать Равные High / Low</value>
    <comment>OutsideBars</comment>
  </data>
  <data name="FixedValue" xml:space="preserve">
    <value>Фиксированное Значение</value>
    <comment>MaEnvelope</comment>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Значение</value>
    <comment>MaEnvelope</comment>
  </data>
  <data name="MaxDynamicPeriod" xml:space="preserve">
    <value>Максимальный Динамический Период</value>
    <comment>VolatilityTrend</comment>
  </data>
  <data name="Overbought1" xml:space="preserve">
    <value>Уровень Перекупленности 1</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Overbought2" xml:space="preserve">
    <value>Уровень Перекупленности 2</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Overbought3" xml:space="preserve">
    <value>Уровень Перекупленности 3</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Oversold1" xml:space="preserve">
    <value>Уровень Перепроданности 1</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Oversold2" xml:space="preserve">
    <value>Уровень Перепроданности 2</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="Oversold3" xml:space="preserve">
    <value>Уровень Перепроданности 3</value>
    <comment>VolumeZone</comment>
  </data>
  <data name="FastLine" xml:space="preserve">
    <value>Быстрая Линия</value>
    <comment>StochasticDiNapoli</comment>
  </data>
  <data name="SlowLine" xml:space="preserve">
    <value>Медленная Линия</value>
    <comment>StochasticDiNapoli</comment>
  </data>
  <data name="InvertOutput" xml:space="preserve">
    <value>Отображать Обратные Значения</value>
    <comment>WilliamsR</comment>
  </data>
  <data name="Range" xml:space="preserve">
    <value>Диапазон</value>
  </data>
  <data name="Drawing" xml:space="preserve">
    <value>Отрисовка</value>
  </data>
  <data name="ImageLocation" xml:space="preserve">
    <value>Путь К Изображению</value>
    <comment>Logo</comment>
  </data>
  <data name="LogoLocation" xml:space="preserve">
    <value>Положение</value>
    <comment>Logo</comment>
  </data>
  <data name="ShowDeltaChange" xml:space="preserve">
    <value>Отображать Изменение Дельты</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="SessionEnd" xml:space="preserve">
    <value>Конец Сессии</value>
  </data>
  <data name="Length" xml:space="preserve">
    <value>Длинна</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Описание</value>
  </data>
  <data name="CustomVWAP" xml:space="preserve">
    <value>Произвольная Точка Старта Индикатора</value>
    <comment>VWAP</comment>
  </data>
  <data name="DeleteStartPoint" xml:space="preserve">
    <value>Удалить Начальную Позицию</value>
    <comment>VWAP</comment>
  </data>
  <data name="ResetOnSession" xml:space="preserve">
    <value>Сбрасывать В Начале Новой Сессии</value>
    <comment>VWAP</comment>
  </data>
  <data name="SaveStartPoint" xml:space="preserve">
    <value>Сохранять Начальную Позицию</value>
    <comment>VWAP</comment>
  </data>
  <data name="SetStartPoint" xml:space="preserve">
    <value>Установить Начальную Позицию</value>
    <comment>VWAP</comment>
  </data>
  <data name="AllowCustomStartPoint" xml:space="preserve">
    <value>Задавать Начало Отсчета Горячими Клавишами</value>
  </data>
  <data name="Transparency" xml:space="preserve">
    <value>Прозрачность</value>
  </data>
  <data name="LogoFilePathDescription" xml:space="preserve">
    <value>Файл Изображения (*.bmp, *.gif, *.jpeg, *.jpg, *.png, *.tiff)</value>
    <comment>Logo</comment>
  </data>
  <data name="FastConst" xml:space="preserve">
    <value>Быстрая Сглаживающая Константа</value>
    <comment>AMA</comment>
  </data>
  <data name="SlowConst" xml:space="preserve">
    <value>Медленная Сглаживающая Константа</value>
    <comment>AMA</comment>
  </data>
  <data name="ShortValues" xml:space="preserve">
    <value>Показывать Сокращенные Значения</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="LineTillTouch" xml:space="preserve">
    <value>Продожить Линию До Касания</value>
    <comment>StackedImbalance</comment>
  </data>
  <data name="Close" xml:space="preserve">
    <value>Закрытие</value>
  </data>
  <data name="High" xml:space="preserve">
    <value>Максимум</value>
  </data>
  <data name="Low" xml:space="preserve">
    <value>Минимум</value>
  </data>
  <data name="Open" xml:space="preserve">
    <value>Открытие</value>
  </data>
  <data name="ShowArea" xml:space="preserve">
    <value>Отображать Область</value>
  </data>
  <data name="CustomSession" xml:space="preserve">
    <value>Произвольное Время Сессии</value>
  </data>
  <data name="RepeatAlert" xml:space="preserve">
    <value>Повторять Алерт</value>
  </data>
  <data name="Tolerance" xml:space="preserve">
    <value>Отклонение</value>
    <comment>InsideBars</comment>
  </data>
  <data name="CustomTimeZone" xml:space="preserve">
    <value>Произвольное Смещение Текущего Времени</value>
    <comment>BarTimer</comment>
  </data>
  <data name="MaxVolPercent" xml:space="preserve">
    <value>Максимальный Процент От Объема Свечи</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="MinVolPercent" xml:space="preserve">
    <value>Минимальный Процент От Объема Свечи</value>
    <comment>ClusterSearch</comment>
  </data>
  <data name="ShowTradesCount" xml:space="preserve">
    <value>Отображать Количество Сделок</value>
    <comment>ClusterStatistic</comment>
  </data>
  <data name="FakeSeries" xml:space="preserve">
    <value>Фальшивая Серия</value>
    <comment>MFI</comment>
  </data>
  <data name="FakeSeriesColor" xml:space="preserve">
    <value>Цвет Фальшивой Серии</value>
    <comment>MFI</comment>
  </data>
  <data name="GreenSeries" xml:space="preserve">
    <value>Зеленая Серия</value>
    <comment>MFI</comment>
  </data>
  <data name="GreenSeriesColor" xml:space="preserve">
    <value>Цвет Зеленой Серии</value>
    <comment>MFI</comment>
  </data>
  <data name="SitSeries" xml:space="preserve">
    <value>Присядающая Серия</value>
    <comment>MFI</comment>
  </data>
  <data name="SitSeriesColor" xml:space="preserve">
    <value>Цвет Приседающей Серии</value>
    <comment>MFI</comment>
  </data>
  <data name="WeakSeries" xml:space="preserve">
    <value>Увядающая Серия</value>
    <comment>MFI</comment>
  </data>
  <data name="WeakSeriesColor" xml:space="preserve">
    <value>Цвет Увядающей Серии</value>
    <comment>MFI</comment>
  </data>
  <data name="ReverseAlert" xml:space="preserve">
    <value>Обратный Алерт</value>
    <comment>Volume</comment>
  </data>
  <data name="VolumeAlert" xml:space="preserve">
    <value>Алерт По Объему</value>
    <comment>Volume</comment>
  </data>
  <data name="HideAll" xml:space="preserve">
    <value>Скрывать Все</value>
    <comment>HRanges</comment>
  </data>
  <data name="Minutes" xml:space="preserve">
    <value>Минуты</value>
  </data>
  <data name="PeriodType" xml:space="preserve">
    <value>Тип Периода</value>
  </data>
  <data name="ShowHeight" xml:space="preserve">
    <value>Отображать Высоту</value>
  </data>
  <data name="ShowDivergence" xml:space="preserve">
    <value>Отображать Расхождение</value>
  </data>
  <data name="BarsCountFilter" xml:space="preserve">
    <value>Фильтр По Количеству Баров</value>
  </data>
  <data name="Color20" xml:space="preserve">
    <value>20% Цвет</value>
    <comment>DomStrength</comment>
  </data>
  <data name="Color50" xml:space="preserve">
    <value>50% Цвет</value>
    <comment>DomStrength</comment>
  </data>
  <data name="Color80" xml:space="preserve">
    <value>80% Цвет</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ColorMinus20" xml:space="preserve">
    <value>-20% Цвет</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ColorMinus50" xml:space="preserve">
    <value>-50% Цвет</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ColorMinus80" xml:space="preserve">
    <value>-80% Цвет</value>
    <comment>DomStrength</comment>
  </data>
  <data name="ShowCurrentValue" xml:space="preserve">
    <value>Отображать Текущее Значение</value>
  </data>
  <data name="Middle" xml:space="preserve">
    <value>Середина</value>
  </data>
  <data name="PocChangeAlert" xml:space="preserve">
    <value>Алерт При Изменении Уровня POC</value>
  </data>
  <data name="PocTouchAlert" xml:space="preserve">
    <value>Алерт При Касании Уровня POC</value>
  </data>
  <data name="VahTouchAlert" xml:space="preserve">
    <value>Алерт При Касании Уровня VAH</value>
  </data>
  <data name="ValTouchAlert" xml:space="preserve">
    <value>Алерт При Касании Уровня VAL</value>
  </data>
  <data name="PriceSelectionColor" xml:space="preserve">
    <value>Цвет Выделения Цен</value>
  </data>
  <data name="ShowPriceSelection" xml:space="preserve">
    <value>Отображать Выделение Цен</value>
  </data>
  <data name="SingalAlert" xml:space="preserve">
    <value>Сигнальный Алерт</value>
  </data>
  <data name="DownAlert" xml:space="preserve">
    <value>Нижний Алерт</value>
  </data>
  <data name="UpAlert" xml:space="preserve">
    <value>Верхний Алерт</value>
  </data>
  <data name="CenterAlign" xml:space="preserve">
    <value>Отображать По Центру</value>
  </data>
  <data name="ShowBotBlock" xml:space="preserve">
    <value>Отображать Нижние Блоки</value>
  </data>
  <data name="ShowTopBlock" xml:space="preserve">
    <value>Отображать Верхние Блоки</value>
  </data>
  <data name="FilterColor" xml:space="preserve">
    <value>Цвет Фильтра</value>
  </data>
  <data name="FillCandles" xml:space="preserve">
    <value>Раскрашивать Свечи</value>
    <comment>ExternalChart</comment>
  </data>
  <data name="AlertBeforeCandle" xml:space="preserve">
    <value>Алерт Перед Новым Баром</value>
  </data>
  <data name="Seconds" xml:space="preserve">
    <value>Секунды</value>
  </data>
  <data name="ShowFirstPartialPeriod" xml:space="preserve">
    <value>Отображать Первый Неполный Период</value>
    <comment>VWAP</comment>
  </data>
  <data name="AlertNewCandle" xml:space="preserve">
    <value>Алерт На Новой Свече</value>
  </data>
  <data name="BackgroundBearlish" xml:space="preserve">
    <value>Фон Направления Вниз</value>
  </data>
  <data name="BackgroundBullish" xml:space="preserve">
    <value>Фон Направления Вверх</value>
  </data>
  <data name="ColorBeforeCandle" xml:space="preserve">
    <value>Изменить Цвет Перед Новой Свечей</value>
  </data>
  <data name="TooSmallRows" xml:space="preserve">
    <value>Ценовые Уровни Слишком Малы Для Отображения</value>
    <comment>ActiveVolume</comment>
  </data>
  <data name="LowerFill" xml:space="preserve">
    <value>Нижняя Заливка</value>
  </data>
  <data name="LowerFill2" xml:space="preserve">
    <value>Нижняя Заливка 2</value>
  </data>
  <data name="LowerStd1" xml:space="preserve">
    <value>Нижнее Отклонение 1</value>
  </data>
  <data name="LowerStd2" xml:space="preserve">
    <value>Нижнее Отклонение 2</value>
  </data>
  <data name="LowerStd3" xml:space="preserve">
    <value>Нижнее Отклонение 3</value>
  </data>
  <data name="MiddleFillDown" xml:space="preserve">
    <value>Средняя Нижняя Заливка</value>
  </data>
  <data name="MiddleFillUp" xml:space="preserve">
    <value>Средняя Верхняя Заливка</value>
  </data>
  <data name="UpperFill" xml:space="preserve">
    <value>Верхняя Заливка</value>
  </data>
  <data name="UpperFill2" xml:space="preserve">
    <value>Верхняя Заливка 2</value>
  </data>
  <data name="UpperStd1" xml:space="preserve">
    <value>Верхнее Отклонение 1</value>
  </data>
  <data name="UpperStd2" xml:space="preserve">
    <value>Верхнее Отклонение 2</value>
  </data>
  <data name="UpperStd3" xml:space="preserve">
    <value>Верхнее Отклонение 3</value>
  </data>
  <data name="NeutralBorderColor" xml:space="preserve">
    <value>Нейтральный Цвет Границы</value>
    <comment>Delta</comment>
  </data>
  <data name="Combined" xml:space="preserve">
    <value>Совмещенный</value>
  </data>
  <data name="Both" xml:space="preserve">
    <value>Оба</value>
  </data>
  <data name="Levels" xml:space="preserve">
    <value>Уровни</value>
  </data>
  <data name="LevelsMode" xml:space="preserve">
    <value>Режим Уровней</value>
  </data>
  <data name="Average" xml:space="preserve">
    <value>Средний</value>
  </data>
  <data name="DisplayBottom" xml:space="preserve">
    <value>Отображать Внизу</value>
  </data>
  <data name="TwapPeriod" xml:space="preserve">
    <value>Период TWAP</value>
  </data>
  <data name="Lower" xml:space="preserve">
    <value>Ниже</value>
  </data>
  <data name="Upper" xml:space="preserve">
    <value>Выше</value>
  </data>
  <data name="Total" xml:space="preserve">
    <value>Объем</value>
  </data>
  <data name="VolumeType" xml:space="preserve">
    <value>Тип Объема</value>
  </data>
  <data name="ColoredDirection" xml:space="preserve">
    <value>Цветные Направления</value>
  </data>
  <data name="DaysLookBack" xml:space="preserve">
    <value>Количество Дней Для Расчета</value>
  </data>
  <data name="DaysLookBackDescription" xml:space="preserve">
    <value>Количество дней, которые используются для расчета индикатора</value>
  </data>
  <data name="LocationFilters" xml:space="preserve">
    <value>Фильтры По Расположению</value>
  </data>
  <data name="DojiCandleBear" xml:space="preserve">
    <value>Медвежья Додж Свеча</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="DojiCandleBull" xml:space="preserve">
    <value>Бычья Додж Свеча</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="DojiEmptyColor" xml:space="preserve">
    <value>Додж Свеча Без Теней</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="EquilibriumBottomCandle" xml:space="preserve">
    <value>Нижняя Тень Додж Свечи</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="EquilibriumTopCandle" xml:space="preserve">
    <value>Верхняя Тень Додж Свечи</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="MoveCandleBear" xml:space="preserve">
    <value>Тело Медвежьей Свечи</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="MoveCandleBull" xml:space="preserve">
    <value>Тело Бычьей Свечи</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="PullbackCandleBear" xml:space="preserve">
    <value>Тень Медвежьей Свечи</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="PullbackCandleBull" xml:space="preserve">
    <value>Тень Бычьей Свечи</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="StrongCandleBear" xml:space="preserve">
    <value>Строго Медвежья Свеча</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="StrongCandleBull" xml:space="preserve">
    <value>Строго Бычья Свеча</value>
    <comment>BionicCandle</comment>
  </data>
  <data name="OnlyAlertsSupported" xml:space="preserve">
    <value>Поддерживаются Только Алерты</value>
    <comment>BarTimer</comment>
  </data>
  <data name="ThirdFormula" xml:space="preserve">
    <value>Формула Третьего Уровня</value>
    <comment>Pivots</comment>
  </data>
  <data name="AlertPerBar" xml:space="preserve">
    <value>Один Алерт В Течение Бара</value>
  </data>
  <data name="Headers" xml:space="preserve">
    <value>Заголовки</value>
  </data>
  <data name="MaximumVolumeDescription" xml:space="preserve">
    <value>Отображает линию максимального значения объема за последние несколько баров(задается в настройке)</value>
  </data>
  <data name="ReverseAlertDescription" xml:space="preserve">
    <value>Появляется на свечах с дивергенцией(свеча положительная, а дельта отрицательная. И наоборот)</value>
  </data>
  <data name="Rows" xml:space="preserve">
    <value>Строки</value>
  </data>
  <data name="VolumeLabel" xml:space="preserve">
    <value>Значения Объемов</value>
  </data>
  <data name="VolumeLabelDescription" xml:space="preserve">
    <value>Отображает значение объемов на каждом баре(значения видны только при растянутых по горизонтали барах)</value>
  </data>
  <data name="BuyOvershootColor" xml:space="preserve">
    <value>Цвет Покупки С Превышением </value>
    <comment>TDSequential</comment>
  </data>
  <data name="BuyOvershoot1Color" xml:space="preserve">
    <value>Цвет Покупки С Превышением 1</value>
    <comment>TDSequential</comment>
  </data>
  <data name="BuyOvershoot2Color" xml:space="preserve">
    <value>Цвет Покупки С Превышением 2</value>
    <comment>TDSequential</comment>
  </data>
  <data name="BuyOvershoot3Color" xml:space="preserve">
    <value>Цвет Покупки С Превышением 3</value>
    <comment>TDSequential</comment>
  </data>
  <data name="HighlightSignalBars" xml:space="preserve">
    <value>Выделять Сигнальные Бары</value>
  </data>
  <data name="ResistanceLevel" xml:space="preserve">
    <value>Уровень Сопротивления</value>
  </data>
  <data name="SellOvershoot1Color" xml:space="preserve">
    <value>Цвет Продажи С Превышением 1</value>
    <comment>TDSequential</comment>
  </data>
  <data name="SellOvershoot2Color" xml:space="preserve">
    <value>Цвет Продажи С Превышением 2</value>
    <comment>TDSequential</comment>
  </data>
  <data name="SellOvershoot3Color" xml:space="preserve">
    <value>Цвет Продажи С Превышением 3</value>
    <comment>TDSequential</comment>
  </data>
  <data name="SellOvershootColor" xml:space="preserve">
    <value>Цвет Продажи С Превышением </value>
    <comment>TDSequential</comment>
  </data>
  <data name="ShowSignalNumbers" xml:space="preserve">
    <value>Показать Номера Сигналов</value>
  </data>
  <data name="SRLevels" xml:space="preserve">
    <value>Уровни Поддержки/Сопротивления</value>
  </data>
  <data name="SupportLevel" xml:space="preserve">
    <value>Уровень Поддержки</value>
  </data>
  <data name="Bearish" xml:space="preserve">
    <value>Медвежье</value>
  </data>
  <data name="WWMA" xml:space="preserve">
    <value>Скользящая Средняя Уэллса Вилдерса</value>
  </data>
  <data name="AskBidVolume" xml:space="preserve">
    <value>Объем Покупок Или Продаж</value>
    <comment>Up/Down Volume Ratio</comment>
  </data>
  <data name="SZMA" xml:space="preserve">
    <value>Простая Скользящая Средняя Пропускающая Нули</value>
  </data>
  <data name="UpDownVolume" xml:space="preserve">
    <value>Объем Бычьей Или Медвежьей Свечи</value>
    <comment>Up/Down Volume Ratio</comment>
  </data>
  <data name="HLAverage" xml:space="preserve">
    <value>HL Среднее Значение</value>
    <comment>Vertical Horizontal Filter</comment>
  </data>
  <data name="HLCAverage" xml:space="preserve">
    <value>HLC Среднее Значение</value>
    <comment>Vertical Horizontal Filter</comment>
  </data>
  <data name="OHLCAverage" xml:space="preserve">
    <value>OHLC Среднее Значение</value>
    <comment>Vertical Horizontal Filter</comment>
  </data>
  <data name="Profile" xml:space="preserve">
    <value>Профиль</value>
  </data>
  <data name="RowWidth" xml:space="preserve">
    <value>Ширина Строки</value>
  </data>
  <data name="ClosePartially" xml:space="preserve">
    <value>Закрыть частично</value>
    <comment>Gaps</comment>
  </data>
  <data name="HideBorder" xml:space="preserve">
    <value>Скрыть границы</value>
  </data>
  <data name="HideGaps" xml:space="preserve">
    <value>Скрыть гэпы</value>
    <comment>Gaps</comment>
  </data>
  <data name="LimitMaxGapBodyLength" xml:space="preserve">
    <value>Ограничение максимальной длины тела гэпа</value>
    <comment>Gaps</comment>
  </data>
  <data name="MaxGapBodyLength" xml:space="preserve">
    <value>Максимальная длина тела гэпа (бары)</value>
    <comment>Gaps</comment>
  </data>
  <data name="MinimalDeviation" xml:space="preserve">
    <value>Минимальное отклонение (%)</value>
    <comment>Gaps</comment>
  </data>
  <data name="BrokenChannelColor" xml:space="preserve">
    <value>Цвет пробитого канала</value>
  </data>
  <data name="Deviation" xml:space="preserve">
    <value>Отклонение</value>
  </data>
  <data name="ExtendLines" xml:space="preserve">
    <value>Продлить линии</value>
  </data>
  <data name="Show Fibonacci" xml:space="preserve">
    <value>Показать уровни Фибоначчи</value>
  </data>
  <data name="ShowBrokenChannel" xml:space="preserve">
    <value>Показать пробитый канал</value>
  </data>
  <data name="ExtendLast" xml:space="preserve">
    <value>Продлить последний</value>
  </data>
  <data name="ExtendPrevious" xml:space="preserve">
    <value>Продлить до следующего</value>
  </data>
  <data name="Zone" xml:space="preserve">
    <value>Зона</value>
  </data>
  <data name="DisplayMode" xml:space="preserve">
    <value>Режим отображения</value>
  </data>
  <data name="General" xml:space="preserve">
    <value>Общее</value>
  </data>
  <data name="LabelLocation" xml:space="preserve">
    <value>Расположение метки</value>
  </data>
  <data name="LineStyle" xml:space="preserve">
    <value>Стиль линии</value>
  </data>
  <data name="OpenClose" xml:space="preserve">
    <value>Открытие / Закрытие</value>
  </data>
  <data name="ResistanceColor" xml:space="preserve">
    <value>Цвет сопротивления</value>
  </data>
  <data name="ShowLines" xml:space="preserve">
    <value>Показать линии</value>
  </data>
  <data name="ShowTimeFrameLabel" xml:space="preserve">
    <value>Показать метку таймфрейма</value>
  </data>
  <data name="SupportColor" xml:space="preserve">
    <value>Цвет поддержки</value>
  </data>
  <data name="TimeFrame1" xml:space="preserve">
    <value>Период свечи 1</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="TimeFrame2" xml:space="preserve">
    <value>Период свечи 2</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="TimeFrame3" xml:space="preserve">
    <value>Период свечи 3</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="TimeFrame4" xml:space="preserve">
    <value>Период свечи 4</value>
    <comment>Volume-based Support &amp; Resistance Zones</comment>
  </data>
  <data name="ColorScheme" xml:space="preserve">
    <value>Цветовая схема</value>
  </data>
  <data name="CoolDownPeriod" xml:space="preserve">
    <value>Период охлаждения (секунды)</value>
    <comment>Order Book Alerts</comment>
  </data>
  <data name="PriceOffset" xml:space="preserve">
    <value>Отклонение цены</value>
  </data>
  <data name="ShowOnChart" xml:space="preserve">
    <value>Показать на графике</value>
  </data>
  <data name="BWMA" xml:space="preserve">
    <value>Скользящая средняя Билла Вильямса</value>
  </data>
  <data name="DEMA" xml:space="preserve">
    <value>Двойная экспоненциальная скользящая средняя</value>
  </data>
  <data name="SWWMA" xml:space="preserve">
    <value>Синусоидальная взвешенная скользящая средняя</value>
  </data>
  <data name="TEMA" xml:space="preserve">
    <value>Тройная экспоненциальная скользящая средняя</value>
  </data>
  <data name="TMA" xml:space="preserve">
    <value>Треугольная скользящая средняя</value>
  </data>
  <data name="ZLEMA" xml:space="preserve">
    <value>Экспоненциальная скользящая средняя с нулевой задержкой</value>
  </data>
  <data name="CurrentTimeFrame" xml:space="preserve">
    <value>Текущий Таймфрейм</value>
  </data>
  <data name="HideOlds" xml:space="preserve">
    <value>Скрыть Старые</value>
  </data>
  <data name="HigherTimeFrame" xml:space="preserve">
    <value>Высший Таймфрейм</value>
  </data>
  <data name="Label" xml:space="preserve">
    <value>Метка</value>
  </data>
  <data name="Midpoint" xml:space="preserve">
    <value>Середина</value>
  </data>
  <data name="MidpointTouch" xml:space="preserve">
    <value>Касание Средней Точки</value>
  </data>
  <data name="HMA" xml:space="preserve">
    <value>Скользящая Средняя Хала (HMA)</value>
  </data>
  <data name="VWAPOnly" xml:space="preserve">
    <value>Только VWAP</value>
    <comment>VWAP</comment>
  </data>
  <data name="Default" xml:space="preserve">
    <value>Стандартно</value>
  </data>
  <data name="FilterEmptyMsg" xml:space="preserve">
    <value>Фильтр пуст</value>
  </data>
</root>




Technical/ACBW.cs





namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Bill Williams AC")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ACDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602333")]
public class ACBW : Indicator
{
	#region Fields

	private readonly SMA _longSma = new();

	private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
	{
		VisualType = VisualMode.Histogram,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true,
		DescriptionKey = "ACVisualizationDescription"
    };

	private readonly SMA _shortSma = new();
	private readonly SMA _signalSma = new();

	private Color _negColor = DefaultColors.Purple;
	private Color _neutralColor = DefaultColors.Gray;
	private Color _posColor = DefaultColors.Green;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueDescription), Order = 610)]
	public CrossColor PosColor
	{
		get => _posColor.Convert();
		set
		{
			_posColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueDescription), Order = 620)]
	public CrossColor NegColor
	{
		get => _negColor.Convert();
		set
		{
			_negColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Neutral), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NeutralValueDescription), Order = 630)]
	public CrossColor NeutralColor
	{
		get => _neutralColor.Convert();
		set
		{
			_neutralColor = value.Convert();
			RecalculateValues();
		}
	}

	[Parameter]
	[Range(1, 10000)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 100)]
	public int LongPeriod
	{
		get => _longSma.Period;
		set
		{
			_longSma.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 110)]
	public int ShortPeriod
	{
		get => _shortSma.Period;
		set
		{
			_shortSma.Period = value;

			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SignalPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SignalPeriodDescription), Order = 120)]
	public int SignalPeriod
	{
		get => _signalSma.Period;
		set
		{
			_signalSma.Period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ACBW()
	{
		Panel = IndicatorDataProvider.NewPanel;

		_shortSma.Period = _signalSma.Period = 50;
		_longSma.Period = 51;

		DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var diff = _shortSma.Calculate(bar, value) - _longSma.Calculate(bar, value);
		var ac = diff - _signalSma.Calculate(bar, diff);
		_renderSeries[bar] = ac;

		if (bar == 0)
		{
			DataSeries.ForEach(x => x.Clear());
			return;
		}

		var prevValue = _renderSeries[bar - 1];

		if (ac > prevValue)
			_renderSeries.Colors[bar] = _posColor;
		else if (ac < prevValue)
			_renderSeries.Colors[bar] = _negColor;
		else
			_renderSeries.Colors[bar] = _posColor;
	}

	#endregion
}






Technical/ACDC.cs



namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("AC DC Histogram")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ACDCDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602293")]
public class ACDC : Indicator
{
	#region Fields

	private readonly ValueDataSeries _ao = new("AO");

	private readonly ValueDataSeries _averPrice = new("Price");

	private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
	{
		VisualType = VisualMode.Histogram,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true
    };

	private readonly SMA _sma1 = new();
	private readonly SMA _sma2 = new();
	private readonly SMA _sma3 = new();
	private readonly SMA _sma4 = new();

	private Color _negColor = Color.Red;
	private Color _posColor = Color.Green;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueDescription), Order = 610)]
	public CrossColor PosColor
	{
		get => _posColor.Convert();
		set
		{
			_posColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueDescription), Order = 620)]
	public CrossColor NegColor
	{
		get => _negColor.Convert();
		set
		{
			_negColor = value.Convert();
			RecalculateValues();
		}
	}

    [Parameter]
	[Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod1), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriod1Description), Order = 100)]
	public int SmaPeriod1
	{
		get => _sma1.Period;
		set
		{
			_sma1.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod2), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriod2Description), Order = 110)]
	public int SmaPeriod2
	{
		get => _sma2.Period;
		set
		{
			_sma2.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod3), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriod3Description), Order = 120)]
	public int SmaPeriod3
	{
		get => _sma3.Period;
		set
		{
			_sma3.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod4), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriod4Description), Order = 130)]
	public int SmaPeriod4
	{
		get => _sma4.Period;
		set
		{
			_sma4.Period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ACDC()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		_sma1.Period = 34;
		_sma2.Period = 5;
		_sma3.Period = 10;
		_sma4.Period = 5;

		DataSeries[0] = _renderSeries;
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    PosColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    NegColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
    }

    protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
			DataSeries.ForEach(x => x.Clear());

		var candle = GetCandle(bar);
		_averPrice[bar] = (candle.High + candle.Low) / 2;
		_sma1.Calculate(bar, _averPrice[bar]);
		_sma2.Calculate(bar, _averPrice[bar]);

		_ao[bar] = _sma2[bar] - _sma1[bar];

		_sma4.Calculate(bar, _ao[bar]);
		_renderSeries[bar] = _sma3.Calculate(bar, _ao[bar] - _sma4[bar]);

		if (bar > 0)
		{
			var lastValue = _renderSeries[bar - 1];

			if (_sma3[bar] - lastValue > 0)
				_renderSeries.Colors[bar] = _posColor;
			else if (_sma3[bar] - lastValue < 0)
				_renderSeries.Colors[bar] = _negColor;
		}
		else
		{
			if (_sma3[bar] > 0)
				_renderSeries.Colors[bar] = _posColor;
			else
				_renderSeries.Colors[bar] = _negColor;
		}
	}

	#endregion
}






Technical/ACR.cs





namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Average Candle Range")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ACRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602323")]
    public class ACR : Indicator
	{
		#region Fields
		
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly ValueDataSeries _rangeSeries = new("Ranges");
		private bool _ignoreWicks;
		private int _lastSession;

		#endregion

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IgnoreWicks), GroupName = nameof(Strings.Settings), Description = nameof(Strings.IgnoreWicksDescription), Order = 100)]
		public bool IgnoreWicks
		{
			get => _ignoreWicks;
			set
			{
				_ignoreWicks = value;
				RecalculateValues();
			}
		}

		#region ctor

		public ACR()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DenyToChangePanel = true;

			_renderSeries.VisualType = VisualMode.Histogram;

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();
				_rangeSeries.Clear();
				_lastSession = 0;
			}

			if (IsNewSession(bar) && bar > 0)
				_lastSession = bar;

			var candle = GetCandle(bar);

			var range = IgnoreWicks
				? Math.Abs(candle.Open - candle.Close)
				: candle.High - candle.Low;

			_rangeSeries[bar] = range;

			_renderSeries[bar] = _rangeSeries.CalcAverage(bar - _lastSession + 1, bar);
		}

		#endregion
	}
}






Technical/AD.cs





namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("AD")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ADDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000606733")]
public class AD : Indicator
{
	#region ctor

	public AD()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = new ValueDataSeries("Ad", "AD")
		{
			VisualType = VisualMode.Histogram,
			UseMinimizedModeIfEnabled = true
		};
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);
		var prev = bar == 0 ? 0m : this[bar - 1];

		var diff = candle.High - candle.Low;

		this[bar] = diff == 0
			? prev
			: (candle.Close - candle.Low - (candle.High - candle.Close)) * candle.Volume / diff + prev;
	}

	#endregion
}






Technical/ADF.cs





namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using OFT.Attributes;
using OFT.Localization;

[DisplayName("Accumulation / Distribution Flow")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ADFDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602569")]
public class ADF : Indicator
{
	#region Fields

	private readonly ValueDataSeries _adf = new("AdfValues");

	private readonly ValueDataSeries _renderSeries = new("RenderSeries", "ADF")
	{
		VisualType = VisualMode.Histogram,
		UseMinimizedModeIfEnabled = true
	};

	private readonly SMA _sma = new()
	{
		Period = 14
	};

	private bool _usePrev = true;

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription), Order = 100)]
	[Range(1, 10000)]
	public int Period
	{
		get => _sma.Period;
		set
		{
			_sma.Period = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UsePreviousClose), GroupName = nameof(Strings.Settings), Description = nameof(Strings.UsePreviousCloseDescription), Order = 110)]
	public bool UsePrev
	{
		get => _usePrev;
		set
		{
			_usePrev = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ADF()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_sma.Calculate(bar, _adf[bar]);
			return;
		}

		var candle = GetCandle(bar);

		if (candle.High - candle.Low == 0)
			_adf[bar] = _adf[bar - 1];
		else
		{
			if (_usePrev)
			{
				var prevCandle = GetCandle(bar - 1);
				_adf[bar] = _adf[bar - 1] + (candle.Close - prevCandle.Close) * candle.Volume / (candle.High - candle.Low);
			}
			else
				_adf[bar] = _adf[bar - 1] + (candle.Close - candle.Open) * candle.Volume / (candle.High - candle.Low);
		}

		_renderSeries[bar] = _sma.Calculate(bar, _adf[bar]);
	}

	#endregion
}






Technical/ADR.cs




namespace ATAS.Indicators.Technical
{
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Linq;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context.GDIPlus;
	using OFT.Rendering.Settings;

	[DisplayName("Average Daily Range")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ADRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602312")]
	public class ADR : Indicator
	{
		#region Nested types

		public enum ControlPoint
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OpenSession))]
			OpenSession,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LowSession))]
			LowSession,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighSession))]
			HighSession
		}

		#endregion

		#region Fields

		private readonly List<decimal> _ranges = new();
		private ControlPoint _atStart;
		private decimal _avg;
		private decimal _currentSessionHigh;
		private decimal _currentSessionLow;
		private DrawingText _currentText;

		private float _fontSize;
		private int _lastBar;
		private Pen _linePen;

		private LineTillTouch _lowerLine;

		private int _period;
		private LineTillTouch _upperLine;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ADR), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PenSettingsDescription))]
		public PenSettings Pen { get; set; } = new();
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), Description = nameof(Strings.CalculationModeDescription))]
		public ControlPoint CalculationMode
		{
			get => _atStart;
			set
			{
				_atStart = value;
				RecalculateValues();
			}
		}

        [Range(1, 100)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontSize), Description = nameof(Strings.FontSizeDescription))]
		public float FontSize
		{
			get => _fontSize;
			set
			{
				_fontSize = value;
				RecalculateValues();
			}
		}

        [Parameter]
		[Range(2, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription))]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ADR()
			: base(true)
		{
			_lastBar = -1;
			DenyToChangePanel = true;
			_period = 3;
			_fontSize = 12;

			DataSeries[0].IsHidden = true;
			Pen.PropertyChanged += PenChanged;
		}
		
        #endregion
		
        private void PenChanged(object sender, PropertyChangedEventArgs e)
        {
	        _linePen = Pen.RenderObject.ToPen();

	        foreach (var line in HorizontalLinesTillTouch)
		        line.Pen = Pen.RenderObject.ToPen();

	        foreach (var key in Labels.Keys)
				Labels[key].Textcolor = Pen.RenderObject.Color;
        }

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

	        Pen.Color = ChartInfo.ColorsStore.NewSessionPen.Color.Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				var candle = GetCandle(bar);
				HorizontalLinesTillTouch.Clear();
				Labels.Clear();
				_ranges.Clear();
				_currentSessionHigh = candle.High;
				_currentSessionLow = candle.Low;
			}

			if (bar != _lastBar)
			{
				ProcessNewBar(bar);
				_lastBar = bar;
			}
			else
				ProcessNewTick(bar);
		}

		#endregion

		#region Private methods
		
		private void ProcessNewBar(int bar)
		{
			var candle = GetCandle(bar);

			if (IsNewSession(bar) && _currentSessionHigh != 0)
			{
				_ranges.Add(_currentSessionHigh - _currentSessionLow);

				if (_ranges.Count > Period)
					_ranges.RemoveAt(0);
				_avg = _ranges.Average();

				var pen = _linePen;

				switch (CalculationMode)
				{
					case ControlPoint.OpenSession:
						_upperLine = new LineTillTouch(bar, candle.Open + _avg / 2.0m, pen, 5);
						_lowerLine = new LineTillTouch(bar, candle.Open - _avg / 2.0m, pen, 5);
						break;

					case ControlPoint.HighSession:
						_upperLine = new LineTillTouch(bar, candle.High, pen, 5);
						_lowerLine = new LineTillTouch(bar, candle.High - _avg, pen, 5);
						break;

					case ControlPoint.LowSession:
						_upperLine = new LineTillTouch(bar, candle.Low + _avg, pen, 5);
						_lowerLine = new LineTillTouch(bar, candle.Low, pen, 5);
						break;
				}

				_currentSessionLow = _currentSessionHigh = 0;
				HorizontalLinesTillTouch.Add(_upperLine);
				HorizontalLinesTillTouch.Add(_lowerLine);

				AddOrEditText(true);
			}
			else
			{
				if (_upperLine != null)
					_upperLine.SecondBar = bar;

				if (_lowerLine != null)
					_lowerLine.SecondBar = bar;
			}

			UpdateCurrentSessionHighLow(candle);
		}

		private void ProcessNewTick(int bar)
		{
			var candle = GetCandle(bar);

			UpdateCurrentSessionHighLow(candle);
		}

		private void UpdateCurrentSessionHighLow(IndicatorCandle candle)
		{
			if (candle.High > _currentSessionHigh)
				_currentSessionHigh = candle.High;

			if (candle.Low < _currentSessionLow || _currentSessionLow == 0)
				_currentSessionLow = candle.Low;

			switch (CalculationMode)
			{
				case ControlPoint.HighSession:
					if (candle.High
						>
						_upperLine.FirstPrice)
					{
						_upperLine.FirstPrice =
							_upperLine.SecondPrice = candle.High;

						_lowerLine.FirstPrice =
							_lowerLine.SecondPrice = candle.High - _avg;

						AddOrEditText(false);
					}

					break;

				case ControlPoint.LowSession:
					if (candle.Low
						<
						_lowerLine.FirstPrice)
					{
						_upperLine.FirstPrice =
							_upperLine.SecondPrice = candle.Low + _avg;

						_lowerLine.FirstPrice =
							_lowerLine.SecondPrice = candle.Low;

						AddOrEditText(false);
					}

					break;
			}
		}

		private void AddOrEditText(bool add)
		{
			var textNumber = $"{_avg / ChartInfo.PriceChartContainer.Step:0.00}";

			if (add)
			{
				var firstBar = _upperLine.FirstBar;

				_currentText = AddText("Aver" + firstBar, $"AveR: {textNumber}", true, firstBar, _upperLine.FirstPrice, _linePen.Color, Color.Transparent,
					Color.Transparent,
					FontSize, DrawingText.TextAlign.Right);
			}
			else
			{
				_currentText.Text = $"AveR: {textNumber}";
				_currentText.TextPrice = _upperLine.FirstPrice;
			}
		}

		#endregion
	}
}






Technical/ADX.cs





namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Settings;

[DisplayName("ADX")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ADXDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602313")]
public class ADX : Indicator
{
	#region Nested types

	private class Rma
	{
		#region Fields

		private decimal _alpha;
		private int _lastBar;
		private int _period;
		private decimal _prevSum;

		private decimal _sum;

		#endregion

		#region Properties

		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				_alpha = 1m / value;
			}
		}

		#endregion

		#region ctor

		public Rma(int period)
		{
			Period = period;
		}

		public Rma()
		{
			Period = 14;
		}

		#endregion

		#region Public methods

		public decimal Calculate(int bar, decimal value)
		{
			if (bar is 0)
			{
				_sum = _prevSum = 0;
				return 0;
			}

			if (_lastBar != bar)
				_prevSum = _sum;

			_sum = _alpha * value + (1 - _alpha) * _prevSum;

			_lastBar = bar;
			return _sum;
		}

		#endregion
	}

	#endregion

	#region Fields

	private Rma _adxRma = new();
	private Rma _minusDmRma = new();
	private Rma _plusDmRma = new();
    private Rma _trRma = new();

    private ValueDataSeries _adxSeries = new("Adx", nameof(Strings.ADX))
	{
		Color = DefaultColors.Green.Convert(),
		DescriptionKey = nameof(Strings.ADX)
	};
	
	private ValueDataSeries _negSeries = new("DiNeg", nameof(Strings.DINeg))
	{
		Color = DefaultColors.Red.Convert(),
		DescriptionKey = nameof(Strings.DIMinusDescription),
		LineDashStyle = LineDashStyle.Dash
	};
	
	private ValueDataSeries _posSeries = new("DiPos", nameof(Strings.DIPos))
	{
		Color = DefaultColors.Blue.Convert(),
		DescriptionKey = nameof(Strings.DIPlusDescription)
	};
	
	#endregion

	#region Properties

	//ADX Smoothing
	[Parameter]
	[Range(1, 10000)]
	[Display(ResourceType = typeof(Strings),
		Name = nameof(Strings.Smoothing),
		GroupName = nameof(Strings.Common),
		Description = nameof(Strings.SmoothPeriodFilterDescription),
		Order = 19)]
	public int SmoothPeriod
	{
		get => _adxRma.Period;
		set
		{
			_adxRma.Period = value;
			RecalculateValues();
		}
	}

	//DI Length
	[Parameter]
	[Range(1, 10000)]
	[Display(ResourceType = typeof(Strings),
		Name = nameof(Strings.Period),
		GroupName = nameof(Strings.Common),
		Description = nameof(Strings.PeriodDescription),
		Order = 20)]
	public int Period
	{
		get => _trRma.Period;
		set
		{
			_trRma.Period = _plusDmRma.Period = _minusDmRma.Period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ADX()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = _adxSeries;
		DataSeries.Add(_posSeries);
		DataSeries.Add(_negSeries);

		Period = SmoothPeriod = 14;
	}

	#endregion

	#region Protected methods

	protected override void OnRecalculate()
	{
		DataSeries.ForEach(x => x.Clear());
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		if (bar < Period)
		{
			DataSeries.ForEach(ds => ((ValueDataSeries)ds).SetPointOfEndLine(bar));

			if (bar is 0)
			{
				_trRma.Calculate(bar, 0);
				_plusDmRma.Calculate(bar, 0);
				_minusDmRma.Calculate(bar, 0);
				_adxRma.Calculate(bar, 0);
				return;
			}
		}

		var prevCandle = GetCandle(bar - 1);

		var up = candle.High - prevCandle.High;
		var down = prevCandle.Low - candle.Low;

		var plusDm = up > down && up > 0 ? up : 0;
		var minusDm = down > up && down > 0 ? down : 0;

		var tr = Math.Max(candle.High - candle.Low, Math.Abs(candle.High - prevCandle.Close));
		tr = Math.Max(tr, Math.Abs(candle.Low - prevCandle.Close));

		var trur = _trRma.Calculate(bar, tr);

		var plus = trur is 0 ? 0 : 100m * _plusDmRma.Calculate(bar, plusDm) / trur;
		var minus = trur is 0 ? 0 : 100m * _minusDmRma.Calculate(bar, minusDm) / trur;

		_posSeries[bar] = plus;
		_negSeries[bar] = minus;

		var sum = plus + minus;

		var adx = 100m * _adxRma.Calculate(bar, Math.Abs(plus - minus) / (sum == 0 ? 1 : sum));

		_adxSeries[bar] = adx;
	}

	#endregion
}





Technical/ADXR.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("ADXR")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ADXRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602314")]
	public class ADXR : Indicator
	{
		#region Fields

		private readonly ADX _adx = new();

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", "ADXR");
		private int _period;

        #endregion

        #region Properties

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AdxPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.AdxPeriodDescription), Order = 110)]
		public int AdxPeriod
		{
			get => _adx.Period;
			set
			{
				_adx.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ADXR()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			_adx.Period = 14;
			_period = 2;
			_renderSeries.ShowZeroValue = true;
			Add(_adx);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar < _period)
				return;

			_renderSeries[bar] = Math.Max(0.01m, (_adx[bar] + _adx[bar - _period]) / 2m);
			RaiseBarValueChanged(bar);
		}

		#endregion
	}
}






Technical/AMA.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Adaptive Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.AMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602310")]
	public class AMA : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _diffSeries = new("Diff");

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private decimal _fastConstant;
		private int _period;
		private decimal _slowConstant;

		#endregion

		#region Properties

		[Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FastConst), GroupName = nameof(Strings.Settings), Description = nameof(Strings.FastConstDescription), Order = 110)]
		public decimal FastConstant
		{
			get => _fastConstant;
			set
			{
				_fastConstant = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SlowConst), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SlowConstDescription), Order = 110)]
		public decimal SlowConstant
		{
			get => _slowConstant;
			set
			{
				_slowConstant = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public AMA()
		{
			_period = 15;
			_fastConstant = 3;
			_slowConstant = 20;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			_diffSeries[bar] = Math.Abs(value - (decimal)SourceDataSeries[bar - 1]);

			if (bar < _period)
				return;

			var dir = value - (decimal)SourceDataSeries[bar - _period];
			var vol = _diffSeries.CalcSum(_period, bar);
			vol = vol == 0 ? 0.000001m : vol;
			var c = Math.Abs(dir / vol) * (2 / (_fastConstant + 1) - 2 / (_slowConstant + 1)) + 2 / (_slowConstant + 1);
			c = c * c;

			if (_renderSeries[bar - 1] != 0)
				_renderSeries[bar] = _renderSeries[bar - 1] + c * (value - _renderSeries[bar - 1]);
			else
				_renderSeries[bar] = (decimal)SourceDataSeries[bar - 1] + c * (value - (decimal)SourceDataSeries[bar - 1]);
		}

		#endregion
	}
}







Technical/AO.cs





namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Awesome Oscillator")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.AODescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602325")]
public class AwesomeOscillator : Indicator
{
	#region Fields

	private Color _negColor = Color.Red;
	private Color _neutralColor = Color.Gray;

	private int _p1 = 34;
	private int _p2 = 5;
	private Color _posColor = Color.Green;

	private ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
	{
		VisualType = VisualMode.Histogram,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true
	};

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueDescription), Order = 610)]
	public CrossColor PosColor
	{
		get => _posColor.Convert();
		set
		{
			_posColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueDescription), Order = 620)]
	public CrossColor NegColor
	{
		get => _negColor.Convert();
		set
		{
			_negColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Neutral), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NeutralValueDescription), Order = 630)]
	public CrossColor NeutralColor
	{
		get => _neutralColor.Convert();
		set
		{
			_neutralColor = value.Convert();
			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 10)]
    public int P1
	{
		get => _p1;
		set
		{
			if (value <= _p2)
				return;

			_p1 = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 10)]
    public int P2
	{
		get => _p2;
		set
		{
			if (value >= _p1)
				return;

			_p2 = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public AwesomeOscillator()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Public methods

	public override string ToString()
	{
		return "Awesome Oscillator";
	}

    #endregion

    #region Protected methods
	
    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    PosColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    NegColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	    NeutralColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
    }

    protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
			DataSeries.ForEach(x => x.Clear());

		if (bar <= _p1)
			return;

		decimal sma1 = 0;
		decimal sma2 = 0;

		for (var ct = 1; ct <= _p1; ct += 1)
		{
			var candleCt = GetCandle(bar - ct + 1);
			var midPrice = (candleCt.High + candleCt.Low) / 2;
			sma1 += midPrice;

			if (ct <= _p2)
				sma2 += midPrice;
		}

		var aw = sma2 / _p2 - sma1 / _p1;
		_renderSeries[bar] = aw;
		var lastAw = bar > 0 ? _renderSeries[bar - 1] : 0;

		if (aw > lastAw)
			_renderSeries.Colors[bar] = _posColor;
		else if (aw < lastAw)
			_renderSeries.Colors[bar] = _negColor;
		else
			_renderSeries.Colors[bar] = _neutralColor;
	}

	#endregion
}






Technical/ATR.cs






namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("ATR")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ATRDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602536")]
public class ATR : Indicator
{
	#region Fields

	private int _period = 10;
	private decimal _multiplier = 1;
	private ValueDataSeries _values = new("values");

	#endregion

	#region Properties

	[Parameter]
	[Display(ResourceType = typeof(Strings),
		Name = nameof(Strings.Period),
		GroupName = nameof(Strings.Common),
        Description = nameof(Strings.PeriodDescription),
        Order = 20)]
	[Range(1, 10000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings),
		Name = nameof(Strings.Multiplier),
		GroupName = nameof(Strings.Common),
        Description = nameof(Strings.ATRMultiplierDescription),
        Order = 20)]
	[Range(0.0000001, 10000000)]
	public decimal Multiplier
	{
		get => _multiplier;
		set
		{
			_multiplier = value;
			RecalculateValues();
		}
	}

    #endregion

    #region ctor

    public ATR()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
    }

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0 && ChartInfo != null)
			((ValueDataSeries)DataSeries[0]).StringFormat = ChartInfo.StringFormat;

		var candle = GetCandle(bar);
		var high0 = candle.High;
		var low0 = candle.Low;

		if (bar == 0)
			_values[bar] = high0 - low0;
		else
		{
			var close1 = GetCandle(bar - 1).Close;
			var trueRange = Math.Max(Math.Abs(low0 - close1), Math.Max(high0 - low0, Math.Abs(high0 - close1)));
			_values[bar] = ((Math.Min(CurrentBar + 1, Period) - 1) * _values[bar - 1] + trueRange) / Math.Min(CurrentBar + 1, Period);
		}

        this[bar] = Multiplier * _values[bar];
    }

	#endregion
}






Technical/ATRN.cs






namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("ATR Normalized")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ATRNDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602633")]
public class ATRN : Indicator
{
	#region Fields

	private readonly ATR _atr = new()
	{
		Period = 10
	};

	private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
	[Range(1, 10000)]
	public int Period
	{
		get => _atr.Period;
		set
		{
			_atr.Period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ATRN()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		Add(_atr);
		DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		_renderSeries[bar] = 100m * ((ValueDataSeries)_atr.DataSeries[0])[bar] / GetCandle(bar).Close;
	}

	#endregion
}







Technical/ActiveVolume.cs






namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Globalization;
using System.Linq;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

using Utils.Common.Collections;

[DisplayName("Active Volume")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ActiveVolumeDescription))]
[HelpLink("https://help.atas.net/ru-RU/support/solutions/articles/72000608343-active-volume")]
[FeatureId("070459C1-1655-4824-BB31-8B2BE78EEB4D")]
public class ActiveVolume : Indicator
{
	#region Nested types

	[Serializable]
	public enum CalcMode
	{
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidAsk))]
        BidAsk = 0,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
        Bid = 1,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
        Ask = 2
	}

	#endregion

	#region Fields

	private readonly RenderStringFormat _renderStringFormat = new() 
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center,
		FormatFlags = StringFormatFlags.NoWrap
	};

	private Dictionary<decimal, decimal> _askValues = new();
	private Dictionary<decimal, decimal> _bidValues = new();
	private List<CumulativeTrade> _cumulativeTrades = new();
	private DateTime _dateTimeFrom = DateTime.UtcNow.Date;

	private int _filter = 50;
	private CumulativeTrade _lastTrade = new();
	private object _locker = new();
	private decimal _maxAskValue;
	private decimal _maxBidAskValue;
	private decimal _maxBidValue;
	private bool _reloadTrades;

	private RenderFont _warningFont = new("Arial", 20);

	#endregion

	#region Properties
	[Range(0, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 10)]
	public int Filter
	{
		get => _filter;
		set
		{
			_filter = value;
			Calculate();
		}
	}

	[Range(0, 500)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.RowWidth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.TableCellWidthPixelsDescription), Order = 30)]
	public int RowWidth { get; set; } = 70;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowBid), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowBidsDescription), Order = 40)]
	public bool ShowBid { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowAsk), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowAsksDescription), Order = 50)]
	public bool ShowAsk { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolume), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowVolumesDescription), Order = 60)]
	public bool ShowSum { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Offset), GroupName = nameof(Strings.Settings), Description = nameof(Strings.TableOffsetXDescription), Order = 70)]
	public int Offset { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionBegin), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SessionBeginDescription), Order = 80)]
	public DateTime DateFrom
	{
		get => _dateTimeFrom;
		set
		{
			_dateTimeFrom = value;
			_reloadTrades = true;
			RecalculateValues();
		}
	}

	[Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DigitsAfterComma), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DigitsAfterCommaDescription), Order = 90)]
    public int DigitsAfterComma { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Profile), Description = nameof(Strings.CalculationModeDescription), Order = 10)]
	public CalcMode Mode { get; set; }

	[Range(0, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Profile), Description = nameof(Strings.ProfileWidthPixelsDescription), Order = 20)]
	public int ProfileWidth { get; set; } = 70;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Offset), GroupName = nameof(Strings.Profile), Description = nameof(Strings.ProfileOffsetXDescription), Order = 30)]
	public int ProfileOffset { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Profile), Description = nameof(Strings.ProfileFillColorDescription), Order = 40)]
	public Color ProfileFillColor { get; set; } = Color.White;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidColor), GroupName = nameof(Strings.Profile), Description = nameof(Strings.ProfileBidValueColorDescription), Order = 50)]
	public Color BidProfileValueColor { get; set; } = Color.Green;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskColor), GroupName = nameof(Strings.Profile), Description = nameof(Strings.ProfileAskValueColorDescription), Order = 60)]
	public Color AskProfileValueColor { get; set; } = Color.Red;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Author), GroupName = nameof(Strings.Info), Description = nameof(Strings.IndicatorAuthorDescription), Order = 10)]
    public string Creator => "Aleksey Ivanov";

	#endregion

	#region ctor

	public ActiveVolume()
		: base(true)
	{
		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
        DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Final);
		DrawAbovePrice = true;
	}

	#endregion

	#region Protected methods

	protected override void OnInitialize()
	{
		_reloadTrades = true;
	}

	protected override void OnDispose()
	{
		_cumulativeTrades.Clear();
		_cumulativeTrades.TrimExcess();
	}

	protected override void OnCalculate(int bar, decimal value)
	{
	}

	protected override void OnFinishRecalculate()
	{
		if (InstrumentInfo is null || !_reloadTrades)
			return;

		if (CurrentBar <= 0)
			return;

		var firstTime = GetCandle(0).Time;
		var lastTime = GetCandle(CurrentBar - 1).LastTime;

		var startTime = new DateTime(
			Math.Max(_dateTimeFrom.Ticks, firstTime.Ticks));

		startTime = new DateTime(
			Math.Max(startTime.Ticks, DateTime.UtcNow.AddDays(-5).Date.Ticks));

		var request = new CumulativeTradesRequest(startTime, lastTime, 0, 0);
		RequestForCumulativeTrades(request);
	}

	protected override void OnCumulativeTradesResponse(CumulativeTradesRequest request, IEnumerable<CumulativeTrade> cumulativeTrades)
	{
		_reloadTrades = false;
		_cumulativeTrades = cumulativeTrades.ToList();
		Calculate();
	}

	protected override void OnCumulativeTrade(CumulativeTrade trade)
	{
		if (ChartInfo is null)
			return;

		if (CurrentBar <= 0)
			return;

		_cumulativeTrades.Add(trade);

		if (trade.NewBid.Volume < _filter && trade.NewAsk.Volume < _filter)
			return;

		var bidAskValue = 0m;

		lock (_locker)
		{
			switch (trade.Direction)
			{
				case TradeDirection.Sell:
				{
					if (_bidValues.ContainsKey(trade.FirstPrice))
						_bidValues[trade.FirstPrice] += trade.Volume;
					else
						_bidValues.Add(trade.FirstPrice, trade.Volume);
					_maxBidValue = Math.Max(_maxBidValue, _bidValues[trade.FirstPrice]);

					bidAskValue = _bidValues[trade.FirstPrice];

					if (_askValues.TryGetValue(trade.FirstPrice, out var askValue))
						bidAskValue += askValue;
					break;
				}
				case TradeDirection.Buy:
				{
					if (_askValues.ContainsKey(trade.FirstPrice))
						_askValues[trade.FirstPrice] += trade.Volume;
					else
						_askValues.Add(trade.FirstPrice, trade.Volume);
					_maxAskValue = Math.Max(_maxAskValue, _askValues[trade.FirstPrice]);

					bidAskValue = _askValues[trade.FirstPrice];

					if (_bidValues.TryGetValue(trade.FirstPrice, out var bidValue))
						bidAskValue += bidValue;
					break;
				}
			}
		}

		_lastTrade = trade;

		_maxBidAskValue = Math.Max(_maxBidAskValue, bidAskValue);
	}

	protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
	{
		if (ChartInfo is null)
			return;

		if (CurrentBar <= 0 || _cumulativeTrades.Count == 0)
			return;

		_cumulativeTrades.RemoveAt(_cumulativeTrades.Count - 1);
		_cumulativeTrades.Add(trade);

		var containsTrade = _lastTrade.IsEqual(trade);

		if (trade.NewBid.Volume < _filter && trade.NewAsk.Volume < _filter)
			return;

		var incValue = containsTrade
			? trade.Volume - _lastTrade.Volume
			: trade.Volume;

		var bidAskValue = 0m;

		lock (_locker)
		{
			switch (trade.Direction)
			{
				case TradeDirection.Sell:
				{
					_bidValues.GetOrAdd(trade.FirstPrice, _ => 0);

					_bidValues[trade.FirstPrice] += incValue;

					_maxBidValue = Math.Max(_maxBidValue, _bidValues[trade.FirstPrice]);

					bidAskValue = _bidValues[trade.FirstPrice];

					if (_askValues.TryGetValue(trade.FirstPrice, out var askValue))
						bidAskValue += askValue;
					break;
				}
				case TradeDirection.Buy:
				{
					_askValues.GetOrAdd(trade.FirstPrice, _ => 0);

					_askValues[trade.FirstPrice] += incValue;

					_maxAskValue = Math.Max(_maxAskValue, _askValues[trade.FirstPrice]);

					bidAskValue = _askValues[trade.FirstPrice];

					if (_bidValues.TryGetValue(trade.FirstPrice, out var bidValue))
						bidAskValue += bidValue;
					break;
				}
			}
		}

		_lastTrade = trade;

		_maxBidAskValue = Math.Max(_maxBidAskValue, bidAskValue);
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo == null)
			return;

		var rowHeight = (int)ChartInfo.PriceChartContainer.PriceRowHeight;

		var fontSize = (int)Math.Min(rowHeight / 2m, 14);
		var renderFont = new RenderFont("Arial", fontSize);

		decimal low, high;

        lock (_locker)
		{
			var minAsk = _askValues.Keys.DefaultIfEmpty(0).Min();
			var minBid = _bidValues.Keys.DefaultIfEmpty(0).Min();
			var maxAsk = _askValues.Keys.DefaultIfEmpty(0).Max();
			var maxBid = _bidValues.Keys.DefaultIfEmpty(0).Max();
			
			low = minAsk is not 0 && minBid is not 0
					? Math.Min(minAsk, minBid)
					: Math.Max(minAsk, minBid);

			high = Math.Max(maxAsk, maxBid);
		}

        var anyValue = high is not 0 && low is not 0;

        low = Math.Max(low, ChartInfo.PriceChartContainer.Low);
		high = Math.Min(high, ChartInfo.PriceChartContainer.High);

		var yHigh = ChartInfo.GetYByPrice(high);
		var yLow = ChartInfo.GetYByPrice(low - InstrumentInfo.TickSize);

		context.FillRectangle(ProfileFillColor, new Rectangle(ProfileOffset, yHigh, ProfileWidth, yLow - yHigh));

		var drawTable = rowHeight >= 8 && anyValue;

		if (!drawTable)
		{
			var shift = 10;
      
			var text = anyValue 
				? Strings.TooSmallRows
				: Strings.FilterEmptyMsg;

			var textArray = text.Split(' ');
			var textPart1 = $"{string.Join(' ', textArray.Take(3))}\n";
			var textPart2 = string.Join(' ', textArray.Skip(3));
			
			text = $"{textPart1}{textPart2}";
			var textSize = context.MeasureString(text, _warningFont);

			var y = anyValue 
				? yHigh 
				: ChartInfo.PriceChartContainer.Region.Height / 2;
			var height = anyValue 
				? Math.Max(textSize.Height + shift, yLow - yHigh) 
				: textSize.Height;

			var tableRect = new Rectangle(ProfileOffset + ProfileWidth, y, textSize.Width + shift, height);
			context.FillRectangle(Color.White, tableRect);
			context.DrawRectangle(RenderPens.Blue, tableRect);
			context.DrawString(text, _warningFont, Color.Black, tableRect, _renderStringFormat);
		}

		for (var price = low; price <= high; price += InstrumentInfo.TickSize)
		{
			var y1 = ChartInfo.GetYByPrice(price);
			var sum = 0m;

			decimal askValue, bidValue;

			lock (_locker)
			{
				if (_bidValues.TryGetValue(price, out bidValue))
					sum += _bidValues[price];

				if (_askValues.TryGetValue(price, out askValue))
					sum += _askValues[price];
			}

			switch (Mode)
			{
				case CalcMode.BidAsk:
					DrawBidAsk(context, bidValue, askValue, y1, rowHeight);
					break;
				case CalcMode.Bid:
					DrawBid(context, bidValue, y1, rowHeight);
					break;
				case CalcMode.Ask:
					DrawAsk(context, askValue, y1, rowHeight);
					break;
			}

			if (!drawTable)
				continue;

			var x = ProfileWidth + Offset;

			var priceRect = new Rectangle(x, y1, RowWidth, rowHeight);
			context.FillRectangle(Color.White, priceRect);
			context.DrawRectangle(RenderPens.Blue, priceRect);
			context.DrawString(price.ToString(CultureInfo.InvariantCulture), renderFont, Color.Black, priceRect, _renderStringFormat);

			x += RowWidth;
			string text;

			if (ShowBid)
			{
                text = GetRoundedValueString(bidValue);
                var rect = new Rectangle(x, y1, RowWidth, rowHeight);
				context.FillRectangle(Color.White, rect);
				context.DrawRectangle(RenderPens.Blue, rect);
				context.DrawString(text, renderFont, Color.Black, rect, _renderStringFormat);

				x += RowWidth;
			}

			if (ShowAsk)
			{
                text = GetRoundedValueString(askValue);
                var rect = new Rectangle(x, y1, RowWidth, rowHeight);
				context.FillRectangle(Color.White, rect);
				context.DrawRectangle(RenderPens.Blue, rect);
				context.DrawString(text, renderFont, Color.Black, rect, _renderStringFormat);

				x += RowWidth;
			}

			if (ShowSum)
			{
                text = GetRoundedValueString(sum);
                var rect = new Rectangle(x, y1, RowWidth, rowHeight);
				context.FillRectangle(Color.White, rect);
				context.DrawRectangle(RenderPens.Blue, rect);

				context.DrawString(text, renderFont, Color.Black, rect, _renderStringFormat);
			}
		}
	}

    #endregion

    #region Private methods

    private string GetRoundedValueString(decimal value)
    {
        return Math.Round(value, DigitsAfterComma).ToString(CultureInfo.InvariantCulture);
    }

    private void DrawBidAsk(RenderContext context, decimal bidValue, decimal askValue, int y, int height)
	{
		var askProfileValue = 0;
		var bidProfileValue = 0;

		if (_maxBidAskValue > 0)
		{
			bidProfileValue = (int)Math.Min(bidValue * ProfileWidth / _maxBidAskValue, ProfileWidth - 1);
			askProfileValue = (int)Math.Min(askValue * ProfileWidth / _maxBidAskValue, ProfileWidth - 1);
		}

		context.FillRectangle(AskProfileValueColor,
			new Rectangle(ProfileOffset + bidProfileValue, y, askProfileValue, height));

		context.FillRectangle(BidProfileValueColor,
			new Rectangle(ProfileOffset, y, bidProfileValue, height));
	}

	private void DrawBid(RenderContext context, decimal bidValue, int y, int height)
	{
		var bidProfileValue = 0m;

		if (_maxBidValue > 0)
			bidProfileValue = Math.Min(bidValue * ProfileWidth / _maxBidValue, ProfileWidth - 1);

		context.FillRectangle(BidProfileValueColor,
			new Rectangle(ProfileOffset, y, (int)bidProfileValue, height));
	}

	private void DrawAsk(RenderContext context, decimal askValue, int y, int height)
	{
		var askProfileValue = 0m;

		if (_maxAskValue > 0)
			askProfileValue = Math.Min(askValue * ProfileWidth / _maxAskValue, ProfileWidth - 1);

		context.FillRectangle(AskProfileValueColor,
			new Rectangle(ProfileOffset, y, (int)askProfileValue, height));
	}

	private void Calculate()
	{
		lock (_locker)
		{
			_bidValues.Clear();
			_askValues.Clear();
		}

		_maxAskValue = _maxBidValue = _maxBidAskValue = 0;

		foreach (var ct in _cumulativeTrades.Where(x => x.NewBid.Volume >= _filter || x.NewAsk.Volume >= _filter))
		{
			var bidAskValue = 0m;

			lock (_locker)
			{
				switch (ct.Direction)
				{
					case TradeDirection.Sell:
						_bidValues.GetOrAdd(ct.FirstPrice, _ => 0);

						_bidValues[ct.FirstPrice] += ct.Volume;

						_maxBidValue = Math.Max(_maxBidValue, _bidValues[ct.FirstPrice]);

						bidAskValue = _bidValues[ct.FirstPrice];

						if (_askValues.TryGetValue(ct.FirstPrice, out var askValue))
							bidAskValue += askValue;
						break;

					case TradeDirection.Buy:
						_askValues.GetOrAdd(ct.FirstPrice, _ => 0);

						_askValues[ct.FirstPrice] += ct.Volume;

						_maxAskValue = Math.Max(_maxAskValue, _askValues[ct.FirstPrice]);

						bidAskValue = _askValues[ct.FirstPrice];

						if (_bidValues.TryGetValue(ct.FirstPrice, out var bidValue))
							bidAskValue += bidValue;
						break;
				}
			}

			_maxBidAskValue = Math.Max(_maxBidAskValue, bidAskValue);
		}
	}

	#endregion
}








Technical/AdaptiveBinaryWaveMA.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Adaptive Binary Wave")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ABWMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602535")]
	public class AdaptiveBinaryWaveMA : Indicator
	{
		#region Fields

		private readonly AMA _ama = new();

		private readonly ValueDataSeries _amaHigh = new("High");
		private readonly ValueDataSeries _amaLow = new("Low");

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly StdDev _stdDev = new();
		private decimal _percent;

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _ama.Period;
			set
			{
				_ama.Period = _stdDev.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.FastConstDescription), Order = 110)]
		public decimal ShortPeriod
		{
			get => _ama.FastConstant;
			set
			{
				_ama.FastConstant = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SlowConstDescription), Order = 120)]
		public decimal LongPeriod
		{
			get => _ama.SlowConstant;
			set
			{
				_ama.SlowConstant = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 100)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DeviationPercentageDescription), Order = 130)]
		public decimal Percent
		{
			get => _percent;
			set
			{
				_percent = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public AdaptiveBinaryWaveMA()
		{
			Panel = IndicatorDataProvider.NewPanel;

			_stdDev.Period = _ama.Period;
			_percent = 30;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_ama.Calculate(bar, value);
			_stdDev.Calculate(bar, _ama[bar]);

			if (bar == 0)
			{
				_renderSeries.Clear();
				_amaHigh[bar] = _amaLow[bar] = _ama[bar];
				return;
			}

			_amaLow[bar] = _ama[bar] < _ama[bar - 1] 
					 	 ? _ama[bar] 
						 : _amaLow[bar - 1];

			_amaHigh[bar] = _ama[bar] > _ama[bar - 1] 
						  ? _ama[bar] 
					   	  : _amaHigh[bar - 1];

			var deviation = _percent * 0.01m * _stdDev[bar];

			if (_ama[bar] - _amaLow[bar] > deviation)
			{
				_renderSeries[bar] = 1;
				return;
			}

			if (_amaHigh[bar] - _ama[bar] > deviation)
			{
				_renderSeries[bar] = -1;
				return;
			}

			_renderSeries[bar] = 0;
		}

		#endregion
	}
}








Technical/AdaptiveRsiAverage.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Adaptive RSI Moving Average")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.AdaptiveRsiAverageDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602311")]
public class AdaptiveRsiAverage : Indicator
{
	#region Fields

	private EMA _priceSmoothed = new();
	private RSI _rsi = new();
	private EMA _rsiSmoothed = new();
	private decimal _scaleFactor = 0.5m;

	#endregion

	#region Properties
	[Parameter]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.RSI), Description = nameof(Strings.PeriodDescription), Order = 100)]
	[Range(1, 10000)]
	public int RsiPeriod
	{
		get => _rsi.Period;
		set
		{
			_rsi.Period = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Smooth), GroupName = nameof(Strings.RSI), Description = nameof(Strings.SmoothPeriodFilterDescription), Order = 110)]
	[Range(1, 10000)]
	public FilterInt RsiSmooth { get; set; } = new(true)
	{
		Enabled = true,
		Value = 10
	};

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Smooth), GroupName = nameof(Strings.Values), Description = nameof(Strings.SmoothPeriodFilterDescription), Order = 200)]
	[Range(1, 10000)]
	public FilterInt PriceSmooth { get; set; } = new(true)
	{
		Enabled = true,
		Value = 10
	};

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Scale), GroupName = nameof(Strings.Values), Description = nameof(Strings.ElementScaleValueDescription), Order = 210)]
	[Range(0.00000001, 2)]
	public decimal ScaleFactor
	{
		get => _scaleFactor;
		set
		{
			_scaleFactor = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public AdaptiveRsiAverage()
	{
		RsiSmooth.PropertyChanged += RsiFilterChanged;
		PriceSmooth.PropertyChanged += ValuesFilterChanged;
	}

	#endregion

	#region Protected methods

	protected override void OnFinishRecalculate()
	{
		RedrawChart();
	}

	protected override void OnRecalculate()
	{
		Clear();
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var calcValue = PriceSmooth.Enabled
			? _priceSmoothed.Calculate(bar, value)
			: value;

		var rsiValue = _rsi.Calculate(bar, calcValue);

		if (RsiSmooth.Enabled)
			rsiValue = _rsiSmoothed.Calculate(bar, rsiValue);

		var sFactor = 2 * ScaleFactor * Math.Abs(rsiValue / 100m - 0.5m);

		this[bar] = bar <= RsiPeriod
			? calcValue
			: (calcValue - this[bar - 1]) * sFactor + this[bar - 1];
	}

	#endregion

	#region Private methods

	private void ValuesFilterChanged(object sender, PropertyChangedEventArgs e)
	{
		_priceSmoothed.Period = PriceSmooth.Value;
		RecalculateValues();
	}

	private void RsiFilterChanged(object sender, PropertyChangedEventArgs e)
	{
		_rsiSmoothed.Period = RsiSmooth.Value;
		RecalculateValues();
	}

	#endregion
}








Technical/Alligator.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Alligator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.AlligatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602579")]
	public class Alligator : Indicator
	{
		#region Fields

		private readonly SMMA _jaw = new();
		private readonly SMMA _lips = new();
		private readonly SMMA _teeth = new();

		private int _jawShift;
		private int _lipsShift;
		private int _teethShift;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.JawAlligator), Description = nameof(Strings.LongPeriodDescription), Order = 0)]
		public int JawPeriod
		{
			get => _jaw.Period;
			set
			{
				_jaw.Period = Math.Max(1, value);
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Shift), GroupName = nameof(Strings.JawAlligator), Description = nameof(Strings.BarShiftDescription), Order = 1)]
		public int JawShift
		{
			get => _jawShift;
			set
			{
				_jawShift = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.TeethAlligator), Description = nameof(Strings.MediumPeriodDescription), Order = 0)]
		public int TeethPeriod
		{
			get => _teeth.Period;
			set
			{
				_teeth.Period = Math.Max(1, value);
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Shift), GroupName = nameof(Strings.TeethAlligator), Description = nameof(Strings.BarShiftDescription), Order = 1)]
		public int TeethShift
		{
			get => _teethShift;
			set
			{
				_teethShift = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.LipsAlligator), Description = nameof(Strings.ShortPeriodDescription), Order = 0)]
		public int LipsPeriod
		{
			get => _lips.Period;
			set
			{
				_lips.Period = Math.Max(1, value);
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Shift), GroupName = nameof(Strings.LipsAlligator), Description = nameof(Strings.BarShiftDescription), Order = 1)]
		public int LipsShift
		{
			get => _lipsShift;
			set
			{
				_lipsShift = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Alligator()
		{
			_jawShift = 8;
			_teethShift = 5;
			_lipsShift = 3;

			((ValueDataSeries)DataSeries[0]).Name = "Jaw";
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Line;
			((ValueDataSeries)DataSeries[0]).ShowZeroValue = false;
			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Blue.Convert();

            DataSeries.Add(new ValueDataSeries("TeethId", "Teeth")
			{
				VisualType = VisualMode.Line,
				ShowZeroValue = false,
				Color = DefaultColors.Red.Convert()
			});

			DataSeries.Add(new ValueDataSeries("LipsId", "Lips")
			{
				VisualType = VisualMode.Line,
				ShowZeroValue = false,
				Color = DefaultColors.Green.Convert()
            });

			JawPeriod = 13;
			TeethPeriod = 8;
			LipsPeriod = 5;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var average = (GetCandle(bar).Low + GetCandle(bar).High) / 2;

			if (bar < _jawShift)
				this[bar] = average;
			else
			{
				if (bar - _jawShift <= CurrentBar - 1)
					this[bar] = _jaw.Calculate(bar - _jawShift, (GetCandle(bar - _jawShift).Low + GetCandle(bar - _jawShift).High) / 2);
			}

			if (bar < _teethShift)
				DataSeries[1][bar] = average;
			else
			{
				if (bar - _teethShift <= CurrentBar - 1)
					DataSeries[1][bar] = _teeth.Calculate(bar - _teethShift, (GetCandle(bar - _teethShift).Low + GetCandle(bar - _teethShift).High) / 2);
			}

			if (bar < _lipsShift)
				DataSeries[2][bar] = average;
			else
			{
				if (bar - _lipsShift <= CurrentBar - 1)
					DataSeries[2][bar] = _lips.Calculate(bar - _lipsShift, (GetCandle(bar - _lipsShift).Low + GetCandle(bar - _lipsShift).High) / 2);
			}
		}

		#endregion
	}
}








Technical/Angle.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Study Angle")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.AngleDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602533")]
	public class Angle : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private int _period;

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Angle()
		{
			Panel = IndicatorDataProvider.NewPanel;
			_period = 10;
			LineSeries.Add(new LineSeries("ZeroVal", Strings.ZeroValue)
			{
				Color = DefaultColors.Gray.Convert(),
				Value = 0,
				Width = 2,
				DescriptionKey = nameof(Strings.ZeroLineDescription),
			});

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				_renderSeries.Clear();

			if (bar < _period)
				return;

			_renderSeries[bar] = (decimal)(Math.Atan((double)
				((value - (decimal)SourceDataSeries[bar - _period]) / _period)) * 180 / Math.PI);
		}

		#endregion
	}
}








Technical/AroonIndicator.cs







namespace ATAS.Indicators.Technical
{
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Aroon Indicator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.AroonIndicatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602316")]
	public class AroonIndicator : Indicator
	{
		#region Nested types

		private class ExtValue
		{
			#region Properties

			public decimal High { get; set; }

			public decimal Low { get; set; }

			public int Bar { get; set; }

			#endregion
		}

		#endregion

		#region Fields

		private readonly ValueDataSeries _downSeries = new("DownSeries", Strings.Lowest) { DescriptionKey = nameof(Strings.AroonLowestDescription) };
		private readonly List<ExtValue> _extValues = new();
		private readonly ValueDataSeries _upSeries = new("UpSeries", Strings.Highest) { DescriptionKey = nameof(Strings.AroonHighestDescription) };
        private int _lastBar;

		private int _period;

        #endregion

        #region Properties

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public AroonIndicator()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			_period = 10;
			_lastBar = -1;
			_upSeries.Color = DefaultColors.Blue.Convert();
			_downSeries.Color = DefaultColors.Red.Convert();

			DataSeries[0] = _upSeries;
			DataSeries.Add(_downSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			_extValues.Clear();
			DataSeries.ForEach(x => x.Clear());
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			if (_lastBar == bar)
				_extValues.RemoveAt(_extValues.Count - 1);

			_extValues.Add(new ExtValue
				{ Bar = bar, High = candle.High, Low = candle.Low });

			if (_extValues.Count > _period)
				_extValues.RemoveAt(0);

			_lastBar = bar;

			if (bar < _period)
				return;

			var highValue = _extValues.OrderByDescending(x => x.High).First();
			var lowValue = _extValues.OrderBy(x => x.Low).First();

			_upSeries[bar] = 100m * (_period - (bar - highValue.Bar)) / _period;
			_downSeries[bar] = 100m * (_period - (bar - lowValue.Bar)) / _period;
		}

		#endregion
	}
}







Technical/AroonOscillator.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Aroon Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.AroonOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602317")]
	public class AroonOscillator : Indicator
	{
		#region Fields

		private readonly AroonIndicator _ai = new();

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", "Aroon");
		private int _period;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		public int Period
		{
			get => _ai.Period;
			set
			{
				_ai.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public AroonOscillator()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			_period = 10;
			_ai.Period = _period;
			Add(_ai);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = ((ValueDataSeries)_ai.DataSeries[0])[bar] - ((ValueDataSeries)_ai.DataSeries[1])[bar];
		}

		#endregion
	}
}







Technical/AskBidBars.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using OFT.Attributes;
using OFT.Localization;

[DisplayName("Ask/Bid Volume Difference Bars")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.AskBidBarsDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602527")]
public class AskBidBars : Indicator
{
	#region Fields

	private readonly CandleDataSeries _renderSeries = new("RenderSeries", Strings.Candles)
	{
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true
	};

	#endregion

	#region ctor

	public AskBidBars()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DataSeries[0] = _renderSeries;
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    _renderSeries.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    _renderSeries.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	    _renderSeries.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
    }

    protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
			_renderSeries.Clear();

		var candle = GetCandle(bar);

		_renderSeries[bar].High = candle.MaxDelta;
		_renderSeries[bar].Low = candle.MinDelta;
		_renderSeries[bar].Close = candle.Delta;
	}

	#endregion
}









Technical/AverageDelta.cs








using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;

namespace ATAS.Indicators.Technical;

[DisplayName("Average Delta")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.AverageDeltaIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618456")]
public class AverageDelta : Indicator
{
    #region Nested Types

    public enum CalculationType
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA))]
        Sma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA))]
        Ema
    }

    #endregion

    #region Fields

    private readonly ValueDataSeries _data = new(nameof(_data), Strings.Data)
    {
        IsHidden = true,
        VisualType = VisualMode.Histogram,
        ShowZeroValue = false
    };

    private int _period = 10;
    private SMA _sma;
    private EMA _ema;
    private CalculationType _calcType;
    private Color _posColor = DefaultColors.Green;
    private Color _negColor = DefaultColors.Red;

    #endregion

    #region Properties

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.PeriodDescription))]
    public int Period
    {
        get => _period;
        set
        {
            _period = value;

            if (_sma is not null && _ema is not null)
            {
                _sma.Period = value;
                _ema.Period = value;
            }

            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.CalculationModeDescription))]
    public CalculationType CalcType
    {
        get => _calcType;
        set
        {
            _calcType = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PositiveValueColorDescription))]
    public Color PosColor
    {
        get => _posColor;
        set
        {
            _posColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.NegativeValueColorDescription))]
    public Color NegColor 
    { 
        get => _negColor;
        set
        {
            _negColor = value;
            RecalculateValues();
        }
    }

    #endregion

    #region ctor

    public AverageDelta() : base(true)
    {
        Panel = IndicatorDataProvider.NewPanel;
        DenyToChangePanel = true;

        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

        DataSeries.Add(_data);
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        _sma = new()
        {
            Period = _period
        };

        _ema = new()
        {
            Period = _period
        };
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        var val = 0m;
        var candle = GetCandle(bar);

        switch (_calcType)
        {
            case CalculationType.Sma:
                val = _sma.Calculate(bar, candle.Delta);
                break;
            case CalculationType.Ema:
                val = _ema.Calculate(bar, candle.Delta);
                break;
        }

        _data[bar] = val;

        if (val > 0)
            _data.Colors[bar] = PosColor;
        else
            _data.Colors[bar] = NegColor;
    }

    #endregion
}







Technical/AveragePriceBar.cs









namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Average Price for Bar")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.AveragePriceBarDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602324")]
	public class AveragePriceBar : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow2))]
			Hl2,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLowClose3))]
			Hlc3,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OpenHighLowClose4))]
			Ohlc4,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow2Close4))]
			Hl2c4
		}

		#endregion

		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private Mode _calcMode;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 110)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public AveragePriceBar()
			: base(true)
		{
			_calcMode = Mode.Hlc3;
			_renderSeries.Color = DefaultColors.Blue.Convert();
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var averValue = _calcMode switch
			{
				Mode.Hl2 => (candle.High + candle.Low) / 2,
				Mode.Hlc3 => (candle.High + candle.Low + candle.Close) / 3,
				Mode.Ohlc4 => (candle.Open + candle.High + candle.Low + candle.Close) / 4,
				Mode.Hl2c4 => (candle.High + candle.Low + 2 * candle.Close) / 4,
				_ => 0m
			};

			_renderSeries[bar] = averValue;
		}

		#endregion
	}
}









Technical/BOP.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Balance of Power")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BOPDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602623")]
	public class BOP : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _bop = new("BOP");
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly SMA _sma = new()
		{
			Period = 14
		};

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BOP()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var highLow = candle.High - candle.Low;

			_bop[bar] = highLow == 0 ? 0 : (candle.Close - candle.Open) / highLow;
			
			_renderSeries[bar] = _sma.Calculate(bar, _bop[bar]);
		}

		#endregion
	}
}









Technical/BWMA.cs








namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bill Williams Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BWMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602334")]
	public class BWMA : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BWMA()
		{
			_renderSeries.Color = DefaultColors.Blue.Convert();
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();
				_renderSeries[bar] = value;
				return;
			}

			_renderSeries[bar] = (1m - 1m / _period) * _renderSeries[bar - 1] + value / _period;
		}

		#endregion
	}
}








Technical/BalanceOI.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("On Balance Open Interest")]
	[Category(IndicatorCategories.VolumeOrderFlow)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BalanceOIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602438")]
    public class BalanceOI : Indicator
	{
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
			UseMinimizedModeIfEnabled = true
		};

		private readonly ValueDataSeries _oiSignedSeries = new("Signed");
		
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.ShortValues), Description = nameof(Strings.UsePeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public FilterInt MinimizedMode { get; set; } = new(true) { Value = 10, Enabled = false };

        public BalanceOI()
		    : base(true)
	    {
		    Panel = IndicatorDataProvider.NewPanel;
		    DataSeries[0] = _renderSeries;

		    MinimizedMode.PropertyChanged += FilterChanged;
	    }

        private void FilterChanged(object sender, PropertyChangedEventArgs e)
        {
	        RecalculateValues();
			RedrawChart();
        }

        protected override void OnCalculate(int bar, decimal value)
	    {
		    var candle = GetCandle(bar);

		    if (bar == 0)
		    {
			    _renderSeries[bar] = candle.OI;
			    return;
		    }

		    var prevCandle = GetCandle(bar - 1);

		    if (!MinimizedMode.Enabled)
		    {
			    _renderSeries[bar] = candle.Close > prevCandle.Close
				    ? _renderSeries[bar - 1] + candle.OI
				    : candle.Close < prevCandle.Close
					    ? _renderSeries[bar - 1] - candle.OI
                        : _renderSeries[bar - 1];

			    return;
		    }

		    _oiSignedSeries[bar] = candle.Close > prevCandle.Close
			    ? candle.OI
			    : candle.Close < prevCandle.Close
				    ? -candle.OI
				    : 0;

		    _renderSeries[bar] = bar < MinimizedMode.Value
			    ? _renderSeries[bar - 1] + _oiSignedSeries[bar]
			    : _renderSeries[bar - 1] + _oiSignedSeries[bar] - _oiSignedSeries[bar - MinimizedMode.Value];
	    }
    }
}









Technical/BandsEnvelope.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bands/Envelope")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BandsEnvelopeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602522")]
	public class BandsEnvelope : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent))]
			Percentage,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PriceChange))]
			Value,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Ticks
		}

		#endregion

		#region Fields

		private readonly RangeDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			DrawAbovePrice = false,
			DescriptionKey = nameof(Strings.RangeAreaDescription)
		};
		private readonly ValueDataSeries _topSeries = new("TopSeries", Strings.TopBand) 
		{
			DescriptionKey = nameof(Strings.TopBandDscription) 
		};

        private readonly ValueDataSeries _botSeries = new("BotSeries", Strings.BottomBand)
		{ 
			DescriptionKey = nameof(Strings.BottomBandDscription) 
		};

        private Mode _calcMode = Mode.Percentage;
        private decimal _rangeFilter = 1;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 100)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Range), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DeviationRangeDescription), Order = 110)]
		[Range(0, 100)]
		public decimal RangeFilter
		{
			get => _rangeFilter;
			set
			{
				if (_calcMode == Mode.Percentage)
					return;

				_rangeFilter = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BandsEnvelope()
		{
			DataSeries[0] = _renderSeries;
			DataSeries.Add(_topSeries);
			DataSeries.Add(_botSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			switch (_calcMode)
			{
				case Mode.Percentage:
					var percValue = value * _rangeFilter * 0.01m;
					_renderSeries[bar].Upper = value + percValue;
					_renderSeries[bar].Lower = value - percValue;
					break;
				case Mode.Value:
					_renderSeries[bar].Upper = value + _rangeFilter;
					_renderSeries[bar].Lower = value - _rangeFilter;
					break;
				case Mode.Ticks:
					var tickValue = _rangeFilter * InstrumentInfo.TickSize;
					_renderSeries[bar].Upper = value + tickValue;
					_renderSeries[bar].Lower = value - tickValue;
					break;
			}

			_topSeries[bar] = _renderSeries[bar].Upper;
			_botSeries[bar] = _renderSeries[bar].Lower;
		}

		#endregion
	}
}









Technical/BarDifference.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bar Difference")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BarDifferenceDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602523")]
	public class BarDifference : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private int _period = 1;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BarDifference()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				_renderSeries.Clear();
			
			if (bar < _period)
				return;

			_renderSeries[bar] = (value - (decimal)SourceDataSeries[bar - _period]) / InstrumentInfo.TickSize;
		}

		#endregion
	}
}








Technical/BarNumbering.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Globalization;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

[DisplayName("Bar Numbering")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.BarNumberingDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618457")]
public class BarNumbering : Indicator
{
	#region Fields

	private RenderStringFormat _format = new()
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center
	};

	private int _lastBar = -1;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.FontSettingDescription), Order = 90)]
	public FontSetting Font { get; set; } = new("arial", 10);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LabelTextColorDescription), Order = 95)]
	public Color FontColor { get; set; } = Color.Gray;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.DisplayBottom), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.DisplayLabelChartBottomDescription), Order = 100)]
	public bool DisplayBottom { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VerticalOffset), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LabelOffsetYDescription), Order = 110)]
	public int Offset { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PeriodDescription), Order = 120)]
	[Range(1, 100000)]
	public int Period { get; set; } = 10;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ResetOnSession), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ResetOnSessionFilterDescription), Order = 130)]
	public bool ResetOnSession { get; set; }

	#endregion

	#region ctor

	public BarNumbering()
		: base(true)
	{
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Historical);
		DenyToChangePanel = true;

		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
		DataSeries[0].IsHidden = true;
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    FontColor = ChartInfo.ColorsStore.AxisTextColor;
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo is null || InstrumentInfo is null)
			return;

		for (var bar = FirstVisibleBarNumber; bar <= LastVisibleBarNumber; bar++)
		{
			var barNum = ResetOnSession
				? this[bar] + 1
				: bar + 1;

			var renderString = barNum.ToString(CultureInfo.InvariantCulture);
			var stringSize = context.MeasureString(renderString, Font.RenderObject);

			if (barNum % Period != 0)
				continue;

			var x = ChartInfo.GetXByBar(bar, false);

			var y1 = Offset;

			if (DisplayBottom)
				y1 += Container.Region.Height - stringSize.Height;
			else
			{
				var low = GetCandle(bar).Low;
				y1 += ChartInfo.GetYByPrice(low - InstrumentInfo.TickSize, false);
			}
			
			context.DrawString(renderString, Font.RenderObject, FontColor, x, y1, _format);
		}
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (_lastBar == bar)
			return;

		this[bar] = IsNewSession(bar)
			? 0
			: this[bar - 1] + 1;

		_lastBar = bar;
	}

	#endregion
}








Technical/BarRange.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;

[DisplayName("Bar Range")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.BarRangeIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618458")]
public class BarRange : Indicator
{
	#region Fields

	private Highest _highestVol = new();
	private ValueDataSeries _maxVolSeries;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.MaxValue), Description = nameof(Strings.ShowMaxValueDescription), Order = 100)]
	public bool ShowMaxVolume
	{
		get => _maxVolSeries.VisualType is not VisualMode.Hide;
		set => _maxVolSeries.VisualType = value ? VisualMode.Line : VisualMode.Hide;
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.MaxValue), Description = nameof(Strings.PeriodDescription), Order = 110)]
	[Range(1, 100000)]
	public int HiVolPeriod
	{
		get => _highestVol.Period;
		set => _highestVol.Period = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLineColor), GroupName = nameof(Strings.MaxValue), Description = nameof(Strings.LineColorDescription), Order = 120)]
	public CrossColor LineColor
	{
		get => _maxVolSeries.Color;
		set => _maxVolSeries.Color = value;
	}

	#endregion

	#region ctor

	public BarRange()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		_maxVolSeries = (ValueDataSeries)_highestVol.DataSeries[0];
		_maxVolSeries.Id = "HighestVolDataSeries";
		_maxVolSeries.IsHidden = true;
		_maxVolSeries.Color = DefaultColors.Green.Convert();
		_maxVolSeries.IgnoredByAlerts = true;

		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Histogram;

        DataSeries.Add(_maxVolSeries);
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		this[bar] = candle.High - candle.Low;
		_highestVol.Calculate(bar, this[bar]);
	}

	#endregion
}








Technical/BarTimer.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Globalization;
	using System.Threading;
	using System.Threading.Tasks;

	using ATAS.Indicators.Drawing;
	using ATAS.Indicators.Technical.Extensions;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Tools;

	using Color = System.Drawing.Color;

    [DisplayName("Bar Timer")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BarTimerDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602327")]
	public class BarTimer : Indicator
	{
		#region Nested types

		public enum Format
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Auto))]
			Auto,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HHMMSS))]
			HHMMSS,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HHMMSSPM))]
			HHMMSSPM,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MMSS))]
			MMSS
		}

		public enum Location
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopLeft))]
			TopLeft,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopRight))]
			TopRight,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomLeft))]
			BottomLeft,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomRight))]
			BottomRight
		}

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeToEndOfCandle))]
			TimeToEndOfCandle,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CurrentTime))]
			CurrentTime
		}

        #endregion

        #region Static and constants

        private static readonly TimeSpan _timerLength = TimeSpan.FromSeconds(1);
        private const int _daySeconds = 86400;
		private const int _weekSeconds = 604800;

        #endregion

        #region Fields

        private readonly RenderStringFormat _format = new()
		{
			Alignment = StringAlignment.Center,
			LineAlignment = StringAlignment.Center
		};

		private Color _backGroundColor;
		private int _barLength;
		private int _customOffset;
		private DateTime _endTime;
		private RenderFont _font = new("Arial", 15);
		private bool _isUnsupportedTimeFrame;
		private int _lastBar;
		private int _lastBeforeAlert;
		private int _lastSecond = -1;
		private bool _offsetIsSet;
		private Color _textColor;
		private TimeSpan _timeDiff;
		private Location _timeLocation;
		private CrossColor _textBeforeColor = DefaultColors.Red.Convert();
		private CrossColor _areaBeforeColor = DefaultColors.Yellow.Convert();

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeSettings), Name = nameof(Strings.TimeFormat), Description = nameof(Strings.TimeFormatDescription), Order = 100)]
		public Format TimeFormat { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeSettings), Name = nameof(Strings.Mode), Description = nameof(Strings.TimeModeDescription), Order = 110)]
		public Mode TimeMode { get; set; }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeSettings), Name = nameof(Strings.TimeZone), Description = nameof(Strings.TimeZoneDescription), Order = 120)]
        [Range(-23, 23)]
        public int CustomTimeZone { get; set; }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.OffsetX), Description = nameof(Strings.LabelOffsetXDescription), Order = 200)]
		[Range(-10000, 10000)]
		public int OffsetX { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.OffsetY), Description = nameof(Strings.LabelOffsetYDescription), Order = 210)]
		[Range(-10000, 10000)]
		public int OffsetY { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Size), Description = nameof(Strings.FontSizeDescription), Order = 220)]
		[Range(1, 100)]
		public int Size
		{
			get => (int)Math.Floor(_font.Size);
			set => _font = new RenderFont("Arial", value);
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Location), Description = nameof(Strings.LabelLocationDescription), Order = 230)]
		public Location TimeLocation
		{
			get => _timeLocation;
			set
			{
				_timeLocation = value;
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.Color), Description = nameof(Strings.LabelTextColorDescription), Order = 300)]
		public CrossColor TextColor
		{
			get => _textColor.Convert();
			set => _textColor = Color.FromArgb(value.A, value.R, value.G, value.B);
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.BackGround), Description = nameof(Strings.LabelFillColorDescription), Order = 310)]
		public CrossColor BackGroundColor
		{
			get => _backGroundColor.Convert();
			set => _backGroundColor = Color.FromArgb(value.A, value.R, value.G, value.B);
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.AlertNewCandle), Name = nameof(Strings.UseAlerts), Description = nameof(Strings.UseAlertsDescription), Order = 400)]
		public bool UseAlert { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.AlertNewCandle), Name = nameof(Strings.AlertFile), Description = nameof(Strings.AlertFileDescription), Order = 410)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.AlertNewCandle), Name = nameof(Strings.TextColor), Description = nameof(Strings.AlertTextColorDescription), Order = 420)]
		public CrossColor AlertTextColor { get; set; } = CrossColors.White;

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.AlertNewCandle), Name = nameof(Strings.AreaColor), Description = nameof(Strings.AlertFillColorDescription), Order = 430)]
		public CrossColor AlertBackgroundColor { get; set; } = CrossColors.Black;

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ColorBeforeCandle), Name = nameof(Strings.UseAlerts), Description = nameof(Strings.UseAlertBeforeDescription), Order = 500)]
		public bool UseAlertBefore { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ColorBeforeCandle), Name = nameof(Strings.AlertFile), Description = nameof(Strings.AlertBeforeFileDescription), Order = 510)]
		public string AlertBeforeFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ColorBeforeCandle), Name = nameof(Strings.Seconds), Description = nameof(Strings.AlertBeforeSecondsDescription), Order = 520)]
		[Range(1, 10000)]
		public int AlertBeforeSeconds { get; set; } = 5;

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ColorBeforeCandle), Name = nameof(Strings.ShowArea), Description = nameof(Strings.ShowAlertAreaDescription), Order = 530)]
		public bool ShowAlertArea { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ColorBeforeCandle), Name = nameof(Strings.AreaColor), Description = nameof(Strings.LabelFillColorDescription), Order = 540)]
		public Color AreaBeforeColor
		{
			get => _areaBeforeColor.Convert();
			set => _areaBeforeColor = value.Convert();
		} 

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ColorBeforeCandle), Name = nameof(Strings.TextColor), Description = nameof(Strings.LabelTextColorDescription), Order = 550)]
		public Color TextBeforeColor
		{
			get => _textBeforeColor.Convert();
			set => _textBeforeColor = value.Convert();
		}

		#endregion

		#region ctor

		public BarTimer()
			: base(true)
		{
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Final);

			_lastBar = -1;
			OffsetX = 10;
			OffsetY = 15;
			Size = 15;
			TimeLocation = Location.BottomRight;
			TextColor = CrossColor.FromArgb(218, 0, 128, 0);
			BackGroundColor = CrossColorExtensions.FromRgb(220, 220, 220);

			DataSeries[0].IsHidden = true;
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
		}

		#endregion

		#region Protected methods
		
		protected override void OnCalculate(int bar, decimal value)
		{
			var frameType = ChartInfo.ChartType;
			var candle = GetCandle(bar);

			if (bar == 0)
			{
				_lastBeforeAlert = -1;
				_customOffset = 0;
				_timeDiff = TimeSpan.Zero;
				_offsetIsSet = false;
				_barLength = CalculateBarLength();

				if (frameType != "Seconds"
				    && frameType != "Tick"
				    && frameType != "Volume"
				    && frameType != "TimeFrame")
					_isUnsupportedTimeFrame = true;
				
				_lastBar = CurrentBar - 1;

				return;
			}

			if (bar != CurrentBar - 1)
				return;

			if (!_offsetIsSet && _lastBar == bar)
				_offsetIsSet = true;

            if (UseAlert && _lastBar != bar && bar == CurrentBar - 1 && _offsetIsSet)
	            AddAlert(AlertFile, InstrumentInfo.Instrument, "New bar", AlertBackgroundColor, AlertTextColor);

            if (_isUnsupportedTimeFrame)
            {
	            _lastBar = bar;
	            return;
            }

            if (frameType is "Seconds" or "TimeFrame")
				_endTime = candle.Time.AddSeconds(_barLength);

			

			var lastCandle = GetCandle(bar);

			_timeDiff = MarketTime - lastCandle.LastTime;

			_lastBar = bar;
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			if (ChartInfo is null)
				return;

			if (CurrentBar < 0)
				return;

			var candle = GetCandle(CurrentBar - 1);

			var isBarTimerMode = TimeMode == Mode.TimeToEndOfCandle;

			var format = TimeFormat switch
			{
				Format.HHMMSS => isBarTimerMode ? @"hh\:mm\:ss" : "HH:mm:ss",
				Format.HHMMSSPM => isBarTimerMode ? @"hh\:mm\:ss" : "hh:mm:ss tt",
				Format.MMSS => @"mm\:ss",
				_ => ""
			};

			var renderText = "";

			if (isBarTimerMode)
			{
				if (!_offsetIsSet)
					renderText = Strings.WaitingForNewTick;

				if (_isUnsupportedTimeFrame)
					renderText = Strings.OnlyAlertsSupported;

				switch (ChartInfo.ChartType)
				{
					case "Tick":
						renderText = $"{_barLength - candle.Ticks:0.##} ticks";
						break;

					case "Volume":
						renderText = $"{_barLength - candle.Volume:0.##} lots";
						break;
					case "Seconds":
					case "TimeFrame":
						if (string.IsNullOrEmpty(renderText))
						{
							var diff = CurrentDifference();

							if (UseAlertBefore || ShowAlertArea)
							{
								var seconds = diff.TotalSeconds;

								if (seconds <= AlertBeforeSeconds && _lastBeforeAlert != CurrentBar - 1)
								{
									if (UseAlertBefore && _lastBeforeAlert != CurrentBar - 1)
										AddAlert(AlertBeforeFile, InstrumentInfo.Instrument, $"New bar incoming: {seconds:0.} seconds", _areaBeforeColor,
											_textBeforeColor);

									_lastBeforeAlert = CurrentBar - 1;
								}
							}

							if (diff.TotalSeconds < 0)
								diff = new TimeSpan();

							renderText = diff.ToString(
								format != ""
									? format
									: diff.Hours == 0
										? @"mm\:ss"
										: @"hh\:mm\:ss"
								, CultureInfo.InvariantCulture);
						}

						break;
				}
			}

			if (!isBarTimerMode)
			{
				var time = MarketTime.AddHours(_customOffset + InstrumentInfo.TimeZone + CustomTimeZone);

				renderText = time.ToString(
					format != ""
						? format
						: @"HH\:mm\:ss"
					, CultureInfo.InvariantCulture);
			}

			var size = context.MeasureString(renderText, _font);
			var height = size.Height;
			var width = size.Width + 10;
			var rect = new Rectangle();

			var x0 = Container.Region.X;
			var y0 = Container.Region.Y;

			switch (TimeLocation)
			{
				case Location.TopLeft:
					rect = new Rectangle(x0 + OffsetX, y0 + OffsetY, width, height);
					break;
				case Location.TopRight:
					rect = new Rectangle(x0 + Container.Region.Width - width - OffsetX, y0 + OffsetY, width, height);
					break;
				case Location.BottomLeft:
					rect = new Rectangle(x0 + OffsetX, y0 + Container.Region.Height - OffsetY - height, width, height);
					break;
				case Location.BottomRight:
					rect = new Rectangle(x0 + Container.Region.Width - width - OffsetX, y0 + Container.Region.Height - OffsetY - height, width, height);
					break;
			}

			var drawAlertArea = ShowAlertArea && _lastBeforeAlert == CurrentBar - 1;

			var bgColor = drawAlertArea
				? AreaBeforeColor
				: _backGroundColor;

			var textColor = drawAlertArea
				? TextBeforeColor
				: _textColor;

			context.FillRectangle(bgColor, rect);
			context.DrawString(renderText, _font, textColor, rect, _format);
		}

		protected override void OnInitialize()
		{
			SubscribeToTimer(_timerLength, Redraw);
        }
		
		protected override void OnDispose()
		{
			UnsubscribeFromTimer(_timerLength, Redraw);
		}

		#endregion

        #region Private methods
		
        private void Redraw()
        {
	        RedrawChart();
        }

        private TimeSpan CurrentDifference()
		{
			return _endTime - MarketTime + _timeDiff;
		}

		private int CalculateBarLength()
		{
			if (ChartInfo.ChartType == "Seconds")
				return int.Parse(ChartInfo.TimeFrame);

			if (ChartInfo.ChartType == "TimeFrame")
			{
				if (ChartInfo.TimeFrame.Contains("M"))
					return int.Parse(ChartInfo.TimeFrame.Replace("M", "")) * 60;

				if (ChartInfo.TimeFrame.Contains("H"))
					return int.Parse(ChartInfo.TimeFrame.Replace("H", "")) * 3600;

				if (ChartInfo.TimeFrame == "Daily")
					return _daySeconds;

				if (ChartInfo.TimeFrame == "Weekly")
					return _weekSeconds;
			}

			if (ChartInfo.ChartType is "Tick" or "Volume")
				return int.Parse(ChartInfo.TimeFrame);

			return 0;
		}

		#endregion
	}
}






Technical/BarVolumeFilter.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[Category(IndicatorCategories.VolumeOrderFlow)]
[DisplayName("Bar's Volume Filter")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.BarVolumeFilterDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602326")]
public class BarVolumeFilter : Indicator
{
	#region Nested types

	public enum VolumeType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
		Volume,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
		Ticks,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Delta))]
		Delta,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
		Bid,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
		Ask
	}

	#endregion

	#region Fields
	
	private readonly PaintbarsDataSeries _paintBars = new("PaintBars", "Paint bars");
	private CrossColor _color = DefaultColors.Orange.Convert();
	private TimeSpan _endTime;
	private TimeSpan _startTime;
	private int _targetBar;
	private bool _timeFilterEnabled;
	private VolumeType _volumeType;

    #endregion

    #region Properties

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Type), Description = nameof(Strings.VolumeTypeDescription), Order = 5)]
	public VolumeType Type
	{
		get => _volumeType;
		set
		{
			_volumeType = value;
			RecalculateValues();
		}
	}

	[Browsable(false)]
	public decimal MinFilter
	{
		get => MinimumFilter.Value;
		set
		{
			MinimumFilter.Value = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Minimum), Description = nameof(Strings.MinimumFilterDescription), Order = 10)]
	public Filter MinimumFilter { get; set; } = new()
		{ Value = 0, Enabled = false };

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Maximum), Description = nameof(Strings.MaximumFilterDescription), Order = 20)]
	public Filter MaximumFilter { get; set; } = new()
		{ Value = 100 };

	[Browsable(false)]
	public decimal MaxFilter
	{
		get => MaximumFilter.Value;
		set
		{
			MaximumFilter.Value = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Color), Description = nameof(Strings.FilterCandleColorDescription), Order = 40)]
	public CrossColor FilterColor
	{
		get => _color;
		set
		{
			_color = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeFilter), Name = nameof(Strings.Enabled), Description = nameof(Strings.UseTimeFilterDescription), Order = 100)]
	public bool TimeFilterEnabled
	{
		get => _timeFilterEnabled;
		set
		{
			_timeFilterEnabled = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeFilter), Name = nameof(Strings.StartTime), Description = nameof(Strings.StartTimeFilterDescription), Order = 110)]
	public TimeSpan StartTime
	{
		get => _startTime;
		set
		{
			_startTime = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeFilter), Name = nameof(Strings.EndTime), Description = nameof(Strings.EndTimeFilterDescription), Order = 120)]
	public TimeSpan EndTime
	{
		get => _endTime;
		set
		{
			_endTime = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public BarVolumeFilter()
		: base(true)
	{
		DataSeries[0] = _paintBars;
		_paintBars.IsHidden = true;
		DenyToChangePanel = true;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_paintBars.Clear();
			_targetBar = 0;
		}

		if (bar < _targetBar)
			return;

		var candle = GetCandle(bar);
		decimal volume;

		switch (Type)
		{
			case VolumeType.Volume:
			{
				volume = candle.Volume;
				break;
			}
			case VolumeType.Ticks:
			{
				volume = candle.Ticks;
				break;
			}
			case VolumeType.Delta:
			{
				volume = candle.Delta;
				break;
			}
			case VolumeType.Bid:
			{
				volume = candle.Bid;
				break;
			}
			case VolumeType.Ask:
			{
				volume = candle.Ask;
				break;
			}
			default:
				throw new ArgumentOutOfRangeException();
		}

		var filtered = (!MinimumFilter.Enabled || volume >= MinimumFilter.Value) && (!MaximumFilter.Enabled || volume <= MaximumFilter.Value);

		if (TimeFilterEnabled && filtered)
		{
			var time = candle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay;
			var lastTime = candle.LastTime.AddHours(InstrumentInfo.TimeZone).TimeOfDay;

			if (StartTime <= EndTime)
				filtered = (StartTime <= time || StartTime <= lastTime) && time < EndTime;
			else
			{
				filtered = (StartTime <= lastTime && time >= StartTime && time > EndTime)
					||
					((EndTime >= time || EndTime >= lastTime) && time < EndTime);
			}
		}

		_paintBars[bar] = filtered ? _color : null;
	}

	protected override void OnInitialize()
	{
		MaximumFilter.PropertyChanged += (a, b) =>
		{
			RecalculateValues();
			RedrawChart();
		};

		MinimumFilter.PropertyChanged += (a, b) =>
		{
			RecalculateValues();
			RedrawChart();
		};
	}

	#endregion
}








Technical/BarsPattern.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bars Pattern")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BarsPatternDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602328")]
	public class BarsPattern : Indicator
	{
		#region Nested types

		public enum Direction
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Disabled))]
			Disabled = 0,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bullish))]
			Bull = 1,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bearlish))]
			Bear = 2,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Dodge))]
			Dodge = 3
		}

		public enum MaxVolumeLocation
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Disabled))]
			Disabled = 0,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UpperWick))]
			UpperWick = 1,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LowerWick))]
			LowerWick = 2,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Body))]
			Body = 3
		}

		#endregion

		#region Fields

		private readonly PaintbarsDataSeries _paintBars = new("PaintBars", "ColoredSeries");

		private Direction _barDirection;
		private CrossColor _dataSeriesColor;
		private int _lastBar;
		private MaxVolumeLocation _maxVolumeLocation;

        #endregion

        #region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Volume), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 10)]
		public Filter MinVolume { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Volume), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 11)]
		public Filter MaxVolume { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Range(1, int.MaxValue)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VolumeMoreNBars), GroupName = nameof(Strings.Volume), Order = 13)]
		public FilterInt LastBarsVolume { get; set; } = new()
			{ Value = 5, Enabled = false };

		[Range(1, int.MaxValue)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VolumeMoreSma), GroupName = nameof(Strings.Volume), Order = 15)]
		public FilterInt LastBarsSMAVolume { get; set; } = new()
			{ Value = 5, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumBid), GroupName = nameof(Strings.DepthMarket), Description = nameof(Strings.MinBidVolumeFilterCommonDescription), Order = 20)]
		public Filter MinBid { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumBid), GroupName = nameof(Strings.DepthMarket), Description = nameof(Strings.MaxBidVolumeFilterCommonDescription), Order = 21)]
		public Filter MaxBid { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumAsk), GroupName = nameof(Strings.DepthMarket), Description = nameof(Strings.MinAskVolumeFilterCommonDescription), Order = 22)]
		public Filter MinAsk { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumAsk), GroupName = nameof(Strings.DepthMarket), Description = nameof(Strings.MaxAskVolumeFilterCommonDescription), Order = 23)]
		public Filter MaxAsk { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumDelta), GroupName = nameof(Strings.DepthMarket), Description = nameof(Strings.MinDeltaVolumeFilterCommonDescription), Order = 24)]
		public Filter MinDelta { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumDelta), GroupName = nameof(Strings.DepthMarket), Description = nameof(Strings.MaxDeltaVolumeFilterCommonDescription), Order = 25)]
		public Filter MaxDelta { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumTrades), GroupName = nameof(Strings.Trades), Description = nameof(Strings.MinTickVolumeFilterCommonDescription), Order = 30)]
		public Filter MinTrades { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumTrades), GroupName = nameof(Strings.Trades), Description = nameof(Strings.MaxTickVolumeFilterCommonDescription), Order = 31)]
		public Filter MaxTrades { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BarsDirection), GroupName = nameof(Strings.BarsDirection), Description = nameof(Strings.BarDirectionDescription), Order = 41)]
		public Direction BarDirection
		{
			get => _barDirection;
			set
			{
				_barDirection = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxVolumeLocation), GroupName = nameof(Strings.MaximumVolume), Description = nameof(Strings.MaxVolumeLocationDescription), Order = 51)]
		public MaxVolumeLocation MaxVolLocation
		{
			get => _maxVolumeLocation;
			set
			{
				_maxVolumeLocation = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumCandleHeight), GroupName = nameof(Strings.CandleHeight), Description = nameof(Strings.MinCandleHeightFilterDescription), Order = 60)]
		public Filter MinCandleHeight { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumCandleHeight), GroupName = nameof(Strings.CandleHeight), Description = nameof(Strings.MaxCandleHeightFilterDescription), Order = 61)]
		public Filter MaxCandleHeight { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumCandleBodyHeight), GroupName = nameof(Strings.CandleHeight), Description = nameof(Strings.MinCandleBodyHeightFilterDescription), Order = 70)]
		public Filter MinCandleBodyHeight { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumCandleBodyHeight), GroupName = nameof(Strings.CandleHeight), Description = nameof(Strings.MaxCandleBodyHeightFilterDescription), Order = 71)]
		public Filter MaxCandleBodyHeight { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Range(0, int.MaxValue)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumCandleWickHeight), GroupName = nameof(Strings.CandleHeight), Order = 73)]
		public Filter MinCandleWickHeight { get; set; } = new()
			{ Value = 0, Enabled = false };

		[Range(0, int.MaxValue)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumCandleWickHeight), GroupName = nameof(Strings.CandleHeight), Order = 75)]
		public Filter MaxCandleWickHeight { get; set; } = new()
			{ Value = 0, Enabled = false };

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription), Order = 101)]
        public bool UseAlerts { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 102)]
        public string AlertFile { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.FilterCandleColorDescription))]
        public CrossColor Color
        {
            get => _dataSeriesColor;
            set
            {
                _dataSeriesColor = value;
                RecalculateValues();
            }
        }

        #endregion

        #region ctor

        public BarsPattern()
			: base(true)
		{
			_lastBar = 0;
			_dataSeriesColor = DefaultColors.Blue.Convert();
			_paintBars.IsHidden = true;
			DenyToChangePanel = true;
			DataSeries[0] = _paintBars;
		}

		#endregion

		private decimal _avgVol;
		private decimal _volSum;

		#region Protected methods

		protected override void OnRecalculate()
		{
			_paintBars.Clear();
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			if (_lastBar == bar)
			{
				_paintBars[bar] = null;
			}
			else
			{
				_lastBar = bar;

				var volSum = 0m;

				for (var i = Math.Max(0, bar - LastBarsVolume.Value); i < bar; i++)
				{
					var avgCandle = GetCandle(i);
					volSum += avgCandle.Volume;
				}

				_volSum = volSum;

				volSum = 0;

				for (var i = Math.Max(0, bar - LastBarsSMAVolume.Value); i < bar; i++)
				{
					var avgCandle = GetCandle(i);
					volSum += avgCandle.Volume;
				}

				_avgVol = volSum / LastBarsSMAVolume.Value;


                if (bar > 0 && bar == CurrentBar - 1 && UseAlerts && _paintBars[bar - 1] != null) 
					AddAlert(AlertFile, "The bar is appropriate");
			}

			if (MaxVolume.Enabled && candle.Volume > MaxVolume.Value)
				return;

			if (MinVolume.Enabled && candle.Volume < MinVolume.Value)
				return;

			if(LastBarsVolume.Enabled && candle.Volume <= _volSum)
				return;

			if (LastBarsSMAVolume.Enabled && candle.Volume <= _avgVol)
				return;

            if (MaxBid.Enabled && candle.Bid > MaxBid.Value)
				return;

			if (MinBid.Enabled && candle.Bid < MinBid.Value)
				return;

			if (MaxAsk.Enabled && candle.Ask > MaxAsk.Value)
				return;

			if (MinAsk.Enabled && candle.Ask < MinAsk.Value)
				return;

			if (MaxDelta.Enabled && candle.Delta > MaxDelta.Value)
				return;

			if (MinDelta.Enabled && candle.Delta < MinDelta.Value)
				return;

			if (MaxTrades.Enabled && candle.Ticks > MaxTrades.Value)
				return;

			if (MinTrades.Enabled && candle.Ticks < MinTrades.Value)
				return;

			if (BarDirection != 0)
			{
				switch (BarDirection)
				{
					case Direction.Bear:
						if (candle.Open <= candle.Close)
							return;

						break;

					case Direction.Bull:
						if (candle.Open >= candle.Close)
							return;

						break;

					case Direction.Dodge:
						if (candle.Open != candle.Close)
							return;

						break;
				}
			}

			if (MaxVolLocation != 0)
			{
				var maxVolPrice = candle.MaxVolumePriceInfo.Price;
				var maxBody = Math.Max(candle.Open, candle.Close);
				var minBody = Math.Min(candle.Open, candle.Close);

				switch (MaxVolLocation)
				{
					case MaxVolumeLocation.Body:
						if (maxVolPrice < minBody || maxVolPrice > maxBody)
							return;

						break;

					case MaxVolumeLocation.UpperWick:
						if (maxVolPrice <= maxBody)
							return;

						break;

					case MaxVolumeLocation.LowerWick:
						if (maxVolPrice >= minBody)
							return;

						break;
				}
			}

			if (MinCandleHeight.Enabled)
			{
				var height = (candle.High - candle.Low) / ChartInfo.PriceChartContainer.Step;

				if (height < MinCandleHeight.Value)
					return;
			}

			if (MaxCandleHeight.Enabled)
			{
				var height = (candle.High - candle.Low) / ChartInfo.PriceChartContainer.Step;

				if (height > MaxCandleHeight.Value)
					return;
			}

			if (MinCandleBodyHeight.Enabled)
			{
				var bodyHeight = Math.Abs(candle.Open - candle.Close) / ChartInfo.PriceChartContainer.Step;

				if (bodyHeight < MinCandleBodyHeight.Value)
					return;
			}

			if (MaxCandleBodyHeight.Enabled)
			{
				var bodyHeight = Math.Abs(candle.Open - candle.Close) / ChartInfo.PriceChartContainer.Step;

				if (bodyHeight > MaxCandleBodyHeight.Value)
					return;
			}

			if (MinCandleWickHeight.Enabled || MaxCandleWickHeight.Enabled)
			{
				var topBody = Math.Max(candle.Open, candle.Close);
				var botBody = Math.Min(candle.Open, candle.Close);
				var maxWick = Math.Max(candle.High - topBody, botBody - candle.Low) / InstrumentInfo.TickSize;

				if (MinCandleWickHeight.Enabled && maxWick < MinCandleWickHeight.Value)
					return;

				if (MaxCandleWickHeight.Enabled && maxWick > MaxCandleWickHeight.Value)
					return;
			}

			_paintBars[bar] = _dataSeriesColor;
		}

		protected override void OnInitialize()
		{
			MaxVolume.PropertyChanged += Filter_PropertyChanged;
			MinVolume.PropertyChanged += Filter_PropertyChanged;
			LastBarsVolume.PropertyChanged += Filter_PropertyChanged;
			LastBarsSMAVolume.PropertyChanged += Filter_PropertyChanged;

			MaxBid.PropertyChanged += Filter_PropertyChanged;
			MinBid.PropertyChanged += Filter_PropertyChanged;
			MaxAsk.PropertyChanged += Filter_PropertyChanged;
			MinAsk.PropertyChanged += Filter_PropertyChanged;

			MaxDelta.PropertyChanged += Filter_PropertyChanged;
			MinDelta.PropertyChanged += Filter_PropertyChanged;
			MaxTrades.PropertyChanged += Filter_PropertyChanged;
			MinTrades.PropertyChanged += Filter_PropertyChanged;

			MaxCandleHeight.PropertyChanged += Filter_PropertyChanged;
			MinCandleHeight.PropertyChanged += Filter_PropertyChanged;
			MaxCandleBodyHeight.PropertyChanged += Filter_PropertyChanged;
			MinCandleBodyHeight.PropertyChanged += Filter_PropertyChanged;
			MaxCandleWickHeight.PropertyChanged += Filter_PropertyChanged;
			MinCandleWickHeight.PropertyChanged += Filter_PropertyChanged;
        }

		#endregion

		public override void Dispose()
		{
			MaxVolume.PropertyChanged -= Filter_PropertyChanged;
			MinVolume.PropertyChanged -= Filter_PropertyChanged;
			LastBarsVolume.PropertyChanged -= Filter_PropertyChanged;
			LastBarsSMAVolume.PropertyChanged -= Filter_PropertyChanged;

			MaxBid.PropertyChanged -= Filter_PropertyChanged;
			MinBid.PropertyChanged -= Filter_PropertyChanged;
			MaxAsk.PropertyChanged -= Filter_PropertyChanged;
			MinAsk.PropertyChanged -= Filter_PropertyChanged;

			MaxDelta.PropertyChanged -= Filter_PropertyChanged;
			MinDelta.PropertyChanged -= Filter_PropertyChanged;
			MaxTrades.PropertyChanged -= Filter_PropertyChanged;
			MinTrades.PropertyChanged -= Filter_PropertyChanged;

			MaxCandleHeight.PropertyChanged -= Filter_PropertyChanged;
			MinCandleHeight.PropertyChanged -= Filter_PropertyChanged;
			MaxCandleBodyHeight.PropertyChanged -= Filter_PropertyChanged;
			MinCandleBodyHeight.PropertyChanged -= Filter_PropertyChanged;
			MaxCandleWickHeight.PropertyChanged -= Filter_PropertyChanged;
			MinCandleWickHeight.PropertyChanged -= Filter_PropertyChanged;
        }

		#region Private methods

		private void Filter_PropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			RecalculateValues();
			RedrawChart();
		}

		#endregion
	}
}








Technical/BidAsk.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;

[DisplayName("Bid Ask")]
[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.BidAskDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602329")]
public class BidAsk : Indicator
{
	#region Fields

	private readonly ValueDataSeries _asks = new("Asks", Strings.Ask)
	{
		VisualType = VisualMode.Histogram,
		Color = DefaultColors.Green.Convert(),
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true,
		DescriptionKey = nameof(Strings.AskVisualizationSettingsDescription)
    };

	private readonly ValueDataSeries _bids = new("Bids", Strings.Bid)
	{
		VisualType = VisualMode.Histogram,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true,
		DescriptionKey = nameof(Strings.BidVisualizationSettingsDescription)
    };

	#endregion

	#region ctor

	public BidAsk()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DenyToChangePanel = true;
		DataSeries[0] = _bids;
		DataSeries.Add(_asks);
	}

	#endregion

	#region Public methods

	public override string ToString()
	{
		return "Bid Ask";
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);
		_bids[bar] = -candle.Bid;
		_asks[bar] = candle.Ask;
	}
	
	protected override void OnApplyDefaultColors()
	{
		if(ChartInfo is null)
			return;

		_bids.Color = ChartInfo.ColorsStore.FootprintBidColor.Convert();
		_asks.Color = ChartInfo.ColorsStore.FootprintAskColor.Convert();
	}

	#endregion
}







Technical/BidAskVR.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Bid Ask Volume Ratio")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.BidAskVRDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602330")]
public class BidAskVR : Indicator
{
	#region Nested types

	public enum Mode
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskBid))]
		AskBid,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidAsk))]
		BidAsk
	}

	public enum MovingType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA))]
		Ema,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LinearReg))]
		LinReg,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA))]
		Wma,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA))]
		Sma,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMMA))]
		Smma
	}

	#endregion

	#region Fields

	private readonly ValueDataSeries _vr = new("VR");
    private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
    {
        VisualType = VisualMode.Histogram,
        ShowZeroValue = false,
        UseMinimizedModeIfEnabled = true,
        ResetAlertsOnNewBar = true
    };

    private Mode _calcMode;
	private decimal _lastBar;
	private Color _lowColor = DefaultColors.Maroon;
	private Color _lowerColor = DefaultColors.Red;
    private Color _upColor = DefaultColors.Green;
    private Color _upperColor = DefaultColors.Lime;

    private object _movingIndicator;
	private MovingType _movingType;
	private int _period;
	private decimal _prevValue;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Upper), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.UpperPositiveValueColorDescription), Order = 610)]
	public CrossColor UpperColor
	{
		get => _upperColor.Convert();
		set
		{
			_upperColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 620)]
	public CrossColor UpColor
	{
		get => _upColor.Convert();
		set
		{
			_upColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 630)]
    public CrossColor LowColor
	{
		get => _lowColor.Convert();
		set
		{
			_lowColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Lower), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LowerNegativeValueColorDescription), Order = 640)]
	public CrossColor LowerColor
	{
		get => _lowerColor.Convert();
		set
		{
			_lowerColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MovingType), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MovingTypeDescription), Order = 100)]
	public MovingType MaType
	{
		get => _movingType;
		set
		{
			_movingType = value;
			RecalculateValues();
		}
	}

    [Parameter]
	[Range(1, 10000)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 120)]
	public Mode CalcMode
	{
		get => _calcMode;
		set
		{
			_calcMode = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public BidAskVR()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		_period = 10;
		DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnRecalculate()
	{
		switch (_movingType)
		{
			case MovingType.Ema:
				_movingIndicator = new EMA
					{ Period = _period };
				break;
			case MovingType.LinReg:
				_movingIndicator = new LinearReg
					{ Period = _period };
				break;
			case MovingType.Wma:
				_movingIndicator = new WMA
					{ Period = _period };
				break;
			case MovingType.Sma:
				_movingIndicator = new SMA
					{ Period = _period };
				break;
			case MovingType.Smma:
				_movingIndicator = new SMMA
					{ Period = _period };
				break;
		}

		_prevValue = 0;
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		var diff = _calcMode == Mode.AskBid
			? candle.Ask - candle.Bid
			: candle.Bid - candle.Ask;

		if (candle.Ask + candle.Bid != 0)
			_vr[bar] = 100 * diff / (candle.Ask + candle.Bid);

		var maValue = 0m;

		if (bar < _period && bar > 0)
		{
			if (_prevValue == 0)
				maValue = 2m / (bar + 2) * _vr[bar] + (1 - 2m / (bar + 2)) * _vr[bar - 1];
			else
				maValue = 2m / (bar + 2) * _vr[bar] + (1 - 2m / (bar + 2)) * _prevValue;
		}

		if (bar >= _period)
			maValue = IndicatorCalculate(bar, _movingType, _vr[bar]);

		_renderSeries[bar] = maValue;

		SetColor(bar, maValue);

		if (bar != _lastBar)
			_prevValue = maValue;

		_lastBar = bar;
	}

	#endregion

	#region Private methods

	private void SetColor(int bar, decimal maValue)
	{
		if (maValue > 0)
			_renderSeries.Colors[bar] = maValue >= _prevValue ? _upperColor : _upColor;
		else
			_renderSeries.Colors[bar] = maValue <= _prevValue ? _lowerColor : _lowColor;
	}

	private decimal IndicatorCalculate(int bar, MovingType type, decimal value)
	{
		var movingValue = 0m;

		switch (type)
		{
			case MovingType.Ema:
				movingValue = ((EMA)_movingIndicator).Calculate(bar, value);
				break;
			case MovingType.LinReg:
				movingValue = ((LinearReg)_movingIndicator).Calculate(bar, value);
				break;
			case MovingType.Wma:
				movingValue = ((WMA)_movingIndicator).Calculate(bar, value);
				break;
			case MovingType.Sma:
				movingValue = ((SMA)_movingIndicator).Calculate(bar, value);
				break;
			case MovingType.Smma:
				movingValue = ((SMMA)_movingIndicator).Calculate(bar, value);
				break;
		}

		return movingValue;
	}

	#endregion
}








Technical/BlockMA.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;

[DisplayName("Block Moving Average")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.BlockMADescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602335")]
public class BlockMA : Indicator
{
	#region Fields

	private readonly ATR _atr = new();

	private readonly ValueDataSeries _bot1 = new("bot1");
	private readonly ValueDataSeries _bot2 = new("bot2");
	private readonly ValueDataSeries _mid1 = new("Mid1", Strings.FirstLine);
	private readonly ValueDataSeries _mid2 = new("Mid2", Strings.SecondLine);

	private readonly ValueDataSeries _top1 = new("top1");
	private readonly ValueDataSeries _top2 = new("top2");
	private decimal _multiplier1;
	private decimal _multiplier2;

        #endregion

        #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ATR), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
	[Range(1,1000000)]
	public int Period
	{
		get => _atr.Period;
		set
		{
			_atr.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier1), GroupName = nameof(Strings.Settings), Description = nameof(Strings.Multiplier1Description), Order = 110)]
	[Range(0.0001, 100000)]
	public decimal Multiplier1
	{
		get => _multiplier1;
		set
		{
			_multiplier1 = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier2), GroupName = nameof(Strings.Settings), Description = nameof(Strings.Multiplier2Description), Order = 120)]
	[Range(0.0001, 100000)]
	public decimal Multiplier2
	{
		get => _multiplier2;
		set
		{
			_multiplier2 = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public BlockMA()
		: base(true)
	{
		_atr.Period = 10;
		_multiplier1 = 1;
		_multiplier2 = 2;

		_mid1.Color = DefaultColors.Red.Convert();
		_mid2.Color = DefaultColors.Green.Convert();

		_mid1.ShowZeroValue = _mid2.ShowZeroValue = false;

		Add(_atr);
		DataSeries[0] = _mid1;
		DataSeries.Add(_mid2);
	}

	#endregion

	#region Protected methods

	protected override void OnRecalculate()
	{
		_top1.Clear();
		_top2.Clear();
		_mid1.Clear();
		_mid2.Clear();
		_bot1.Clear();
		_bot2.Clear();
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar < _atr.Period)
			return;

		var box1 = _multiplier1 * _atr[bar] / 2;
		var box2 = _multiplier2 * _atr[bar] / 2;

		var candle = GetCandle(bar);

		if (candle.High > _top1[bar - 1])
			_top1[bar] = candle.High;
		else if (candle.Low < _bot1[bar - 1] && candle.High <= _top1[bar - 1])
			_top1[bar] = _bot1[bar] + 2 * box1;
		else
			_top1[bar] = _top1[bar - 1];

		if (candle.High > _top2[bar - 1])
			_top2[bar] = candle.High;
		else if (candle.Low < _bot2[bar - 1] && candle.High <= _top2[bar - 1])
			_top2[bar] = _bot2[bar] + 2 * box2;
		else
			_top2[bar] = _top2[bar - 1];

		if (candle.High > _top1[bar - 1])
			_bot1[bar] = _top1[bar] - 2 * box1;
		else if (candle.Low < _bot1[bar - 1] && candle.High <= _top1[bar - 1])
			_bot1[bar] = candle.Low;
		else
			_bot1[bar] = _bot1[bar - 1];

		if (candle.High > _top2[bar - 1])
			_bot2[bar] = _top2[bar] - 2 * box2;
		else if (candle.Low < _bot2[bar - 1] && candle.High <= _top2[bar - 1])
			_bot2[bar] = candle.Low;
		else
			_bot2[bar] = _bot2[bar - 1];

		if (candle.High > _top1[bar - 1])
			_mid1[bar] = _top1[bar] - box1;
		else if (candle.Low < _bot1[bar - 1] && candle.High <= _top1[bar - 1])
			_mid1[bar] = _bot1[bar] + box1;
		else
			_mid1[bar] = _mid1[bar - 1];

		if (candle.High > _top2[bar - 1])
			_mid2[bar] = _top2[bar] - box2;
		else if (candle.Low < _bot2[bar - 1] && candle.High <= _top2[bar - 1])
			_mid2[bar] = _bot2[bar] + box2;
		else
			_mid2[bar] = _mid2[bar - 1];
	}

	#endregion
}









Technical/BollingerBands.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bollinger Bands")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BollingerBandsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602339")]
	public class BollingerBands : Indicator
	{
		#region Fields

		private readonly RangeDataSeries _band = new("Band", "Background Neutral") 
		{ 
			DescriptionKey = nameof(Strings.ChannelNeutralAreaSettingsDescription) 
		};

		private readonly StdDev _dev = new();

		private readonly ObjectDataSeries _dirSeries = new("direction");

		private readonly RangeDataSeries _downBand = new("DownBand", "Background Down")
		{
			RangeColor = CrossColor.FromArgb(90, 255, 0, 0),
            DescriptionKey = nameof(Strings.ChannelNegativeAreaSettingsDescription)
        };

		private readonly RangeDataSeries _downReserveBand = new("DownReserveBand", "Down Reserve")
		{
			RangeColor = CrossColor.FromArgb(90, 255, 0, 0)
		};

		private readonly ValueDataSeries _downSeries = new("DownSeries", "Down")
		{
			VisualType = VisualMode.Line,
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BottomChannelSettingsDescription)
        };

		private readonly RangeDataSeries _reserveBand = new("ReserveBand", "Neutral Reserve");

		private readonly SMA _sma = new();

		private readonly ValueDataSeries _smaSeries = new("SmaSeries", "Bollinger Bands")
		{
			Color = DefaultColors.Green.Convert(),
			DescriptionKey = nameof(Strings.MidChannelSettingsDescription)
		};

		private readonly RangeDataSeries _upBand = new("UpBand", "Background Up")
		{
			RangeColor = CrossColor.FromArgb(90, 0, 255, 0),
            DescriptionKey = nameof(Strings.ChannelPositiveAreaSettingsDescription)
        };

		private readonly RangeDataSeries _upReserveBand = new("UpReserveBand", "Up Reserve")
		{
			RangeColor = CrossColor.FromArgb(90, 0, 255, 0)
		};

		private readonly ValueDataSeries _upSeries = new("UpSeries", "Up")
		{
			VisualType = VisualMode.Line,
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.TopChannelSettingsDescription)
        };

		private int _lastAlertBot;
		private int _lastAlertMid;
		private int _lastAlertTop;
		private int _lastBar;
		private bool _onLineBot;
		private bool _onLineMid;
		private bool _onLineTop;
		private int _shift;
		private decimal _width;

		#endregion

		#region Properties

		[Parameter]
        [Range(0, 100000)]
        [Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = _dev.Period = value;
				RecalculateValues();
			}
		}

		[Parameter]
        [Range(0, 100000)]
        [Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BBandsWidth),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.DeviationRangeDescription),
            Order = 22)]
		public decimal Width
		{
			get => _width;
			set
			{
				_width = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Shift),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.BarShiftDescription),
            Order = 24)]
		public int Shift
		{
			get => _shift;
			set
			{
				_shift = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 100)]
		public bool UseAlertsTop { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 110)]
		public bool RepeatAlertTop { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 120)]
		[Range(0, 100000)]
		public int AlertSensitivityTop { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 130)]
		public string AlertFileTop { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 140)]
		public CrossColor FontColorTop { get; set; } = DefaultColors.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 150)]
		public CrossColor BackgroundColorTop { get; set; } = DefaultColors.Gray.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 200)]
		public bool UseAlertsMid { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 210)]
		public bool RepeatAlertMid { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 220)]
		[Range(0, 100000)]
		public int AlertSensitivityMid { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 230)]
		public string AlertFileMid { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 240)]
		public CrossColor FontColorMid { get; set; } = DefaultColors.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 250)]
		public CrossColor BackgroundColorMid { get; set; } = DefaultColors.Gray.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 300)]
		public bool UseAlertsBot { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 310)]
		public bool RepeatAlertBot { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 320)]
		[Range(0, 100000)]
		public int AlertSensitivityBot { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 330)]
		public string AlertFileBot { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 340)]
		public CrossColor FontColorBot { get; set; } = DefaultColors.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 350)]
		public CrossColor BackgroundColorBot { get; set; } = DefaultColors.Gray.Convert();

		#endregion

		#region ctor

		public BollingerBands()
		{
			DataSeries[0] = _smaSeries;

			DataSeries.Add(_upSeries);
			DataSeries.Add(_downSeries);

			_reserveBand.IsHidden = _upReserveBand.IsHidden = _downReserveBand.IsHidden = true;

			_reserveBand.RangeColor = _band.RangeColor;
			_upReserveBand.RangeColor = _upBand.RangeColor;
			_downReserveBand.RangeColor = _downBand.RangeColor;

			_band.PropertyChanged += RangeChanged;
			_upBand.PropertyChanged += RangeChanged;
			_downBand.PropertyChanged += RangeChanged;
			DataSeries.Add(_band);
			DataSeries.Add(_reserveBand);
			DataSeries.Add(_upBand);
			DataSeries.Add(_upReserveBand);
			DataSeries.Add(_downBand);
			DataSeries.Add(_downReserveBand);
			Period = 10;
			Width = 1;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var sma = _sma.Calculate(bar, value);
			var dev = _dev.Calculate(bar, value);

			if (bar == 0)
			{
				_dirSeries.Clear();
				DataSeries.ForEach(x => x.Clear());

				var startBar = Math.Max(0, Shift);

				if (startBar != 0)
				{
					_smaSeries.SetPointOfEndLine(startBar - 1);
					_upSeries.SetPointOfEndLine(startBar - 1);
					_downSeries.SetPointOfEndLine(startBar - 1);
				}
			}

			if (bar < Shift)
				return;

			var calcBar = bar;


			if (Shift < 0)
			{
				calcBar = bar + Shift;
				_smaSeries[bar + Shift] = sma;
				_upSeries[bar + Shift] = sma + dev * Width;
				_downSeries[bar + Shift] = sma - dev * Width;

				if (bar == CurrentBar - 1)
				{
					for (var i = bar + Shift + 1; i < CurrentBar; i++)
					{
						_smaSeries[i] = _smaSeries[bar + Shift];
						_upSeries[i] = _upSeries[bar + Shift];
						_downSeries[i] = _downSeries[bar + Shift];
					}
				}
			}
			else
			{
				_smaSeries[bar] = _sma[bar - Shift];
				_upSeries[bar] = _sma[bar - Shift] + _dev[bar - Shift] * Width;
				_downSeries[bar] = _sma[bar - Shift] - _dev[bar - Shift] * Width;
			}

			if (_lastBar != bar && calcBar != 0)
				CalcPaint(calcBar);

			_lastBar = bar;

			if (bar != CurrentBar - 1)
				return;

			if (UseAlertsTop && (RepeatAlertTop || _lastAlertTop != bar && !RepeatAlertTop))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(_upSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityTop;

				if (onLine && !_onLineTop)
				{
					AddAlert(AlertFileTop, InstrumentInfo.Instrument, "Bollinger top approximation alert", BackgroundColorTop, FontColorTop);
					_lastAlertTop = bar;
				}

				_onLineTop = onLine;
			}

			if (UseAlertsMid && (RepeatAlertMid || _lastAlertMid != bar && !RepeatAlertMid))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(this[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityMid;

				if (onLine && !_onLineMid)
				{
					AddAlert(AlertFileMid, InstrumentInfo.Instrument, "Bollinger middle approximation alert", BackgroundColorMid, FontColorMid);
					_lastAlertMid = bar;
				}

				_onLineMid = onLine;
			}

			if (UseAlertsBot && (RepeatAlertBot || _lastAlertBot != bar && !RepeatAlertBot))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(_downSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityBot;

				if (onLine && !_onLineBot)
				{
					AddAlert(AlertFileTop, InstrumentInfo.Instrument, "Bollinger bottom approximation alert", BackgroundColorBot, FontColorBot);
					_lastAlertBot = bar;
				}

				_onLineBot = onLine;
			}
		}

		#endregion

		#region Private methods

		private void CalcPaint(int bar)
		{
			if (_smaSeries[bar] > _smaSeries[bar - 1])
			{
				_dirSeries[bar] = TradeDirection.Buy;

				if (AltRequired(bar, TradeDirection.Buy))
				{
					_upReserveBand[bar].Upper = _upSeries[bar];
					_upReserveBand[bar].Lower = _downSeries[bar];
					_upReserveBand[bar - 1].Upper = _upSeries[bar - 1];
					_upReserveBand[bar - 1].Lower = _downSeries[bar - 1];
				}
				else
				{
					_upBand[bar].Upper = _upSeries[bar];
					_upBand[bar].Lower = _downSeries[bar];
					_upBand[bar - 1].Upper = _upSeries[bar - 1];
					_upBand[bar - 1].Lower = _downSeries[bar - 1];
				}
			}
			else if (_smaSeries[bar] < _smaSeries[bar - 1])
			{
				_dirSeries[bar] = TradeDirection.Sell;

				if (AltRequired(bar, TradeDirection.Sell))
				{
					_downReserveBand[bar].Upper = _upSeries[bar];
					_downReserveBand[bar].Lower = _downSeries[bar];
					_downReserveBand[bar - 1].Upper = _upSeries[bar - 1];
					_downReserveBand[bar - 1].Lower = _downSeries[bar - 1];
				}
				else
				{
					_downBand[bar].Upper = _upSeries[bar];
					_downBand[bar].Lower = _downSeries[bar];
					_downBand[bar - 1].Upper = _upSeries[bar - 1];
					_downBand[bar - 1].Lower = _downSeries[bar - 1];
				}
			}
			else
			{
				_dirSeries[bar] = TradeDirection.Between;

				if (AltRequired(bar, TradeDirection.Between))
				{
					_reserveBand[bar].Upper = _upSeries[bar];
					_reserveBand[bar].Lower = _downSeries[bar];
					_reserveBand[bar - 1].Upper = _upSeries[bar - 1];
					_reserveBand[bar - 1].Lower = _downSeries[bar - 1];
				}
				else
				{
					_band[bar].Upper = _upSeries[bar];
					_band[bar].Lower = _downSeries[bar];
					_band[bar - 1].Upper = _upSeries[bar - 1];
					_band[bar - 1].Lower = _downSeries[bar - 1];
				}
			}
		}

		private bool AltRequired(int bar, TradeDirection dir)
		{
			if (bar <= 3 + Shift)
				return true;

			var prevAltValue = dir switch
			{
				TradeDirection.Buy => _upReserveBand[bar - 2],
				TradeDirection.Sell => _downReserveBand[bar - 2],
				TradeDirection.Between => _reserveBand[bar - 2],
				_ => throw new ArgumentOutOfRangeException(nameof(dir), dir, null)
			};

			var altRequired = (TradeDirection)_dirSeries[bar - 1] != (TradeDirection)_dirSeries[bar] &&
				(TradeDirection)_dirSeries[bar - 2] == (TradeDirection)_dirSeries[bar];

			return altRequired && prevAltValue.Lower == 0;
		}

		private void RangeChanged(object sender, PropertyChangedEventArgs e)
		{
			if ((RangeDataSeries)sender == _band)
			{
				_reserveBand.RangeColor = _band.RangeColor;
				_reserveBand.Visible = _band.Visible;
				_reserveBand.DrawAbovePrice = _band.DrawAbovePrice;
				_reserveBand.IgnoredByAlerts = _band.IgnoredByAlerts;
			}
			else if ((RangeDataSeries)sender == _upBand)
			{
				_upReserveBand.RangeColor = _upBand.RangeColor;
				_upReserveBand.Visible = _upBand.Visible;
				_upReserveBand.DrawAbovePrice = _upBand.DrawAbovePrice;
				_upReserveBand.IgnoredByAlerts = _upBand.IgnoredByAlerts;
            }
			else if ((RangeDataSeries)sender == _downBand)
			{
				_downReserveBand.RangeColor = _downBand.RangeColor;
				_downReserveBand.Visible = _downBand.Visible;
				_downReserveBand.DrawAbovePrice = _downBand.DrawAbovePrice;
				_downReserveBand.IgnoredByAlerts = _downBand.IgnoredByAlerts;
            }
		}

		#endregion
	}
}








Technical/BollingerBandsBandwidth.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bollinger Bands: Bandwidth")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BollingerBandsBandwidthDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602340")]
	public class BollingerBandsBandwidth : Indicator
	{
		#region Fields

		private readonly BollingerBands _bb = new();

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _bb.Period;
			set
			{
				_bb.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBandsWidth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DeviationRangeDescription), Order = 110)]
		[Range(0.0, 999999)]
		public decimal Width
		{
			get => _bb.Width;
			set
			{
				_bb.Width = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BollingerBandsBandwidth()
		{
			Panel = IndicatorDataProvider.NewPanel;
			_bb.Period = 10;
			_bb.Width = 1;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_bb.Calculate(bar, value);
			var sma = ((ValueDataSeries)_bb.DataSeries[0])[bar];
			var top = ((ValueDataSeries)_bb.DataSeries[1])[bar];
			var bot = ((ValueDataSeries)_bb.DataSeries[2])[bar];

			if (sma == 0)
				return;

			_renderSeries[bar] = 100 * (top - bot) / sma;
		}

		#endregion
	}
}








Technical/BollingerBandsPercent.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bollinger Bands: Percentage")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BollingerBandsPercentDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602336")]
	public class BollingerBandsPercent : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomBand))]
			Bottom,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MiddleBand))]
			Middle
		}

		#endregion

		#region Fields

		private readonly BollingerBands _bb = new();

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private Mode _calcMode;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 100)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		public int Period
		{
			get => _bb.Period;
			set
			{
				_bb.Period = _bb.Period = value;
				RecalculateValues();
			}
		}

        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBandsWidth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DeviationRangeDescription), Order = 120)]
		public decimal Width
		{
			get => _bb.Width;
			set
			{
				_bb.Width = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BollingerBandsPercent()
		{
			Panel = IndicatorDataProvider.NewPanel;

			_bb.Period = 10;
			_bb.Width = 1;
			_calcMode = Mode.Bottom;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_bb.Calculate(bar, value);
			var top = ((ValueDataSeries)_bb.DataSeries[1])[bar];

			switch (_calcMode)
			{
				case Mode.Bottom:
					var bot = ((ValueDataSeries)_bb.DataSeries[2])[bar];

					if (top - bot == 0)
						return;

					_renderSeries[bar] = 100 * (value - bot) / (top - bot);
					break;
				case Mode.Middle:
					var sma = ((ValueDataSeries)_bb.DataSeries[0])[bar];

					if (top - sma == 0)
						return;

					_renderSeries[bar] = 100 * (value - sma) / (top - sma);
					break;
			}
		}

		#endregion
	}
}









Technical/BollingerSqueeze.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bollinger Squeeze")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BollingerSqueezeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602337")]
	public class BollingerSqueeze : Indicator
	{
		#region Fields

		private readonly BollingerBands _bb = new();
		private readonly KeltnerChannel _kb = new();
        private readonly ValueDataSeries _downRatio = new("DownRatio", Strings.LowRatio);
        private readonly ValueDataSeries _upRatio = new("UpRatio", Strings.HighRatio);

        #endregion

        #region Properties

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.BollingerBands), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int BbPeriod
		{
			get => _bb.Period;
			set
			{
				_bb.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBandsWidth), GroupName = nameof(Strings.BollingerBands), Description = nameof(Strings.DeviationRangeDescription), Order = 110)]
		[Range(1, 10000)]
		public decimal BbWidth
		{
			get => _bb.Width;
			set
			{
				_bb.Width = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.KeltnerChannel), Description = nameof(Strings.PeriodDescription), Order = 200)]
		public int KbPeriod
		{
			get => _kb.Period;
			set
			{
				_kb.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetMultiplier), GroupName = nameof(Strings.KeltnerChannel), Description = nameof(Strings.DeviationRangeDescription), Order = 210)]
        [Range(0.00000001, 10000000)]
        public decimal KbMultiplier
		{
			get => _kb.Koef;
			set
			{
				_kb.Koef = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BollingerSqueeze()
		{
			Panel = IndicatorDataProvider.NewPanel;

			_bb.Period = 10;
			_bb.Width = 1;

			_kb.Period = 10;
			_kb.Koef = 1;

			_upRatio.VisualType = _downRatio.VisualType = VisualMode.Histogram;

			_upRatio.Color = DefaultColors.Green.Convert();
			_downRatio.Color = DefaultColors.Red.Convert();

			Add(_kb);

			DataSeries[0] = _upRatio;
			DataSeries.Add(_downRatio);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			_bb.Calculate(bar, value);
			var bbTop = ((ValueDataSeries)_bb.DataSeries[1])[bar];
			var bbBot = ((ValueDataSeries)_bb.DataSeries[2])[bar];

			var kbTop = ((ValueDataSeries)_kb.DataSeries[1])[bar];
			var kbBot = ((ValueDataSeries)_kb.DataSeries[2])[bar];

			var bandsRatio = 0m;

			if (bbTop - bbBot != 0)
				bandsRatio = (kbTop - kbBot) / (bbTop - bbBot) - 1;

			if (bandsRatio >= 0)
				_upRatio[bar] = bandsRatio;
			else
				_downRatio[bar] = bandsRatio;
		}

		#endregion
	}
}








Technical/BollingerSqueezeV2.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bollinger Squeeze 2")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BollingerSqueezeV2Description))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602634")]
	public class BollingerSqueezeV2 : Indicator
	{
        #region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
        private readonly ValueDataSeries _downSeries = new("DownSeries", Strings.Down) { IgnoredByAlerts = true };
        private readonly ValueDataSeries _upSeries = new("UpSeries", Strings.Up) { IgnoredByAlerts = true };

        private readonly BollingerBands _bb = new();
		private readonly EMA _emaMomentum = new();
		private readonly KeltnerChannel _kb = new();
		private readonly Momentum _momentum = new();

		private System.Drawing.Color _lowColor = DefaultColors.Maroon;
		private System.Drawing.Color _lowerColor = DefaultColors.Red;
		private System.Drawing.Color _upColor = DefaultColors.Green;
		private System.Drawing.Color _upperColor = DefaultColors.Lime;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Upper), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.UpperPositiveValueColorDescription), Order = 610)]
        public CrossColor UpperColor
        {
	        get => _upperColor.Convert();
	        set
	        {
		        _upperColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 620)]
        public CrossColor UpColor
        {
	        get => _upColor.Convert();
	        set
	        {
		        _upColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 630)]
        public CrossColor LowColor
        {
	        get => _lowColor.Convert();
	        set
	        {
		        _lowColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Lower), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LowerNegativeValueColorDescription), Order = 640)]
        public CrossColor LowerColor
        {
	        get => _lowerColor.Convert();
	        set
	        {
		        _lowerColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.BollingerBands), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 1000000)]
		public int BbPeriod
		{
			get => _bb.Period;
			set
			{
				_bb.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBandsWidth), GroupName = nameof(Strings.BollingerBands), Description = nameof(Strings.DeviationRangeDescription), Order = 110)]
		[Range(0.000001, 1000000)]
		public decimal BbWidth
		{
			get => _bb.Width;
			set
			{
				_bb.Width = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.KeltnerChannel), Description = nameof(Strings.PeriodDescription), Order = 200)]
		[Range(1, 1000000)]
		public int KbPeriod
		{
			get => _kb.Period;
			set
			{
				_kb.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetMultiplier), GroupName = nameof(Strings.KeltnerChannel), Description = nameof(Strings.DeviationRangeDescription), Order = 210)]
		[Range(0.000001, 1000000)]
		public decimal KbMultiplier
		{
			get => _kb.Koef;
			set
			{
				_kb.Koef = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Momentum), Description = nameof(Strings.PeriodDescription), Order = 300)]
		[Range(1, 1000000)]
		public int MomentumPeriod
		{
			get => _momentum.Period;
			set
			{
				_momentum.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA), GroupName = nameof(Strings.Momentum), Description = nameof(Strings.PeriodDescription), Order = 310)]
		[Range(1, 1000000)]
		public int EmaMomentum
		{
			get => _emaMomentum.Period;
			set
			{
				_emaMomentum.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BollingerSqueezeV2()
		{
			Panel = IndicatorDataProvider.NewPanel;

			_bb.Period = 10;
			_bb.Width = 1;

			_kb.Period = 10;
			_kb.Koef = 1;

			_upSeries.Color = DefaultColors.Green.Convert();
			_downSeries.Color = CrossColors.Firebrick;

			_upSeries.VisualType = _downSeries.VisualType = VisualMode.Dots;
			_upSeries.Width = _downSeries.Width = 3;

			Add(_kb);

			DataSeries[0] = _upSeries;
			DataSeries.Add(_downSeries);
			DataSeries.Add(_renderSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			_momentum.Calculate(bar, value);
			_bb.Calculate(bar, value);
			_renderSeries[bar] = _emaMomentum.Calculate(bar, _momentum[bar]);

			if (bar == 0)
				return;

			_renderSeries.Colors[bar] = _emaMomentum[bar] switch
			{
				> 0 when _emaMomentum[bar] >= _emaMomentum[bar - 1] => _upperColor,
				> 0 when _emaMomentum[bar] < _emaMomentum[bar - 1] => _upColor,
				< 0 when _emaMomentum[bar] <= _emaMomentum[bar - 1] => _lowerColor,
				< 0 when _emaMomentum[bar] > _emaMomentum[bar - 1] => _lowColor,
				_ => _renderSeries.Colors[bar]
			};

			var bbTop = ((ValueDataSeries)_bb.DataSeries[1])[bar];
			var bbBot = ((ValueDataSeries)_bb.DataSeries[2])[bar];

			var kbTop = ((ValueDataSeries)_kb.DataSeries[1])[bar];
			var kbBot = ((ValueDataSeries)_kb.DataSeries[2])[bar];

			if (bbTop > kbTop && bbBot < kbBot)
				_upSeries[bar] = 0.00001m;
			else
				_downSeries[bar] = 0.00001m;
		}

		#endregion
	}
}










Technical/BollingerSqueezeV3.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Bollinger Squeeze 3")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.BollingerSqueezeV3Description))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602338")]
	public class BollingerSqueezeV3 : Indicator
	{
		#region Fields

		private readonly ATR _atr = new();

		private readonly StdDev _stdDev = new();
		private decimal _atrMultiplier;
		private decimal _stdMultiplier;

		private System.Drawing.Color _negColor = DefaultColors.Red;
		private System.Drawing.Color _posColor = DefaultColors.Green;

		private ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
			ShowZeroValue = false,
			UseMinimizedModeIfEnabled = true
		};

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 610)]
        public CrossColor PosColor
        {
	        get => _posColor.Convert();
	        set
	        {
		        _posColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 620)]
        public CrossColor NegColor
        {
	        get => _negColor.Convert();
	        set
	        {
		        _negColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.ATR), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 1000000)]
		public int AtrPeriod
		{
			get => _atr.Period;
			set
			{
				_atr.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.ATR), Description = nameof(Strings.ATRMultiplierDescription), Order = 110)]
		[Range(0.000001, 1000000)]
		public decimal AtrMultiplier
		{
			get => _atrMultiplier;
			set
			{
				_atrMultiplier = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.StdDev), Description = nameof(Strings.PeriodDescription), Order = 200)]
		[Range(1, 1000000)]
		public int StdDevPeriod
		{
			get => _stdDev.Period;
			set
			{
				_stdDev.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.StdDev), Description = nameof(Strings.MultiplierDescription), Order = 210)]
		[Range(0.000001, 1000000)]
		public decimal StdMultiplier
		{
			get => _stdMultiplier;
			set
			{
				_stdMultiplier = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public BollingerSqueezeV3()
		{
			Panel = IndicatorDataProvider.NewPanel;

			_atr.Period = 10;
			_stdDev.Period = 10;
			
			_stdMultiplier = 1;
			_atrMultiplier = 1;
			Add(_atr);

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			var ratio = 0m;
			var stdValue = _stdDev.Calculate(bar, value);

			if (_atr[bar] != 0)
				ratio = _stdMultiplier * stdValue / (_atrMultiplier * _atr[bar]);

			_renderSeries[bar] = ratio;
			_renderSeries.Colors[bar] = ratio >= 1 ? _posColor : _negColor;
		}

		#endregion
	}
}









Technical/CAV.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Cumulative Adjusted Value")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CAVDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602359")]
	public class CAV : Indicator
	{
		#region Fields

		private readonly EMA _ema = new()
		{
			Period = 10
		};

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public CAV()
		{
			Panel = IndicatorDataProvider.NewPanel;
			var zeroLine = new LineSeries("ZeroVal", Strings.ZeroValue) 
			{
				Color = DefaultColors.Gray.Convert(), 
				Value = 0, 
				DescriptionKey = nameof(Strings.ZeroLineDescription)
			};

            LineSeries.Add(zeroLine);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var adjVal = value - _ema.Calculate(bar, value);

			if (bar == 0)
			{
				_renderSeries[bar] = adjVal;
				return;
			}

			_renderSeries[bar] = _renderSeries[bar - 1] + adjVal;
		}

		#endregion
	}
}









Technical/CBI.cs







namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Connie Brown Composite Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CBIDescription))] 
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602601")]
	public class CBI : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _cbi1Series = new("Cbi1Series", Strings.ShortPeriod) { IgnoredByAlerts = true };
		private readonly ValueDataSeries _cbi2Series = new("Cbi2Series", Strings.MiddleBand);
        private readonly ValueDataSeries _cbi3Series = new("Cbi3Series", Strings.LongPeriod) { IgnoredByAlerts = true };
        private readonly Momentum _momentum = new();

		private readonly RSI _rsi1 = new();
		private readonly RSI _rsi2 = new();
		private readonly SMA _sma1 = new();
		private readonly SMA _sma2 = new();
		private readonly SMA _sma3 = new();

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod1), GroupName = nameof(Strings.RSI), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Rsi1Period
		{
			get => _rsi1.Period;
			set
			{
				_rsi1.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod2), GroupName = nameof(Strings.RSI), Description = nameof(Strings.PeriodDescription), Order = 110)]
		public int Rsi2Period
		{
			get => _rsi2.Period;
			set
			{
				_rsi2.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Momentum), Description = nameof(Strings.PeriodDescription), Order = 200)]
		public int MomentumPeriod
		{
			get => _momentum.Period;
			set
			{
				_momentum.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod1), GroupName = nameof(Strings.SMA), Description = nameof(Strings.PeriodDescription), Order = 300)]
		public int Sma1Period
		{
			get => _sma1.Period;
			set
			{
				_sma1.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod2), GroupName = nameof(Strings.SMA), Description = nameof(Strings.PeriodDescription), Order = 310)]
		public int Sma2Period
		{
			get => _sma2.Period;
			set
			{
				_sma2.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod3), GroupName = nameof(Strings.SMA), Description = nameof(Strings.PeriodDescription), Order = 320)]
		public int Sma3Period
		{
			get => _sma3.Period;
			set
			{
				_sma3.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public CBI()
		{
			Panel = IndicatorDataProvider.NewPanel;
			_momentum.Period = 9;
			_rsi1.Period = 3;
			_rsi2.Period = 14;

			_sma1.Period = 3;
			_sma2.Period = 13;
			_sma3.Period = 33;

			_cbi1Series.Color = DefaultColors.Red.Convert();
			_cbi2Series.Color = DefaultColors.Orange.Convert();
			_cbi3Series.Color = DefaultColors.Green.Convert();

			DataSeries[0] = _cbi1Series;
			DataSeries.Add(_cbi2Series);
			DataSeries.Add(_cbi3Series);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_cbi1Series[bar] = _momentum.Calculate(bar, _rsi1.Calculate(bar, value)) + _sma1.Calculate(bar, _rsi2.Calculate(bar, value));
			_cbi2Series[bar] = _sma2.Calculate(bar, _cbi1Series[bar]);
			_cbi3Series[bar] = _sma3.Calculate(bar, _cbi1Series[bar]);
		}

		#endregion
	}
}








Technical/CCI.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

    [DisplayName("CCI")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CCIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602539")]
	public class CCI : Indicator
	{
		#region Fields

		private readonly SMA _sma = new();
		private readonly ValueDataSeries _typicalSeries = new("typical");
		private bool _drawLines = true;

        #endregion

        #region Properties

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Show),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.DrawLinesDescription),
            Order = 30)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if (LineSeries.Contains(Line100))
						return;

					LineSeries.Add(Line100);
					LineSeries.Add(LineM100);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.p100),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OverboughtLimitDescription),
            Order = 30)]
		public LineSeries Line100 { get; set; } = new("Line100", "100")
		{
			Color = DefaultColors.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 100,
			Width = 1,
			IsHidden = true
		};
		
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.m100),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OversoldLimitDescription),
            Order = 30)]
		public LineSeries LineM100 { get; set; } = new("LineM100", "-100")
		{
			Color = DefaultColors.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = -100,
			Width = 1,
			IsHidden = true
		};

        #endregion

        #region ctor

        public CCI()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			Period = 10;
			
			LineSeries.Add(Line100);
			LineSeries.Add(LineM100);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			decimal mean = 0;
			var typical = (candle.High + candle.Low + candle.Close) / 3m;
			var sma0 = _sma.Calculate(bar, typical);
			_typicalSeries[bar] = typical;

			for (var i = bar; i > bar - Period && i >= 0; i--)
				mean += Math.Abs(_typicalSeries[i] - sma0);

			var res = 0.015m * (mean / Math.Min(Period, bar + 1));

			if (typical - sma0 == 0)
				this[bar] = 0.000000001m;
			else
				this[bar] = (typical - sma0) / (res <= 0.000000001m ? 1 : res);
		}

		#endregion
	}
}









Technical/CFO.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Chande Forecast Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CFODescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602274")]
	public class CFO : Indicator
	{
		#region Fields

		private readonly LinearReg _linReg = new()
		{
			Period = 10
		};

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _linReg.Period;
			set
			{
				_linReg.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public CFO()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var cfoValue = value != 0
				? 100m * (value - _linReg.Calculate(bar, value)) / value
				: 0;
			
			_renderSeries[bar] = cfoValue;
		}

		#endregion
	}
}









Technical/CMF.cs








namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Chaikin Money Flow")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CMFDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602540")]
	public class CMF : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _adSeries = new("ADSeries");
		private readonly ValueDataSeries _cmf = new("Cmf", "CMFline");
		private readonly RangeDataSeries _cmfHigh = new("CmfHigh", "CMFHigh")
		{ 
			DescriptionKey = nameof(Strings.PositiveValueColorDescription) 
		};

		private readonly RangeDataSeries _cmfLow = new("CmfLow", "CMFLow")
		{
			DescriptionKey = nameof(Strings.NegativeValueColorDescription)
		};

		private decimal _ad;
		private decimal _dailyHigh;
		private decimal _dailyLow;
		private DateTime _lastSessionTime;

		private int _period = 21;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription))]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public CMF()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			_cmfHigh.RangeColor = DefaultColors.Green.Convert();
			_cmfLow.RangeColor = DefaultColors.Red.Convert();
			_cmf.Color = DefaultColors.Gray.Convert();

			DataSeries[0] = _cmfHigh;
            DataSeries.Add(_cmfLow);
			DataSeries.Add(_cmf);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_dailyHigh = _dailyLow = 0;
				return;
			}

			var candle = GetCandle(bar);

			if (IsNewSession(bar))
			{
				if (_lastSessionTime != candle.Time)
				{
					_lastSessionTime = candle.Time;
					_dailyHigh = _dailyLow = 0;
				}
			}

			if (candle.High > _dailyHigh || _dailyHigh == 0)
				_dailyHigh = candle.High;

			if (candle.Low < _dailyLow || _dailyLow == 0)
				_dailyLow = candle.Low;

			if (_dailyHigh != _dailyLow)
				_ad = (candle.Close - _dailyLow - (_dailyHigh - candle.Close)) / (_dailyHigh - _dailyLow) * candle.Volume;
			else
				_ad = _adSeries[bar - 1];

			_adSeries[bar] = _ad;

			if (bar > _period)
			{
				decimal adSum = 0;
				decimal volumeSum = 0;

				for (var i = 0; i <= _period; i++)
				{
					adSum += _adSeries[bar - i];
					volumeSum += GetCandle(bar - i).Volume;
				}

				var result = adSum / volumeSum;
				_cmf[bar] = result;

				if (result >= 0)
				{
					_cmfHigh[bar].Upper = result;
					_cmfHigh[bar].Lower = 0;
				}
				else
				{
					_cmfLow[bar].Upper = 0;
					_cmfLow[bar].Lower = result;
				}
			}
		}

		#endregion
	}
}








Technical/CMO.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Chaikin Money Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CMODescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602299")]
	public class CMO : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _ad = new("AdLine");
		private readonly ValueDataSeries _cmo = new("Cmo", "Oscillator");
		private decimal _dailyHigh;
		private decimal _dailyLow;
		private DateTime _lastSessionTime;
		private int _periodLong = 10;

		private int _periodShort = 3;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), Description = nameof(Strings.LongPeriodDescription))]
		[Range(1, 10000)]
		public int PeriodLong
		{
			get => _periodLong;
			set
			{
				_periodLong = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), Description = nameof(Strings.ShortPeriodDescription))]
		[Range(1, 10000)]
        public int PeriodShort
		{
			get => _periodShort;
			set
			{
				_periodShort = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public CMO()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _cmo;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_cmo.Clear();
				_dailyHigh = _dailyLow = 0;
				return;
			}

			var candle = GetCandle(bar);

			if (IsNewSession(bar))
			{
				if (_lastSessionTime != candle.Time)
				{
					_lastSessionTime = candle.Time;
					_dailyHigh = _dailyLow = 0;
				}
			}

			if (candle.High > _dailyHigh || _dailyHigh == 0)
				_dailyHigh = candle.High;

			if (candle.Low < _dailyLow || _dailyLow == 0)
				_dailyLow = candle.Low;

			if (_dailyHigh == _dailyLow)
				return;

			_ad[bar] = (candle.Close - _dailyLow - (_dailyHigh - candle.Close)) / (_dailyHigh - _dailyLow) * candle.Volume;

			if (bar < _periodLong)
				return;

			var emaLong = _ad[bar] * (2.0m / (1 + _periodLong)) + (1 - 2.0m / (1 + _periodLong)) * _ad[bar - 1];
			var emaShort = _ad[bar] * (2.0m / (1 + _periodShort)) + (1 - 2.0m / (1 + _periodShort)) * _ad[bar - 1];

			_cmo[bar] = emaLong - emaShort;
		}

		#endregion
	}
}








Technical/CMS.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Clear Method Swing Line")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CMSDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602257")]
	public class CMS : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _downSeries = new("DownSeries", Strings.Down)
		{
			DescriptionKey = nameof(Strings.BearishTrendDescription)
		};

		private readonly ValueDataSeries _upSeries = new("UpSeries", Strings.Up)
		{
            DescriptionKey = nameof(Strings.BullishTrendDescription)
        };


        private readonly ValueDataSeries _hh = new("hh");
		private readonly ValueDataSeries _hh1 = new("hh1");
		private readonly ValueDataSeries _hh2 = new("hh2");
		private readonly ValueDataSeries _hh3 = new("hh3");

		private readonly ValueDataSeries _hl = new("hl");
		private readonly ValueDataSeries _hl1 = new("hl1");
		private readonly ValueDataSeries _hl2 = new("hl2");
		private readonly ValueDataSeries _hl3 = new("hl3");

		private readonly ValueDataSeries _lh = new("lh");
		private readonly ValueDataSeries _lh1 = new("lh1");
		private readonly ValueDataSeries _lh2 = new("lh2");
		private readonly ValueDataSeries _lh3 = new("lh3");

		private readonly ValueDataSeries _ll = new("ll");
		private readonly ValueDataSeries _ll1 = new("ll1");
		private readonly ValueDataSeries _ll2 = new("ll2");
		private readonly ValueDataSeries _ll3 = new("ll3");

		private readonly ValueDataSeries _us = new("us");
		private readonly ValueDataSeries _us1 = new("us1");
		private readonly ValueDataSeries _us2 = new("us2");
		private readonly ValueDataSeries _us3 = new("us3");

		#endregion

		#region ctor

		public CMS()
			: base(true)
		{
			DenyToChangePanel = true;
			_upSeries.Color = CrossColors.Cyan;
			_downSeries.Color = CrossColors.Magenta;

			DataSeries[0] = _upSeries;
			DataSeries.Add(_downSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			if (bar == 0)
			{
				_hh1[bar] = _hh2[bar] = _hh3[bar] = _hh[bar] = candle.High;
				_hl1[bar] = _hl2[bar] = _hl3[bar] = _hl[bar] = candle.Low;
				_us1[bar] = _us2[bar] = _us3[bar] = _us[bar] = 1;
				_ll1[bar] = _ll2[bar] = _ll3[bar] = _ll[bar] = candle.Low;
				_lh1[bar] = _lh2[bar] = _lh3[bar] = _lh[bar] = candle.High;

				DataSeries.ForEach(x =>
				{
					x.Clear();
					((ValueDataSeries)x).SetPointOfEndLine(0);
				});
				return;
			}

			_hh1[bar] = candle.High > _hh[bar - 1] ? candle.High : _hh[bar - 1];
			_hl1[bar] = candle.Low > _hl[bar - 1] ? candle.Low : _hl[bar - 1];
			_us1[bar] = candle.High < _hl1[bar] ? 0 : 1;
			_ll1[bar] = candle.High < _hl1[bar] ? candle.Low : _ll[bar - 1];
			_lh1[bar] = candle.High < _hl1[bar] ? candle.High : _lh[bar - 1];

			_ll2[bar] = candle.Low < _ll1[bar] ? candle.Low : _ll1[bar];
			_lh2[bar] = candle.High < _lh1[bar] ? candle.High : _lh1[bar];
			_us2[bar] = candle.Low > _lh2[bar] ? 1 : 0;
			_hh2[bar] = candle.Low > _lh2[bar] ? candle.High : _hh1[bar];
			_hl2[bar] = candle.Low > _lh2[bar] ? candle.Low : _hl1[bar];

			_ll3[bar] = candle.Low < _ll[bar - 1] ? candle.Low : _ll[bar - 1];
			_lh3[bar] = candle.High < _lh[bar - 1] ? candle.High : _lh[bar - 1];
			_us3[bar] = candle.Low > _lh3[bar] ? 1 : 0;
			_hh3[bar] = candle.Low > _lh3[bar] ? candle.High : _hh[bar - 1];
			_hl3[bar] = candle.Low > _lh3[bar] ? candle.Low : _lh[bar - 1];

			if (_us[bar - 1] == 0)
			{
				_hh[bar] = _hh3[bar];
				_hl[bar] = _hl3[bar];
				_us[bar] = _us3[bar];
				_ll[bar] = _ll3[bar];
				_lh[bar] = _lh3[bar];
			}
			else
			{
				if (_us1[bar] == 0)
				{
					_hh[bar] = _hh2[bar];
					_hl[bar] = _hl2[bar];
					_us[bar] = _us2[bar];
					_ll[bar] = _ll2[bar];
					_lh[bar] = _lh2[bar];
				}
				else
				{
					_hh[bar] = _hh1[bar];
					_hl[bar] = _hl1[bar];
					_us[bar] = _us1[bar];
					_ll[bar] = _ll1[bar];
					_lh[bar] = _lh1[bar];
				}
			}

			if (_us[bar] == 1)
				_upSeries[bar] = _hl[bar];
			else
				_downSeries[bar] = _lh[bar];

			if (_upSeries[bar] != 0 && _downSeries[bar - 1] != 0 || _downSeries[bar] != 0 && _upSeries[bar - 1] != 0)
				SplitLines(bar);
		}

		#endregion

		#region Private methods

		private void SplitLines(int bar)
		{
			if (_upSeries[bar] != 0 && _downSeries[bar - 1] != 0)
			{
				_upSeries[bar - 1] = _downSeries[bar - 1];
				_upSeries.SetPointOfEndLine(bar - 2);
				_downSeries.SetPointOfEndLine(bar - 1);
			}

			if (_downSeries[bar] != 0 && _upSeries[bar - 1] != 0)
			{
				_downSeries[bar - 1] = _upSeries[bar - 1];
				_downSeries.SetPointOfEndLine(bar - 2);
				_upSeries.SetPointOfEndLine(bar - 1);
			}
		}

		#endregion
	}
}








Technical/CamarillaPivots.cs








namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Camarilla Pivots")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CamarillaPivotsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602341")]
	public class CamarillaPivots : Indicator
	{
		#region Fields

		private decimal _close;
		private decimal _high;
		private decimal _low;
		private decimal _lastH1;
		private decimal _lastH2;
		private decimal _lastH3;
		private decimal _lastH4;
		private decimal _lastH5;
		private decimal _lastH6;
		
		private decimal _lastL1;
		private decimal _lastL2;
		private decimal _lastL3;
		private decimal _lastL4;
		private decimal _lastL5;
		private decimal _lastL6;

		private decimal _lastPivot;
		
		
		private ValueDataSeries _h1 = new("H1", "Daily H1") { DescriptionKey = nameof(Strings.ResistanceLevelDisplayDescription) };
        private ValueDataSeries _h2 = new("H2", "Daily H2") { DescriptionKey = nameof(Strings.ResistanceLevelDisplayDescription) };
        private ValueDataSeries _h3 = new("H3", "Daily H3") { DescriptionKey = nameof(Strings.ResistanceLevelDisplayDescription) };
        private ValueDataSeries _h4 = new("H4", "Daily H4") { DescriptionKey = nameof(Strings.ResistanceLevelDisplayDescription) };
        private ValueDataSeries _h5 = new("H5", "Daily H5") { DescriptionKey = nameof(Strings.ResistanceLevelDisplayDescription) };
        private ValueDataSeries _h6 = new("H6", "Daily H6") { DescriptionKey = nameof(Strings.ResistanceLevelDisplayDescription) };

        private ValueDataSeries _l1 = new("L1", "Daily L1") { DescriptionKey = nameof(Strings.SupportLevelDisplayDescription) };
        private ValueDataSeries _l2 = new("L2", "Daily L2") { DescriptionKey = nameof(Strings.SupportLevelDisplayDescription) };
        private ValueDataSeries _l3 = new("L3", "Daily L3") { DescriptionKey = nameof(Strings.SupportLevelDisplayDescription) };
        private ValueDataSeries _l4 = new("L4", "Daily L4") { DescriptionKey = nameof(Strings.SupportLevelDisplayDescription) };
		private ValueDataSeries _l5 = new("L5", "Daily L5") { DescriptionKey = nameof(Strings.SupportLevelDisplayDescription) };
        private ValueDataSeries _l6 = new("L6", "Daily L6") { DescriptionKey = nameof(Strings.SupportLevelDisplayDescription) };
        private int _lastSession;

		private ValueDataSeries _pivot = new("Pivot", "Daily Pivot") { DescriptionKey = nameof(Strings.HLCAveragePrevSessionDescription) };
		private int _lastBar;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PivotRange), GroupName = nameof(Strings.Colors), Description = nameof(Strings.PivotLevelColorDescription), Order = 100)]
		public CrossColor PivotColor
		{
			get => _pivot.Color;
			set => _pivot.Color = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BetweenColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.MidLevelColorDescription), Order = 100)]
		public CrossColor BetweenColor
		{
			get => _h3.Color;
			set => _h3.Color = _l3.Color = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLowColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.AllLevelsColorDescription), Order = 110)]
		public CrossColor HighLowColor
		{
			get => _h1.Color;
			set => _h1.Color = _h2.Color = _h4.Color = _h5.Color = _h6.Color =
				_l1.Color = _l2.Color = _l4.Color = _l5.Color = _l6.Color = value;
		}

		#endregion

		#region ctor

		public CamarillaPivots()
			: base(true)
		{
			DenyToChangePanel = true;
			PivotColor = DefaultColors.Gray.Convert();
			BetweenColor = DefaultColors.Red.Convert();
			HighLowColor = DefaultColors.Green.Convert();

			_pivot.ScaleIt = false;
			_h6.ScaleIt = false;
            _h5.ScaleIt = false;
            _h4.ScaleIt = false;
            _h3.ScaleIt = false;
            _h2.ScaleIt = false;
            _h1.ScaleIt = false;
            _l1.ScaleIt = false;
            _l2.ScaleIt = false;
            _l3.ScaleIt = false;
            _l4.ScaleIt = false;
            _l5.ScaleIt = false;
            _l6.ScaleIt = false;

            DataSeries[0] = _pivot;
			DataSeries.Add(_h6);
			DataSeries.Add(_h5);
			DataSeries.Add(_h4);
			DataSeries.Add(_h3);
			DataSeries.Add(_h2);
			DataSeries.Add(_h1);
			DataSeries.Add(_l1);
			DataSeries.Add(_l2);
			DataSeries.Add(_l3);
			DataSeries.Add(_l4);
			DataSeries.Add(_l5);
			DataSeries.Add(_l6);

			DataSeries.ForEach(x => ((ValueDataSeries)x).Width = 2);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_close = _high = _low = 0;
				_lastH1 = _lastH2 = _lastH3 = _lastH4 = _lastH5 = _lastH6 = 0;
				_lastL1 = _lastL2 = _lastL3 = _lastL4 = _lastL5 = _lastL6 = 0;
				_lastSession = 0;
			}

			var candle = GetCandle(bar);

			if (IsNewSession(bar) && _lastSession != bar)
			{
				DataSeries.ForEach(x => ((ValueDataSeries)x).SetPointOfEndLine(bar - 1));
								
				_lastSession = bar;
				
				_lastPivot = (_high + _low + _close) / 3;
				var range = _high - _low;
				_lastH5 = _high / _low * _close;
				_lastH4 = _close + range * 1.1m / 2;
				_lastH3 = _close + range * 1.1m / 4;
				_lastH2 = _close + range * 1.1m / 6;
				_lastH1 = _close + range * 1.1m / 12;
                _lastH6 = _lastH5 + 1.168m * (_lastH5 - _lastH4);

                _lastL1 = _close - range * 1.1m / 12;
				_lastL2 = _close - range * 1.1m / 6;
				_lastL3 = _close - range * 1.1m / 4;
				_lastL4 = _close - range * 1.1m / 2;
				_lastL5 = _close - (_lastH5 - _close);
				_lastL6 = _close - (_lastH6 - _close);

				_close = _high = _low = 0;
			}

			_close = candle.Close;

			if (candle.High > _high || _high == 0)
				_high = candle.High;

			if (candle.Low < _low || _low == 0)
				_low = candle.Low;

			if (_lastBar == bar)
				return; 
			
			RenderValues(bar);

			_lastBar = bar;
		}

		#endregion

		#region Private methods

		private void RenderValues(int bar)
		{
			if (bar == 0)
				return;

			for (var i = _lastSession; i <= bar; i++)
			{
				_pivot[i] = _lastPivot;
				_h6[i] = _lastH6;
				_h5[i] = _lastH5;
				_h4[i] = _lastH4;
				_h3[i] = _lastH3;
				_h2[i] = _lastH2;
				_h1[i] = _lastH1;
				_l1[i] = _lastL1;
				_l2[i] = _lastL2;
				_l3[i] = _lastL3;
				_l4[i] = _lastL4;
				_l5[i] = _lastL5;
				_l6[i] = _lastL6;
			}
		}

		#endregion
	}
}









Technical/CandleStatistics.cs








namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

[DisplayName("Candle Statistics")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.CandleStatisticsDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618476")]
public class CandleStatistics : Indicator
{
	#region Nested types

	public enum LabelLocations
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AboveCandle))]
		Top,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BelowCandle))]
		Bottom,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ByCandleDirection))]
		CandleDirection
	}

	#endregion

	#region Fields

	private readonly BrushSettings _bgBrush = new();

	private readonly PenSettings _bgPen = new() { Color = DefaultColors.Gray.Convert() };

	private readonly RenderStringFormat _format = new()
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center
	};

	private int _backGroundTransparency = 8;

	#endregion

	#region ctor

	public CandleStatistics()
		: base(true)
	{
		DenyToChangePanel = true;
		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).ShowZeroValue = false;

		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Final);

		_bgPen.Color = BackGroundColor.Convert();
		_bgBrush.StartColor = GetColorTransparency(BackGroundColor, _backGroundTransparency).Convert();
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo == null)
			return;

		if(ChartInfo.PriceChartContainer.BarsWidth < 5)
			return;

		if (ClusterModeOnly && ChartInfo.ChartVisualMode != ChartVisualModes.Clusters)
			return;

		if (!ShowDelta && !ShowVolume && !ShowTrades && !ShowDuration)
			return;

		DrawLabels(context);
	}

	#endregion

	#region Private methods

	private void DrawLabels(RenderContext context)
	{
		var shift = 2;
        var shiftBetweenStr = (int)(FontSetting.RenderObject.Size / 100 * 20);
		var rowHeight = context.MeasureString("0", FontSetting.RenderObject).Height + shiftBetweenStr;

        for (var bar = FirstVisibleBarNumber; bar <= LastVisibleBarNumber; bar++)
		{
			var candle = GetCandle(bar);
			var delta = candle.Delta;

			var volumeStr = ChartInfo.TryGetMinimizedVolumeString(candle.Volume);
			var deltaStr = ChartInfo.TryGetMinimizedVolumeString(delta);
			var ticksStr = ChartInfo.TryGetMinimizedVolumeString(candle.Ticks);

			var duration = candle.LastTime - candle.Time;
			var durationStr = "";

			if (ShowDuration)
			{
				if (duration.TotalHours >= 1)
					durationStr = string.Format("{0}:{1:mm}:{1:ss}", (int)duration.TotalHours, duration);
				else if (duration.Minutes > 0)
					durationStr = duration.ToString(@"mm\:ss");
				else
					durationStr = duration.ToString(@"ss");
			}
			
			var volumeSize = new Size();
			var deltaSize = new Size();
			var ticksSize = new Size();
			var durationSize = new Size();

			var maxWidth = 0;

			if (ShowVolume)
			{
				volumeSize = context.MeasureString(volumeStr, FontSetting.RenderObject);
				maxWidth = volumeSize.Width;
			}

			if (ShowDelta)
			{
				deltaSize = context.MeasureString(deltaStr, FontSetting.RenderObject);
				maxWidth = Math.Max(maxWidth, deltaSize.Width);
			}

			if (ShowTrades)
			{
				ticksSize = context.MeasureString(ticksStr, FontSetting.RenderObject);
				maxWidth = Math.Max(maxWidth, ticksSize.Width);
			}

			if (ShowDuration)
			{
				durationSize = context.MeasureString(durationStr, FontSetting.RenderObject);
				maxWidth = Math.Max(maxWidth, durationSize.Width);
			}

			var h = volumeSize.Height + deltaSize.Height + ticksSize.Height + durationSize.Height + shift * 2 + shiftBetweenStr;
			var y = (int)GetStartY(candle, h) + shift;

			maxWidth += shift * 4;
			maxWidth = GetTrueWidth(maxWidth);

			var x = ChartInfo.GetXByBar(bar) + (int)((ChartInfo.PriceChartContainer.BarsWidth - maxWidth) / 2);

			var rectangle = new Rectangle(x, y, maxWidth, h);

			if (!HideBackGround)
				context.DrawFillRectangle(_bgPen.RenderObject, _bgBrush.RenderObject.StartColor, rectangle);
			
			if (ShowVolume)
			{
				var rec = new Rectangle(x, y, maxWidth, volumeSize.Height);
				context.DrawString(volumeStr, FontSetting.RenderObject, VolumeColor, rec, _format);
				y += rowHeight;
            }

			if (ShowDelta)
			{
				var rec = new Rectangle(x, y, maxWidth, deltaSize.Height);
				var color = delta < 0 ? NegativeDeltaColor : PositiveDeltaColor;
				context.DrawString(deltaStr, FontSetting.RenderObject, color, rec, _format);
				y += rowHeight;
            }

			if (ShowTrades)
			{
				var rec = new Rectangle(x, y, maxWidth, ticksSize.Height);
				context.DrawString(ticksStr, FontSetting.RenderObject, TradesColor, rec, _format);
				y += rowHeight;
			}

			if (ShowDuration)
			{
				var rec = new Rectangle(x, y, maxWidth, durationSize.Height);
				context.DrawString(durationStr, FontSetting.RenderObject, DurationColor, rec, _format);
			}
		}
	}

	private string GetTrueString(decimal value)
	{
		var absValue = Math.Abs(value);

		if ((int)absValue < absValue)
			return value.ToString().TrimEnd('0');

		return value.ToString();
	}

	private int GetTrueWidth(int width)
	{
		return Math.Min(width, (int)ChartInfo.PriceChartContainer.BarsWidth);
	}

	private decimal GetStartY(IndicatorCandle candle, int height)
	{
		var topHeight = ChartInfo.GetYByPrice(candle.High) - Offset - height;
		var bottomHeight = ChartInfo.GetYByPrice(candle.Low) + Offset + ChartInfo.PriceChartContainer.PriceRowHeight;

		return LabelLocation switch
		{
			LabelLocations.Top => topHeight,
			LabelLocations.Bottom => bottomHeight,
			LabelLocations.CandleDirection => candle.Open > candle.Close
				? bottomHeight
				: topHeight,
			_ => 0
		};
	}

	private Color GetColorTransparency(Color color, int tr = 5)
	{
		var colorA = Math.Max(color.A - tr * 25, 0);

		return Color.FromArgb((byte)colorA, color.R, color.G, color.B);
	}

	#endregion

	#region Settings

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LabelLocation), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.LabelLocationDescription))]
	public LabelLocations LabelLocation { get; set; } = LabelLocations.Top;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolume), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.ShowVolumesDescription))]
	public bool ShowVolume { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDelta), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.ShowDeltaDescription))]
	public bool ShowDelta { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTradesCount), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.ShowTradesCountDescription))]
	public bool ShowTrades { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDurationHHMMSS), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.ShowCandleDurationDescription))]
	public bool ShowDuration { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ClustersMode), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.DisplayLabelClustersModeOnlyDescription))]
	public bool ClusterModeOnly { get; set; }

	#endregion

	#region Visualization

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.VolumeColorDescription))]
	public Color VolumeColor { get; set; } = DefaultColors.Blue;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PositiveDelta), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.PositiveValueColorDescription))]
	public Color PositiveDeltaColor { get; set; } = DefaultColors.Green;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.NegativeDelta), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.NegativeValueColorDescription))]
	public Color NegativeDeltaColor { get; set; } = DefaultColors.Red;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Trades), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.ShowTradesCountDescription))]
	public Color TradesColor { get; set; } = DefaultColors.Lime;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Duration), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.ShowTradesCountDescription))]
	public Color DurationColor { get; set; } = DefaultColors.Olive;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.LabelFillColorDescription))]
	public Color BackGroundColor
	{
		get => _bgPen.Color.Convert();
		set
		{
			_bgPen.Color = value.Convert();
			_bgBrush.StartColor = GetColorTransparency(value, BackGroundTransparency).Convert();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideBackGround), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.HideLabelBackGroundDescription))]
	public bool HideBackGround { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.FontSettingDescription))]
	public FontSetting FontSetting { get; set; } = new("Trebuchet MS", 9);

	[Range(0, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Offset), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.LabelOffsetYDescription))]
	public int Offset { get; set; } = 10;

	[Range(1, 10)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BorderWidth), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BorderWidthPixelDescription))]
	public int BorderWidth
	{
		get => _bgPen.Width;
		set => _bgPen.Width = value;
	}

	[Range(0, 10)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.VisualObjectsTransparencyDescription))]
	public int BackGroundTransparency
	{
		get => _backGroundTransparency;
		set
		{
			_backGroundTransparency = value;
			_bgBrush.StartColor = GetColorTransparency(BackGroundColor, BackGroundTransparency).Convert();
		}
	}

	#endregion
}









Technical/ChaikinOscillator.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("Chaikin Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ChaikinOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602273")]
	public class ChaikinOscillator : Indicator
	{
		#region Fields

		private readonly EMA _emaLong = new();
		private readonly EMA _emaShort = new();

		private LineSeries _overbought;
		private LineSeries _oversold;
		private int _divisor;
		private decimal _exAd;
		private decimal _lastAd;
		private int _lastBar;
		private bool _drawLines = true;

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.LongPeriod), Description = nameof(Strings.LongPeriodDescription), Order = 1)]
		public int LongAvg
		{
			get => _emaLong.Period;
			set
			{
				_emaLong.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.ShortPeriod), Description = nameof(Strings.ShortPeriodDescription), Order = 2)]
		public int ShortAvg
		{
			get => _emaShort.Period;
			set
			{
				_emaShort.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Divisor), Description = nameof(Strings.DivisorDescription), Order = 3)]
		public int Divisor
		{
			get => _divisor;
			set
			{
				_divisor = value;
				RecalculateValues();
			}
		}

        [Parameter]
		[Browsable(false)]
		public decimal Overbought
		{
			get => _overbought.Value;
			set => _overbought.Value = value;
        }

        [Parameter]
        [Browsable(false)]
		public decimal Oversold
		{
			get => _oversold.Value;
			set => _oversold.Value = value;
        }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Line), Description = nameof(Strings.DrawLinesDescription), Order = 300)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if (LineSeries.Contains(_overbought))
						return;

					LineSeries.Add(_overbought);
					LineSeries.Add(_oversold);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Overbought), GroupName = nameof(Strings.Line), Description = nameof(Strings.OverboughtLimitDescription), Order = 310)]
		public LineSeries OverboughtLine
		{
			get => _overbought;
			set => _overbought = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Oversold), GroupName = nameof(Strings.Line), Description = nameof(Strings.OversoldLimitDescription), Order = 320)]
		public LineSeries OversoldLine
		{
			get => _oversold;
			set => _oversold = value;
		}

        #endregion

        #region ctor

        public ChaikinOscillator()
			: base(true)
		{
			_emaLong.Period = 10;
			_emaShort.Period = 3;
			_divisor = 3;
			_lastBar = -1;

			Panel = IndicatorDataProvider.NewPanel;

			DataSeries[0] = new ValueDataSeries("RenderSeries", "ChaikinOscillator")
			{
				Color = DefaultColors.Blue.Convert(),
				LineDashStyle = LineDashStyle.Solid,
				VisualType = VisualMode.Line,
				Width = 2
			};

			_overbought = new LineSeries("Overbought", Strings.Overbought)
			{
				Color = DefaultColors.Red.Convert(),
				Width = 1,
				IsHidden = true
			};

            _oversold = new LineSeries("Oversold", Strings.Oversold)
			{
				Color = DefaultColors.Red.Convert(),
				Width = 1,
				IsHidden = true
			};

			LineSeries.Add(_overbought);
			LineSeries.Add(_oversold);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var currentCandle = GetCandle(bar);

			var ad = AccumulationDistributionBase(currentCandle);

			if (bar == 0)
				_exAd = ad;
			else
			{
				if (bar != _lastBar)
					_exAd = _lastAd;
				else
					_lastAd = ad;

				ad += _exAd;
			}

			var emaShort = _emaShort.Calculate(bar, ad);
			var emaLong = _emaLong.Calculate(bar, ad);

			var oscValue = (emaShort - emaLong) / Divisor;

			DataSeries[0][bar] = oscValue;

			_lastBar = bar;
		}

		#endregion

		#region Private methods

		private decimal AccumulationDistributionBase(IndicatorCandle candle)
		{
			var high = Convert.ToDouble(candle.High);
			var low = Convert.ToDouble(candle.Low);
			var close = Convert.ToDouble(candle.Close);
			var volume = Convert.ToDouble(candle.Volume);

			var ad = (close - low - (high - close)) / (high - low + Math.Pow(10, -9)) * volume;
			return Convert.ToDecimal(ad);
		}

		#endregion
	}
}









Technical/ChandeMomentum.cs







using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

namespace ATAS.Indicators.Technical
{
    [DisplayName("Chande Momentum Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ChandeMomentumDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602279")]
	public class ChandeMomentum : Indicator
	{
        #region Fields

        private readonly ValueDataSeries _renderSeries = new("RenderSeries", "Momentum");
        private readonly ValueDataSeries _downValues = new("Down");
		private readonly ValueDataSeries _upValues = new("Up");

		private int _period;

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ChandeMomentum()
		{
			Panel = IndicatorDataProvider.NewPanel;
			_period = 14;

			_renderSeries.Color = DefaultColors.Blue.Convert();
			_renderSeries.Width = 2;

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			_upValues[bar] = Math.Max(value - (decimal)SourceDataSeries[bar - 1], 0);
			_downValues[bar] = Math.Max((decimal)SourceDataSeries[bar - 1] - value, 0);

			if (bar < _period)
				return;

			var upSum = _upValues.CalcSum(_period, bar);
			var downSum = _downValues.CalcSum(_period, bar);
			var renderValue = 100m * (upSum - downSum) / (upSum + downSum);

			if (upSum + downSum != 0)
				_renderSeries[bar] = renderValue;
			else
				_renderSeries[bar] = _renderSeries[bar - 1];
		}

		#endregion
	}
}









Technical/ClusterSearch.Models.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Localization;

public partial class ClusterSearch
{
	#region Nested types

	//Merged between bars
	private class MergedClusterDictionary(int priceRowsMerge, decimal tickSize) : Dictionary<decimal, CustomVolumeInfo>
	{
		#region Fields

		private decimal _maxVol = decimal.MinValue;

		#endregion

		#region Properties

		public decimal TotalVolume { get; private set; }

		/// <summary>
		/// Calculated with N - 1 levels price merged values
		/// </summary>
		
		/* N = 2
		 * 30
		 * 14 |
		 * 23 | <= POC is 23 + 14 = 37
		 * 1
		 */
		public decimal PocPrice { get; private set; }

		public new CustomVolumeInfo this[decimal price]
		{
			get => base[price];
			set
			{
				if (TryGetValue(price, out var level))
					TotalVolume -= level.Volume;

				base[price] = value;
				TotalVolume += value.Volume;

                var sum = 0m;

				for (var iPrice = price; iPrice <= price + (priceRowsMerge - 1) * tickSize; iPrice += tickSize)
				{
					if (!TryGetValue(price, out var iLevel))
						continue;

					sum += iLevel.Volume;
				}

				if (sum <= _maxVol)
					return;

				_maxVol = sum;
				PocPrice = price;
			}
		}

        #endregion

        #region Public methods

        public void RemoveVolume(CustomVolumeInfo level)
        {
            TotalVolume -= level.Volume;
        }

        public void AddVolume(CustomVolumeInfo level)
        {
            TotalVolume += level.Volume;
        }

        public new void Clear()
        {
			_maxVol = decimal.MinValue;
			TotalVolume = 0;
			base.Clear();
		}

		#endregion
	}

	//PriceVolumeInfo with additional properties
	private class CustomVolumeInfo : PriceVolumeInfo
	{
		#region Properties

		public decimal AvgTrade => Ticks is 0 ? 0 : Volume / Ticks;

		public decimal Delta => Ask - Bid;

		#endregion

		#region ctor
		
		public CustomVolumeInfo(decimal price)
		{
			Price = price;
		}

		public CustomVolumeInfo(PriceVolumeInfo cluster)
		{
			Price = cluster.Price;

			Ask = cluster.Ask;
			Between = cluster.Between;
			Bid = cluster.Bid;
			Ticks = cluster.Ticks;
			Volume = cluster.Volume;
        }

		#endregion

		#region Public methods
		
		public static CustomVolumeInfo operator+(CustomVolumeInfo a, CustomVolumeInfo b)
		{
			a.Ask += b.Ask;
			a.Between += b.Between;
			a.Bid += b.Bid;
			a.Ticks += b.Ticks;
			a.Volume += b.Volume;
			return a;
		}
		
		#endregion
	}

	public enum CalcMode
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
		Bid,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
		Ask,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Delta))]
		Delta,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
		Volume,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
		Tick,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PocLevel))]
		MaxVolume,

		[Browsable(false)]
		[Obsolete]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Time))]
		Time
	}

	public enum CandleDirection
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bearlish))]
		Bearish,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bullish))]
		Bullish,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
		Any,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Neutral))]
		Neutral
	}

	public enum PriceLocation
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AtHigh))]
		AtHigh,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AtLow))]
		AtLow,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
		Any,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Body))]
		Body,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UpperWick))]
		UpperWick,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LowerWick))]
		LowerWick,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AtHighOrLow))]
		AtHighOrLow,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AnyWick))]
		AtUpperLowerWick
	}

	#endregion
}









Technical/ClusterSearch.SeriesHandling.cs










namespace ATAS.Indicators.Technical;

using System;

using OFT.Localization;

public partial class ClusterSearch
{
	#region Private methods

	//Binary search of insert index to keep price values sorted
	private void InsertOrReplace(int bar, PriceSelectionValue value)
	{
		var index = GetSeriesLevelIndex(bar, value.MinimumPrice);

		if (index >= 0)
			_lastSeriesBar[index] = value;
		else
			_lastSeriesBar.Insert(~index, value);
	}

	//Check ranges between previous and current trade prices when Price Location filter is not Any
	private void UpdatePriceLocationValues(int bar, MarketDataArg trade)
	{
		var candle = GetCandle(bar);

		switch (PriceLoc)
		{
			case PriceLocation.AtHigh:
				if (_lastSeriesBar.Count is 0)
					return;

				if (trade.Price != candle.High)
					return;

				RemoveOldSelection(bar, _lastPrice, trade.Price - InstrumentInfo.TickSize);
				break;

			case PriceLocation.AtLow:
				if (_lastSeriesBar.Count is 0)
					return;

				if (trade.Price != candle.Low)
					return;

				RemoveOldSelection(bar, trade.Price + InstrumentInfo.TickSize, _lastPrice);
				break;

			case PriceLocation.Body:
			{
				if (trade.Price >= candle.Open)
				{
					if (_lastPrice > candle.Open)
					{
						if (_lastPrice > trade.Price)
							RemoveOldSelection(bar, trade.Price + InstrumentInfo.TickSize, _lastPrice);
						else
							CheckPriceRange(bar, _lastPrice, trade.Price - InstrumentInfo.TickSize);
					}
					else
					{
						RemoveOldSelection(bar, _lastPrice, candle.Open);
						CheckPriceRange(bar, candle.Open, trade.Price - InstrumentInfo.TickSize);
					}
				}
				else
				{
					if (_lastPrice > candle.Open)
					{
						RemoveOldSelection(bar, _lastPrice, candle.Open);
						CheckPriceRange(bar, candle.Open, trade.Price + InstrumentInfo.TickSize);
					}
					else
					{
						if (_lastPrice > trade.Price)
							CheckPriceRange(bar, _lastPrice, trade.Price + InstrumentInfo.TickSize);
						else
							RemoveOldSelection(bar, trade.Price - InstrumentInfo.TickSize, _lastPrice);
					}
				}

				break;
			}
			case PriceLocation.UpperWick:
			{
				if (trade.Price >= candle.Open)
				{
					if (_lastPrice > candle.Open)
					{
						if (_lastPrice > trade.Price)
							CheckPriceRange(bar, trade.Price + InstrumentInfo.TickSize, _lastPrice);
						else
							RemoveOldSelection(bar, _lastPrice, trade.Price);
					}
					else
						RemoveOldSelection(bar, candle.Open, trade.Price);
				}
				else
				{
					if (_lastPrice > candle.Open)
					{
						RemoveOldSelection(bar, trade.Price, candle.Open);
						CheckPriceRange(bar, candle.Open + InstrumentInfo.TickSize, _lastPrice);
					}
				}

				break;
			}
			case PriceLocation.LowerWick:
			{
				if (trade.Price >= candle.Open)
				{
					if (_lastPrice < candle.Open)
					{
						RemoveOldSelection(bar, candle.Open, trade.Price);
						CheckPriceRange(bar, _lastPrice, candle.Open - InstrumentInfo.TickSize);
					}
				}
				else
				{
					if (_lastPrice > candle.Open)
						RemoveOldSelection(bar, trade.Price, _lastPrice);
					else
					{
						if (_lastPrice > trade.Price)
							RemoveOldSelection(bar, trade.Price, _lastPrice);
						else
							CheckPriceRange(bar, _lastPrice, trade.Price - InstrumentInfo.TickSize);
					}
				}

				break;
			}
			case PriceLocation.AtHighOrLow:
			{
				if (_lastSeriesBar.Count is 0)
					return;

				if (trade.Price == candle.High && _lastPrice != candle.Low)
					RemoveOldSelection(bar, _lastPrice, trade.Price - InstrumentInfo.TickSize);

				else if (trade.Price == candle.Low && _lastPrice != candle.High)
					RemoveOldSelection(bar, trade.Price + InstrumentInfo.TickSize, _lastPrice);
				break;
			}
			case PriceLocation.AtUpperLowerWick:
				if (trade.Price >= candle.Open)
				{
					if (_lastPrice < candle.Open)
					{
						CheckPriceRange(bar, _lastPrice, candle.Open - InstrumentInfo.TickSize);
						RemoveOldSelection(bar, candle.Open, trade.Price);
					}
					else
					{
						if (_lastPrice > trade.Price)
							CheckPriceRange(bar, trade.Price + InstrumentInfo.TickSize, _lastPrice);
						else
							RemoveOldSelection(bar, _lastPrice, trade.Price);
					}
				}
				else
				{
					if (_lastPrice > candle.Open)
					{
						if (_lastPrice > trade.Price)
						{
							CheckPriceRange(bar, candle.Open + InstrumentInfo.TickSize, _lastPrice);
							RemoveOldSelection(bar, trade.Price, candle.Open);
						}
					}
					else
					{
						if (_lastPrice > trade.Price)
							RemoveOldSelection(bar, trade.Price, _lastPrice);
						else
							CheckPriceRange(bar, _lastPrice, trade.Price - InstrumentInfo.TickSize);
					}
				}

				break;
		}
	}

	//Remove price selection from series by bar and price
	private void RemoveOldSelection(int bar, decimal price)
	{
		var idx = GetSeriesLevelIndex(bar, price);

		if (idx >= 0)
			_lastSeriesBar.RemoveAt(idx);
	}

	private void RemoveOldSelection(int bar, decimal from, decimal to)
	{
		for (var price = from; price <= to; price += InstrumentInfo.TickSize)
			RemoveOldSelection(bar, price);
	}

	//Insert or replace price level in series
	private void PlaceToDataSeries(int bar, CustomVolumeInfo cluster)
	{
		var value = CalcType switch
		{
			CalcMode.Bid => cluster.Bid,
			CalcMode.Ask => cluster.Ask,
			CalcMode.Delta => cluster.Delta,
			CalcMode.Volume or CalcMode.MaxVolume => cluster.Volume,
			CalcMode.Tick => cluster.Ticks,
			_ => 0
		};

		var level = CreatePriceSelectionValue(cluster);

        if (OnlyOneSelectionPerBar
		    && CalcType is not CalcMode.MaxVolume
		    && _lastSeriesBar.Count is not 0)
		{
			if (_lastSeriesBar[0].Context is decimal vol)
			{
				var newMax = CalcType is CalcMode.Delta
					? Math.Abs(vol) < Math.Abs(value)
					: vol < value;

				if (newMax)
					_lastSeriesBar[0] = level;
			}
		}
		else
		{
			InsertOrReplace(bar, level);
		}

		if (UseAlerts && _alertPrices.Add(cluster.Price) && _isFinishRecalculate)
			AddClusterAlert(level.Tooltip);
	}

	//Find index of price level by price
	private int GetSeriesLevelIndex(int bar, decimal value)
	{
		int left = 0, right = _lastSeriesBar.Count;

		while (left < right)
		{
			var mid = left + (right - left) / 2;

			if (_lastSeriesBar[mid].MinimumPrice < value)
				left = mid + 1;
			else if (_lastSeriesBar[mid].MinimumPrice > value)
				right = mid;
			else
				return mid;
		}

		return ~left;
	}

	//Create level value for data series
	private PriceSelectionValue CreatePriceSelectionValue(CustomVolumeInfo cluster)
	{
		var selectionSide = CalcType switch
		{
			CalcMode.Ask => SelectionType.Ask,
			CalcMode.Bid => SelectionType.Bid,
			_ => SelectionType.Full
		};

		var value = CalcType switch
		{
			CalcMode.Bid => cluster.Bid,
			CalcMode.Ask => cluster.Ask,
			CalcMode.Delta => cluster.Delta,
			CalcMode.Volume or CalcMode.MaxVolume => cluster.Volume,
			CalcMode.Tick => cluster.Ticks,
			_ => 0
		};

		var absValue = CalcType is CalcMode.Delta ? Math.Abs(value) : value;
		var clusterSize = FixedSizes ? _size : (int)(absValue * _size / Math.Max(_minFilterValue, 1));

		if (!FixedSizes)
		{
			clusterSize = Math.Min(clusterSize, MaxSize);
			clusterSize = Math.Max(clusterSize, MinSize);
		}

		var priceValue = new PriceSelectionValue(cluster.Price)
		{
			VisualObject = VisualType,
			Size = clusterSize,
			SelectionSide = selectionSide,
			ObjectColor = _clusterTransColor,
			ObjectsTransparency = _visualObjectsTransparency,
			PriceSelectionColor = ShowPriceSelection ? _clusterPriceColor : CrossColors.Transparent,
			Tooltip = CreateToolTip(value),
			Context = absValue,
			MinimumPrice = cluster.Price,
			MaximumPrice = cluster.Price + InstrumentInfo.TickSize * (PriceRange - 1)
		};

		return priceValue;
	}

	//Create tooltip text for PriceSelectionValue
	private string CreateToolTip(decimal value)
	{
		var tip = "Cluster Search" + Environment.NewLine + ChartInfo.TryGetMinimizedVolumeString(value) + " ";

		tip += CalcType switch
		{
			CalcMode.Bid => Strings.Bid,
			CalcMode.Ask => Strings.Ask,
			CalcMode.Delta => Strings.Delta,
			CalcMode.Volume => Strings.Volume,
			CalcMode.Tick => Strings.Ticks,
			CalcMode.MaxVolume => Strings.PocLevel,
			_ => ""
		};

		return tip;
	}

	#endregion
}









Indicators/Technical
/ClusterSearch.cs








namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;

using MoreLinq;

using OFT.Attributes;
using OFT.Localization;

using Utils.Common;
using Utils.Common.Collections;
using Utils.Common.Collections.Synchronized;

using static DynamicLevels;

[Category(IndicatorCategories.VolumeOrderFlow)]
[DisplayName("Cluster Search")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ClusterSearchDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602240")]
public partial class ClusterSearch : Indicator
{
	#region Fields

	private readonly PriceSelectionDataSeries _renderDataSeries = new("RenderDataSeries", "Price");
	private bool _autoFilter;
	private decimal _autoFilterValue;

	private HashSet<decimal> _alertPrices = [];

	private int _barsRange = 1;
	private CandleDirection _candleDirection = CandleDirection.Any;
	private CrossColor _clusterPriceColor;

	private Dictionary<(int Bar, decimal Price), PriceVolumeInfo> _clustersCache = new();

	private CrossColor _clusterTransColor;
	private int _days = 20;
	private decimal _deltaFilter;
	private decimal _deltaImbalance;
	private bool _fixedSizes;
	private bool _isFinishRecalculate;
	private int _lastBar = -1;

	private decimal _lastPrice;

	private SyncList<PriceSelectionValue> _lastSeriesBar = [];
	private decimal _maxAverageTrade;
	private Filter _maxFilter = new() { Enabled = true, Value = 99999 };
	private decimal _maxPercent;
	private int _maxSize = 50;

	private MergedClusterDictionary _mergedLevels;
	private decimal _minAverageTrade;
	private Filter _minFilter = new() { Enabled = true, Value = 1000 };
	private decimal _minFilterValue;
	private decimal _minPercent;
	private int _minSize = 5;
	private bool _onlyOneSelectionPerBar;
	private Filter _pipsFromHigh = new() { Value = 100000000 };
	private Filter _pipsFromLow = new() { Value = 100000000 };
	private PriceLocation _priceLocation = PriceLocation.Any;
	private int _priceRange = 1;
	private bool _showPriceSelection = true;
	private int _size = 10;
	private int _targetBar;
	private TimeSpan _timeFrom = TimeSpan.Zero;
	private TimeSpan _timeTo = TimeSpan.Zero;
	private CalcMode _type = CalcMode.Volume;
	private bool _usePrevClose;
	private bool _useTimeFilter;

	private Dictionary<decimal, CustomVolumeInfo> _validVolumeLevels = new();
	private int _visualObjectsTransparency;
	private ObjectType _visualType = ObjectType.Rectangle;

	#endregion

	#region ctor

	public ClusterSearch()
		: base(true)
	{
		VisualObjectsTransparency = 70;
		PriceSelectionColor = ClusterColor = CrossColor.FromArgb(100, 255, 0, 255);

		VisualType = ObjectType.Rectangle;

		DenyToChangePanel = true;
		_renderDataSeries.IsHidden = true;
		DataSeries[0] = _renderDataSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnInitialize()
	{
		_maxFilter.PropertyChanged += MaxMinFilter_PropertyChanged;
		_minFilter.PropertyChanged += MaxMinFilter_PropertyChanged;
		PipsFromHigh.PropertyChanged += Filter_PropertyChanged;
		PipsFromLow.PropertyChanged += Filter_PropertyChanged;

		MinCandleHeight.PropertyChanged += Filter_PropertyChanged;
		MaxCandleHeight.PropertyChanged += Filter_PropertyChanged;
		MinCandleBodyHeight.PropertyChanged += Filter_PropertyChanged;
		MaxCandleBodyHeight.PropertyChanged += Filter_PropertyChanged;
	}

	protected override void OnNewTrade(MarketDataArg trade)
	{
		if (!_isFinishRecalculate || UsePrevClose)
			return;

		var curBar = CurrentBar - 1;

		var i = 0;

		while (i < curBar)
		{
			if (trade.Time < GetCandle(curBar - i).Time)
			{
				i++;
				continue;
			}

			break;
		}

		if (_lastBar != curBar - i)
		{
			OnNewBar(curBar - i);
			_lastBar = curBar - i;
		}

		CalculateTick(curBar - i, trade);
		_lastPrice = trade.Price;
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar is 0 && UsePrevClose)
			return;

		if (!UsePrevClose)
		{
			if (_isFinishRecalculate)
				return;
		}
		else
			bar--;

		var newBar = _lastBar != bar;
		_lastBar = bar;

		if (bar < _targetBar || !newBar)
			return;

		if (bar is 0)
			_renderDataSeries[bar] = _lastSeriesBar;
		else
			OnNewBar(bar);

		CalculateBar(bar);
	}

	protected override void OnRecalculate()
	{
		if (InstrumentInfo is null)
			return;

		_lastBar = -1;
        _isFinishRecalculate = false;
		_mergedLevels = new MergedClusterDictionary(PriceRange, InstrumentInfo.TickSize);
		
		_autoFilterValue = 0;
		_targetBar = 0;

		if (Days is 0)
			return;

		var days = 0;

		for (var i = CurrentBar - 1; i >= 0; i--)
		{
			_targetBar = i;

			if (!IsNewSession(i))
				continue;

			days++;

			if (days == Days)
				break;
		}

		_lastSeriesBar.Clear();
		_renderDataSeries.Clear();
		_minFilterValue = MinimalFilter();
    }

	//Apply autofilter
	protected override void OnFinishRecalculate()
	{
		if (!AutoFilter)
		{
			_isFinishRecalculate = true;
			return;
		}

		var valuesList = new List<PriceSelectionValue>();

		for (var i = 0; i < _renderDataSeries.Count; i++)
		{
			if (_renderDataSeries[i].Count is 0)
				continue;

			valuesList.AddRange(_renderDataSeries[i]);
		}

		if (valuesList.Count is 0)
		{
			_isFinishRecalculate = true;
			return;
		}

		valuesList = valuesList.OrderByDescending(x => (decimal)x.Context).ToList();

		_autoFilterValue = valuesList.Count <= 10
			? (decimal)valuesList.Last().Context
			: (decimal)valuesList.Skip(10).First().Context;

		//Set autofilter value to see it in minimal filter value
		MinimumFilter.SetValueSilently(_autoFilterValue);

        for (var i = 0; i < _renderDataSeries.Count; i++)
		{
			if (_renderDataSeries[i].Count is 0)
				continue;

			_renderDataSeries[i].RemoveAll(x => (decimal)x.Context < _autoFilterValue);

			_renderDataSeries[i].ForEach(l =>
			{
				var clusterSize = FixedSizes ? _size : (int)((decimal)l.Context * _size / Math.Max(_autoFilterValue, 1));

				if (!FixedSizes)
				{
					clusterSize = Math.Min(clusterSize, MaxSize);
					clusterSize = Math.Max(clusterSize, MinSize);
				}

				l.Size = clusterSize;
			});
		}

		OnChangeProperty(nameof(MinimumFilter));

		_isFinishRecalculate = true;
	}

	#endregion

	#region Private methods

	private void CalculateTick(int bar, MarketDataArg trade)
	{
		var priceLevel = _clustersCache.GetOrAdd((bar, trade.Price), () => new CustomVolumeInfo(trade.Price));

		switch (trade.Direction)
		{
			case TradeDirection.Buy:
				priceLevel.Ask += trade.Volume;
				break;
			case TradeDirection.Sell:
				priceLevel.Bid += trade.Volume;
				break;
			case TradeDirection.Between:
			default:
				priceLevel.Between += trade.Volume;
				break;
		}

		priceLevel.Volume += trade.Volume;
		priceLevel.Ticks++;
		UpdateLevelCache(bar, trade);

		var candle = GetCandle(bar);
		var endPrice = Math.Max(candle.Low, candle.High - (PriceRange - 1) * InstrumentInfo.TickSize);

		for (var price = candle.Low; price <= endPrice; price += InstrumentInfo.TickSize)
		{
			if (!CheckCluster(bar, price))
				_validVolumeLevels.Remove(price);
		}

		if (!CheckBarFormation(candle))
		{
			_renderDataSeries[bar] = new SyncList<PriceSelectionValue>();
			return;
		}

		_renderDataSeries[bar] = _lastSeriesBar;

		if (_validVolumeLevels.Count is 0)
		{
			RemoveOldSelection(bar, trade.Price);
			return;
		}

		var ranges = GetPriceRanges(bar, endPrice);

		foreach (var range in ranges)
		{
			if (trade.Price < range.From || trade.Price > range.To)
				continue;

			RemoveOldSelection(bar, trade.Price);
			CheckPriceRange(bar, range.From, range.To);
			break;
		}

		if (_lastPrice == trade.Price)
			return;

		if (PriceLoc is not PriceLocation.Any)
			UpdatePriceLocationValues(bar, trade);

		if (PipsFromHigh.Enabled)
		{
			var lowValue = candle.High - InstrumentInfo.TickSize * PipsFromHigh.Value;

			if (lowValue > candle.Low)
			{
				for (var i = _lastSeriesBar.Count - 1; i >= 0; i--)
				{
					var item = _lastSeriesBar[i];

					if (item.MinimumPrice >= lowValue)
						break;

					_lastSeriesBar.RemoveAt(i);
				}
			}
		}

		if (PipsFromLow.Enabled)
		{
			var highValue = candle.Low + InstrumentInfo.TickSize * PipsFromLow.Value;

			if (highValue < candle.High)
			{
				for (var i = 0; i < _lastSeriesBar.Count; i++)
				{
					var item = _lastSeriesBar[i];

					if (item.MinimumPrice <= highValue)
						break;

					_lastSeriesBar.RemoveAt(i);
				}
			}
		}
	}

	private void OnNewBar(int bar)
	{
		_mergedLevels.Clear();
		_validVolumeLevels.Clear();

		if (CheckBarFormation(GetCandle(bar - 1)))
		{
			var lastBar = _lastSeriesBar.Select(p => p.MemberwiseClone()).ToArray();
			_renderDataSeries[bar - 1] = new SyncList<PriceSelectionValue>(lastBar);
		}
		else
			_renderDataSeries[bar - 1] = [];

		_lastSeriesBar.Clear();
		_renderDataSeries[bar] = _lastSeriesBar;

		_lastPrice = GetCandle(bar).Close;
		_alertPrices.Clear();
	}

	private void MaxMinFilter_PropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		Filter_PropertyChanged(sender, e);
	}

	//Calculate all clusters on current bar
	private void CalculateBar(int bar)
	{
		UpdateCumulativeCachePerBar(bar);

		var candle = GetCandle(bar);

		var endPrice = Math.Max(candle.Low, candle.High - (PriceRange - 1) * InstrumentInfo.TickSize);

		for (var price = candle.Low; price <= endPrice; price += InstrumentInfo.TickSize)
		{
			if (!CheckCluster(bar, price))
				_validVolumeLevels.Remove(price);
		}

		if (_validVolumeLevels.Count is 0)
			return;

		if (!CheckBarFormation(candle))
			return;

		var ranges = GetPriceRanges(bar, endPrice);

		foreach (var range in ranges)
			CheckPriceRange(bar, range.From, range.To);
	}

	/// <summary>
	///     Get price ranges on bar that are passed candle filters
	/// </summary>
	/// <param name="bar">Bar number</param>
	/// <param name="endPrice">High price minus price range value</param>
	/// <returns></returns>
	private List<(decimal From, decimal To)> GetPriceRanges(int bar, decimal endPrice)
	{
		var ranges = new List<(decimal From, decimal To)>();
		var candle = GetCandle(bar);

		var maxPrice = PipsFromLow.Enabled
			? candle.Low + PipsFromLow.Value * InstrumentInfo.TickSize
			: candle.High;

		var minPrice = PipsFromHigh.Enabled
			? candle.High - PipsFromHigh.Value * InstrumentInfo.TickSize
			: candle.Low;

		if (minPrice > maxPrice)
			return ranges;

		maxPrice = Math.Min(candle.High, maxPrice);
		minPrice = Math.Max(candle.Low, minPrice);

		switch (PriceLoc)
		{
			case PriceLocation.AtHigh when maxPrice != candle.High:
			case PriceLocation.AtLow when minPrice != candle.Low:
			case PriceLocation.AtHighOrLow when maxPrice != candle.High && minPrice != candle.Low:
				return ranges;

			case PriceLocation.Any:
				return [(minPrice, maxPrice)];

			case PriceLocation.AtHighOrLow:
			case PriceLocation.AtHigh:
			case PriceLocation.AtLow:
			{
				if (PriceLoc is PriceLocation.AtHighOrLow or PriceLocation.AtHigh)
				{
					if (maxPrice >= endPrice)
						ranges.Add((endPrice, endPrice));
				}

				if (PriceLoc is PriceLocation.AtHighOrLow or PriceLocation.AtLow)
				{
					if (minPrice <= candle.Low)
						ranges.Add((candle.Low, candle.Low));
				}

				return ranges;
			}
			case PriceLocation.AtUpperLowerWick or PriceLocation.UpperWick or PriceLocation.LowerWick or PriceLocation.Body:
			{
				var maxBody = Math.Max(candle.Close, candle.Open);
				var minBody = Math.Min(candle.Close, candle.Open);

				if (PriceLoc is PriceLocation.Body)
				{
					maxBody = Math.Min(maxBody, maxPrice);
					minBody = Math.Max(minBody, minPrice);
					return [(minBody, maxBody)];
				}

				if (PriceLoc is PriceLocation.UpperWick or PriceLocation.AtUpperLowerWick)
					ranges.Add((maxBody + InstrumentInfo.TickSize, maxPrice));

				if (PriceLoc is PriceLocation.LowerWick or PriceLocation.AtUpperLowerWick)
					ranges.Add((minPrice, minBody - InstrumentInfo.TickSize));

				return ranges;
			}
		}

		return ranges;
	}

	//Check valid clusters on filtered price range and draw it
	private void CheckPriceRange(int bar, decimal from, decimal to)
	{
		for (var price = from; price <= to; price += InstrumentInfo.TickSize)
			CheckPriceRange(bar, price);
	}

	private void CheckPriceRange(int bar, decimal price)
	{
		if (_validVolumeLevels.TryGetValue(price, out var info))
			PlaceToDataSeries(bar, info);
		else
			RemoveOldSelection(bar, price);
	}

	//Compare current candle with current candles filters
	private bool CheckBarFormation(IndicatorCandle candle)
	{
		if ((CandleDir is CandleDirection.Bearish && candle.Close >= candle.Open)
		    ||
		    (CandleDir is CandleDirection.Bullish && candle.Close <= candle.Open)
		    ||
		    (CandleDir is CandleDirection.Neutral && candle.Close != candle.Open))
			return false;

		if (UseTimeFilter)
		{
			var time = candle.Time.AddHours(InstrumentInfo.TimeZone);

			if (TimeFrom < TimeTo)
			{
				if (time < time.Date + TimeFrom)
					return false;

				if (time > time.Date + TimeTo)
					return false;
			}
			else
			{
				if (time < time.Date + TimeFrom && time > time.Date + TimeTo)
					return false;
			}
		}

		if (MinCandleHeight.Enabled || MaxCandleHeight.Enabled)
		{
			var height = (candle.High - candle.Low) / InstrumentInfo.TickSize + 1;

			if (MinCandleHeight.Enabled && height < MinCandleHeight.Value)
				return false;

			if (MaxCandleHeight.Enabled && height > MaxCandleHeight.Value)
				return false;
		}

		if (MinCandleBodyHeight.Enabled || MaxCandleBodyHeight.Enabled)
		{
			var bHeight = Math.Abs(candle.Close - candle.Open) / InstrumentInfo.TickSize + 1;

			if (MinCandleBodyHeight.Enabled && bHeight < MinCandleBodyHeight.Value)
				return false;

			if (MaxCandleBodyHeight.Enabled && bHeight > MaxCandleBodyHeight.Value)
				return false;
		}

		return true;
	}

	//Merge wide clusters if price levels is more then 1
	//Compare clusters values with volume filters
	private bool CheckCluster(int bar, decimal price)
	{
		var fullLevel = new CustomVolumeInfo(price);
		var endPrice = price + (PriceRange - 1) * InstrumentInfo.TickSize;

		for (var iPrice = price; iPrice <= endPrice; iPrice += InstrumentInfo.TickSize)
		{
			if (_mergedLevels.TryGetValue(iPrice, out var level))
				fullLevel += level;
		}

		if (CalcType is CalcMode.MaxVolume && price != _mergedLevels.PocPrice)
			return false;

		var value = CalcType switch
		{
			CalcMode.Bid => fullLevel.Bid,
			CalcMode.Ask => fullLevel.Ask,
			CalcMode.Delta => fullLevel.Delta,
			CalcMode.Volume or CalcMode.MaxVolume => fullLevel.Volume,
			CalcMode.Tick => fullLevel.Ticks,
			_ => 0
		};

		if (AutoFilter)
		{
			if (_autoFilterValue is 0)
			{
				_validVolumeLevels[price] = fullLevel;
				return true;
			}

			if (value < _autoFilterValue)
				return false;
		}

		if (MinimumFilter.Enabled && value < MinimumFilter.Value)
			return false;

		if (MaximumFilter.Enabled && value > MaximumFilter.Value)
			return false;

		if (MinAverageTrade != 0 && fullLevel.AvgTrade < MinAverageTrade)
			return false;

		if (MaxAverageTrade != 0 && fullLevel.AvgTrade > MinAverageTrade)
			return false;

		if (MinPercent != 0 || MaxPercent != 0)
		{
			var curPerc = 100 * fullLevel.Volume / _mergedLevels.TotalVolume;

			if (curPerc < MinPercent || curPerc > MaxPercent)
				return false;
		}

		if (DeltaImbalance != 0)
		{
			var ask = fullLevel.Ask;
			var bid = fullLevel.Bid;
			var vol = fullLevel.Volume;

			var askImbalance = vol is not 0
				? ask * 100.0m / vol
				: 0;

			var bidImbalance = vol is not 0
				? bid * 100.0m / vol
				: 0;

			switch (DeltaImbalance)
			{
				case > 0 when askImbalance < DeltaImbalance:
				case < 0 when bidImbalance < Math.Abs(DeltaImbalance):
					return false;
			}
		}

		if (DeltaFilter != 0)
		{
			var delta = fullLevel.Delta;

			switch (DeltaFilter)
            {
				case > 0 when delta < DeltaFilter:
				case < 0 when delta > DeltaFilter:
					return false;
			}
		}

		_validVolumeLevels[price] = fullLevel;
		return true;
	}

	//Create horizontal merged clusters on all current bar prices
	private void UpdateCumulativeCachePerBar(int bar)
	{
		var candle = GetCandle(bar);
		var highPrice = candle.High - (PriceRange - 1) * InstrumentInfo.TickSize;

		for (var iPrice = candle.Low; iPrice <= highPrice; iPrice += InstrumentInfo.TickSize)
			CreateLevelCache(bar, iPrice);
	}

	//Create horizontal merged clusters
	private void CreateLevelCache(int bar, decimal price)
	{
		var level = new CustomVolumeInfo(price);
		var endBar = Math.Max(0, bar - (BarsRange - 1));

		for (var i = bar; i >= endBar; i--)
		{
			var iCandle = GetCandle(i);
			var cluster = _clustersCache.GetOrAdd((i, price), () => iCandle.GetPriceVolumeInfo(price), true);

			if (cluster is null)
				continue;

			level.Ask += cluster.Ask;
			level.Between += cluster.Between;
			level.Bid += cluster.Bid;
			level.Ticks += cluster.Ticks;
			level.Volume += cluster.Volume;
		}

		_mergedLevels[price] = level;
	}

	//Increment trade data to existing cluster
	private void UpdateLevelCache(int bar, MarketDataArg trade)
	{
		if (!_mergedLevels.TryGetValue(trade.Price, out var level))
		{
			level = new CustomVolumeInfo(trade.Price);
			var startBar = Math.Max(0, bar - 1);
			var endBar = Math.Max(0, bar - (BarsRange - 1));

			for (var i = startBar; i >= endBar; i--)
			{
				var iCandle = GetCandle(i);
				var cluster = _clustersCache.GetOrAdd((i, trade.Price), () => iCandle.GetPriceVolumeInfo(trade.Price), true);

				if (cluster is null)
					continue;

				level.Ask += cluster.Ask;
				level.Between += cluster.Between;
				level.Bid += cluster.Bid;
				level.Ticks += cluster.Ticks;
				level.Volume += cluster.Volume;
			}

			_mergedLevels[trade.Price] = level;
		}

		_mergedLevels.RemoveVolume(level);

		switch (trade.Direction)
		{
			case TradeDirection.Buy:
				level.Ask += trade.Volume;
				break;
			case TradeDirection.Sell:
				level.Bid += trade.Volume;
				break;
			case TradeDirection.Between:
			default:
				level.Between += trade.Volume;
				break;
		}
		
		level.Volume += trade.Volume;
		level.Ticks++;

		_mergedLevels.AddVolume(level);
    }

	//Update data series values size on properties change
	private void SetSize()
	{
		if (_fixedSizes)
		{
			for (var i = 0; i < _renderDataSeries.Count; i++)
				_renderDataSeries[i].ForEach(x => x.Size = _size);
		}
		else
		{
			var filterValue = MinimalFilter();

			for (var i = 0; i < _renderDataSeries.Count; i++)
			{
				_renderDataSeries[i].ForEach(x =>
				{
					x.Size = (int)((decimal)x.Context * _size / Math.Max(filterValue, 1));

					if (x.Size > MaxSize)
						x.Size = MaxSize;

					if (x.Size < MinSize)
						x.Size = MinSize;
				});
			}
		}
	}

	private void Filter_PropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		RecalculateValues();
		RedrawChart();
	}

	private void AddClusterAlert(string msg)
	{
		if (!UseAlerts)
			return;

		AddAlert(AlertFile, InstrumentInfo.Instrument, msg, AlertColor, ClusterColor);
	}

	private decimal MinimalFilter()
	{
		var minFilter = MinimumFilter.Enabled ? MinimumFilter.Value : 0;
		var maxFilter = MaximumFilter.Enabled ? MaximumFilter.Value : 0;

		if (MinimumFilter.Value >= 0 && MaximumFilter.Value >= 0)
			return minFilter;

		if (MinimumFilter.Value < 0 && MaximumFilter.Value >= 0)
			return Math.Min(Math.Abs(minFilter), maxFilter);

		return Math.Abs(maxFilter);
	}

	#endregion

	#region Filters

	[Browsable(false)]
	[Obsolete]
	public MiddleClusterType Type
	{
		get => CalcType switch
		{
			CalcMode.Bid => MiddleClusterType.Bid,
			CalcMode.Ask => MiddleClusterType.Ask,
			CalcMode.Delta => MiddleClusterType.Delta,
			CalcMode.Volume => MiddleClusterType.Volume,
			CalcMode.Tick => MiddleClusterType.Tick,
			_ => MiddleClusterType.Volume
		};
		set => CalcType = value switch
		{
			MiddleClusterType.Bid => CalcMode.Bid,
			MiddleClusterType.Ask => CalcMode.Ask,
			MiddleClusterType.Delta => CalcMode.Delta,
			MiddleClusterType.Volume or MiddleClusterType.Time => CalcMode.Volume,
			MiddleClusterType.Tick => CalcMode.Tick,
			_ => throw new ArgumentOutOfRangeException(nameof(value), value, null)
		};
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Name = nameof(Strings.CalculationMode),
		Description = nameof(Strings.CalculationModeDescription), Order = 200)]
	public CalcMode CalcType
	{
		get => _type;
		set
		{
			_type = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Name = nameof(Strings.AutoFilter),
		Description = nameof(Strings.ClusterSearchAutofilterDescription), Order = 215)]
	public bool AutoFilter
	{
		get => _autoFilter;
		set
		{
			_autoFilter = value;

			MinimumFilter.Enabled = MaximumFilter.Enabled = !value;

			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MinimumFilterDescription),
		Name = nameof(Strings.MinValue), Order = 220)]
	public Filter MinimumFilter
	{
		get => _minFilter;
		set
		{
			_minFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MaximumFilterDescription),
		Name = nameof(Strings.MaxValue), Order = 230)]
	public Filter MaximumFilter
	{
		get => _maxFilter;
		set
		{
			_maxFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Name = nameof(Strings.MinimumAverageTrade), Order = 470,
		Description = nameof(Strings.MinAvgTradeDescription))]
	[Range(0, 10000000)]
	public decimal MinAverageTrade
	{
		get => _minAverageTrade;
		set
		{
			_minAverageTrade = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Name = nameof(Strings.MaximumAverageTrade), Order = 480,
		Description = nameof(Strings.MaxAvgTradeDescription))]
	[Range(0, 10000000)]
	public decimal MaxAverageTrade
	{
		get => _maxAverageTrade;
		set
		{
			_maxAverageTrade = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Name = nameof(Strings.MinVolumePercent), Order = 490,
		Description = nameof(Strings.MinPercentDescription))]
	[Range(0, 100)]
	public decimal MinPercent
	{
		get => _minPercent;
		set
		{
			_minPercent = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Filters), Name = nameof(Strings.MaxVolumePercent), Order = 492,
		Description = nameof(Strings.MaxPercentDescription))]
	[Range(0, 100)]
	public decimal MaxPercent
	{
		get => _maxPercent;
		set
		{
			_maxPercent = value;
			RecalculateValues();
		}
	}

	#endregion

	#region DeltaFilters

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.DeltaFilters), Name = nameof(Strings.DeltaImbalance), Order = 300,
		Description = nameof(Strings.DeltaImbalanceDescription))]
	[Range(-100, 100)]
	public decimal DeltaImbalance
	{
		get => _deltaImbalance;
		set
		{
			_deltaImbalance = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.DeltaFilters), Name = nameof(Strings.DeltaFilter), Order = 310,
		Description = nameof(Strings.DeltaFilterDescription))]
	public decimal DeltaFilter
	{
		get => _deltaFilter;
		set
		{
			_deltaFilter = value;
			RecalculateValues();
		}
	}

	#endregion

	#region Location filters

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.LocationFilters), Name = nameof(Strings.CandleDirection),
		Description = nameof(Strings.CandleDirectionDescription), Order = 400)]
	public CandleDirection CandleDir
	{
		get => _candleDirection;
		set
		{
			_candleDirection = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.LocationFilters), Name = nameof(Strings.BarsRange), Order = 410,
		Description = nameof(Strings.BarsRangeDescription))]
	[Range(1, 10000)]
	public int BarsRange
	{
		get => _barsRange;
		set
		{
			_barsRange = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.LocationFilters), Name = nameof(Strings.PriceRange), Order = 420,
		Description = nameof(Strings.PriceRangeDescription))]
	[Range(1, 100000)]
	public int PriceRange
	{
		get => _priceRange;
		set
		{
			_priceRange = value;
			RecalculateValues();
		}
	}

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.LocationFilters), Name = nameof(Strings.PipsFromHigh), Order = 430,
		Description = nameof(Strings.PipsFromHighDescription))]
	public Filter PipsFromHigh
	{
		get => _pipsFromHigh;
		set
		{
			_pipsFromHigh = value;
			RecalculateValues();
		}
	}

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.LocationFilters), Name = nameof(Strings.PipsFromLow), Order = 440,
		Description = nameof(Strings.PipsFromLowDescription))]
	public Filter PipsFromLow
	{
		get => _pipsFromLow;
		set
		{
			_pipsFromLow = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.LocationFilters), Name = nameof(Strings.PriceLocation), Order = 450,
		Description = nameof(Strings.PriceLocationDescription))]
	public PriceLocation PriceLoc
	{
		get => _priceLocation;
		set
		{
			_priceLocation = value;
			RecalculateValues();
		}
	}

	#endregion

	#region Candle size filters

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumCandleHeight), GroupName = nameof(Strings.CandleHeight), Order = 460,
		Description = nameof(Strings.MinCandleHeightDescription))]
	public FilterInt MinCandleHeight { get; set; } = new()
		{ Value = 1, Enabled = false };

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumCandleHeight), GroupName = nameof(Strings.CandleHeight), Order = 461,
		Description = nameof(Strings.MaxCandleHeightDescription))]
	public FilterInt MaxCandleHeight { get; set; } = new()
		{ Value = 1, Enabled = false };

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumCandleBodyHeight), GroupName = nameof(Strings.CandleHeight), Order = 470,
		Description = nameof(Strings.MinCandleBodyHeightDescription))]
	public FilterInt MinCandleBodyHeight { get; set; } = new()
		{ Value = 1, Enabled = false };

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumCandleBodyHeight), GroupName = nameof(Strings.CandleHeight), Order = 471,
		Description = nameof(Strings.MaxCandleBodyHeightDescription))]
	public FilterInt MaxCandleBodyHeight { get; set; } = new()
		{ Value = 1, Enabled = false };

	#endregion

	#region Time filtration

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeFiltration), Name = nameof(Strings.UseTimeFilter), Order = 500,
		Description = nameof(Strings.UseTimeFilterDescription))]
	public bool UseTimeFilter
	{
		get => _useTimeFilter;
		set
		{
			_useTimeFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeFiltration), Name = nameof(Strings.TimeFrom), Order = 510,
		Description = nameof(Strings.TimeFromDescription))]
	public TimeSpan TimeFrom
	{
		get => _timeFrom;
		set
		{
			_timeFrom = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.TimeFiltration), Name = nameof(Strings.TimeTo), Order = 520,
		Description = nameof(Strings.TimeToDescription))]
	public TimeSpan TimeTo
	{
		get => _timeTo;
		set
		{
			_timeTo = value;
			RecalculateValues();
		}
	}

	#endregion

	#region Visualization

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.OnlyOneSelectionPerBar), Order = 590,
		Description = nameof(Strings.OneSelectionPerBarDescription))]
	public bool OnlyOneSelectionPerBar
	{
		get => _onlyOneSelectionPerBar;
		set
		{
			_onlyOneSelectionPerBar = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.VisualMode), Order = 600,
		Description = nameof(Strings.VisualModeDescription))]
	public ObjectType VisualType
	{
		get => _visualType;
		set
		{
			_visualType = value;

			for (var i = 0; i < _renderDataSeries.Count; i++)
				_renderDataSeries[i].ForEach(x => { x.VisualObject = value; });
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.ObjectsColor), Order = 605,
		Description = nameof(Strings.VisualObjectsDescription))]
	public CrossColor ClusterColor
	{
		get => _clusterTransColor;
		set
		{
			_clusterTransColor = value;

			for (var i = 0; i < _renderDataSeries.Count; i++)
				_renderDataSeries[i].ForEach(x => { x.ObjectColor = _clusterTransColor; });
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.VisualObjectsTransparency), Order = 610,
		Description = nameof(Strings.VisualObjectsTransparencyDescription))]
	[Range(0, 100)]
	public int VisualObjectsTransparency
	{
		get => _visualObjectsTransparency;
		set
		{
			_visualObjectsTransparency = value;

			for (var i = 0; i < _renderDataSeries.Count; i++)
			{
				_renderDataSeries[i].ForEach(x =>
				{
					x.ObjectColor = _clusterTransColor;
					x.ObjectsTransparency = _visualObjectsTransparency;
				});
			}
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.ShowPriceSelection), Order = 615,
		Description = nameof(Strings.ShowPriceSelectionDescription))]
	public bool ShowPriceSelection
	{
		get => _showPriceSelection;
		set
		{
			_showPriceSelection = value;

			for (var i = 0; i < _renderDataSeries.Count; i++)
				_renderDataSeries[i].ForEach(x => { x.PriceSelectionColor = value ? _clusterPriceColor : CrossColors.Transparent; });
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.PriceSelectionColor), Order = 620,
		Description = nameof(Strings.PriceSelectionColorDescription))]
	public CrossColor PriceSelectionColor
	{
		get => _clusterPriceColor;
		set
		{
			_clusterPriceColor = value;

			for (var i = 0; i < _renderDataSeries.Count; i++)
				_renderDataSeries[i].ForEach(x => x.PriceSelectionColor = ShowPriceSelection ? _clusterPriceColor : CrossColors.Transparent);
		}
	}

	[Browsable(false)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.ClusterSelectionTransparency), Order = 625,
		Description = nameof(Strings.PriceSelectionTransparencyDescription))]
	[Range(0, 100)]
	public int Transparency { get; set; }

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.FixedSizes), Order = 640,
		Description = nameof(Strings.FixedSizesDescription))]
	public bool FixedSizes
	{
		get => _fixedSizes;
		set
		{
			_fixedSizes = value;
			SetSize();
		}
	}

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Size), Order = 650,
		Description = nameof(Strings.SizeDescription))]
	public int Size
	{
		get => _size;
		set
		{
			_size = value;
			SetSize();
		}
	}

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.MinimumSize), Order = 660,
		Description = nameof(Strings.MinimumSizeDescription))]
	public int MinSize
	{
		get => _minSize;
		set
		{
			_minSize = value;

			if (!_fixedSizes)
			{
				var filterValue = MinimalFilter();

				for (var i = 0; i < _renderDataSeries.Count; i++)
				{
					_renderDataSeries[i].ForEach(x =>
					{
						x.Size = (int)((decimal)x.Context * _size / Math.Max(filterValue, 1));

						if (x.Size > MaxSize)
							x.Size = MaxSize;

						if (x.Size < value)
							x.Size = value;
					});
				}
			}
		}
	}

	[Range(1, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.MaximumSize), Order = 670,
		Description = nameof(Strings.MaximumSizeDescription))]
	public int MaxSize
	{
		get => _maxSize;
		set
		{
			_maxSize = value;

			if (!_fixedSizes)
			{
				var filterValue = MinimalFilter();

				for (var i = 0; i < _renderDataSeries.Count; i++)
				{
					_renderDataSeries[i].ForEach(x =>
					{
						x.Size = (int)((decimal)x.Context * _size / Math.Max(filterValue, 1));

						if (x.Size > value)
							x.Size = value;

						if (x.Size < MinSize)
							x.Size = MinSize;
					});
				}
			}
		}
	}

	#endregion

	#region Alerts

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Alerts), Name = nameof(Strings.UseAlerts), Order = 700,
		Description = nameof(Strings.UseAlertDescription))]
	public bool UseAlerts { get; set; }

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Alerts), Name = nameof(Strings.AlertFile), Order = 720,
		Description = nameof(Strings.AlertFileDescription))]
	public string AlertFile { get; set; } = "alert2";

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Alerts), Name = nameof(Strings.BackGround), Order = 740,
		Description = nameof(Strings.AlertBackgroundDescription))]
	public CrossColor AlertColor { get; set; } = CrossColors.Black;

	#endregion

	#region Calculation

	[Range(0, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue,
		Description = nameof(Strings.DaysLookBackDescription))]
	public int Days
	{
		get => _days;
		set
		{
			_days = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.UsePreviousClose), Order = 800,
		Description = nameof(Strings.CalculateOnBarCloseDescription))]
	public bool UsePrevClose
	{
		get => _usePrevClose;
		set
		{
			_usePrevClose = value;
			RecalculateValues();
		}
	}

	#endregion
}








Technical/ClusterStatistic.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Globalization;
using System.Linq;

using ATAS.Indicators.Drawing;
using ATAS.Indicators.Technical.Extensions;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering;
using OFT.Rendering.Context;
using OFT.Rendering.Control;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

using Utils.Common.Logging;

using Color = CrossColor;

[DisplayName("Cluster Statistic")]
[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ClusterStatisticDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602624")]
public class ClusterStatistic : Indicator
{
	#region Nested types

	public class SortedRows : SortedList<int, DataType>
	{
		#region Properties

		public int SkipIdx { get; set; } = -1;

		#endregion
	}

	public class RenderOrder : Dictionary<DataType, RenderInfo>
	{
		#region Fields

		public readonly SortedRows AvailableStrings = new();

		#endregion

		#region ctor

		public RenderOrder()
		{
			Add(DataType.Ask, new RenderInfo(0));
			Add(DataType.Bid, new RenderInfo(1));
			Add(DataType.Delta, new RenderInfo(2));
			Add(DataType.DeltaVolume, new RenderInfo(3));
			Add(DataType.SessionDelta, new RenderInfo(4));
			Add(DataType.SessionDeltaVolume, new RenderInfo(5));
			Add(DataType.MaxDelta, new RenderInfo(6));
			Add(DataType.MinDelta, new RenderInfo(7));
			Add(DataType.DeltaChange, new RenderInfo(8));
			Add(DataType.Volume, new RenderInfo(9));
			Add(DataType.VolumeSecond, new RenderInfo(10));
			Add(DataType.SessionVolume, new RenderInfo(11));
			Add(DataType.Trades, new RenderInfo(12));
			Add(DataType.Height, new RenderInfo(13));
			Add(DataType.Time, new RenderInfo(14));
			Add(DataType.Duration, new RenderInfo(15));
		}

		#endregion

		#region Public methods

		public void SetEnabled(DataType type, bool enabled)
		{
			this[type].Enabled = enabled;
			RebuildCache();
		}

		public void UpdateOrder(DataType from, DataType to)
		{
			var fromOrder = this[from].Order;
			var toOrder = this[to].Order;

			if (fromOrder > toOrder)
			{
				foreach (var row in this.Where(row => row.Value.Order < fromOrder && row.Value.Order >= toOrder))
					row.Value.Order++;
			}
			else
			{
				foreach (var row in this.Where(row => row.Value.Order > fromOrder && row.Value.Order <= toOrder))
					row.Value.Order--;
			}

			this[from].Order = toOrder;
			RebuildCache();
		}

		#endregion

		#region Private methods

		private void RebuildCache()
		{
			AvailableStrings.Clear();

			foreach (var (type, info) in this)
			{
				if (!info.Enabled)
					continue;

				AvailableStrings.Add(info.Order, type);
			}
		}

		#endregion
	}

	public class RenderInfo(int order, bool enabled = false)
	{
		#region Properties

		public int Order { get; set; } = order;

		public bool Enabled { get; set; } = enabled;

		#endregion
	}

	private struct MaxValues
	{
		public decimal MaxAsk { get; set; }

		public decimal MaxBid { get; set; }

		public decimal MaxSessionDelta { get; set; }

		public decimal MaxDeltaPerVolume { get; set; }

		public decimal MaxSessionDeltaPerVolume { get; set; }

		public decimal MaxDelta { get; set; }

		public decimal MinDelta { get; set; }

		public decimal MaxMaxDelta { get; set; }

		public decimal MaxMinDelta { get; set; }

		public decimal MaxVolume { get; set; }

		public decimal MaxTicks { get; set; }

		public decimal MaxDuration { get; set; }

		public decimal CumVolume { get; set; }

		public decimal MaxDeltaChange { get; set; }

		public decimal MaxHeight { get; set; }

		public decimal MaxVolumeSec { get; set; }
	}

	public enum DataType
	{
		Ask,
		Bid,
		Delta,
		DeltaVolume,
		SessionDelta,
		SessionDeltaVolume,
		MaxDelta,
		MinDelta,
		DeltaChange,
		Volume,
		VolumeSecond,
		SessionVolume,
		Trades,
		Height,
		Time,
		Duration,
		None
	}

	#endregion

	#region Static and constants

	private const int _headerOffset = 3;

	private static readonly RenderStringFormat _tipFormat = new()
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center
	};

	#endregion

	#region Fields

	private readonly ValueDataSeries _candleDurations = new("durations");
	private readonly ValueDataSeries _candleHeights = new("heights");
	private readonly ValueDataSeries _cDelta = new("cDelta");
	private readonly ValueDataSeries _cDeltaPerVol = new("DeltaPerVol");
	private readonly ValueDataSeries _cVolume = new("cVolume");
	private readonly ValueDataSeries _deltaPerVol = new("BarDeltaPerVol");

	private readonly RenderStringFormat _stringLeftFormat = new()
	{
		Alignment = StringAlignment.Near,
		LineAlignment = StringAlignment.Center,
		Trimming = StringTrimming.EllipsisCharacter,
		FormatFlags = StringFormatFlags.NoWrap
	};

	private readonly ValueDataSeries _volPerSecond = new("VolPerSecond");
	private bool _atHeader;

	private bool _atPanel;

	private byte _bgAlpha = 255;
	private int _bgTransparency = 10;
	private bool _centerAlign;
	private decimal _cumVolume;
	private bool _fontChanged;
	private System.Drawing.Color _headerBackground = System.Drawing.Color.FromArgb(0xFF, 84, 84, 84);

	private int _headerWidth = 130;

	private int _height = 15;

	private int _lastBar = -1;
	private int _lastDeltaAlert;
	private decimal _lastDeltaValue;
	private int _lastVolumeAlert;
	private decimal _lastVolumeValue;

	private RenderPen _linePen = new(System.Drawing.Color.Transparent);
	private decimal _maxAsk;
	private decimal _maxBid;
	private decimal _maxDelta;
	private decimal _maxDeltaChange;
	private decimal _maxDeltaPerVolume;
	private decimal _maxDuration;
	private decimal _maxHeight;
	private decimal _maxMaxDelta;
	private decimal _maxMinDelta;
	private decimal _maxSessionDelta;
	private decimal _maxSessionDeltaPerVolume;
	private decimal _maxTicks;
	private decimal _maxVolume;
	private decimal _minDelta;

	private DataType _pressedString = DataType.None;
	
	private int _selectionOffset;
	private RenderPen _selectionPen = new(System.Drawing.Color.Transparent, 3);
	private int _selectionY;
	private bool _showAsk;
	private bool _showBid;
	private bool _showDelta;
	private bool _showDeltaChange;
	private bool _showDeltaPerVolume;
	private bool _showDuration;
	private bool _showHighLow;
	private bool _showMaximumDelta;
	private bool _showMinimumDelta;
	private bool _showSessionDelta;
	private bool _showSessionDeltaPerVolume;
	private bool _showSessionVolume;
	private bool _showTicks;
	private bool _showTime;
	private bool _showVolume;
	private bool _showVolumePerSecond;
	private System.Drawing.Color _textColor;
	private string _tipText;

	[Browsable(false)]
	public RenderOrder RowsOrder = new();

    #endregion

    #region Properties

    private int StrCount => RowsOrder.AvailableStrings.Count;
	
    #region Rows

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowAsk), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowAsksDescription), Order = 110)]
    public bool ShowAsk
    {
        get => _showAsk;
        set
        {
            _showAsk = value;
            RowsOrder.SetEnabled(DataType.Ask, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowBid), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowBidsDescription), Order = 110)]
    public bool ShowBid
    {
        get => _showBid;
        set
        {
            _showBid = value;
            RowsOrder.SetEnabled(DataType.Bid, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDelta), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowDeltaDescription), Order = 120)]
    public bool ShowDelta
    {
        get => _showDelta;
        set
        {
            _showDelta = value;
            RowsOrder.SetEnabled(DataType.Delta, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDeltaPerVolume), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowDeltaPerVolumeDescription), Order = 130)]
    public bool ShowDeltaPerVolume
    {
        get => _showDeltaPerVolume;
        set
        {
            _showDeltaPerVolume = value;
            RowsOrder.SetEnabled(DataType.DeltaVolume, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSessionDelta), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowSessionDeltaDescription), Order = 140)]
    public bool ShowSessionDelta
    {
        get => _showSessionDelta;
        set
        {
            _showSessionDelta = value;
            RowsOrder.SetEnabled(DataType.SessionDelta, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSessionDeltaPerVolume), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowSessionDeltaPerVolumeDescription), Order = 150)]
    public bool ShowSessionDeltaPerVolume
    {
        get => _showSessionDeltaPerVolume;
        set
        {
            _showSessionDeltaPerVolume = value;
            RowsOrder.SetEnabled(DataType.SessionDeltaVolume, value);

            if (value)
                _headerWidth = 180;
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowMaximumDelta), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowMaximumDeltaDescription), Order = 160)]
    public bool ShowMaximumDelta
    {
        get => _showMaximumDelta;
        set
        {
            _showMaximumDelta = value;
            RowsOrder.SetEnabled(DataType.MaxDelta, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowMinimumDelta), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowMinimumDeltaDescription), Order = 170)]
    public bool ShowMinimumDelta
    {
        get => _showMinimumDelta;
        set
        {
            _showMinimumDelta = value;
            RowsOrder.SetEnabled(DataType.MinDelta, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDeltaChange), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowDeltaChangeDescription), Order = 175)]
    public bool ShowDeltaChange
    {
        get => _showDeltaChange;
        set
        {
            _showDeltaChange = value;
            RowsOrder.SetEnabled(DataType.DeltaChange, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolume), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowVolumesDescription), Order = 180)]
    public bool ShowVolume
    {
        get => _showVolume;
        set
        {
            _showVolume = value;
            RowsOrder.SetEnabled(DataType.Volume, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolumePerSecond), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowVolumePerSecondDescription), Order = 190)]
    public bool ShowVolumePerSecond
    {
        get => _showVolumePerSecond;
        set
        {
            _showVolumePerSecond = value;
            RowsOrder.SetEnabled(DataType.VolumeSecond, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSessionVolume), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowSessionVolumeDescription), Order = 191)]
    public bool ShowSessionVolume
    {
        get => _showSessionVolume;
        set
        {
            _showSessionVolume = value;
            RowsOrder.SetEnabled(DataType.SessionVolume, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTradesCount), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowTradesCountDescription), Order = 192)]
    public bool ShowTicks
    {
        get => _showTicks;
        set
        {
            _showTicks = value;
            RowsOrder.SetEnabled(DataType.Trades, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowHeight), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowCandleHeightDescription), Order = 193)]
    public bool ShowHighLow
    {
        get => _showHighLow;
        set
        {
            _showHighLow = value;
            RowsOrder.SetEnabled(DataType.Height, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTime), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowCandleTimeDescription), Order = 194)]
    public bool ShowTime
    {
        get => _showTime;
        set
        {
            _showTime = value;
            RowsOrder.SetEnabled(DataType.Time, value);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDuration), GroupName = nameof(Strings.Rows),
        Description = nameof(Strings.ShowCandleDurationDescription), Order = 196)]
    public bool ShowDuration
    {
        get => _showDuration;
        set
        {
            _showDuration = value;
            RowsOrder.SetEnabled(DataType.Duration, value);
        }
    }

    #endregion

    #region Colors

    [Display(ResourceType = typeof(Strings), Name = "BackGround", GroupName = nameof(Strings.Visualization),
        Description = nameof(Strings.LabelFillColorDescription), Order = 200)]
    public Color BackGroundColor { get; set; } = Color.FromArgb(120, 0, 0, 0);

    [Range(1, 10)]
    [Display(ResourceType = typeof(Strings), Name = "Transparency", GroupName = nameof(Strings.Visualization), Order = 205)]
    public int BgTransparency
    {
        get => _bgTransparency;
        set
        {
            _bgTransparency = value;
            _bgAlpha = (byte)(255 * value / 10);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Grid), GroupName = nameof(Strings.Visualization),
        Description = nameof(Strings.GridColorDescription), Order = 210)]
    public Color GridColor
    {
        get => _linePen.Color.Convert();
        set
        {
            _linePen = new RenderPen(value.Convert());
            _selectionPen = new RenderPen(value.Convert(), 3);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisibleProportion), GroupName = nameof(Strings.Visualization),
        Description = nameof(Strings.VisibleProportionDescription), Order = 220)]
    public bool VisibleProportion { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume), GroupName = nameof(Strings.Visualization),
        Description = nameof(Strings.VolumeColorDescription), Order = 230)]
    public Color VolumeColor { get; set; } = CrossColors.DarkGray;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskColor), GroupName = nameof(Strings.Visualization),
        Description = nameof(Strings.AskColorDescription), Order = 240)]
    public Color AskColor { get; set; } = CrossColors.Green;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidColor), GroupName = nameof(Strings.Visualization),
        Description = nameof(Strings.BidColorDescription), Order = 250)]
    public Color BidColor { get; set; } = CrossColors.Red;

    #endregion

    #region Text

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Text),
        Description = nameof(Strings.LabelTextColorDescription), Order = 300)]
    public Color TextColor
    {
        get => _textColor.Convert();
        set => _textColor = value.Convert();
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.Text),
        Description = nameof(Strings.FontSettingDescription), Order = 310)]
    public FontSetting Font { get; set; } = new("Arial", 9);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CenterAlign), GroupName = nameof(Strings.Text),
        Description = nameof(Strings.CenterAlignDescription), Order = 320)]
    public bool CenterAlign
    {
        get => _centerAlign;
        set
        {
            _centerAlign = value;
            _stringLeftFormat.Alignment = value ? StringAlignment.Center : StringAlignment.Near;
        }
    }

    #endregion

    #region Headers

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Headers),
        Description = nameof(Strings.HeaderBackgroundDescription), Order = 330)]
    public Color HeaderBackground
    {
        get => _headerBackground.Convert();
        set => _headerBackground = value.Convert();
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideRowsDescription), GroupName = nameof(Strings.Headers),
        Description = nameof(Strings.HideHeadersDescription), Order = 340)]
    public bool HideRowsDescription { get; set; }

    #endregion

    #region Volume Alert

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.VolumeAlert),
        Description = nameof(Strings.UseAlertDescription), Order = 400)]
    public bool UseVolumeAlert { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.VolumeAlert),
        Description = nameof(Strings.AlertFilterDescription), Order = 410)]
    [Range(0, int.MaxValue)]
    public decimal VolumeAlertValue { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.VolumeAlert),
        Description = nameof(Strings.AlertFileDescription), Order = 420)]
    public string VolumeAlertFile { get; set; } = "alert1";

    #endregion

    #region Delta alert

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.DeltaAlert),
        Description = nameof(Strings.UseAlertDescription), Order = 500)]
    public bool UseDeltaAlert { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.DeltaAlert),
        Description = nameof(Strings.AlertFilterDescription), Order = 510)]
    public decimal DeltaAlertValue { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.DeltaAlert),
        Description = nameof(Strings.AlertFileDescription), Order = 520)]
    public string DeltaAlertFile { get; set; } = "alert1";

    #endregion

    #endregion

    #region ctor

    public ClusterStatistic()
		: base(true)
	{
		DenyToChangePanel = true;
		Panel = IndicatorDataProvider.NewPanel;
		EnableCustomDrawing = true;
		ShowDelta = ShowSessionDelta = ShowVolume = true;
		SubscribeToDrawingEvents(DrawingLayouts.LatestBar | DrawingLayouts.Historical | DrawingLayouts.Final);

		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
		ShowDescription = false;
	}

	#endregion

	#region Public methods

	public override bool ProcessMouseDown(RenderControlMouseEventArgs e)
	{
		var cursor = e.Location;

		if (!Container.Region.Contains(cursor) || e.X > _headerWidth)
			return base.ProcessMouseDown(e);

		if (StrCount <= 1)
			return base.ProcessMouseDown(e);

		var height = Container.Region.Height / StrCount;

		var rowNum = Math.Max((e.Y - Container.Region.Top) / height, 0);
		rowNum = Math.Min(rowNum, StrCount - 1);

		_selectionOffset = 0;
		_selectionY = e.Y;
		_pressedString = RowsOrder.AvailableStrings.GetValueAtIndex(rowNum);
		CacheChanged();

		return true;
	}

	public override bool ProcessMouseMove(RenderControlMouseEventArgs e)
	{
		_atPanel = Container.Region.Contains(e.Location);
		_atHeader = e.X <= _headerWidth && _atPanel;

		if (_pressedString is DataType.None)
			return base.ProcessMouseMove(e);

		if (StrCount <= 1)
			return base.ProcessMouseDown(e);

		var height = Container.Region.Height / StrCount;

		var rowNum = Math.Max((e.Y - Container.Region.Top) / height, 0);
		rowNum = Math.Min(rowNum, StrCount - 1);

		var currentString = RowsOrder.AvailableStrings.GetValueAtIndex(rowNum);

		if (_pressedString != currentString)
		{
			RowsOrder.UpdateOrder(_pressedString, currentString);
			CacheChanged();

			_selectionY += (e.Y > _selectionY ? 1 : -1) * height;
		}

		_selectionOffset = _selectionY - e.Y;

		return true;
	}

	public override StdCursor GetCursor(RenderControlMouseEventArgs e)
	{
		if ((!Container.Region.Contains(e.Location) || e.X > _headerWidth) && _pressedString is DataType.None)
			return base.GetCursor(e);

		return StdCursor.Hand;
	}

	public override bool ProcessMouseUp(RenderControlMouseEventArgs e)
	{
		_pressedString = DataType.None;
		CacheChanged();
		return base.ProcessMouseUp(e);
	}

	#endregion

	#region Protected methods

	protected override void OnApplyDefaultColors()
	{
		if (ChartInfo is null)
			return;

		BidColor = ChartInfo.ColorsStore.FootprintBidColor.Convert();
		BidColor = CrossColorExtensions.FromRgb(BidColor.R, BidColor.G, BidColor.B);

		AskColor = ChartInfo.ColorsStore.FootprintAskColor.Convert();
		AskColor = CrossColorExtensions.FromRgb(AskColor.R, AskColor.G, AskColor.B);

		VolumeColor = ChartInfo.ColorsStore.PaneSeparators.Color.Convert();
		VolumeColor = CrossColorExtensions.FromRgb(VolumeColor.R, VolumeColor.G, VolumeColor.B);

		GridColor = ChartInfo.ColorsStore.Grid.Color.Convert();
		GridColor = CrossColorExtensions.FromRgb(GridColor.R, GridColor.G, GridColor.B);

		HeaderBackground = DefaultColors.Gray.Convert();
		TextColor = CrossColors.White;

		BackGroundColor = ChartInfo.ColorsStore.BaseBackgroundColor.Convert();
		BackGroundColor = Color.FromArgb(128, BackGroundColor.R, BackGroundColor.G, BackGroundColor.B);
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		var candleSeconds = Convert.ToDecimal((candle.LastTime - candle.Time).TotalSeconds);

		if (candleSeconds is 0)
			candleSeconds = 1;

		_volPerSecond[bar] = candle.Volume / candleSeconds;

		if (bar == 0)
		{
			_cumVolume = 0;
			_maxVolume = 0;
			_maxDelta = 0;
			_maxMaxDelta = 0;
			_maxMinDelta = 0;
			_maxDeltaChange = 0;
			_minDelta = decimal.MaxValue;
			_maxHeight = 0;
			_maxTicks = 0;
			_maxDuration = 0;
			_maxSessionDelta = 0;
			_maxDeltaPerVolume = 0;
			_maxSessionDeltaPerVolume = 0;
			_maxBid = _maxAsk = 0;
			_cDelta[bar] = candle.Delta;
			return;
		}

		_deltaPerVol[bar] = candle.Volume is 0 
			? 0
			: Math.Abs(candle.Delta * 100m / candle.Volume);

		var prevCandle = GetCandle(bar - 1);

		if (IsNewSession(bar))
		{
			_cVolume[bar] = _cumVolume = candle.Volume;
			_cDelta[bar] = candle.Delta;
		}
		else
		{
			_cumVolume = _cVolume[bar] = _cVolume[bar - 1] + candle.Volume;
			_cDelta[bar] = _cDelta[bar - 1] + candle.Delta;
		}

		_maxSessionDelta = Math.Max(Math.Abs(_cDelta[bar]), _maxSessionDelta);

		_maxAsk = Math.Max(candle.Ask, _maxAsk);
		_maxBid = Math.Max(candle.Ask, _maxBid);

		_maxDeltaChange = Math.Max(Math.Abs(candle.Delta - prevCandle.Delta), _maxDeltaChange);

		_maxDelta = Math.Max(Math.Abs(candle.Delta), _maxDelta);

		_maxMaxDelta = Math.Max(Math.Abs(candle.MaxDelta), _maxMaxDelta);
		_maxMinDelta = Math.Max(Math.Abs(candle.MinDelta), _maxMinDelta);

		_maxVolume = Math.Max(candle.Volume, _maxVolume);

		_minDelta = Math.Min(candle.MinDelta, _minDelta);

		_maxDeltaPerVolume = candle.Volume is 0
			? 0
			: Math.Max(Math.Abs(100 * candle.Delta / candle.Volume), _minDelta);

		var candleHeight = candle.High - candle.Low;
		_maxHeight = Math.Max(candleHeight, _maxHeight);
		_candleHeights[bar] = candleHeight;

		_maxTicks = Math.Max(candle.Ticks, _maxTicks);

		_candleDurations[bar] = (int)(candle.LastTime - candle.Time).TotalSeconds;
		_maxDuration = Math.Max(_candleDurations[bar], _maxDuration);

		if (Math.Abs(_cVolume[bar] - 0) > 0.000001m)
			_cDeltaPerVol[bar] = _cDelta[bar] * 
				(_cVolume[bar] is 0 
					? _cDelta[bar] 
					: 100.0m / _cVolume[bar]);

		_maxSessionDeltaPerVolume = Math.Max(Math.Abs(_cDeltaPerVol[bar]), _maxSessionDeltaPerVolume);

		if (_lastBar != bar)
			_lastVolumeValue = _lastDeltaValue = 0m;

		if (bar == CurrentBar - 1)
		{
			if (UseDeltaAlert && _lastDeltaAlert != bar)
			{
				if ((_lastDeltaValue < DeltaAlertValue && candle.Delta >= DeltaAlertValue)
				    || (_lastDeltaValue > DeltaAlertValue && candle.Delta <= DeltaAlertValue))
				{
					AddAlert(DeltaAlertFile, $"Cluster statistic delta alert: {candle.Delta}");
					_lastDeltaAlert = bar;
				}
			}

			if (UseVolumeAlert && _lastVolumeAlert != bar)
			{
				if (_lastVolumeValue < VolumeAlertValue && candle.Volume >= VolumeAlertValue)
				{
					AddAlert(VolumeAlertFile, $"Cluster statistic volume alert: {candle.Volume}");
					_lastVolumeAlert = bar;
				}
			}
		}

		_lastVolumeValue = candle.Volume;
		_lastDeltaValue = candle.Delta;
		_lastBar = bar;
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo is not { PriceChartContainer.BarsWidth: > 2 })
			return;

		if (LastVisibleBarNumber > CurrentBar - 1)
			return;

		if (StrCount is 0)
			return;

		if (_fontChanged)
		{
			var str = "Session Delta/Volume";
			var width = context.MeasureString(str, Font.RenderObject).Width;
			_headerWidth = width + 10;
			_fontChanged = false;
		}

		var bounds = context.ClipBounds;

		_height = Container.Region.Height / StrCount;
		var fullBarsWidth = (int)(ChartInfo.PriceChartContainer.BarsWidth + ChartInfo.PriceChartContainer.BarSpacing);
		var showHeadersText = context.MeasureString("1", Font.RenderObject).Height * 0.9 <= _height;
		var showValues = fullBarsWidth >= 30 && showHeadersText;

		try
		{
			context.SetClip(Container.Region);

			context.SetTextRenderingHint(RenderTextRenderingHint.Aliased);

			var overPixels = Container.Region.Height % StrCount;

			var y = Container.Region.Y;

			var maxX = ChartInfo.GetXByBar(LastVisibleBarNumber) + fullBarsWidth;

			var maxValues = CreateMaxValues();

			var drawHeaders = !HideRowsDescription
				|| Container.Region.Contains(MouseLocationInfo.LastPosition)
				|| _pressedString is not DataType.None;

			var selectionY = 0;

			if ((layout is DrawingLayouts.LatestBar or DrawingLayouts.Historical && _pressedString is DataType.None)
			    ||
			    (_pressedString is not DataType.None && layout is DrawingLayouts.Final))
			{
				var startBar = LastVisibleBarNumber;

				if (layout is DrawingLayouts.Historical)
					startBar = Math.Min(startBar, CurrentBar - 2);

				for (var bar = startBar; bar >= FirstVisibleBarNumber; bar--)
				{
					if (layout is DrawingLayouts.LatestBar)
					{
						if (bar < CurrentBar - 1)
							break;
					}

					var x = ChartInfo.GetXByBar(bar);

					var y1 = y;
					var candle = GetCandle(bar);

					DrawBarValues(context, maxValues, candle, x, ref y1, ref selectionY, fullBarsWidth, showValues, overPixels, bar);
					overPixels = Container.Region.Height % StrCount;
				}
			}

			if (layout is DrawingLayouts.Historical || _pressedString is not DataType.None)
				DrawValuesTable(context, fullBarsWidth, maxX);

			if ((drawHeaders && layout is DrawingLayouts.Final && (HideRowsDescription || _pressedString is not DataType.None))
			    ||
			    (layout is DrawingLayouts.Historical && !HideRowsDescription && _pressedString is DataType.None))
			{
				for (var i = 0; i < RowsOrder.AvailableStrings.Count; i++)
				{
					var type = RowsOrder.AvailableStrings.GetValueAtIndex(i);
					var rectHeight = _height + (overPixels > 0 ? 1 : 0);

					if (i == RowsOrder.AvailableStrings.SkipIdx && i != RowsOrder.AvailableStrings.Count - 1)
					{
						y += rectHeight;
						overPixels--;
						continue;
					}

					DrawHeader(type);

					if (_pressedString is not DataType.None && i == RowsOrder.AvailableStrings.Count - 1 && i != RowsOrder.AvailableStrings.SkipIdx)
						DrawHeader(_pressedString);

					y += rectHeight;
					overPixels--;

					void DrawHeader(DataType type)
					{
						var isSelected = type == _pressedString;
						var rectY = type == _pressedString ? selectionY - _selectionOffset : y;

						if (isSelected)
							rectY = Math.Max(Container.Region.Y, Math.Min(Container.Region.Bottom - rectHeight, rectY));

						var descRect = new Rectangle(0, rectY, _headerWidth, rectHeight);
						context.FillRectangle(_headerBackground, descRect);

						if (showHeadersText)
						{
							var text = GetHeader(type);

							var textRect = descRect with
							{
								X = descRect.X + _headerOffset
							};

							context.DrawString(text, Font.RenderObject, _textColor, textRect, _stringLeftFormat);
						}

						if (type == _pressedString)
						{
							var selectionRect = descRect with
							{
								X = Container.Region.X,
								Width = maxX - Container.Region.X
							};

							switch (_selectionOffset)
							{
								case < 0:
									context.FillRectangle(_headerBackground,
										new Rectangle(Container.Region.X, selectionY, selectionRect.Width, rectY - selectionY));
									context.DrawLine(_linePen, Container.Region.X, selectionY, maxX, selectionY);
									break;
								case > 0:
									context.FillRectangle(_headerBackground,
										new Rectangle(Container.Region.X, rectY + rectHeight, selectionRect.Width, selectionY - rectY));
									context.DrawLine(_linePen, Container.Region.X, selectionY + rectHeight, maxX, selectionY + rectHeight);
									break;
							}

							context.DrawRectangle(_selectionPen, selectionRect);
						}
						else if (i is not 0 && i - 1 != RowsOrder.AvailableStrings.SkipIdx)
							context.DrawLine(_linePen, Container.Region.X, rectY, maxX, rectY);
					}
				}

				var tableRect = new Rectangle(Container.Region.X, Container.Region.Y, maxX - Container.Region.X, Container.Region.Height - 1);
				context.DrawLine(_linePen, _headerWidth, Container.Region.Y, _headerWidth, Container.Region.Bottom);
				context.DrawRectangle(_linePen, tableRect);
			}

			if (_pressedString is not DataType.None)
				return;

			if (!_atPanel)
				return;

			if (layout is DrawingLayouts.Final)
			{
				if (!Container.Region.Contains(MouseLocationInfo.LastPosition))
					return;

				if ((_atHeader && showHeadersText) || (!_atHeader && showValues))
					return;

				var bar = MouseLocationInfo.BarBelowMouse;
				var rowNum = Math.Max((MouseLocationInfo.LastPosition.Y - Container.Region.Top) / _height, 0);
				rowNum = Math.Min(rowNum, StrCount - 1);

				var type = RowsOrder.AvailableStrings.GetValueAtIndex(rowNum);

				var tipColor = System.Drawing.Color.Transparent;
				var tipText = "";

				if (_atHeader)
				{
					tipText = GetHeader(type);
					tipColor = _headerBackground;
				}
				else
				{
					var candle = GetCandle(bar);
					var rate = GetRate(maxValues, type, candle, bar);

					tipColor = GetBrush(type, candle, bar, rate);
					tipText = GetValueText(type, candle, bar);
				}

				DrawToolTip(context, MouseLocationInfo.LastPosition, tipText, tipColor);
			}
		}
		catch (ArgumentOutOfRangeException)
		{
			//Chart cleared
		}
		catch (Exception e)
		{
			this.LogError("Cluster statistic rendering error ", e);
			throw;
		}
		finally
		{
			context.SetTextRenderingHint(RenderTextRenderingHint.AntiAlias);
			context.SetClip(bounds);
		}
	}

	#endregion

	#region Private methods

	private void DrawValuesTable(RenderContext context, int barWidth, int maxX)
	{
		var x = 0;

		for (var bar = FirstVisibleBarNumber; bar <= LastVisibleBarNumber; bar++)
		{
			x = ChartInfo.GetXByBar(bar);
			context.DrawLine(_linePen, x, Container.Region.Y, x, Container.Region.Bottom);
		}

		x += barWidth;
		context.DrawLine(_linePen, x, Container.Region.Y, x, Container.Region.Bottom);

		var overPixels = Container.Region.Height % StrCount;

		var y = Container.Region.Y;

		var skipIdx = RowsOrder.AvailableStrings.SkipIdx;

		for (var i = 0; i < RowsOrder.AvailableStrings.Count; i++)
		{
			if (_pressedString is not DataType.None)
			{
				if ((_selectionOffset < 0 && i == skipIdx + 1) || (_selectionOffset > 0 && i == skipIdx))
				{
					y += _height + (overPixels > 0 ? 1 : 0);
					overPixels--;
					continue;
				}
			}

			context.DrawLine(_linePen, Container.Region.X, y, maxX, y);

			y += _height + (overPixels > 0 ? 1 : 0);
			overPixels--;
		}

		y--;
		context.DrawLine(_linePen, Container.Region.X, y, maxX, y);
	}

	private void DrawBarValues(RenderContext context, MaxValues maxValues, IndicatorCandle candle,
		int x, ref int y, ref int selectionY, int fullBarsWidth, bool showValues, int overPixelsSpace, int bar)
	{
		var overPixels = overPixelsSpace;

		for (var i = 0; i < RowsOrder.AvailableStrings.Count; i++)
		{
			var rowIndex = i;
			var type = RowsOrder.AvailableStrings.GetValueAtIndex(rowIndex);
			var isSelected = type == _pressedString;

			if (isSelected)
				selectionY = y;

			var rectHeight = _height + (overPixels > 0 ? 1 : 0);

			if (rowIndex == RowsOrder.AvailableStrings.SkipIdx && rowIndex != RowsOrder.AvailableStrings.Count - 1)
			{
				y += rectHeight;
				overPixels--;
				continue;
			}

			DrawValue(context, type, candle, maxValues, selectionY, x, y, bar, rectHeight, fullBarsWidth, showValues);

			y += rectHeight;
			overPixels--;
		}

		if (_pressedString is DataType.None)
			return;

		{
			var idx = RowsOrder.AvailableStrings.SkipIdx;
			var rectHeight = _height + (overPixels - 1 < idx ? 0 : 1);
			DrawValue(context, _pressedString, candle, maxValues, selectionY, x, y, bar, rectHeight, fullBarsWidth, showValues);
		}
	}

	private void DrawValue(RenderContext context, DataType type, IndicatorCandle candle, MaxValues maxValues,
		int selectionY, int x, int y, int bar, int rectHeight, int fullBarsWidth, bool showValues)
	{
		var rectY = type == _pressedString ? selectionY - _selectionOffset : y;

		if (type == _pressedString)
			rectY = Math.Max(Container.Region.Y, Math.Min(Container.Region.Bottom - rectHeight, rectY));

		var rect = new Rectangle(x, rectY, fullBarsWidth, rectHeight);
		var rate = GetRate(maxValues, type, candle, bar);

		var bgBrush = GetBrush(type, candle, bar, rate);

		context.FillRectangle(bgBrush, rect);

		if (showValues)
		{
			var text = GetValueText(type, candle, bar);

			var textRect = rect with
			{
				X = rect.X + _headerOffset
			};

			context.DrawString(text, Font.RenderObject, _textColor, textRect, _stringLeftFormat);
		}
	}

	private System.Drawing.Color GetBrush(DataType type, IndicatorCandle candle, int bar, decimal rate)
	{
		return type switch
		{
			DataType.Ask or DataType.Bid or DataType.Delta or DataType.DeltaVolume =>
				Blend(candle.Delta > 0 ? AskColor : BidColor, BackGroundColor, rate),

			DataType.Volume or DataType.VolumeSecond or DataType.SessionVolume or
				DataType.Trades or DataType.Height or DataType.Time or DataType.Duration => Blend(VolumeColor, BackGroundColor, rate),
			DataType.MaxDelta => Blend(candle.MaxDelta > 0 ?  AskColor : BidColor, BackGroundColor, rate),
			DataType.MinDelta => Blend(candle.MinDelta > 0 ?  AskColor : BidColor, BackGroundColor, rate),
            DataType.SessionDeltaVolume => Blend(_cDeltaPerVol[bar] > 0 ? AskColor : BidColor, BackGroundColor, rate),
			DataType.SessionDelta => Blend(_cDelta[bar] > 0 ? AskColor : BidColor, BackGroundColor, rate),
			DataType.DeltaChange => GetDeltaChangeBrush(candle, bar, rate),
			DataType.None => System.Drawing.Color.Transparent,
			_ => throw new ArgumentOutOfRangeException()
		};
	}

	private decimal GetRate(MaxValues maxValues, DataType type, IndicatorCandle candle, int bar)
	{
		return type switch
		{
			DataType.Ask => GetRate(candle.Ask, maxValues.MaxAsk),
			DataType.Bid => GetRate(candle.Bid, maxValues.MaxBid),
			DataType.Delta => GetRate(Math.Abs(candle.Delta), maxValues.MaxDelta),
			DataType.DeltaVolume => candle.Volume != 0 ? GetRate(Math.Abs(candle.Delta * 100.0m / candle.Volume), maxValues.MaxDeltaPerVolume) : 0,
			DataType.SessionDelta => GetRate(Math.Abs(_cDelta[bar]), maxValues.MaxSessionDelta),
			DataType.SessionDeltaVolume => GetRate(Math.Abs(_cDeltaPerVol[bar]), maxValues.MaxSessionDeltaPerVolume),
			DataType.MaxDelta => GetRate(Math.Abs(candle.MaxDelta), maxValues.MaxMaxDelta),
			DataType.MinDelta => GetRate(Math.Abs(candle.MinDelta), maxValues.MaxMinDelta),
			DataType.DeltaChange => GetRate(Math.Abs(candle.Delta - GetCandle(Math.Max(bar - 1, 0)).Delta), maxValues.MaxDeltaChange),
			DataType.Volume => GetRate(candle.Volume, maxValues.MaxVolume),
			DataType.VolumeSecond => GetRate(_volPerSecond[bar], maxValues.MaxVolumeSec),
			DataType.SessionVolume => GetRate(_cVolume[bar], maxValues.CumVolume),
			DataType.Trades => GetRate(candle.Ticks, maxValues.MaxTicks),
			DataType.Height => GetRate(_candleHeights[bar], maxValues.MaxHeight),
			DataType.Time => GetRate(_cVolume[bar], maxValues.CumVolume),
			DataType.Duration => GetRate(_candleDurations[bar], maxValues.MaxDuration),
			DataType.None => 0,

			_ => throw new ArgumentOutOfRangeException()
		};
	}

	private MaxValues CreateMaxValues()
	{
		decimal maxVolumeSec;
		var maxDelta = 0m;
		var maxAsk = 0m;
		var maxBid = 0m;
		var maxMaxDelta = 0m;
		var maxMinDelta = 0m;
		var maxVolume = 0m;
		var cumVolume = 0m;
		var maxDeltaChange = 0m;
		var maxSessionDelta = 0m;
		var maxSessionDeltaPerVolume = 0m;
		var maxDeltaPerVolume = 0m;
		var minDelta = decimal.MaxValue;
		var maxHeight = 0m;
		var maxTicks = 0m;
		var maxDuration = 0m;

		if (VisibleProportion)
		{
			for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
			{
				var candle = GetCandle(i);
				maxDelta = Math.Max(candle.Delta, maxDelta);
				maxVolume = Math.Max(candle.Volume, maxVolume);
				minDelta = Math.Min(candle.MinDelta, minDelta);
				maxAsk = Math.Max(candle.Ask, maxAsk);
				maxBid = Math.Max(candle.Ask, maxBid);
				maxMaxDelta = Math.Max(Math.Abs(candle.MaxDelta), maxMaxDelta);
				maxMinDelta = Math.Max(Math.Abs(candle.MinDelta), maxMinDelta);
				maxSessionDelta = Math.Max(Math.Abs(_cDelta[i]), maxSessionDelta);

				if (candle.Volume is not 0)
					maxDeltaPerVolume = Math.Max(Math.Abs(100 * candle.Delta / candle.Volume), maxDeltaPerVolume);

				maxSessionDeltaPerVolume = Math.Max(Math.Abs(_cDeltaPerVol[i]), maxSessionDeltaPerVolume);
				cumVolume += candle.Volume;

				if (i == 0)
					continue;

				var prevCandle = GetCandle(i - 1);
				maxDeltaChange = Math.Max(Math.Abs(candle.Delta - prevCandle.Delta), maxDeltaChange);
				maxHeight = Math.Max(candle.High - candle.Low, maxHeight);
				maxTicks = Math.Max(candle.Ticks, maxTicks);
				maxDuration = Math.Max(_candleDurations[i], maxDuration);
			}

			maxVolumeSec = _volPerSecond.MAX(LastVisibleBarNumber - FirstVisibleBarNumber, LastVisibleBarNumber);
		}
		else
		{
			maxAsk = _maxAsk;
			maxBid = _maxBid;
			maxSessionDelta = _maxSessionDelta;
			maxDeltaPerVolume = _maxDeltaPerVolume;
			maxSessionDeltaPerVolume = _maxSessionDeltaPerVolume;
			maxDelta = _maxDelta;
			minDelta = _minDelta;
			maxMaxDelta = _maxMaxDelta;
			maxMinDelta = _maxMinDelta;
			maxVolume = _maxVolume;
			maxTicks = _maxTicks;
			maxDuration = _maxDuration;
			cumVolume = _cumVolume;
			maxDeltaChange = _maxDeltaChange;
			maxHeight = _maxHeight;
			maxVolumeSec = _volPerSecond.MAX(CurrentBar - 1, CurrentBar - 1);
		}

		return new MaxValues
		{
			MaxAsk = maxAsk,
			MaxBid = maxBid,
			MaxSessionDelta = maxSessionDelta,
			MaxDeltaPerVolume = maxDeltaPerVolume,
			MaxSessionDeltaPerVolume = maxSessionDeltaPerVolume,
			MaxDelta = maxDelta,
			MinDelta = minDelta,
			MaxMaxDelta = maxMaxDelta,
			MaxMinDelta = maxMinDelta,
			MaxVolume = maxVolume,
			MaxTicks = maxTicks,
			MaxDuration = maxDuration,
			CumVolume = cumVolume,
			MaxDeltaChange = maxDeltaChange,
			MaxHeight = maxHeight,
			MaxVolumeSec = maxVolumeSec
		};
	}

	private string GetValueText(DataType type, IndicatorCandle candle, int bar)
	{
		return type switch
		{
			DataType.Ask => ChartInfo.TryGetMinimizedVolumeString(candle.Ask),
			DataType.Bid => ChartInfo.TryGetMinimizedVolumeString(candle.Bid),
			DataType.Delta => ChartInfo.TryGetMinimizedVolumeString(candle.Delta),
			DataType.DeltaVolume => _deltaPerVol[bar].ToString("F") + "%",
			DataType.SessionDelta => ChartInfo.TryGetMinimizedVolumeString(_cDelta[bar]),
			DataType.SessionDeltaVolume => _cDeltaPerVol[bar].ToString("F") + "%",
			DataType.MaxDelta => ChartInfo.TryGetMinimizedVolumeString(candle.MaxDelta),
			DataType.MinDelta => ChartInfo.TryGetMinimizedVolumeString(candle.MinDelta),
			DataType.DeltaChange => ChartInfo.TryGetMinimizedVolumeString(candle.Delta - GetCandle(Math.Max(bar - 1, 0)).Delta),
			DataType.Volume => ChartInfo.TryGetMinimizedVolumeString(candle.Volume),
			DataType.VolumeSecond => ChartInfo.TryGetMinimizedVolumeString(_volPerSecond[bar]),
			DataType.SessionVolume => ChartInfo.TryGetMinimizedVolumeString(_cVolume[bar]),
			DataType.Trades => candle.Ticks.ToString(CultureInfo.InvariantCulture),
			DataType.Height => _candleHeights[bar].ToString(CultureInfo.InvariantCulture),
			DataType.Time => candle.Time.AddHours(InstrumentInfo.TimeZone).ToString("HH:mm:ss"),
			DataType.Duration => ((int)(candle.LastTime - candle.Time).TotalSeconds).ToString(),
			DataType.None => string.Empty,
			_ => throw new ArgumentOutOfRangeException()
		};
	}

	private void DrawToolTip(RenderContext g, Point location, string text, System.Drawing.Color bgColor)
	{
		var bounds = g.ClipBounds;
		g.ResetClip();

		const int offset = 15;

		var x = location.X;
		var y = location.Y;

		var size = g.MeasureString(text, Font.RenderObject);
		var height = size.Height + 10;
		var rect = new Rectangle(x + offset, y - height - 20, size.Width + 20, height);

		var center = rect.Y + rect.Height / 2;

		Point[] points =
		[
			new(x, y),
			new(x + offset, center - (int)(0.3 * height)),
			new(x + offset, center + (int)(0.3 * height))
		];

		g.FillPolygon(_textColor, points);

		var pen = new RenderPen(_textColor, 2);
		g.DrawRectangle(pen, rect, 2);
		g.FillRectangle(bgColor, rect);
		g.DrawString(text, Font.RenderObject, _textColor, rect, _tipFormat);

		g.SetClip(bounds);
	}

	private void CacheChanged()
	{
		if (_pressedString is DataType.None)
		{
			RowsOrder.AvailableStrings.SkipIdx = -1;
			return;
		}

		var idx = RowsOrder.AvailableStrings.IndexOfValue(_pressedString);

		if (idx is -1)
			throw new KeyNotFoundException("Type " + _pressedString + " not found at cache");

		RowsOrder.AvailableStrings.SkipIdx = idx;
	}

	private System.Drawing.Color GetDeltaChangeBrush(IndicatorCandle candle, int j, decimal rate)
	{
		var prevCandle = GetCandle(Math.Max(j - 1, 0));
		var change = candle.Delta - prevCandle.Delta;
		var rectColor = change > 0 ? AskColor : BidColor;
		return Blend(rectColor, BackGroundColor, rate);
	}

	private void FontChanged(object sender, PropertyChangedEventArgs e)
	{
		_fontChanged = true;
	}

	private string GetHeader(DataType type)
	{
		return type switch
		{
			DataType.Ask => "Ask",
			DataType.Bid => "Bid",
			DataType.Delta => "Delta",
			DataType.DeltaVolume => "Delta/Volume",
			DataType.SessionDelta => "Session Delta",
			DataType.SessionDeltaVolume => "Session Delta/Volume",
			DataType.MaxDelta => "Max.Delta",
			DataType.MinDelta => "Min.Delta",
			DataType.DeltaChange => "Delta Change",
			DataType.Volume => "Volume",
			DataType.VolumeSecond => "Volume/sec",
			DataType.SessionVolume => "Session Volume",
			DataType.Trades => "Trades",
			DataType.Height => "Height",
			DataType.Time => "Time",
			DataType.Duration => "Duration",
			DataType.None => string.Empty,

			_ => throw new ArgumentOutOfRangeException()
		};
	}

	private decimal GetRate(decimal value, decimal maximumValue)
	{
		if (maximumValue == 0)
			return 10;

		var rate = value * 100.0m / (maximumValue * 0.6m);

		if (rate < 10)
			rate = 10;

		if (rate > 100)
			return 100;

		return rate;
	}

	private System.Drawing.Color Blend(Color color, Color backColor, decimal amount)
	{
		var r = (byte)(color.R + (backColor.R - color.R) * (1 - amount * 0.01m));
		var g = (byte)(color.G + (backColor.G - color.G) * (1 - amount * 0.01m));
		var b = (byte)(color.B + (backColor.B - color.B) * (1 - amount * 0.01m));
		return System.Drawing.Color.FromArgb(_bgAlpha, r, g, b);
	}

	#endregion
}







Technical/ColorBarHighLow.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Color Bar HH/LL")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ColorBarHighLowIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618502")]
public class ColorBarHighLow : Indicator
{
	#region Fields

	private CrossColor _averageColor = CrossColors.Orange;
	private CrossColor _highColor = CrossColors.Aqua;
	private CrossColor _lowColor = CrossColors.DarkMagenta;

	private PaintbarsDataSeries _renderSeries = new("RenderSeries", "PaintBars")
	{
		IsHidden = true
	};

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Average), GroupName = nameof(Strings.Color), Description = nameof(Strings.ColorDescription), Order = 100)]
	public CrossColor AverageColor
	{
		get => _averageColor;
		set
		{
			_averageColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Highest), GroupName = nameof(Strings.Color), Description = nameof(Strings.ColorDescription), Order = 100)]
	public CrossColor HighColor
	{
		get => _highColor;
		set
		{
			_highColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Lowest), GroupName = nameof(Strings.Color), Description = nameof(Strings.ColorDescription), Order = 100)]
	public CrossColor LowColor
	{
		get => _lowColor;
		set
		{
			_lowColor = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ColorBarHighLow()
		: base(true)
	{
		DenyToChangePanel = true;
        DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnRecalculate()
	{
		Clear();
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
			return;

		var candle = GetCandle(bar);
		var prevCandle = GetCandle(bar - 1);

		if (candle.High == prevCandle.High && candle.Low == prevCandle.Low)
			return;

		if (candle.High > prevCandle.High && candle.Low < prevCandle.Low)
		{
			_renderSeries[bar] = AverageColor;
			return;
		}

		if (candle.High > prevCandle.High && candle.Low >= prevCandle.Low)
		{
			_renderSeries[bar] = HighColor;
			return;
		}

		if (candle.High <= prevCandle.High && candle.Low < prevCandle.Low)
			_renderSeries[bar] = LowColor;
	}

	#endregion
}








Technical/ColorBarOpenClose.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Color Bar Open/Close")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ColorBarOpenCloseDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618541")]
public class ColorBarOpenClose : Indicator
{
    #region Fields
    
    private CrossColor _highColor = CrossColors.Aqua;
    private CrossColor _lowColor = CrossColors.DarkMagenta;

    private readonly PaintbarsDataSeries _renderSeries = new("RenderSeries", "PaintBars")
    {
        IsHidden = true
    };

    #endregion

    #region Properties
    
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Highest), GroupName = nameof(Strings.Color), Description = nameof(Strings.BullishColorDescription), Order = 100)]
    public CrossColor HighColor
    {
        get => _highColor;
        set
        {
            _highColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Lowest), GroupName = nameof(Strings.Color), Description = nameof(Strings.BearishColorDescription), Order = 100)]
    public CrossColor LowColor
    {
        get => _lowColor;
        set
        {
            _lowColor = value;
            RecalculateValues();
        }
    }

    #endregion

    #region ctor

    public ColorBarOpenClose()
        : base(true)
    {
	    DenyToChangePanel = true;
        DataSeries[0] = _renderSeries;
    }

    #endregion

    #region Protected methods

    protected override void OnRecalculate()
    {
        Clear();
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (bar == 0)
            return;

        var candle = GetCandle(bar);

        if (candle.Close > candle.Open)
        {
	        _renderSeries[bar] = HighColor;
            return;
        }

        if (candle.Close < candle.Open)
        {
	        _renderSeries[bar] = LowColor;
	        return;
        }

        _renderSeries[bar] = _renderSeries[bar - 1];
    }

    #endregion
}







Technical/CoppockCurve.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Coppock Curve")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CoppockCurveDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602602-coppock-curve")]
	public class CoppockCurve : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram
		};

		private readonly ROC _rocLong = new()
		{
			Period = 14,
			CalcMode = ROC.Mode.Percent
		};
		private readonly ROC _rocShort = new()
		{
			Period = 11,
			CalcMode = ROC.Mode.Percent
		};
		private readonly WMA _wma = new()
		{
			Period = 10
		};

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _wma.Period;
			set
			{
				_wma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public CoppockCurve()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var rocShort = _rocShort.Calculate(bar, value);
			var rocLong = _rocLong.Calculate(bar, value);

			_renderSeries[bar] = _wma.Calculate(bar, rocLong + rocShort);
		}

		#endregion
	}
}







Indicators/Technical
/CotHigh.cs







namespace ATAS.Indicators.Technical;

using OFT.Attributes;
using OFT.Localization;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

[DisplayName("COT High/Low")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.CotHighDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602603")]
public class CotHigh : Indicator
{
	#region Nested types

	public enum CotMode
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.High))]
		High,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low))]
		Low
	}

	#endregion

	#region Fields

	private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
	{
		VisualType = VisualMode.Histogram,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true
	};
	
	private decimal _extValue;
	private CotMode _mode = CotMode.High;

	private System.Drawing.Color _negColor = System.Drawing.Color.Red;
	private System.Drawing.Color _posColor = System.Drawing.Color.Green;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 610)]
    public CrossColor PosColor
    {
	    get => _posColor.Convert();
	    set
	    {
		    _posColor = value.Convert();
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 620)]
    public CrossColor NegColor
    {
	    get => _negColor.Convert();
	    set
	    {
		    _negColor = value.Convert();
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 100)]
	public CotMode Mode
	{
		get => _mode;
		set
		{
			_mode = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public CotHigh()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = _renderSeries;
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    PosColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    NegColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
    }

    protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_extValue = 0;
			DataSeries.ForEach(x => x.Clear());
		}

		var candle = GetCandle(bar);

		if ((candle.High >= _extValue && Mode is CotMode.High)
		    ||
		    (candle.Low >= _extValue && Mode is CotMode.High))
		{
			_extValue = Mode is CotMode.High
				? candle.High
				: candle.Low;

			_renderSeries[bar] = candle.Delta;
		}
		else
		{
			_renderSeries[bar] = bar == 0 ? candle.Delta : _renderSeries[bar - 1] + candle.Delta;
		}

		_renderSeries.Colors[bar] = _renderSeries[bar] >= 0 ? _posColor : _negColor;
	}
	
	#endregion
}







Technical/CumulativeDailyVolume.cs






using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using Color = System.Drawing.Color;

namespace ATAS.Indicators.Technical
{
    [DisplayName("Cumulative Daily Volume")]
    [Category(IndicatorCategories.VolumeOrderFlow)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CumulativeDailyVolumeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000618670")]
    public class CumulativeDailyVolume : Indicator
    {
        #region Fields

        private readonly ValueDataSeries _data = new("Data", Strings.Volume)
        {
            IsHidden = true,
            VisualType = VisualMode.Histogram,
            ShowZeroValue = false
        };

        private int _lastBar = -1;
        private decimal _sum;
        private Color _histogramColor = DefaultColors.Blue;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColorDescription))]
        public Color HistogramColor
        {
            get => _histogramColor;
            set
            {
                _histogramColor = value;
                _data.Color = value.Convert();
            }
        }

        #endregion

        #region ctor

        public CumulativeDailyVolume() : base(true)
        {
            Panel = IndicatorDataProvider.NewPanel;
            DenyToChangePanel = true;

            DataSeries[0] = _data;
            _data.Color = _histogramColor.Convert();
        }

        #endregion

        #region Protected Methods

        protected override void OnCalculate(int bar, decimal value)
        {
            if (bar != _lastBar)
            {
                if (IsNewSession(bar) || bar == 0)
                    _sum = 0;
                else
                    _sum = _data[bar - 1];
            }

            var candle = GetCandle(bar);
            var sum = _sum + candle.Volume;
            _data[bar] = sum;

            _lastBar = bar;
        }

        #endregion
    }
}









Technical/CumulativeDelta.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Settings;
using Utils.Common.Logging;

using Color = System.Drawing.Color;

[DisplayName("CVD - Cumulative Volume Delta")]
[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.CumulativeDeltaDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602360-cumulative-volume-delta")]
public class CumulativeDelta : Indicator
{
    #region Nested types

    [Serializable]
    public enum SessionDeltaVisualMode
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Candles))]
        Candles = 0,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bars))]
        Bars = 1,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line))]
        Line = 2
    }

    public enum SessionMode
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.None))]
        None,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Default))]
        DefaultSession,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomSession))]
        CustomSession
    }

    #endregion

    #region Fields

    private CandleDataSeries _candleSeries = new("CandleSeries", Strings.Candles) 
    { 
        UseMinimizedModeIfEnabled = true ,
        IsHidden = true
    };

    private ValueDataSeries _lineHistSeries = new("LineHistSeries", Strings.Line)
    {
        UseMinimizedModeIfEnabled = true,
        VisualType = VisualMode.Hide,
        ShowZeroValue = false,
        IsHidden = true
    };

    private bool _isAlerted;
    private int _lastBar = -1;
    private bool _subscribedToChangeZeroLine;
    private Candle _currentCandle;

    private decimal _cumDelta;
    private decimal _open;
    private decimal _high;
    private decimal _low;
    private SessionDeltaVisualMode _mode = SessionDeltaVisualMode.Candles;
    private Color _negColor = Color.Red;
    private Color _posColor = Color.Green;
    private bool _sessionDeltaMode;
    private decimal _changeSize;
    private TimeSpan _customSessionStart;
    private SessionMode _sessionCumDeltaMode = SessionMode.DefaultSession;
    private bool _isVisible = true;

    #endregion

    #region Properties

    #region Settings

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ChartDisplayModeDescription), Order = 10)]
    public SessionDeltaVisualMode Mode
    {
        get => _mode;
        set
        {
            _mode = value;

            if (_mode == SessionDeltaVisualMode.Candles)
            {
                _candleSeries.Visible = _isVisible;
                _lineHistSeries.VisualType = VisualMode.Hide;
            }
            else
            {
                _candleSeries.Visible = false;

                _lineHistSeries.VisualType = !_isVisible
                    ? VisualMode.Hide
                    : _mode == SessionDeltaVisualMode.Line
                          ? VisualMode.Line
                          : VisualMode.Histogram;
            }

            SetFiltersEnabled();
            RecalculateValues();
        }
    }

    [Browsable(false)]
    public bool SessionDeltaMode
    {
        get => _sessionDeltaMode;
        set
        {
            _sessionDeltaMode = value;

            if (_sessionDeltaMode)
                _sessionCumDeltaMode = SessionMode.DefaultSession;
            else
                _sessionCumDeltaMode = SessionMode.None;

            RaisePropertyChanged("SessionDeltaMode");
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionDeltaMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SessionModeDescription), Order = 20)]
    public SessionMode SessionCumDeltaMode 
    { 
        get => _sessionCumDeltaMode;
        set
        {
            _sessionCumDeltaMode = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomSessionStart), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CustomSessionStartDescription), Order = 25)]
    public TimeSpan CustomSessionStart
    {
        get => _customSessionStart;
        set
        {
            _customSessionStart = value;

            if (_sessionCumDeltaMode == SessionMode.CustomSession)
                RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseScale), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DisplayFromZeroDescription), Order = 30)]
    public bool UseScale
    {
        get => LineSeries[0].UseScale;
        set => LineSeries[0].UseScale = value;
    }

    #endregion

    #region Alerts

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription), Order = 110)]
    public bool UseAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 120)]
    public string AlertFile { get; set; } = "alert1";

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RequiredChange), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFilterDescription), Order = 130)]
    public decimal ChangeSize
    {
        get => _changeSize;
        set
        {
            _changeSize = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 140)]
    public Color AlertForeColor { get; set; } = Color.FromArgb(255, 247, 249, 249);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 150)]
    public Color AlertBGColor { get; set; } = Color.FromArgb(255, 75, 72, 72);

    #endregion

    #region Drawing

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 210)]
    public CrossColor PosColor
    {
        get => _posColor.Convert();
        set
        {
            _posColor = value.Convert();
            _candleSeries.UpCandleColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 220)]
    public CrossColor NegColor
    {
        get => _negColor.Convert();
        set
        {
            _negColor = value.Convert();
            _candleSeries.DownCandleColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.AxisTextColorDescription), Order = 230)]
    public CrossColor TextColor
    {
        get => _candleSeries.ValuesColor.Convert();
        set
        {
           _candleSeries.ValuesColor = _lineHistSeries.ValuesColor = value.Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BorderColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.BorderColorDescription), Order = 240)]
    public Indicators.FilterColor BorderColorFilter { get; set; } = new(false) { Value = Color.Gray.Convert() };


    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ElementDisplayModeDescription), Order = 250)]
    public FilterEnum<CandleVisualMode> CandleModeFilter { get; set; } = new(false);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowValue), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ShowValueOnLabelDescription), Order = 260)]
    public bool ShowValue
    {
        get => _candleSeries.ShowCurrentValue;
        set
        {
            _candleSeries.ShowCurrentValue = _lineHistSeries.ShowCurrentValue = value;
            RecalculateValues();
        }
    }


    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Visible), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.IsVisibleDescription), Order = 270)]
    public bool IsVisible
    {
        get => _isVisible;
        set
        {
            _isVisible = _candleSeries.Visible = value;
            _lineHistSeries.VisualType = !value
                                       ? VisualMode.Hide
                                       : _mode switch
                                       {
                                           SessionDeltaVisualMode.Bars => VisualMode.Histogram,
                                           SessionDeltaVisualMode.Line => VisualMode.Line,
                                           _ => VisualMode.Hide
                                       };
        }
    }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.WidthDataSeriesDescription), Order = 280)]
    public FilterInt WidthFilter { get; set; } = new(false) { Value = 1 };

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineStyle), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LineDashStyleDescription), Order = 290)]
    public FilterEnum<LineDashStyle> LineStyleFilter { get; set; } = new(false);

    #endregion

    #endregion

    #region ctor

    public CumulativeDelta()
        : base(true)
    {
	    Panel = IndicatorDataProvider.NewPanel;
	    DenyToChangePanel = true;
        var series = (ValueDataSeries)DataSeries[0];
        series.VisualType = VisualMode.Hide;

        var zeroLine = new LineSeries("ZeroId", "Zero")
        {
            Color = DefaultColors.Gray.Convert(),
            Width = 1,
            UseScale = false,
            DescriptionKey = nameof(Strings.ZeroLineDescription)
        };

        LineSeries.Add(zeroLine);

        DataSeries[0] = _lineHistSeries;
        DataSeries.Add(_candleSeries);

        Panel = IndicatorDataProvider.NewPanel;
        DenyToChangePanel = true;

        SetFiltersEnabled();

        BorderColorFilter.PropertyChanged += (sender, e) =>
        {
            if (e.PropertyName is nameof(BorderColorFilter.Value))
            {
                _candleSeries.BorderColor = BorderColorFilter.Value;
                RedrawChart();
            }
        };

        CandleModeFilter.PropertyChanged += (sender, e) =>
        {
            if (e.PropertyName is nameof(CandleModeFilter.Value))
            {
                _candleSeries.Mode = CandleModeFilter.Value;
                BorderColorFilter.Enabled = CandleModeFilter.Value == CandleVisualMode.Candles;
                RedrawChart();
            }
        };

        WidthFilter.PropertyChanged += (sender, e) =>
        {
            if (e.PropertyName is nameof(WidthFilter.Value))
            {
                _lineHistSeries.Width = WidthFilter.Value;
                RedrawChart();
            }
        };

        LineStyleFilter.PropertyChanged += (sender, e) =>
        {
            if (e.PropertyName is nameof(LineStyleFilter.Value))
            {
                _lineHistSeries.LineDashStyle = LineStyleFilter.Value;
                RedrawChart();
            }
        };
    }

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
        if (ChartInfo is null)
            return;

        _posColor = ChartInfo.ColorsStore.UpCandleColor;
        _negColor = ChartInfo.ColorsStore.DownCandleColor;
        _lineHistSeries.Color = _candleSeries.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
        _candleSeries.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
        _candleSeries.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (!_subscribedToChangeZeroLine)
        {
            _subscribedToChangeZeroLine = true;

            _lineHistSeries.ZeroValue = LineSeries[0].Value;

            LineSeries[0].PropertyChanged += (sender, arg) =>
            {
	            if (arg.PropertyName == "UseScale" || arg.PropertyName == "Value")
	            {
		            _lineHistSeries.ZeroValue = LineSeries[0].Value;
                    RecalculateValues();
	            }
            };
        }

        var candle = GetCandle(bar);

        if (bar != _lastBar)
        {
            _currentCandle = null;
            _isAlerted = false;
        }

        try
        {
	        var zero = 0;// LineSeries[0].Value;

            if (CheckStartBar(bar))
            {
                _open = zero;
                _low = zero + candle.MinDelta;
                _high = zero + candle.MaxDelta;
                _cumDelta = zero + candle.Delta;

                if (bar > 0)
                    _lineHistSeries.SetPointOfEndLine(bar - 1);
            }
            else
            {
                var prev = (decimal)DataSeries[0][bar - 1];
                _open = prev;
                _cumDelta = prev + candle.Delta;
                var dh = candle.MaxDelta - candle.Delta;
                var dl = candle.Delta - candle.MinDelta;
                _low = _cumDelta - dl;
                _high = _cumDelta + dh;
            }

            _lineHistSeries[bar] = _cumDelta;

            switch (Mode)
            {
                case SessionDeltaVisualMode.Candles:

                    if (_currentCandle is null)
                    {
                        _currentCandle = new();
                        _candleSeries[bar] = _currentCandle;
                    }
                    
                    _currentCandle.Close = _cumDelta;
                    _currentCandle.High = Math.Max(_high, Math.Max(_open, _cumDelta));
                    _currentCandle.Low = Math.Min(_low, Math.Min(_open, _cumDelta));
                    _currentCandle.Open = _open;

                    break;
                case SessionDeltaVisualMode.Bars:
                case SessionDeltaVisualMode.Line:

                    if (_cumDelta >= LineSeries[0].Value)
                        _lineHistSeries.Colors[bar] = _posColor;
                    else
                        _lineHistSeries.Colors[bar] = _negColor;
                    break;
            }
        }
        catch (Exception exc)
        {
            this.LogError("CumulativeDelta calculation error", exc);
        }

        if (bar == CurrentBar - 1)
        {
            if (UseAlerts && Math.Abs(candle.Delta) >= _changeSize && !_isAlerted)
            {
                AddAlert(AlertFile, InstrumentInfo.Instrument, "Delta changed!", AlertBGColor.Convert(), AlertForeColor.Convert());
                _isAlerted = true;
            }
        }

        _lastBar = bar;
    }

    private bool CheckStartBar(int bar)
    {
        switch (_sessionCumDeltaMode)
        {
            case SessionMode.None:
                return bar == 0;
            case SessionMode.DefaultSession:
                return IsNewSession(bar);
            case SessionMode.CustomSession:
                if (bar == 0)
                    return true;

                var candle = GetCandle(bar);
                var prevCandle = GetCandle(bar - 1);

                return prevCandle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay < _customSessionStart
                    && candle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay >= _customSessionStart;
            default:
                return false;
        }
    }

    #endregion

    #region Private methods

    private void SetFiltersEnabled()
    {
        BorderColorFilter.Enabled = _mode == SessionDeltaVisualMode.Candles && _candleSeries.Mode == CandleVisualMode.Candles;
        CandleModeFilter.Enabled  = _mode == SessionDeltaVisualMode.Candles;
        WidthFilter.Enabled       = _mode != SessionDeltaVisualMode.Candles;
        LineStyleFilter.Enabled   = _mode == SessionDeltaVisualMode.Line;
    }

    #endregion
}









Technical/CurrentPrice.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Tools;

    [DisplayName("Current price")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.CurrentPriceDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602361-current-price")]
	public class CurrentPrice : Indicator
	{
		#region Fields

		private Color _background = Color.Blue;
		private RenderFont _font = new("Roboto", 14);

		private RenderStringFormat _stringFormat = new()
			{ LineAlignment = StringAlignment.Center, Alignment = StringAlignment.Far };

		private Color _textColor = Color.LightBlue;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), Description = nameof(Strings.LabelFillColorDescription))]
		public CrossColor Background
		{
			get => _background.Convert();
			set => _background = value.Convert();
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), Description = nameof(Strings.LabelTextColorDescription))]
		public CrossColor TextColor
		{
			get => _textColor.Convert();
			set => _textColor = value.Convert();
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontSize), Description = nameof(Strings.FontSizeDescription))]
		[Range(6, 30)]
		public float FontSize
		{
			get => _font.Size;
			set
			{
				_font = new RenderFont("Roboto", value);
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTime), GroupName = nameof(Strings.Time), Description = nameof(Strings.IsNeedShowCurrentTimeDescription))]
		public bool ShowTime { get; set; } = true;

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFormat), GroupName = nameof(Strings.Time), Description = nameof(Strings.TimeFormatDescription))]
		public string TimeFormat { get; set; } = "HH:mm:ss";

		#endregion

		#region ctor

		public CurrentPrice()
			: base(true)
		{
			SubscribeToDrawingEvents(DrawingLayouts.Final);
			EnableCustomDrawing = true;
			DataSeries[0].IsHidden = true;
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
			DenyToChangePanel = true;
		}

		#endregion

		#region Protected methods
		
		protected override void OnCalculate(int bar, decimal value)
		{
		}
		
		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			if (LastVisibleBarNumber != CurrentBar - 1 || LastVisibleBarNumber < 0)
				return;

			var candle = GetCandle(LastVisibleBarNumber);
			var priceString = candle.Close.ToString();
			var size = context.MeasureString(priceString, _font);

			var x = (int)(ChartInfo.GetXByBar(LastVisibleBarNumber) + ChartInfo.PriceChartContainer.BarsWidth);
			var y = ChartInfo.GetYByPrice(candle.Close, false);
			var rectangle = new Rectangle(x + 10, y - size.Height / 2, size.Width + 10, size.Height);

			var points = new List<Point>
			{
				new(x, y),
				new(rectangle.X, rectangle.Y),
				new(rectangle.X + rectangle.Width, rectangle.Y),
				new(rectangle.X + rectangle.Width, rectangle.Y + rectangle.Height),
				new(rectangle.X, rectangle.Y + rectangle.Height)
			};

			context.FillPolygon(_background, points.ToArray());

			rectangle.Y++;
			context.DrawString(priceString, _font, _textColor, rectangle, _stringFormat);

			if (!ShowTime)
				return;

			var time = MarketTime.AddHours(InstrumentInfo.TimeZone).ToString(TimeFormat);
			size = context.MeasureString(time, _font);
			context.DrawString(time, _font, _textColor, rectangle.X + rectangle.Width - size.Width, rectangle.Y - size.Height);
		}

		#endregion
	}
}










Technical/DEMA.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Double Exponential Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DEMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602543")]
	public class DEMA : Indicator
	{
		#region Fields

		private readonly EMA _emaFirst = new()
		{
			Period = 10
		};
		private readonly EMA _emaSecond = new()
		{
			Period = 10
		};

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization) { UseMinimizedModeIfEnabled = true };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _emaFirst.Period;
			set
			{
				_emaFirst.Period = _emaSecond.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DEMA()
		{
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_emaFirst.Calculate(bar, value);
			_emaSecond.Calculate(bar, _emaFirst[bar]);
			_renderSeries[bar] = 2 * _emaFirst[bar] - _emaSecond[bar];
		}

		#endregion
	}
}










Technical/DINeg.cs








using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Settings;

namespace ATAS.Indicators.Technical
{
    [DisplayName("DI-")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DINegIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000621048")]
	public class DINeg : Indicator
	{
		#region Fields

		private readonly ATR _atr = new() { Period = 10 };
		private readonly WMA _wma = new() { Period = 10 };

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _wma.Period;
			set
			{
				_wma.Period = _atr.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DINeg()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Red.Convert();
			((ValueDataSeries)DataSeries[0]).LineDashStyle = LineDashStyle.Dash;

            Add(_atr);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar > 0)
			{
				var atr = _atr[bar];

				var currentCandle = GetCandle(bar);
				var prevCandle = GetCandle(bar - 1);

				var val = currentCandle.Low < prevCandle.Low && currentCandle.High - prevCandle.High < prevCandle.Low - currentCandle.Low
					? prevCandle.Low - currentCandle.Low
					: 0m;

				var wma = _wma.Calculate(bar, val);

				this[bar] = atr != 0m ? 100m * wma / atr : 0m;
			}
			else
				this[bar] = 0;
		}

		#endregion
	}
}









Technical/DIPos.cs









using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

namespace ATAS.Indicators.Technical
{
    [DisplayName("DI+")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DIPosIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000621049")]
	public class DIPos : Indicator
	{
		#region Fields

		private readonly ATR _atr = new() { Period = 10 };
		private readonly WMA _wma = new() { Period = 10 };
		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
        public int Period
		{
			get => _wma.Period;
			set
			{
				_wma.Period = _atr.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DIPos()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Blue.Convert();

            Add(_atr);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar > 0)
			{
				var atr = _atr[bar];

				var currentCandle = GetCandle(bar);
				var prevCandle = GetCandle(bar - 1);

				var val = currentCandle.High > prevCandle.High && currentCandle.High - prevCandle.High > prevCandle.Low - currentCandle.Low
					? currentCandle.High - prevCandle.High
					: 0m;

				var wma = _wma.Calculate(bar, val);

				this[bar] = atr != 0m ? 100m * wma / atr : 0m;
			}
			else
				this[bar] = 0;
		}

		#endregion
	}
}









Technical/DMI.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Dynamic Momentum Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DMIDescription))] 
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602261")]
	public class DMI : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _negDiff = new("Diff");
		private readonly ValueDataSeries _posDiff = new("Diff");
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", "DMI")
		{
			Color = DefaultColors.Blue.Convert(),
			Width = 2
		};

		private readonly SMA _sma = new() { Period = 10 };
		private readonly StdDev _std = new() { Period = 5 };
		private int _lastBar;
		private decimal _negSmma;
		private decimal _posSmma;
		private decimal _prevNegSmma;
		private decimal _prevPosSmma;
		private int _rsiMax = 30;
		private int _rsiMin = 3;
		private int _rsiPeriod = 14;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.RSI), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int RsiPeriod
		{
			get => _rsiPeriod;
			set
			{
				_rsiPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinPeriod), GroupName = nameof(Strings.RSI), Description = nameof(Strings.ShortPeriodDescription), Order = 110)]
		[Range(1, 10000)]
		public int RsiMin
		{
			get => _rsiMin;
			set
			{
				_rsiMin = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxPeriod), GroupName = nameof(Strings.RSI), Description = nameof(Strings.LongPeriodDescription), Order = 120)]
		[Range(1, 10000)]
		public int RsiMax
		{
			get => _rsiMax;
			set
			{
				_rsiMax = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.StdPeriod), GroupName = nameof(Strings.StdDev), Description = nameof(Strings.StdPeriodDescription), Order = 200)]
		[Range(1, 10000)]
		public int StdPeriod
		{
			get => _std.Period;
			set
			{
				_std.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.StdDev), Description = nameof(Strings.SMAPeriodDescription), Order = 210)]
		public int SmaPeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DMI()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_std.Calculate(bar, value);
			_sma.Calculate(bar, _std[bar]);

			if (bar == 0)
			{
				_posSmma = _negSmma = 0;
				_prevPosSmma = _prevNegSmma = 0;
				return;
			}

			var diff = (decimal)SourceDataSeries[bar] - (decimal)SourceDataSeries[bar - 1];
			_posDiff[bar] = diff > 0 ? diff : 0;
			_negDiff[bar] = diff < 0 ? -diff : 0;

			if (_sma[bar] == 0 || _std[bar] == 0)
			{
				_renderSeries[bar] = _renderSeries[bar - 1];
				_lastBar = bar;
				return;
			}

			var vi = _std[bar] / _sma[bar];
			var td = RsiPeriod / vi;

			td = Math.Max(RsiMin, td);
			td = Math.Min(RsiMax, td);
			td = Math.Round(td);

			_renderSeries[bar] = RsiDynamic(bar, (int)td);

			_lastBar = bar;
		}

		#endregion

		#region Private methods

		private decimal RsiDynamic(int bar, int period)
		{
			_posSmma = (_prevPosSmma * (period - 1) + _posDiff[bar]) / period;
			_negSmma = (_prevNegSmma * (period - 1) + _negDiff[bar]) / period;

			if (_lastBar != bar)
			{
				_prevPosSmma = _posSmma;
				_prevNegSmma = _negSmma;
			}

			if (_negSmma != 0)
			{
				if (_negSmma == 0)
					return 0;

				var div = _posSmma / _negSmma;
				return div == 1 ? 0 : 100 - 100 / (1 + div);
			}

			return 100;
		}

		#endregion
	}
}











Technical/DOM.cs









namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;
using System.Runtime.CompilerServices;

using Newtonsoft.Json;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering;
using OFT.Rendering.Context;
using OFT.Rendering.Helpers;
using OFT.Rendering.Tools;
using Utils.Common.Logging;

using Color = System.Drawing.Color;

[Category(IndicatorCategories.OrderBook)]
[DisplayName("Depth Of Market")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DOMDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602367")]
public class DOM : Indicator
{
	#region Nested types

	public class VolumeInfo
	{
		#region Properties

		public decimal Volume { get; set; }

		public decimal Price { get; set; }

		#endregion
	}

	public enum Mode
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Levels))]
		Common,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Cumulative))]
		Cumulative,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Both))]
		Combined
	}

	#endregion

	#region Static and constants

	private const int _fontSize = 10;
	private const int _unitedVolumeHeight = 15;
	private const int _heightToSolidMode = 4;

    #endregion

    #region Fields

    private readonly ValueDataSeries _upScale = new("UpScale", "Up") { ScaleIt = false };
    private readonly ValueDataSeries _downScale = new("DownScale", "Down") { ScaleIt = false };

    private readonly RedrawArg _emptyRedrawArg = new(new Rectangle(0, 0, 0, 0));

	private readonly RenderStringFormat _stringLeftFormat = new()
	{
		Alignment = StringAlignment.Near,
		LineAlignment = StringAlignment.Center,
		Trimming = StringTrimming.EllipsisCharacter,
		FormatFlags = StringFormatFlags.NoWrap
	};

	private readonly RenderStringFormat _stringRightFormat = new()
	{
		Alignment = StringAlignment.Far,
		LineAlignment = StringAlignment.Center,
		Trimming = StringTrimming.EllipsisCharacter,
		FormatFlags = StringFormatFlags.NoWrap
	};

	private Color _askBackGround;
	private Color _askColor;
	private HistogramRender _asksHistogram;
	private Color _bestAskBackGround;
	private Color _bestBidBackGround;
	private Color _bidBackGround;
	private Color _bidColor;
	private HistogramRender _bidsHistogram;

	private SortedList<decimal, decimal> _cumulativeAsk = new();
	private SortedList<decimal, decimal> _cumulativeBid = new();

	private MultiColorsHistogramRender _cumulativeHistogram;
	private Dictionary<decimal, Color> _filteredColors = new();

	private RenderFont _font = new("Arial", _fontSize);
	private object _locker = new();

	private decimal _maxBid;
	private decimal _maxPrice = decimal.MinValue;

	private VolumeInfo _maxVolume = new();
	private SortedDictionary<decimal, MarketDataArg> _mDepth = new();
	private decimal _minAsk;
	private decimal _minPrice = decimal.MaxValue;

	private int _priceLevelsHeight;
	private int _lastRenderedHeight;
	private int _scale;

	private List<FilterColor> _sortedFilters = new();
	private Color _textColor;
	private Mode _visualMode = Mode.Common;
	private Color _volumeAskColor;
	private Color _volumeBidColor;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualMode), GroupName = nameof(Strings.HistogramSize), Description = nameof(Strings.ElementDisplayModeDescription), Order = 100)]
	public Mode VisualMode
	{
		get => _visualMode;
		set
		{
			_visualMode = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAutoSize), GroupName = nameof(Strings.HistogramSize), Description = nameof(Strings.UseAutoMaxSizeDetectionDescription), Order = 105)]
	public bool UseAutoSize { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ProportionVolume), GroupName = nameof(Strings.HistogramSize), Description = nameof(Strings.MaxSizeProportionVolumeDescription), Order = 110)]
	[Range(0, 1000000000000)]
	public decimal ProportionVolume { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.HistogramSize), Description = nameof(Strings.HistogramWidthDescription), Order = 120)]
	[Range(0, 4000)]
	public int Width { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.RightToLeft), GroupName = nameof(Strings.HistogramSize), Description = nameof(Strings.RightToLeftDescription), Order = 130)]
	public bool RightToLeft { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidRows), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.ProfileBidValueColorDescription), Order = 200)]
	public CrossColor BidRows
	{
		get => _bidColor.Convert();
		set
		{
			_bidColor = value.Convert();
			_volumeBidColor = Color.FromArgb(50, value.R, value.G, value.B);
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.LabelTextColorDescription), Order = 210)]
	public CrossColor TextColor
	{
		get => _textColor.Convert();
		set => _textColor = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskRows), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.ProfileAskValueColorDescription), Order = 220)]
	public CrossColor AskRows
	{
		get => _askColor.Convert();
		set
		{
			_askColor = value.Convert();
			_volumeAskColor = Color.FromArgb(50, value.R, value.G, value.B);
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidsBackGround), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.BidBGColorDescription), Order = 230)]
	public CrossColor BidsBackGround
	{
		get => _bidBackGround.Convert();
		set => _bidBackGround = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AsksBackGround), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.AskBGColorDescription), Order = 240)]
	public CrossColor AsksBackGround
	{
		get => _askBackGround.Convert();
		set => _askBackGround = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BestBidBackGround), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.BestBidBGColorDescription), Order = 250)]
	public CrossColor BestBidBackGround
	{
		get => _bestBidBackGround.Convert();
		set => _bestBidBackGround = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BestAskBackGround), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.BestAskBGColorDescription), Order = 260)]
	public CrossColor BestAskBackGround
	{
		get => _bestAskBackGround.Convert();
		set => _bestAskBackGround = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filters), GroupName = nameof(Strings.LevelsMode), Description = nameof(Strings.FiltersMaxVolumeDecimalColorDescription), Order = 270)]
	[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Reuse)]
	public ObservableCollection<FilterColor> FilterColors { get; set; } = new();

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskColor), GroupName = nameof(Strings.CumulativeMode), Description = nameof(Strings.CumulativeModeAskColorDescription), Order = 280)]
	public Color CumulativeAskColor { get; set; } = Color.FromArgb(255, 100, 100);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidColor), GroupName = nameof(Strings.CumulativeMode), Description = nameof(Strings.CumulativeModeBidColorDescription), Order = 285)]
	public Color CumulativeBidColor { get; set; } = Color.FromArgb(100, 255, 100);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowCumulativeValues), GroupName = nameof(Strings.Other), Description = nameof(Strings.ShowCumulativeValuesDescription), Order = 300)]
	public bool ShowCumulativeValues { get; set; }

	[Range(0, 1000)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomPriceLevelsHeight), GroupName = nameof(Strings.Other), Description = nameof(Strings.CustomPriceLevelsHeightDescription), Order = 310)]
	public int PriceLevelsHeight
	{
		get => _priceLevelsHeight;
		set => _priceLevelsHeight = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseScale), GroupName = nameof(Strings.Scale), Description = nameof(Strings.UseScaleDescription), Order = 400)]
	public bool UseScale
	{
		get => _upScale.ScaleIt;
		set => _upScale.ScaleIt = _downScale.ScaleIt = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomScale), GroupName = nameof(Strings.Scale), Description = nameof(Strings.ElementScaleValueDescription), Order = 410)]
	[Range(0, 1000)]
	public int Scale
	{
		get => _scale;
		set
		{
			_scale = value;
			_upScale.Clear();
			_downScale.Clear();
		}
	}

	#endregion

	#region ctor

	public DOM()
		: base(true)
	{
		DrawAbovePrice = true;
		DenyToChangePanel = true;
		_upScale.IsHidden = _downScale.IsHidden = true;
		_upScale.ShowCurrentValue = _downScale.ShowCurrentValue = false;
		_upScale.Color = _downScale.Color = Color.Transparent.Convert();

		DataSeries[0] = _upScale;
		DataSeries.Add(_downScale);

		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Final);

		UseAutoSize = true;

		ProportionVolume = 100;
		Width = 200;
		RightToLeft = true;

		BidRows = Color.FromArgb(153, 0, 128, 0).Convert();
		TextColor = Color.White.Convert();
		AskRows = Color.FromArgb(153, 255, 0, 0).Convert();

		ShowCumulativeValues = true;
		Scale = 20;

		FilterColors.CollectionChanged += FiltersChanged;
	}

	#endregion

	#region Protected methods

	protected override void OnDispose()
	{
		_mDepth?.Clear();
	}
	
	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			lock (_locker)
			{
				_cumulativeAsk = new SortedList<decimal, decimal>();
				_cumulativeBid = new SortedList<decimal, decimal>();
			}

			DataSeries.ForEach(x => x.Clear());

			lock (_locker)
			{
				var depths = MarketDepthInfo.GetMarketDepthSnapshot();

				var mDepth = new SortedDictionary<decimal, MarketDataArg>();

				foreach (var depth in depths)
				{
					try
					{
						mDepth.Add(depth.Price, depth);
                    }
					catch (ArgumentException)
					{
						//catch duplicates in snapshot
                    }
                }

				_mDepth = mDepth;

				if (_mDepth.Count == 0)
				{
					_maxPrice = _minPrice = GetCandle(CurrentBar - 1).Close;
					return;
				}

				ResetColors();

				_minAsk = _mDepth.FirstOrDefault(x => x.Value.Direction == TradeDirection.Buy).Key;
				_maxBid = _mDepth.LastOrDefault(x => x.Value.Direction == TradeDirection.Sell).Key;

				_maxPrice = Math.Min(_mDepth.Keys.Last(), _maxBid * 1.3m);
                _minPrice = Math.Max(_mDepth.Keys.First(), _maxBid * 0.7m);

				var maxLevel = _mDepth
					.Values
					.OrderByDescending(x => x.Volume)
					.First();

				_maxVolume = new VolumeInfo
				{
					Price = maxLevel.Price,
					Volume = maxLevel.Volume
				};

				if (VisualMode is not Mode.Common)
				{
					var sum = 0m;

					foreach (var (price, level) in _mDepth.Where(x => x.Value.DataType is MarketDataType.Ask))
					{
						sum += level.Volume;
						_cumulativeAsk[price] = sum;
					}

					sum = 0m;

					foreach (var (price, level) in _mDepth.Where(x => x.Value.DataType is MarketDataType.Bid).OrderByDescending(x => x.Key))
					{
						sum += level.Volume;
						_cumulativeBid[price] = sum;
					}
				}
			}

			return;
		}

		if (UseScale)
		{
			_upScale[CurrentBar - 2] = 0;
			_downScale[CurrentBar - 2] = 0;

			if (_maxPrice != 0)
				_upScale[CurrentBar - 1] = _maxPrice + InstrumentInfo.TickSize * (_scale + 3);

			if (_minPrice != 0)
				_downScale[CurrentBar - 1] = _minPrice - InstrumentInfo.TickSize * (_scale + 3);
		}
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		var chartInfo = ChartInfo;
		var instrumentInfo = InstrumentInfo;

		if (chartInfo is null || instrumentInfo is null)
			return;

		if (chartInfo.PriceChartContainer.TotalBars == -1)
			return;

		var xOfLastBar = ChartInfo.PriceChartContainer.GetXByBar(CurrentBar - 1);

		if (xOfLastBar > ChartInfo.PriceChartContainer.Region.Right)
			return;

        if (CurrentBar <= 0)
			return;

		lock (_locker)
		{
			if (_mDepth.Count == 0)
				return;
		}

		var height = (int)Math.Floor(chartInfo.PriceChartContainer.PriceRowHeight) - 1;

		if (PriceLevelsHeight != 0)
			height = PriceLevelsHeight - 2;

        height = height < 1 ? 1 : height;

        if (_lastRenderedHeight != height && height < 20)
        {
	        var textAutoSize = GetTextSize(context, height);
	        _font = new RenderFont("Arial", textAutoSize);
	        _lastRenderedHeight = height;
        }

        var maxVolume = _maxVolume.Volume;

		lock (_locker)
		{
			if (VisualMode is not Mode.Common)
				DrawCumulative(context);
		}

		if (VisualMode is not Mode.Cumulative)
		{
			if (UseAutoSize)
			{
				var maxVisiblePrice = chartInfo.PriceChartContainer.High;
                var minVisiblePrice = chartInfo.PriceChartContainer.Low;

                lock (_locker)
                {
					maxVolume = _mDepth.Where(md => md.Key <= maxVisiblePrice && md.Key >= minVisiblePrice)
						.Select(x => x.Value.Volume)
						.DefaultIfEmpty(0)
						.Max();
                }
            }
			else
                maxVolume = ProportionVolume;

            decimal currentPrice;

			try
			{
				currentPrice = GetCandle(CurrentBar - 1).Close;
			}
			catch (Exception e)
			{
				this.LogDebug("Chart does not contains bars", e);
				return;
			}

			var currentPriceY = chartInfo.GetYByPrice(currentPrice);
			
			DrawBackGround(context, currentPriceY);


			var chartHigh = chartInfo.PriceChartContainer.High;
			var chartLow = chartInfo.PriceChartContainer.Low;

			lock (_locker)
			{
				var stringRects = new List<(string Text, Rectangle Rect)>();

				if (_mDepth.Values.Any(x => x.DataType is MarketDataType.Ask))
				{
					_asksHistogram = new HistogramRender(!RightToLeft);
					var firstPrice = _minAsk;

					foreach (var priceDepth in _mDepth.Values.Where(x => x.DataType is MarketDataType.Ask))
					{
						if (!IsInChart(priceDepth.Price))
							continue;

						int y;

						if (PriceLevelsHeight == 0)
						{
							y = chartInfo.GetYByPrice(priceDepth.Price);
							height = Math.Abs(y - chartInfo.GetYByPrice(priceDepth.Price - instrumentInfo.TickSize)) - 1;

							if (height < 1)
								height = 1;
						}
						else
						{
							height = PriceLevelsHeight - 1;

							if (height < 1)
								height = 1;
							var diff = (priceDepth.Price - firstPrice) / instrumentInfo.TickSize;
							y = currentPriceY - height * ((int)diff + 1) - (int)diff - 15;
						}

						if (y + height < chartInfo.Region.Top)
							continue;

						var width = GetLevelWidth(priceDepth.Volume, maxVolume);

						if (!UseAutoSize)
							width = Math.Min(width, Width);

						if (priceDepth.Price == _minAsk)
						{
							var bestRect = new Rectangle(new Point(chartInfo.Region.Width - Width, y),
								new Size(Width, height));
							context.FillRectangle(_bestAskBackGround, bestRect);
						}

						var x1 = RightToLeft
							? chartInfo.Region.Width - width
							: chartInfo.Region.Width - Width;

						var x2 = x1 + width;
						var botY = y + height;

						var rect = RightToLeft
							? new Rectangle(chartInfo.Region.Width - width, y, width, height)
							: new Rectangle(new Point(chartInfo.Region.Width - Width, y), new Size(width, height));

						if (!_filteredColors.TryGetValue(priceDepth.Price, out var fillColor))
							fillColor = _askColor;

						if (_font.Size >= _heightToSolidMode)
						{
							context.FillRectangle(fillColor, rect);

							if (_font.Size > 4)
							{
								var renderText = chartInfo.TryGetMinimizedVolumeString(priceDepth.Volume, priceDepth.Price);
								var textWidth = context.MeasureString(renderText, _font).Width + 5;

								var textRect = RightToLeft
									? new Rectangle(new Point(chartInfo.Region.Width - textWidth, y), new Size(textWidth, height))
									: new Rectangle(new Point(chartInfo.Region.Width - Width, y), new Size(textWidth, height));

								stringRects.Add((renderText, textRect));
							}
						}
						else
							_asksHistogram.AddPrice(RightToLeft ? x2 : x1, RightToLeft ? x1 : x2, botY, y - 1);
					}
				}

				if (_mDepth.Values.Any(x => x.DataType is MarketDataType.Bid))
				{
					_bidsHistogram = new HistogramRender(!RightToLeft);
					var spread = 0;

					if (_mDepth.Values.Any(x => x.DataType is MarketDataType.Ask))
						spread = (int)((_minAsk - _maxBid) / instrumentInfo.TickSize);

					var firstPrice = _maxBid;

					foreach (var priceDepth in _mDepth.Values.Where(x => x.DataType is MarketDataType.Bid))
					{
						if (!IsInChart(priceDepth.Price))
							continue;

                        int y;

						if (PriceLevelsHeight == 0)
						{
							y = chartInfo.GetYByPrice(priceDepth.Price);
							height = Math.Abs(y - chartInfo.GetYByPrice(priceDepth.Price - instrumentInfo.TickSize)) - 1;

							if (height < 1)
								height = 1;
						}
						else
						{
							height = PriceLevelsHeight - 1;

							if (height < 1)
								height = 1;
							var diff = (firstPrice - priceDepth.Price) / instrumentInfo.TickSize;
							y = currentPriceY + height * ((int)diff + spread - 1) + (int)diff - 15;
						}

						if (y > chartInfo.Region.Bottom)
							continue;

						var width = GetLevelWidth(priceDepth.Volume, maxVolume);

						if (!UseAutoSize)
							width = Math.Min(width, Width);

						if (priceDepth.Price == _maxBid)
						{
							var bestRect = new Rectangle(new Point(chartInfo.Region.Width - Width, y),
								new Size(Width, height));
							context.FillRectangle(_bestBidBackGround, bestRect);
						}

						var x1 = RightToLeft
							? chartInfo.Region.Width - width
							: chartInfo.Region.Width - Width;

						var x2 = x1 + width;
						var botY = y + height;

						var rect = RightToLeft
							? new Rectangle(chartInfo.Region.Width - width, y, width, height)
							: new Rectangle(new Point(chartInfo.Region.Width - Width, y), new Size(width, height));

						if (!_filteredColors.TryGetValue(priceDepth.Price, out var fillColor))
							fillColor = _bidColor;

						if (_font.Size >= _heightToSolidMode)
						{
							if (_font.Size > 4)
							{
								var renderText = chartInfo.TryGetMinimizedVolumeString(priceDepth.Volume, priceDepth.Price);
								var textWidth = context.MeasureString(renderText, _font).Width + 5;

								var textRect = RightToLeft
									? new Rectangle(new Point(chartInfo.Region.Width - textWidth, y), new Size(textWidth, height))
									: new Rectangle(new Point(chartInfo.Region.Width - Width, y), new Size(textWidth, height));

								stringRects.Add((renderText, textRect));
							}

							context.FillRectangle(fillColor, rect);
						}
						else
							_bidsHistogram.AddPrice(RightToLeft ? x2 : x1, RightToLeft ? x1 : x2, botY, y - 1);
					}
				}

				if (_font.Size < _heightToSolidMode)
				{
					_asksHistogram?.Draw(context, _askColor, true);
					_bidsHistogram?.Draw(context, _bidColor, true);
				}

				foreach (var (text, rect) in stringRects)
				{
					context.DrawString(text,
						_font,
						_textColor,
						rect,
						RightToLeft ? _stringRightFormat : _stringLeftFormat);
				}
			}

			if (ShowCumulativeValues)
				DrawCumulativeValues(context);
		}
	}

	private bool IsInChart(decimal price)
	{
		return price <= ChartInfo?.PriceChartContainer.High && price >= ChartInfo?.PriceChartContainer.Low;
	}

	protected override void OnBestBidAskChanged(MarketDataArg depth)
	{
		if (depth.DataType is MarketDataType.Ask)
			_minAsk = depth.Price;
		else
			_maxBid = depth.Price;

		RedrawChart(_emptyRedrawArg);
	}

	protected override void MarketDepthChanged(MarketDataArg depth)
	{
		lock (_locker)
		{
			var isCumulative = VisualMode is not Mode.Common;
			
			_filteredColors.Remove(depth.Price);

			if (isCumulative)
			{
				if (depth.DataType is MarketDataType.Bid)
					_cumulativeBid.Remove(depth.Price);
				else
					_cumulativeAsk.Remove(depth.Price);
			}

			if (depth.Volume != 0)
			{
				_mDepth[depth.Price] = depth;

				foreach (var filterColor in _sortedFilters)
				{
					if (depth.Volume < filterColor.Value)
						continue;

					_filteredColors[depth.Price] = filterColor.Color;
					break;
				}
			}
			else
				_mDepth.Remove(depth.Price);

            if (_mDepth.Count == 0)
			{
				if (isCumulative)
				{
					_cumulativeAsk = new SortedList<decimal, decimal>();
					_cumulativeBid = new SortedList<decimal, decimal>();
				}

				return;
			}

			if (UseScale || isCumulative)
			{
				if (depth.Price >= _maxPrice || depth.Volume == 0)
				{
					if (depth.Price >= _maxPrice && depth.Volume != 0)
						_maxPrice = depth.Price;
					else if (depth.Price >= _maxPrice && depth.Volume == 0)
						_maxPrice = _mDepth.Keys.LastOrDefault();

					if (UseScale)
						_upScale[CurrentBar - 1] = _maxPrice + InstrumentInfo.TickSize * (_scale + 3);
				}

				if (depth.Price <= _minPrice || depth.Volume == 0)
				{
					if (depth.Price <= _minPrice && depth.Volume != 0)
						_minPrice = depth.Price;
					else if (depth.Price <= _minPrice && depth.Volume == 0)
						_minPrice = _mDepth.Keys.FirstOrDefault();

					if (UseScale)
						_downScale[CurrentBar - 1] = _minPrice - InstrumentInfo.TickSize * (_scale + 3);
				}
			}

			if (depth.Price == _maxVolume.Price)
			{
				if (depth.Volume >= _maxVolume.Volume)
					_maxVolume.Volume = depth.Volume;
				else
				{
					var priceLevel = _mDepth.Values
						.OrderByDescending(x => x.Volume)
						.First();

					_maxVolume.Price = priceLevel.Price;
					_maxVolume.Volume = priceLevel.Volume;
				}
			}
			else
			{
				if (depth.Volume > _maxVolume.Volume)
				{
					_maxVolume.Price = depth.Price;
					_maxVolume.Volume = depth.Volume;
				}
			}

			if (isCumulative)
			{
				if (depth.DataType is MarketDataType.Ask)
				{
					var sum = _cumulativeAsk.LastOrDefault(x => x.Key < depth.Price).Value;

					foreach (var (price, level) in _mDepth.Where(x => x.Key >= depth.Price && x.Value.DataType is MarketDataType.Ask))
					{
						sum += level.Volume;
						_cumulativeAsk[price] = sum;
					}
				}
				else
				{
					var sum = _cumulativeBid.FirstOrDefault(x => x.Key > depth.Price).Value;

					var otherBids = _mDepth
						.Where(x => x.Key <= depth.Price && x.Value.DataType is MarketDataType.Bid)
						.ToArray();

					for (var i = otherBids.Length - 1; i >= 0; i--)
					{
						var level = otherBids[i];

						sum += level.Value.Volume;
						_cumulativeBid[level.Key] = sum;
					}
				}
			}
		}

		RedrawChart(_emptyRedrawArg);
	}

	protected override void OnApplyDefaultColors()
	{
		if (ChartInfo is null)
			return;

		_bidColor = ChartInfo.ColorsStore.UpCandleColor;
		_askColor = ChartInfo.ColorsStore.DownCandleColor;
		_textColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor;

		var cumulativeBid = Color.FromArgb(
			_bidColor.R / 4 * 3,
			_bidColor.G / 4 * 3,
			_bidColor.B / 4 * 3).SetTransparency(0.4m);

		var cumulativeAsk = Color.FromArgb(
			_askColor.R / 4 * 3,
			_askColor.G / 4 * 3,
			_askColor.B / 4 * 3).SetTransparency(0.4m);

		CumulativeBidColor = cumulativeBid;
		CumulativeAskColor = cumulativeAsk;
	}
	
	#endregion

	#region Private methods

	private void DrawCumulativeValues(RenderContext context)
	{
		var maxWidth = (int)Math.Round(ChartInfo.Region.Width * 0.2m);
		var totalVolume = MarketDepthInfo.CumulativeDomAsks + MarketDepthInfo.CumulativeDomBids;

		if (totalVolume == 0)
			return;

		var font = new RenderFont("Arial", 9);

		var askRowWidth = (int)Math.Round(MarketDepthInfo.CumulativeDomAsks * (maxWidth - 1) / totalVolume);
		var bidRowWidth = maxWidth - askRowWidth;
		var yRect = ChartInfo.Region.Bottom - _unitedVolumeHeight;
		var bidStr = $"{MarketDepthInfo.CumulativeDomBids:0.##}";
		var askStr = $"{MarketDepthInfo.CumulativeDomAsks:0.##}";

		var askWidth = context.MeasureString(askStr, font).Width;
		var bidWidth = context.MeasureString(bidStr, font).Width;

		if (askWidth > askRowWidth && MarketDepthInfo.CumulativeDomAsks != 0)
		{
			askRowWidth = askWidth;
			maxWidth = (int)Math.Round(Math.Min(ChartInfo.Region.Width * 0.3m, totalVolume * askRowWidth / MarketDepthInfo.CumulativeDomAsks + 1));
			bidRowWidth = maxWidth - askRowWidth;
		}

		if (bidWidth > bidRowWidth && MarketDepthInfo.CumulativeDomBids != 0)
		{
			bidRowWidth = bidWidth;
			maxWidth = (int)Math.Round(Math.Min(ChartInfo.Region.Width * 0.3m, totalVolume * bidRowWidth / MarketDepthInfo.CumulativeDomBids + 1));
			askRowWidth = maxWidth - bidRowWidth;
		}

		if (askRowWidth > 0)
		{
			var askRect = new Rectangle(new Point(ChartInfo.Region.Width - askRowWidth, yRect),
				new Size(askRowWidth, _unitedVolumeHeight));
			context.FillRectangle(_volumeAskColor, askRect);
			context.DrawString(askStr, font, _bidColor, askRect, _stringLeftFormat);
		}

		if (bidRowWidth > 0)
		{
			var bidRect = new Rectangle(new Point(ChartInfo.Region.Width - maxWidth, yRect),
				new Size(bidRowWidth, _unitedVolumeHeight));
			context.FillRectangle(_volumeBidColor, bidRect);
			context.DrawString(bidStr, font, _askColor, bidRect, _stringRightFormat);
		}
	}

	private void DrawCumulative(RenderContext context)
	{
		_cumulativeHistogram = new MultiColorsHistogramRender(CumulativeAskColor, !RightToLeft);

		var maxVolume = Math.Max(
			_cumulativeAsk.Values.DefaultIfEmpty(0).Max(),
			_cumulativeBid.Values.DefaultIfEmpty(0).Max());

		var startX = RightToLeft ? Container.Region.Width : Container.Region.Width - Width;

		if (_mDepth.Any(x => x.Value.DataType is MarketDataType.Ask))
		{
			var curIdx = 0;
			var lastIdx = _cumulativeAsk.Count - 1;

			foreach (var (price, volume) in _cumulativeAsk)
			{
				var levelWidth = (int)(Width * volume / maxVolume);

				var x = RightToLeft
					? Container.Region.Width - levelWidth
					: Container.Region.Width - Width + levelWidth;

				var y1 = ChartInfo.GetYByPrice(price - InstrumentInfo.TickSize);

				var y2 = curIdx == lastIdx
					? ChartInfo.GetYByPrice(price)
					: ChartInfo.GetYByPrice(_cumulativeAsk.Keys[curIdx + 1] - InstrumentInfo.TickSize);

				_cumulativeHistogram.AddPrice(startX, x, y1, y2, CumulativeAskColor);
				curIdx++;
			}
		}

		if (_mDepth.Any(x => x.Value.DataType is MarketDataType.Bid))
		{
			var curIdx = 0;
			var lastIdx = _cumulativeBid.Count - 1;

			foreach (var (price, volume) in _cumulativeBid)
			{
				var levelWidth = (int)(Width * volume / maxVolume);

				var x = RightToLeft
					? Container.Region.Width - levelWidth
					: Container.Region.Width - Width + levelWidth;

				var y1 = ChartInfo.GetYByPrice(price - InstrumentInfo.TickSize);

				var y2 = curIdx == lastIdx
					? ChartInfo.GetYByPrice(price)
					: ChartInfo.GetYByPrice(_cumulativeBid.Keys[curIdx + 1]);

				_cumulativeHistogram.AddPrice(startX, x, y1, y2, CumulativeBidColor);
				curIdx++;
			}
		}

		_cumulativeHistogram.Draw(context, true);

		if (VisualMode is Mode.Cumulative)
		{
			foreach (var (price, volume) in _cumulativeBid)
				DrawText(context, price, volume);

			foreach (var (price, volume) in _cumulativeAsk)
				DrawText(context, price, volume);
		}
	}

	private void DrawText(RenderContext context, decimal price, decimal volume)
	{
		var form = RightToLeft ? _stringRightFormat : _stringLeftFormat;

		var y = ChartInfo.GetYByPrice(price);
		var renderText = ChartInfo.TryGetMinimizedVolumeString(volume,price);
		var textWidth = context.MeasureString(renderText, _font).Width + 5;

		var textRect = new Rectangle(new Point(ChartInfo.Region.Width - textWidth, y),
			new Size(textWidth, (int)ChartInfo.PriceChartContainer.PriceRowHeight));

		if (!RightToLeft)
		{
			textRect = new Rectangle(new Point(ChartInfo.Region.Width - Width, y),
				new Size(textWidth, (int)ChartInfo.PriceChartContainer.PriceRowHeight));
		}

		if (_font.Size >= 6)
		{
			context.DrawString(renderText,
				_font,
				_textColor,
				textRect,
				form);
		}
	}

	private int GetLevelWidth(decimal curVolume, decimal maxVolume)
	{
		var width = Math.Floor(curVolume * Width /
			(maxVolume == 0 ? 1 : maxVolume));

		return (int)Math.Min(Width, width);
	}

	private void DrawBackGround(RenderContext context, int priceY)
	{
		if (PriceLevelsHeight == 0)
		{
			var y2 = ChartInfo.GetYByPrice(_minAsk - InstrumentInfo.TickSize);
			var y3 = ChartInfo.GetYByPrice(_maxBid);
			var y4 = ChartInfo.Region.Height;

			var fullRect = new Rectangle(new Point(ChartInfo.Region.Width - Width, 0), new Size(Width, y2));

			context.FillRectangle(_askBackGround, fullRect);

			fullRect = new Rectangle(new Point(ChartInfo.Region.Width - Width, y3),
				new Size(Width, y4 - y3));

			context.FillRectangle(_bidBackGround, fullRect);
		}
		else
		{
			var spread = (int)((_minAsk - _maxBid) / InstrumentInfo.TickSize);
			var y = priceY - 15;

			var fullRect = new Rectangle(new Point(ChartInfo.Region.Width - Width, 0), new Size(Width, y));
			context.FillRectangle(_askBackGround, fullRect);

			y = priceY + (PriceLevelsHeight - 1) * (spread - 1) - 15;
			fullRect = new Rectangle(new Point(ChartInfo.Region.Width - Width, y), new Size(Width, ChartInfo.Region.Height - y));
			context.FillRectangle(_bidBackGround, fullRect);
		}
	}

	private void FiltersChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.NewItems != null)
		{
			foreach (var item in e.NewItems)
				((INotifyPropertyChanged)item).PropertyChanged += ItemPropertyChanged;
		}

		if (e.OldItems != null)
		{
			foreach (var item in e.OldItems)
				((INotifyPropertyChanged)item).PropertyChanged -= ItemPropertyChanged;
		}

		lock(_locker)
			_sortedFilters = new List<FilterColor>(FilterColors.OrderByDescending(x => x.Value));

		ResetColors();
	}

	private void ItemPropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		lock (_locker)
            _sortedFilters = new List<FilterColor>(FilterColors.OrderByDescending(x => x.Value));

		ResetColors();
	}

	private void ResetColors()
	{
		_filteredColors.Clear();

		foreach (var arg in _mDepth.Values)
		{
			foreach (var filterColor in _sortedFilters)
			{
				if (arg.Volume < filterColor.Value)
					continue;

				_filteredColors[arg.Price] = filterColor.Color;
				break;
			}
		}
	}

	private int GetTextSize(RenderContext context, int height)
	{
		for (var i = _fontSize; i > 0; i--)
		{
            var size = context.MeasureString("12", new RenderFont("Arial", i));

            if (size.Height < height + 4)
				return i;
		}

		return 0;
	}

	#endregion
}

public class FilterColor : INotifyPropertyChanged
{
	#region Fields

	private Color _color = Color.LightBlue;
	private decimal _value;

	#endregion

	#region Properties

	public decimal Value
	{
		get => _value;
		set
		{
			_value = value;
			OnPropertyChanged();
		}
	}

	public Color Color
	{
		get => _color;
		set
		{
			_color = value;
			OnPropertyChanged();
		}
	}

	#endregion

	#region Events

	public event PropertyChangedEventHandler PropertyChanged;

	#endregion

	#region Protected methods

	protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
	{
		PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
	}

	#endregion
}








Technical/DX.cs









namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("DX")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DXDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000606735-dx-indicator")]
	public class DX : Indicator
	{
		#region Fields

		private readonly DINeg _diNeg = new() { Period = 10 };
		private readonly DIPos _diPos = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _diPos.Period;
			set
			{
				_diPos.Period = _diNeg.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DX()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

            DataSeries.Add(_diPos.DataSeries[0]);
			DataSeries.Add(_diNeg.DataSeries[0]);
			DataSeries[0].IgnoredByAlerts = DataSeries[1].IgnoredByAlerts = true;

			Add(_diNeg);
			Add(_diPos);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var pos = _diPos[bar];
			var neg = _diNeg[bar];

			var sum = pos + neg;
			var diff = Math.Abs(pos - neg);

			this[bar] = sum != 0m ? 100 * diff / sum : 0m;
		}

		#endregion
	}
}








Technical/DailyChange.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Tools;

    [DisplayName("Daily Change")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DailyChangeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602542")]
	public class DailyChange : Indicator
	{
		#region Nested types

		public enum Align
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopLeft))]
			TopLeft = 0,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopRight))]
			TopRight = 1,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomLeft))]
			BottomLeft = 2,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomRight))]
			BottomRight = 3
		}

		public enum CalculationType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OpenCurDay))]
			CurrentDayOpen = 0,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ClosePrevDay))]
			PreviousDayClose = 1
		}

		public enum ValueType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent))]
			Percent = 0,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Ticks = 1,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PriceChange))]
			Price = 2
		}

		#endregion

		#region Fields
		
		private readonly RenderStringFormat _textFormat = new()
		{
			Alignment = StringAlignment.Center,
			LineAlignment = StringAlignment.Center
		};

		private Color _backgroundBuyColor;
		private Color _backgroundSellColor;
		private Color _buyColor;

		private CalculationType _calcType;

		private decimal _changeValue;
		private int _lastSession = -1;
		private Color _sellColor;
		private decimal _startPrice;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.PositiveValueColorDescription), Order = 1)]
		public CrossColor BuyColor
		{
			get => _buyColor.Convert();
			set => _buyColor = value.Convert();
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGroundBuyColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.LabelFillColorDescription), Order = 2)]
		public CrossColor BackGroundBuyColor
		{
			get => _backgroundBuyColor.Convert();
			set => _backgroundBuyColor = value.Convert();
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.NegativeValueColorDescription), Order = 3)]
		public CrossColor SellColor
		{
			get => _sellColor.Convert();
			set => _sellColor = value.Convert();
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGroundSellColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.LabelFillColorDescription), Order = 4)]
		public CrossColor BackGroundSellColor
		{
			get => _backgroundSellColor.Convert();
			set => _backgroundSellColor = value.Convert();
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Common), Description = nameof(Strings.CalculationModeDescription))]
		public CalculationType CalcType
		{
			get => _calcType;
			set
			{
				_calcType = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextLocation), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelLocationDescription))]
		public Align Alignment { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Type), GroupName = nameof(Strings.Common), Description = nameof(Strings.SourceDescription))]
		public ValueType ValType { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontSize), GroupName = nameof(Strings.Common), Description = nameof(Strings.FontSizeDescription))]
		public int FontSize { get; set; }

		#endregion

		#region ctor

		public DailyChange()
			: base(true)
		{
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Final);
			DataSeries[0].IsHidden = true;

			_calcType = CalculationType.PreviousDayClose;

			Alignment = Align.BottomRight;
			FontSize = 14;
			_buyColor = Color.LimeGreen;
			_sellColor = Color.Red;
			_backgroundBuyColor = _backgroundSellColor = Color.LightGray;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			if (IsNewSession(bar))
				_lastSession = bar;

			if (_lastSession < 0 && CalcType == CalculationType.PreviousDayClose)
				return;

			var candle = GetCandle(bar);

			switch (CalcType)
			{
				case CalculationType.PreviousDayClose:
					_startPrice = GetCandle(_lastSession - 1).Close;
					break;

				case CalculationType.CurrentDayOpen:
					_startPrice = GetCandle(Math.Max(0, _lastSession)).Open;
					break;
			}

			_changeValue = candle.Close - _startPrice;
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			var renderValue = 0.0m;
			var renderText = "";

			if (_lastSession > 0 || CalcType != CalculationType.PreviousDayClose)
			{
				switch (ValType)
				{
					case ValueType.Percent:
						renderValue = _changeValue / _startPrice * 100.0m;
						renderText = $"{renderValue:0.00}" + "%";
						break;

					case ValueType.Ticks:
						renderValue = _changeValue / ChartInfo.PriceChartContainer.Step;
						renderText = $"{renderValue} ticks";
						break;

					case ValueType.Price:
						renderValue = _changeValue;
						renderText = $"{renderValue}";
						break;
				}
			}
			else
				renderText = "Previous day is not loaded";

			if (_changeValue > 0)
				renderText = "+" + renderText;

			var font = new RenderFont("Arial", FontSize);
			var stringSize = context.MeasureString(renderText, font);
			var width = stringSize.Width + 10;
			var height = stringSize.Height + 5;
			int x = 0, y = 0;

			switch (Alignment)
			{
				case Align.BottomRight:
					x = Container.Region.Width - width;
					y = Container.Region.Height - height - 15;
					break;

				case Align.BottomLeft:
					y = Container.Region.Height - height - 15;
					break;

				case Align.TopRight:
					x = Container.Region.Width - width;
					break;

				case Align.TopLeft:
					if (!MouseLocationInfo.IsMouseLeave)
						y = 15;
					break;
			}

			var textColor = renderValue < 0 ? _sellColor : _buyColor;
			var backgroundColor = renderValue < 0 ? _backgroundSellColor : _backgroundBuyColor;
			
			var rectangle = new Rectangle(x, y, width, height);

			context.FillRectangle(backgroundColor, backgroundColor, rectangle);

			context.DrawString(renderText, font, textColor, rectangle, _textFormat);
		}

		#endregion
	}
}








Technical/DailyHighLow.cs






namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Daily HighLow")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DailyHighLowDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602609")]
public class DailyHighLow : Indicator
{
	#region Fields

	private readonly ValueDataSeries _highSeries = new("HighSeries", "High")
	{
		Color = System.Drawing.Color.FromArgb(255, 135, 135, 135).Convert(),
		VisualType = VisualMode.Square,
		DescriptionKey= nameof(Strings.CurrentDayHighDescription)
    };

	private readonly ValueDataSeries _lowSeries = new("LowSeries", "Low")
	{
		Color = System.Drawing.Color.FromArgb(255, 135, 135, 135).Convert(),
		VisualType = VisualMode.Square,
        DescriptionKey = nameof(Strings.CurrentDayLowDescription)
    };

	private readonly ValueDataSeries _medianSeries = new("MedianSeries", "Median")
	{
		Color = DefaultColors.Lime.Convert(),
		VisualType = VisualMode.Square,
        DescriptionKey = nameof(Strings.CurrentDayMedianDescription)
    };

	private readonly ValueDataSeries _prevMiddleSeries = new("PrevMiddleSeries", "Yesterday median")
	{
		Color = DefaultColors.Blue.Convert(),
		VisualType = VisualMode.Square,
        DescriptionKey = nameof(Strings.PrevDayMedianDescription)
    };

	private int _days = 20;

	private decimal _high;
	private bool _highSpecified;
	private DateTime _lastSessionTime;
	private decimal _low;
	private bool _lowSpecified;
	private decimal _median;

	private decimal _prevMiddle;
	private int _targetBar;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
    [Range(0, 1000)]
	public int Days
	{
		get => _days;
		set
		{
			_days = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public DailyHighLow()
		: base(true)
	{
		DenyToChangePanel = true;

		DataSeries[0] = _highSeries;
		DataSeries.Add(_lowSeries);
		DataSeries.Add(_medianSeries);
		DataSeries.Add(_prevMiddleSeries);
	}

	#endregion

	#region Public methods

	public override string ToString()
	{
		return "Daily HighLow";
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			if (_days == 0)
				_targetBar = 0;
			else
			{
				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}
			}

			_high = _low = _prevMiddle = 0;
			_highSpecified = _lowSpecified = false;
			DataSeries.ForEach(x => x.Clear());
		}

		if (bar < _targetBar)
			return;

		var candle = GetCandle(bar);

		if (IsNewSession(bar))
		{
			if (_lastSessionTime != candle.Time)
			{
				_lastSessionTime = candle.Time;
				_prevMiddle = _median;
				_high = _low = 0;
				_highSpecified = _lowSpecified = false;
			}
		}

		if (candle.High > _high || !_highSpecified)
			_high = candle.High;

		if (candle.Low < _low || !_lowSpecified)
			_low = candle.Low;

		_median = _low + (_high - _low) / 2;

		_highSpecified = _lowSpecified = true;
		_highSeries[bar] = _high;
		_lowSeries[bar] = _low;
		_medianSeries[bar] = _median;
		_prevMiddleSeries[bar] = _prevMiddle;
	}

	#endregion
}









Technical/DailyLines.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Globalization;
using System.Reflection;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

using Color = System.Drawing.Color;

[DisplayName("Daily Lines")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DailyLinesDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602284")]
public class DailyLines : Indicator
{
	#region Nested types

	private class SessionRange
	{
		#region Properties

		public int OpenBar { get; private set; } = -1;

		public decimal OpenPrice { get; private set; }

		public int HighBar { get; private set; }

		public decimal HighPrice { get; private set; } = decimal.MinValue;

		public int LowBar { get; private set; }

		public decimal LowPrice { get; private set; } = decimal.MaxValue;

		public int CloseBar { get; private set; }

		public decimal ClosePrice { get; private set; }

		public bool IsFinished { get; set; }

		#endregion

		#region ctor

		public SessionRange()
		{
		}

		public SessionRange(IndicatorCandle candle, int bar)
		{
			OpenBar = CloseBar = HighBar = LowBar = bar;
			OpenPrice = candle.Open;
			HighPrice = candle.High;
			LowPrice = candle.Low;
			ClosePrice = candle.Close;
		}

		#endregion

		internal void IncCandle(IndicatorCandle candle, int bar)
		{
			if (OpenBar < 0)
			{
				OpenPrice = candle.Open;
				OpenBar = bar;
			}

			if (candle.High > HighPrice)
			{
				HighPrice = candle.High;
				HighBar = bar;
			}

			if (candle.Low < LowPrice)
			{
				LowPrice = candle.Low;
				LowBar = bar;
			}

			ClosePrice = candle.Close;
			CloseBar = bar;
		}
	}

	[Serializable]
	[Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
	public enum PeriodType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CurrentDay))]
		CurrentDay,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PreviousDay))]
		PreviousDay,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CurrentWeek))]
		CurrenWeek,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PreviousWeek))]
		PreviousWeek,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CurrentMonth))]
		CurrentMonth,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PreviousMonth))]
		PreviousMonth
	}

	#endregion

	#region Fields

	private readonly RenderFont _axisFont = new("Arial", 9);
	private readonly FontSetting _fontSetting = new("Arial", 9);

	[Browsable(false)]
	public readonly RenderStringFormat _format = new()
	{
		Alignment = StringAlignment.Near,
		LineAlignment = StringAlignment.Center,
		Trimming = StringTrimming.EllipsisCharacter
	};

	private bool _customSession;
	private int _days = 60;
	private bool _drawOverChart;
	private bool _newWeekWait;
	private PeriodType _per = PeriodType.PreviousDay;
	private SessionRange _prevSessionRange;
	private SessionRange _sessionRange;
	private bool _showText = true;
	private int _lastDefaultSession;

	#endregion

	#region Properties

	#region Calculation

	[Browsable(false)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue,
		Description = nameof(Strings.DaysLookBackDescription))]
	[Range(1, 1000)]
	public int Days
	{
		get => _days;
		set
		{
			_days = value;
			RecalculateValues();
		}
	}

    #endregion

	#region Filters

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Filters),
        Description = nameof(Strings.PeriodDescription), Order = 110)]
    public PeriodType Period
    {
        get => _per;
        set
        {
            _per = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomSession), GroupName = nameof(Strings.Filters),
        Description = nameof(Strings.IsCustomSessionDescription), Order = 120)]
    public bool CustomSession
    {
        get => _customSession;
        set
        {
            _customSession = value;
            FilterStartTime.Enabled = FilterEndTime.Enabled = _customSession;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionBegin), GroupName = nameof(Strings.Filters),
        Description = nameof(Strings.SessionBeginDescription), Order = 120)]
    public FilterTimeSpan FilterStartTime { get; set; } = new(false);

    [Browsable(false)]
    public TimeSpan StartTime
    {
        get => FilterStartTime.Value;
        set => FilterStartTime.Value = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionEnd), GroupName = nameof(Strings.Filters),
        Description = nameof(Strings.SessionEndDescription), Order = 120)]
    public FilterTimeSpan FilterEndTime { get; set; } = new(false);

    [Browsable(false)]
    public TimeSpan EndTime
    {
        get => FilterEndTime.Value;
        set => FilterEndTime.Value = value;
    }

    #endregion

    #region Show

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.Show),
        Description = nameof(Strings.IsNeedShowLabelDescription), Order = 200)]
    public bool ShowText
    {
        get => _showText;
        set
        {
            _showText = value;
            TextSize.Enabled = _showText;
            RecalculateValues();
        }
    }

    [Range(5, 30)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize), GroupName = nameof(Strings.Show),
        Description = nameof(Strings.FontSizeDescription), Order = 205)]
    public FilterInt TextSize { get; set; } = new(false);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowPriceLabels), GroupName = nameof(Strings.Show),
        Description = nameof(Strings.ShowSelectedPriceOnPriceAxisDescription), Order = 210)]
    public bool ShowPrice { get; set; } = true;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FirstBar), GroupName = nameof(Strings.Show),
        Description = nameof(Strings.FirstBarDescription), Order = 220)]
    public bool DrawFromBar { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AbovePrice), GroupName = nameof(Strings.Show),
        Description = nameof(Strings.DrawAbovePriceDescription), Order = 230)]
    public bool DrawOverChart
    {
        get => _drawOverChart;
        set => _drawOverChart = DrawAbovePrice = value;
    }

    #endregion

    #region Open

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.Open),
        Description = nameof(Strings.PenSettingsDescription), Order = 310)]
    public PenSettings OpenPen { get; set; } = new() { Color = DefaultColors.Red.Convert(), Width = 2 };

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.Open), Description = nameof(Strings.LabelTextDescription),
        Order = 315)]
    public string OpenText { get; set; }

    #endregion

    #region Close

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.Close),
        Description = nameof(Strings.PenSettingsDescription), Order = 320)]
    public PenSettings ClosePen { get; set; } = new() { Color = DefaultColors.Red.Convert(), Width = 2 };

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.Close), Description = nameof(Strings.LabelTextDescription),
        Order = 325)]
    public string CloseText { get; set; }

    #endregion

    #region High

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.High),
        Description = nameof(Strings.PenSettingsDescription), Order = 330)]
    public PenSettings HighPen { get; set; } = new() { Color = DefaultColors.Red.Convert(), Width = 2 };

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.High), Description = nameof(Strings.LabelTextDescription),
        Order = 335)]
    public string HighText { get; set; }

    #endregion

    #region Low

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.Low), Description = nameof(Strings.PenSettingsDescription),
        Order = 340)]
    public PenSettings LowPen { get; set; } = new() { Color = DefaultColors.Red.Convert(), Width = 2 };

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.Low), Description = nameof(Strings.LabelTextDescription),
        Order = 345)]
    public string LowText { get; set; }

    #endregion

    #endregion

    #region ctor

    public DailyLines()
		: base(true)
	{
		DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Historical);
		DrawAbovePrice = true;

		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

		FilterStartTime.PropertyChanged += OnFilterPropertyChanged;
		FilterEndTime.PropertyChanged += OnFilterPropertyChanged;
		TextSize.PropertyChanged += OnFilterPropertyChanged;

		TextSize.Enabled = ShowText;
		TextSize.Value = _fontSetting.Size;
	}

	#endregion

	#region Protected methods

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo is null)
			return;

		var isCurrent = Period is PeriodType.CurrentDay or PeriodType.CurrenWeek or PeriodType.CurrentMonth;

		if (isCurrent && _lastDefaultSession > _sessionRange.OpenBar && _sessionRange.IsFinished)
		{
			DrawMessage(context);
			return;
		}

		var range = isCurrent || (Period is PeriodType.PreviousDay && _sessionRange.OpenBar <= _lastDefaultSession && CustomSession)
			? _sessionRange
			: _prevSessionRange;
		
        var periodStr = Period switch
		{
			PeriodType.CurrentDay => "Curr. Day",
			PeriodType.PreviousDay => "Prev. Day",
			PeriodType.CurrenWeek => "Curr. Week",
			PeriodType.PreviousWeek => "Prev. Week",
			PeriodType.CurrentMonth => "Curr. Month",
			PeriodType.PreviousMonth => "Prev. Month",
			_ => throw new ArgumentOutOfRangeException()
		};

		DrawLevel(context, OpenPen, range.OpenBar, range.OpenPrice, OpenText, "Open", periodStr);
		DrawLevel(context, HighPen, range.HighBar, range.HighPrice, HighText, "High", periodStr);
		DrawLevel(context, LowPen, range.LowBar, range.LowPrice, LowText, "Low", periodStr);

		if (range.IsFinished)
			DrawLevel(context, ClosePen, range.CloseBar, range.ClosePrice, CloseText, "Close", periodStr);
	}

	protected override void OnRecalculate()
	{
		_prevSessionRange = new SessionRange();
		_sessionRange = new SessionRange();
	}

	protected new bool IsNewSession(int bar)
	{
		if (!CustomSession)
			return base.IsNewSession(bar);

		var candle = GetCandle(bar);

		var startTime = candle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay;
		var endTime = candle.LastTime.AddHours(InstrumentInfo.TimeZone).TimeOfDay;

		if (bar == 0)
		{
			if (startTime <= endTime)
				return FilterStartTime.Value >= startTime && FilterStartTime.Value <= endTime;

			return FilterStartTime.Value >= startTime || FilterStartTime.Value <= endTime;
		}

		var insideBar = (startTime <= endTime && FilterStartTime.Value >= startTime && FilterStartTime.Value <= endTime)
			||
			(startTime > endTime && (FilterStartTime.Value >= startTime || FilterStartTime.Value <= endTime));

		if (insideBar)
			return true;

		var prevCandle = GetCandle(bar - 1);
		startTime = prevCandle.LastTime.AddHours(InstrumentInfo.TimeZone).TimeOfDay;
		endTime = candle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay;

		if (startTime <= endTime)
			return FilterStartTime.Value >= startTime && FilterStartTime.Value <= endTime;

		return FilterStartTime.Value >= startTime || FilterStartTime.Value <= endTime;
	}

	protected new bool IsNewWeek(int bar)
	{
		var isNew = base.IsNewWeek(bar);

		if (!CustomSession)
			return isNew;

		if (isNew)
			_newWeekWait = true;

		if (!InsideSession(bar) || !_newWeekWait)
			return false;

		_newWeekWait = false;
		return true;
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		if (base.IsNewSession(bar))
			_lastDefaultSession = bar;

		if (bar != _sessionRange.OpenBar)
		{
			var isNewPeriod = IsNewPeriod(bar);

			if (isNewPeriod)
			{
				if (_sessionRange.OpenBar >= 0)
				{
					_sessionRange.IsFinished = true;
					_prevSessionRange = _sessionRange;
				}

				_sessionRange = new SessionRange(candle, bar);
            }
			else
			{
				if (Period is PeriodType.CurrentDay or PeriodType.PreviousDay)
				{
                    if (InsideSession(bar))
					{
						_sessionRange.IncCandle(candle, bar);
					}
					else 
					{
						if (_sessionRange.OpenBar >= 0)
							_sessionRange.IsFinished = true;
					}
				}
				else
				{
					if (_sessionRange.OpenBar >= 0)
						_sessionRange.IncCandle(candle, bar);
				}
			}
		}
		else
		{
			if (Period is PeriodType.CurrentDay or PeriodType.PreviousDay)
			{
				if (InsideSession(bar))
				{
					_sessionRange.IncCandle(candle, bar);
				}
				else
				{
					if (_sessionRange.OpenBar >= 0)
						_sessionRange.IsFinished = true;
				}
			}
			else
			{
				if (_sessionRange.OpenBar >= 0)
					_sessionRange.IncCandle(candle, bar);
			}
		}
    }

	#endregion

	#region Private methods

	private bool InsideSession(int bar)
	{
		if (!CustomSession)
			return true;

		if (FilterStartTime.Value == FilterEndTime.Value)
			return true;

		var candle = GetCandle(bar);

		var sessionStart = FilterStartTime.Value;
		var sessionEnd = FilterEndTime.Value;

		var startTime = candle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay;
		var endTime = candle.LastTime.AddHours(InstrumentInfo.TimeZone).TimeOfDay;

		if (sessionStart < sessionEnd)
		{
			return (startTime >= sessionStart && startTime <= sessionEnd) ||
				(endTime >= sessionStart && endTime <= sessionEnd) ||
				(startTime <= sessionStart && endTime >= sessionEnd);
		}

		return startTime >= sessionStart || endTime >= sessionStart ||
			startTime <= sessionEnd || endTime <= sessionEnd;
	}

	private bool IsNewPeriod(int bar)
	{
		return Period switch
		{
			PeriodType.CurrentDay or PeriodType.PreviousDay => IsNewSession(bar),
			PeriodType.CurrenWeek or PeriodType.PreviousWeek => IsNewWeek(bar),
			PeriodType.CurrentMonth or PeriodType.PreviousMonth => IsNewMonth(bar),
			_ => false
		};
	}

	private void OnFilterPropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		if (e.PropertyName != "Value")
			return;

		if (sender.Equals(FilterStartTime))
		{
			RecalculateValues();
			RedrawChart();
		}
		else if (sender.Equals(FilterEndTime))
		{
			RecalculateValues();
			RedrawChart();
		}
		else if (sender.Equals(TextSize))
			_fontSetting.Size = TextSize.Value;
	}

	private void DrawString(RenderContext context, RenderFont font, string renderText, int yPrice, Color color)
	{
		var textSize = context.MeasureString(renderText, font);
		context.DrawString(renderText, font, color, Container.Region.Right - textSize.Width - 5, yPrice - textSize.Height);
	}

	private void DrawPrice(RenderContext context, decimal price, RenderPen pen)
	{
		var y = ChartInfo.GetYByPrice(price, false);

		if (y + 8 > Container.Region.Height)
			return;

		var renderText = price.ToString(CultureInfo.InvariantCulture);
		var size = context.MeasureString(renderText, _axisFont);
		var priceHeight = size.Height / 2;
		var x = Container.Region.Right;

		var points = new Point[5];
		points[0] = new Point(x, y);
		points[1] = new Point(x + priceHeight, y - priceHeight);
		points[2] = new Point(x + size.Width + 2 * priceHeight, y - priceHeight);
		points[3] = new Point(points[2].X, y + priceHeight + 1);
		points[4] = new Point(x + priceHeight, y + priceHeight + 1);

		var textRect = new Rectangle(points[1], new Size(size.Width + priceHeight, 2 * priceHeight));
		context.FillPolygon(pen.Color, points);
		context.DrawString(renderText, _axisFont, Color.White, textRect, _format);
	}

	private void DrawLevel(RenderContext context, PenSettings pen, int bar, decimal price, string text, string ohlc, string periodStr)
	{
		if (DrawFromBar && bar > LastVisibleBarNumber)
			return;
		
		var x1 = DrawFromBar ? ChartInfo.GetXByBar(bar) : 0;
		var x2 = Container.Region.Right;
		var y = ChartInfo.GetYByPrice(price, false);
		context.DrawLine(pen.RenderObject, x1, y, x2, y);

		var offset = 3;
		var renderText = string.IsNullOrEmpty(text) ? $"{periodStr} {ohlc}" : text;

		if (ShowText)
			DrawString(context, _fontSetting.RenderObject, renderText, y - offset, pen.RenderObject.Color);

		if (ShowPrice)
		{
			var bounds = context.ClipBounds;
			context.ResetClip();
			context.SetTextRenderingHint(RenderTextRenderingHint.Aliased);
			DrawPrice(context, price, pen.RenderObject);
			context.SetTextRenderingHint(RenderTextRenderingHint.AntiAlias);
			context.SetClip(bounds);
		}
	}

	private void DrawMessage(RenderContext g)
	{
		var text = Strings.CustomSessionInactive;

		var textSize = g.MeasureString(text, ChartInfo.PriceAxisFont);

		var rect = new Rectangle(Container.Region.X, Container.Region.Bottom - textSize.Height, textSize.Width, textSize.Height);
		g.DrawString(text, ChartInfo.PriceAxisFont, DefaultColors.Red, rect);
	}

	#endregion
}








Technical/DeMarker.cs









namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("DeMarker")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeMarkerDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602365")]
	public class DeMarker : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly SMA _smaMax = new() { Period = 10 };
		private readonly SMA _smaMin = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _smaMax.Period;
			set
			{
				_smaMax.Period = _smaMin.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DeMarker()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_smaMax.Calculate(bar, 0);
				_smaMin.Calculate(bar, 0);
				return;
			}

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var deMax = Math.Max(0, candle.High - prevCandle.High);
			var deMin = Math.Min(0, prevCandle.Low - candle.Low);

			_smaMax.Calculate(bar, deMax);
			_smaMin.Calculate(bar, deMin);

			if (_smaMax[bar] + _smaMin[bar] != 0)
				_renderSeries[bar] = _smaMax[bar] / (_smaMax[bar] + _smaMin[bar]);
			else
				_renderSeries[bar] = _renderSeries[bar - 1];
		}

		#endregion
	}
}









Technical/DeTrended.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("DeTrended Price Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeTrendedDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602370")]
	public class DeTrended : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly SMA _sma = new();
		private int _lookBack;
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DeTrended()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();
				_sma.Period = _period / 2;
				_lookBack = _sma.Period / 2 + 1;
			}

			_sma.Calculate(bar, value);

			if (bar < _lookBack)
				return;

			_renderSeries[bar] = value - _sma[bar - _lookBack];
		}

		#endregion
	}
}








Technical/DeTrendedDi.cs





namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Detrended Oscillator - DiNapoli")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeTrendedDiDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602369")]
	public class DeTrendedDi : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly SMA _sma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DeTrendedDi()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = value - _sma.Calculate(bar, value);
		}

		#endregion
	}
}









Technical/Delta.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeltaDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602362")]
public class Delta : Indicator
{
	#region Nested types

	[Serializable]
	public enum BarDirection
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
		Any = 0,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bullish))]
		Bullish = 1,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bearlish))]
		Bearlish = 2
	}

	[Serializable]
	public enum DeltaType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
		Any = 0,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive))]
		Positive = 1,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative))]
		Negative = 2
	}

	[Serializable]
	public enum DeltaVisualMode
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Candles))]
		Candles = 0,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow))]
		HighLow = 1,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Histogram))]
		Histogram = 2,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bars))]
		Bars = 3
	}

	public enum Location
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up))]
		Up,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Middle))]
		Middle,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Down))]
		Down
	}

	#endregion

	#region Fields

	private readonly CandleDataSeries _candles = new("Candles", "Delta candles")
	{
		DownCandleColor = System.Drawing.Color.Red.Convert(),
		UpCandleColor = System.Drawing.Color.Green.Convert(),
		IsHidden = true,
		ShowCurrentValue = false,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true
    };

	private readonly CandleDataSeries _downCandles = new("DownCandles", "Delta candles")
	{
		DownCandleColor = Color.Green.Convert(),
		UpCandleColor = Color.Red.Convert(),
		IsHidden = true,
		ShowCurrentValue = false,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true
    };

	private readonly ValueDataSeries _currentValues = new("CurrentValues", "Current Values")
	{
		IsHidden = true,
		VisualType = VisualMode.OnlyValueOnAxis,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
		IgnoredByAlerts = true
    };

	private readonly ValueDataSeries _diapasonHigh = new("DiapasonHigh", "Delta range high")
	{
		Color = CrossColor.FromArgb(128, 128, 128, 128),
		ShowZeroValue = false,
		ShowCurrentValue = false,
		VisualType = VisualMode.Hide,
		IsHidden = true,
		UseMinimizedModeIfEnabled = true,
		IgnoredByAlerts = true
    };

	private readonly ValueDataSeries _diapasonLow = new("DiapasonLow", "Delta range low")
	{
		Color = CrossColor.FromArgb(128, 128, 128, 128),
		ShowZeroValue = false,
		ShowCurrentValue = false,
		VisualType = VisualMode.Hide,
		IsHidden = true,
		UseMinimizedModeIfEnabled = true,
		IgnoredByAlerts = true
    };

	private readonly ValueDataSeries _delta = new("DeltaId", "Delta")
	{
		Color = System.Drawing.Color.Red.Convert(), 
		VisualType = VisualMode.Hide,
		ShowZeroValue = false,
		ShowCurrentValue = false,
		IsHidden = true,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true
	};
	
	private decimal _alertFilter;
	private BarDirection _barDirection;
	private DeltaType _deltaType;
	private System.Drawing.Color _downColor = System.Drawing.Color.Red;

	private ValueDataSeries _downSeries = new("DownSeries", Strings.Down)
	{
		VisualType = VisualMode.Hide,
		IsHidden = true,
		UseMinimizedModeIfEnabled = true,
		IgnoredByAlerts = true
    };

	private decimal _filter;

	private System.Drawing.Color _fontColor;

	private RenderStringFormat _format = new()
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center
	};

	private int _lastBar;
	private int _lastBarAlert;
	private bool _minimizedMode;
	private DeltaVisualMode _mode = DeltaVisualMode.Candles;
	private CrossColor _neutralColor = System.Drawing.Color.Gray.Convert();
	private decimal _prevDeltaValue;
	private bool _showCurrentValues = true;

	private System.Drawing.Color _upColor = System.Drawing.Color.Green;

	private ValueDataSeries _upSeries = new("UpSeries", Strings.Up)
	{
		Color = System.Drawing.Color.Green.Convert(),
		VisualType = VisualMode.Hide,
		IsHidden = true,
		UseMinimizedModeIfEnabled = true,
		IgnoredByAlerts = true
	};

	private decimal _negativeAlertFilter;
	private int _lastBarNegativeAlert;

	#endregion

    #region Properties

    #region Visualization

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualMode), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualModeDescription), Order = 10)]
    public DeltaVisualMode Mode
    {
	    get => _mode;
	    set
	    {
		    _mode = value;

		    if (_mode == DeltaVisualMode.Histogram)
		    {
			    _delta.VisualType = VisualMode.Histogram;
			    _diapasonHigh.VisualType = VisualMode.Hide;
			    _diapasonLow.VisualType = VisualMode.Hide;
			    _candles.Visible = _downCandles.Visible = false;
		    }
		    else if (_mode == DeltaVisualMode.HighLow)
		    {
			    _delta.VisualType = VisualMode.Histogram;
                _diapasonHigh.VisualType = VisualMode.Histogram;
			    _diapasonLow.VisualType = VisualMode.Histogram;
			    _candles.Visible = _downCandles.Visible = false;
		    }
		    else if (_mode == DeltaVisualMode.Candles)
		    {
			    _delta.VisualType = VisualMode.Hide;
			    _diapasonHigh.VisualType = VisualMode.Hide;
			    _diapasonLow.VisualType = VisualMode.Hide;
			    _candles.Visible = _downCandles.Visible = true;
			    _candles.Mode = _downCandles.Mode = CandleVisualMode.Candles;
		    }
		    else
		    {
			    _delta.VisualType = VisualMode.Hide;
			    _diapasonHigh.VisualType = VisualMode.Hide;
			    _diapasonLow.VisualType = VisualMode.Hide;
			    _candles.Visible = _downCandles.Visible = true;
			    _candles.Mode = _downCandles.Mode = CandleVisualMode.Bars;
		    }

		    RaisePropertyChanged("Mode");
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimizedMode), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.HistogramMinimizedModeDescription), Order = 20)]

    public bool MinimizedMode
    {
	    get => _minimizedMode;
	    set
	    {
		    _minimizedMode = value;
		    RaisePropertyChanged("MinimizedMode");
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowCurrentValue), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowCurrentValueDescription), Order = 30)]
    public bool ShowCurrentValues
    {
	    get => _showCurrentValues;
	    set
	    {
		    _showCurrentValues = value;
		    _currentValues.ShowCurrentValue = value;
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 40)]
    public CrossColor UpColor
    {
	    get => _upColor.Convert();
	    set
	    {
		    _upColor = value.Convert();
		    _candles.UpCandleColor = value;
		    _upSeries.Color = value;
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 50)]
    public CrossColor DownColor
    {
	    get => _downColor.Convert();
	    set
	    {
		    _downColor = value.Convert();
		    _candles.DownCandleColor = value;
		    _downCandles.UpCandleColor = value;
		    _downSeries.Color = value;
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.NeutralBorderColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NeutralValueDescription), Order = 60)]
    public CrossColor NeutralColor
    {
	    get => _neutralColor;
	    set
	    {
		    _neutralColor = value;
		    _candles.BorderColor = _downCandles.BorderColor = value;
		    _diapasonHigh.Color = _diapasonLow.Color = value;
	    }
    }

    #endregion

    #region Filters

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BarsDirection), GroupName = nameof(Strings.Filters), Description = nameof(Strings.BarDirectionDescription), Order = 100)]
    public BarDirection BarsDirection
    {
	    get => _barDirection;
	    set
	    {
		    _barDirection = value;
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DeltaType), GroupName = nameof(Strings.Filters), Description = nameof(Strings.DeltaTypeDescription), Order = 110)]
    public DeltaType DeltaTypes
    {
	    get => _deltaType;
	    set
	    {
		    _deltaType = value;
		    RecalculateValues();
	    }
    }

    [Parameter]
	[Range(0, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MinDeltaVolumeFilterCommonDescription), Order = 120)]
    public decimal Filter
    {
	    get => _filter;
	    set
	    {
		    _filter = value;
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDivergence), GroupName = nameof(Strings.Filters), Description = nameof(Strings.BarDirVsDeltaDivergenceDescription), Order = 130)]
    public bool ShowDivergence { get; set; }

    #endregion

    #region Volume

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.VolumeLabel), Order = 200, Description = nameof(Strings.VolumeLabelDescription))]
    public bool ShowVolume { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.LabelTextColorDescription), Order = 210)]
    public CrossColor FontColor
    {
	    get => _fontColor.Convert();
	    set => _fontColor = value.Convert();
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Location), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.LabelLocationDescription), Order = 220)]
    public Location VolLocation { get; set; } = Location.Middle;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.FontSettingDescription), Order = 230)]
    public FontSetting Font { get; set; } = new("Arial", 10);

    #endregion

    #region Alerts

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlert), GroupName = nameof(Strings.UpAlert), Description = nameof(Strings.UpAlertFileFilterDescription), Order = 300)]
    public bool UseAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.UpAlert), Description = nameof(Strings.AlertFilterDescription), Order = 310)]
	[Range(0, int.MaxValue)]
    public decimal AlertFilter
    {
	    get => _alertFilter;
	    set
	    {
		    _lastBarAlert = 0;
		    _alertFilter = value;
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlert), GroupName = nameof(Strings.DownAlert), Description = nameof(Strings.DownAlertFileFilterDescription), Order = 312)]
    public bool UseNegativeAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.DownAlert), Description = nameof(Strings.AlertFilterDescription), Order = 314)]
    [Range(int.MinValue, 0)]
    public decimal NegativeAlertFilter
    {
	    get => _negativeAlertFilter;
	    set
	    {
		    _lastBarNegativeAlert = 0;
		    _negativeAlertFilter = value;
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 320)]
    public string AlertFile { get; set; } = "alert1";

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 330)]
    public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 340)]
    public CrossColor AlertBGColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

    #endregion

	#endregion

	#region ctor

	public Delta()
		: base(true)
	{
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Final);
		FontColor = System.Drawing.Color.Blue.Convert();

		Panel = IndicatorDataProvider.NewPanel;
		DataSeries[0] = _delta; //2
		
		DataSeries.Insert(0, _diapasonHigh); //0
		DataSeries.Insert(1, _diapasonLow); //1
		DataSeries.Add(_candles); //4

		DataSeries.Add(_upSeries);
		DataSeries.Add(_downSeries);
		DataSeries.Add(_currentValues);
		DataSeries.Add(_downCandles);
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    UpColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    DownColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	    NeutralColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
	    FontColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor.Convert();
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo is null || InstrumentInfo is null)
			return;

		if (ShowDivergence)
		{
			for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
			{
				try
				{
					if (_upSeries[i] == 0 && _downSeries[i] == 0)
						continue;

					var candle = GetCandle(i);
					var x = ChartInfo.PriceChartContainer.GetXByBar(i, false);

					if (_upSeries[i] != 0)
					{
						var yPrice = ChartInfo.PriceChartContainer.GetYByPrice(candle.Low, false) + 10;

						if (yPrice <= ChartInfo.PriceChartContainer.Region.Bottom)
						{
							var rect = new Rectangle(x - 5, yPrice - 4, 8, 8);
							context.FillEllipse(_upColor, rect);
						}
					}

					if (_downSeries[i] != 0)
					{
						var yPrice = ChartInfo.PriceChartContainer.GetYByPrice(candle.High, false) - 10;

						if (yPrice <= ChartInfo.PriceChartContainer.Region.Bottom)
						{
							var rect = new Rectangle(x - 5, yPrice - 4, 8, 8);
							context.FillEllipse(_downColor, rect);
						}
					}
				}
				catch (OverflowException)
				{
					//Old instrument coordinates exception
					return;
				}
			}
		}

		if (!ShowVolume || ChartInfo.ChartVisualMode != ChartVisualModes.Clusters || Panel == IndicatorDataProvider.CandlesPanel)
			return;

		var minWidth = GetMinWidth(context, FirstVisibleBarNumber, LastVisibleBarNumber);
		var barWidth = ChartInfo.GetXByBar(1) - ChartInfo.GetXByBar(0);

		if (minWidth > barWidth)
			return;

		var strHeight = context.MeasureString("0", Font.RenderObject).Height;

		var y = VolLocation switch
		{
			Location.Up => Container.Region.Y,
			Location.Down => Container.Region.Bottom - strHeight,
			_ => Container.Region.Y + (Container.Region.Bottom - Container.Region.Y) / 2
		};

		for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
		{
			decimal value;

			if (MinimizedMode)
			{
				value = _candles[i].Close > 0
					? _candles[i].Close
					: -_downCandles[i].Close;
			}
			else
				value = _candles[i].Close;
			
			var renderText = ChartInfo.TryGetMinimizedVolumeString(value);

			var strRect = new Rectangle(ChartInfo.GetXByBar(i),
				y,
				barWidth,
				strHeight);

			context.DrawString(renderText, Font.RenderObject, _fontColor, strRect, _format);
		}
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			DataSeries.ForEach(x => x.Clear());
			_upSeries.Clear();
			_downSeries.Clear();
		}

		var candle = GetCandle(bar);
		var deltaValue = candle.Delta;
		var absDelta = Math.Abs(deltaValue);
		var maxDelta = candle.MaxDelta;
		var minDelta = candle.MinDelta;

		var isUnderFilter = absDelta < _filter;

		if (_barDirection == BarDirection.Bullish)
		{
			if (candle.Close < candle.Open)
				isUnderFilter = true;
		}
		else if (_barDirection == BarDirection.Bearlish)
		{
			if (candle.Close > candle.Open)
				isUnderFilter = true;
		}

		if (_deltaType == DeltaType.Negative && deltaValue > 0)
			isUnderFilter = true;

		if (_deltaType == DeltaType.Positive && deltaValue < 0)
			isUnderFilter = true;

		if (isUnderFilter)
		{
			deltaValue = 0;
			absDelta = 0;
			minDelta = maxDelta = 0;
		}

		_delta[bar] = MinimizedMode ? absDelta : deltaValue;

		_delta.Colors[bar] = deltaValue > 0 ? _upColor : _downColor;

		if (MinimizedMode)
		{
			var high = Math.Abs(maxDelta);
			var low = Math.Abs(minDelta);
			_diapasonLow[bar] = Math.Min(Math.Min(high, low), absDelta);
			_diapasonHigh[bar] = Math.Max(high, low);

			if (deltaValue >= 0)
			{
				var currentCandle = _candles[bar];
				currentCandle.Open = deltaValue > 0 ? 0 : absDelta;
				currentCandle.Close = deltaValue > 0 ? absDelta : 0;
				currentCandle.High = _diapasonHigh[bar];
				currentCandle.Low = _diapasonLow[bar];
				_downCandles[bar] = new Candle();
            }
			else
			{
				var currentCandle = _downCandles[bar];
				currentCandle.Open = 0;
				currentCandle.Close = absDelta;
				currentCandle.High = _diapasonHigh[bar];
				currentCandle.Low = _diapasonLow[bar];
				_candles[bar] = new Candle();
            }
		}
		else
		{
			_diapasonLow[bar] = minDelta;
			_diapasonHigh[bar] = maxDelta;

			_candles[bar].Open = 0;
			_candles[bar].Close = deltaValue;
			_candles[bar].High = maxDelta;
			_candles[bar].Low = minDelta;
		}

		if (candle.Close > candle.Open && (_candles[bar].Close < _candles[bar].Open || _downCandles[bar].Close > _downCandles[bar].Open))
			_downSeries[bar] = _candles[bar].Close < _candles[bar].Open ? _candles[bar].High : _downCandles[bar].High;
		else
			_downSeries[bar] = 0;

		if (candle.Close < candle.Open && _candles[bar].Close > _candles[bar].Open)
			_upSeries[bar] = _candles[bar].High;
		else
			_upSeries[bar] = 0;

		if (_lastBar != bar)
		{
			_prevDeltaValue = deltaValue;
			_lastBar = bar;
		}

		if (UseAlerts && CurrentBar - 1 == bar && _lastBarAlert != bar)
		{
			if ((deltaValue >= AlertFilter && _prevDeltaValue < AlertFilter) || (deltaValue <= AlertFilter && _prevDeltaValue > AlertFilter))
			{
				_lastBarAlert = bar;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Delta reached {AlertFilter} filter", AlertBGColor, AlertForeColor);
			}
		}

		if (UseNegativeAlerts && CurrentBar - 1 == bar && _lastBarNegativeAlert != bar)
		{
			if ((deltaValue >= NegativeAlertFilter && _prevDeltaValue < NegativeAlertFilter) || (deltaValue <= NegativeAlertFilter && _prevDeltaValue > NegativeAlertFilter))
			{
				_lastBarNegativeAlert = bar;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Delta reached {NegativeAlertFilter} filter", AlertBGColor, AlertForeColor);
			}
		}

		_prevDeltaValue = deltaValue;

		if (!ShowCurrentValues)
			return;

		_currentValues[bar] = MinimizedMode ? absDelta : deltaValue;
        _currentValues.Colors[bar] = deltaValue > 0 ? _upColor : _downColor;
	}

	#endregion

	#region Private methods
	

	private int GetMinWidth(RenderContext context, int startBar, int endBar)
	{
		var maxLength = 0;

		for (var i = startBar; i <= endBar; i++)
		{
			decimal value;

			if (MinimizedMode)
			{
				value = _candles[i].Close > _candles[i].Open
					? _candles[i].Close
					: -_candles[i].Open;
			}
			else
				value = _candles[i].Close;

			var length = $"{value:0.#####}".Length;

			if (length > maxLength)
				maxLength = length;
		}

		var sampleStr = "";

		for (var i = 0; i < maxLength; i++)
			sampleStr += '0';

		return context.MeasureString(sampleStr, Font.RenderObject).Width;
	}

	#endregion
}







Technical/DeltaColoredCandles.cs








namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Heatmap;

[DisplayName("Delta Colored Candles")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeltaColoredCandlesDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618743")]
public class DeltaColoredCandles : Indicator
{
    #region Fields

    private readonly ValueDataSeries _delta = new("delta");
    private readonly PaintbarsDataSeries _colorBars = new("ColorBars", Strings.Candles) { IsHidden = true };
    private decimal _maxDelta = 600;
    private HeatmapTypes _colorScheme = HeatmapTypes.RedToDarkToGreen;
    private int _period = 14;

    #endregion

    #region Properties

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.General), Description = nameof(Strings.PeriodDescription))]
    public int Period 
    { 
        get => _period; 
        set
        {
            _period = value;
            RecalculateValues();
        }
    }

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumDelta), GroupName = nameof(Strings.General), Description = nameof(Strings.MaxDeltaVolumeFilterCommonDescription))]
    public decimal MaxDelta 
    { 
        get => _maxDelta;
        set
        {
            _maxDelta = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColorScheme), GroupName = nameof(Strings.General), Description = nameof(Strings.ColorSchemeDescription))]
    public HeatmapTypes ColorScheme 
    { 
        get => _colorScheme;
        set
        {
            _colorScheme = value;
            RecalculateValues();
        }
    }

    #endregion

    #region ctor

    public DeltaColoredCandles() : base(true)
    {
        DenyToChangePanel = true;
        DataSeries[0] = _colorBars;
    }

    #endregion

    #region Protected Methods

    protected override void OnCalculate(int bar, decimal value)
    {
        _delta[bar] = GetCandle(bar).Delta;
        var sumDelta = _delta.CalcSum(_period, bar);
        var percent = sumDelta * 100 / MaxDelta;
        var rate = 50 + percent / 2;
        rate = rate < 1 ? 1 : rate;
        var color = HeatmapExtensions.GetColor(ColorScheme, (int)rate);
        _colorBars[bar] = color.Convert();
    }

    #endregion
}









Technical/DeltaStrength.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Delta Strength")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeltaStrengthDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602363")]
	public class DeltaStrength : Indicator
	{
		#region Nested types

		public enum FilterType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bullish))]
			Bull,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bearlish))]
			Bear,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
			All
		}

		#endregion

		#region Fields

		private FilterType _negFilter;
        private FilterType _posFilter;

		private ValueDataSeries _negSeries = new("NegSeries", Strings.Negative)
		{
			DescriptionKey = nameof(Strings.PositiveDeltaSettingsDescription),
		};

		private ValueDataSeries _posSeries = new("PosSeries", Strings.Positive)
		{
			DescriptionKey = nameof(Strings.NegativeDeltaSettingsDescription),
		};

		private ValueDataSeries _neutralSeries = new("NeutralSeries", Strings.Neutral)
		{
            DescriptionKey = nameof(Strings.NeutralDeltaSettingsDescription),
		};

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxValue), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MaxDeltaFilterPercentDescription), Order = 100)]
		[Range(0, 100)]
		public Filter MaxFilter { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinValue), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinDeltaFilterPercentDescription), Order = 110)]
		[Range(0, 100)]
		public Filter MinFilter { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PositiveDelta), GroupName = nameof(Strings.Filter), Description = nameof(Strings.BarDirectionDescription), Order = 200)]
		public FilterType PosFilter
		{
			get => _posFilter;
			set
			{
				_posFilter = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.NegativeDelta), GroupName = nameof(Strings.Filter), Description = nameof(Strings.BarDirectionDescription), Order = 210)]
		public FilterType NegFilter
		{
			get => _negFilter;
			set
			{
				_negFilter = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DeltaStrength()
			: base(true)
		{
			DenyToChangePanel = true;
			_posFilter = _negFilter = FilterType.All;
			_posSeries.Color = System.Drawing.Color.Green.Convert();
			_negSeries.Color = System.Drawing.Color.Red.Convert();
			_neutralSeries.Color = System.Drawing.Color.Gray.Convert();
			_posSeries.VisualType = _negSeries.VisualType = _neutralSeries.VisualType = VisualMode.Dots;
			_posSeries.Width = _negSeries.Width = _neutralSeries.Width = 4;

			_posSeries.ShowCurrentValue = _negSeries.ShowCurrentValue = false;

			MaxFilter = new Filter
			{
				Enabled = true,
				Value = 98
			};

			MinFilter = new Filter
			{
				Enabled = true,
				Value = 90
			};

			MaxFilter.PropertyChanged += FilterChanged;
			MinFilter.PropertyChanged += FilterChanged;
			DataSeries[0] = _posSeries;
			DataSeries.Add(_negSeries);
			DataSeries.Add(_neutralSeries);

			_posSeries.ShowTooltip = _negSeries.ShowTooltip = _neutralSeries.ShowTooltip = false;
		}

        #endregion

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

	        _posSeries.Color = ChartInfo.ColorsStore.UpCandleColor.Convert();
	        _negSeries.Color = ChartInfo.ColorsStore.DownCandleColor.Convert();
	        _neutralSeries.Color = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				DataSeries.ForEach(x => x.Clear());

			if (!MaxFilter.Enabled && !MinFilter.Enabled)
				return;

			var candle = GetCandle(bar);

			if (candle.Delta < 0 && candle.MinDelta < 0
				&& candle.Delta <= candle.MinDelta * 0.01m * MinFilter.Value
				&& candle.Delta >= candle.MinDelta * 0.01m * MaxFilter.Value)
			{
				if (_negFilter == FilterType.All
					|| _negFilter == FilterType.Bull && candle.Close > candle.Open
					|| _negFilter == FilterType.Bear && candle.Close < candle.Open)
					_negSeries[bar] = candle.High + 2 * InstrumentInfo.TickSize;
				else
					_negSeries[bar] = _neutralSeries[bar] = 0;
				
			}
			else
				_negSeries[bar] = _neutralSeries[bar] = 0;

			if (candle.Delta > 0 && candle.MaxDelta > 0
				&& (candle.Delta >= candle.MaxDelta * 0.01m * MinFilter.Value || !MinFilter.Enabled)
				&& (candle.Delta <= candle.MaxDelta * 0.01m * MaxFilter.Value || !MaxFilter.Enabled))
			{
				if (_posFilter == FilterType.All
					|| _posFilter == FilterType.Bull && candle.Close > candle.Open
					|| _posFilter == FilterType.Bear && candle.Close < candle.Open)
					_posSeries[bar] = candle.Low - 2 * InstrumentInfo.TickSize;
				else
					_posSeries[bar] = _neutralSeries[bar] = 0;
			}
			else
				_posSeries[bar] = _neutralSeries[bar] = 0;

			if(candle.Delta == 0 && MinFilter.Value <= 0)
				_neutralSeries[bar] = candle.Low - 2 * InstrumentInfo.TickSize;
		}

		
		protected override void OnFinishRecalculate()
		{
			RedrawChart();
		}
		
		#endregion

		#region Private methods

		private void FilterChanged(object sender, PropertyChangedEventArgs e)
		{
			RecalculateValues();
		}

		#endregion
	}
}








Technical/DeltaTurnaround.cs









namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Delta Turnaround")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DeltaTurnaroundDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602364")]
public class DeltaTurnaround : Indicator
{
	#region Fields

	private readonly ValueDataSeries _negSeries = new("NegSeries", Strings.Down)
	{
		Color = Color.Red.Convert(),
		VisualType = VisualMode.DownArrow,
		DescriptionKey = nameof(Strings.NegativeDeltaSettingsDescription)
	};

	private readonly ValueDataSeries _posSeries = new("PosSeries", Strings.Up)
	{
		Color = Color.Green.Convert(),
		VisualType = VisualMode.UpArrow,
		DescriptionKey = nameof(Strings.PositiveDeltaSettingsDescription)
	};

	private int _lastBar;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlert), GroupName = nameof(Strings.UpAlert),
		Description = nameof(Strings.UpAlertFileFilterDescription), Order = 300)]
	public bool UseAlerts { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertNewCandle), GroupName = nameof(Strings.UpAlert),
		Order = 300)]
	public bool AlertOnNewCandle { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts),
		Description = nameof(Strings.AlertFileDescription), Order = 320)]
	public string AlertFile { get; set; } = "alert1";

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 330)]
	public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 340)]
	public CrossColor AlertBGColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

    #endregion

    #region ctor

    public DeltaTurnaround()
		: base(true)
	{
		DenyToChangePanel = true;

		DataSeries[0] = _posSeries;
		DataSeries.Add(_negSeries);
	}

	#endregion

	#region Protected methods

	protected override void OnApplyDefaultColors()
	{
		if (ChartInfo is null)
			return;

		_posSeries.Color = ChartInfo.ColorsStore.UpCandleColor.Convert();
		_negSeries.Color = ChartInfo.ColorsStore.DownCandleColor.Convert();
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar < 2)
			return;

		var candle = GetCandle(bar);
		var prevCandle = GetCandle(bar - 1);
		var prev2Candle = GetCandle(bar - 2);


		if (AlertOnNewCandle && _lastBar != bar && bar == CurrentBar - 1)
		{
			if (AlertOnNewCandle && (_posSeries[bar - 1] != 0 || _negSeries[bar - 1] != 0))
				AddAlert(AlertFile, InstrumentInfo.Instrument, "Delta turnaround down signal.", AlertBGColor, AlertForeColor);
		}

		_lastBar = bar;

		var checkAlerts = bar == CurrentBar - 1 && UseAlerts && !AlertOnNewCandle;

        if (prevCandle.Close - prevCandle.Open > 0
		    && prev2Candle.Close - prev2Candle.Open > 0
		    && candle.Close - candle.Open < 0
		    && candle.High >= prevCandle.High
		    && candle.Delta < 0)
		{
			var lastValue = _negSeries[bar];
			_negSeries[bar] = candle.High + InstrumentInfo.TickSize * 2;

			if(lastValue == 0 && checkAlerts)
				AddAlert(AlertFile, InstrumentInfo.Instrument, "Delta turnaround down signal.", AlertBGColor, AlertForeColor);
		}
		else
			_negSeries[bar] = 0;

		if (prevCandle.Close - prevCandle.Open < 0
		    && prev2Candle.Close - prev2Candle.Open < 0
		    && candle.Close - candle.Open > 0
		    && candle.Low <= prevCandle.Low
		    && candle.Delta > 0)
		{
			var lastValue = _posSeries[bar];
            _posSeries[bar] = candle.Low - InstrumentInfo.TickSize * 2;

			if (lastValue == 0 && checkAlerts)
				AddAlert(AlertFile, InstrumentInfo.Instrument, "Delta turnaround down signal.", AlertBGColor, AlertForeColor);
        }
		else
			_posSeries[bar] = 0;
	}

	#endregion
}









Technical/Demand.cs









namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Demand Index")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DemandDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602288")]
public class Demand : Indicator
{
	#region Fields

	private readonly EMA _emaBp = new() { Period = 10 };
	private readonly EMA _emaRange = new() { Period = 10 };
	private readonly EMA _emaSp = new() { Period = 10 };
	private readonly EMA _emaVolume = new() { Period = 10 };

	private readonly ValueDataSeries _priceSumSeries = new("PriceSum");
	private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Indicator)
	{
		DescriptionKey = nameof(Strings.BuySellPowerSettingsDescription)
	};

    private readonly ValueDataSeries _smaSeries = new("SmaSeries", Strings.SMA)
    {
        Color = DefaultColors.Blue.Convert(),
        IgnoredByAlerts = true,
		DescriptionKey=nameof(Strings.SmaSetingsDescription)
    };

    private readonly SMA _sma = new()
	{
		Period = 10
	};

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuySellPower), GroupName = nameof(Strings.Period), Description = nameof(Strings.VolumeMAPeriodDescription), Order = 100)]
	[Range(1, 10000)]
	public int BuySellPower
	{
		get => _emaRange.Period;
		set
		{
			_emaRange.Period = _emaVolume.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuySellPower), GroupName = nameof(Strings.Smooth), Description = nameof(Strings.BuySellPowerPeriodDescription), Order = 200)]
	[Range(1, 10000)]
	public int BuySellSmooth
	{
		get => _emaBp.Period;
		set
		{
			_emaBp.Period = _emaSp.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Indicator), GroupName = nameof(Strings.Smooth), Description = nameof(Strings.PeriodDescription), Order = 210)]
	[Range(1, 10000)]
	public int IndicatorSmooth
	{
		get => _sma.Period;
		set
		{
			_sma.Period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public Demand()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		var zeroLine = new LineSeries("ZeroVal", Strings.ZeroValue)
		{
			Color = System.Drawing.Color.Gray.Convert(),
			Value = 0,
			DescriptionKey = nameof(Strings.ZeroValue),
		};

        LineSeries.Add(zeroLine);

		DataSeries[0] = _renderSeries;
		DataSeries.Add(_smaSeries);
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);
		_priceSumSeries[bar] = candle.High + candle.Low + 2 * candle.Close;
		_emaVolume.Calculate(bar, candle.Volume);

		if (bar == 0)
		{
			_sma.Calculate(bar, 0);
			return;
		}

		var firstCandle = GetCandle(0);

		var bp = 0m;

		if (_emaVolume[bar] != 0 && firstCandle.High != firstCandle.Low && _priceSumSeries[bar] != 0)
		{
			if (_priceSumSeries[bar] < _priceSumSeries[bar - 1])
			{
				bp = candle.Volume / _emaVolume[bar] /
					(decimal)Math.Exp(0.375 * (double)(
						(_priceSumSeries[bar] + _priceSumSeries[bar - 1]) / (firstCandle.High - firstCandle.Low) *
						(_priceSumSeries[bar - 1] - _priceSumSeries[bar]) / _priceSumSeries[bar]
					));
			}
			else
				bp = candle.Volume / _emaVolume[bar];
		}
		else
			bp = candle.Volume / _emaVolume[bar - 1];

		var sp = 0m;

		if (_emaVolume[bar] != 0 && firstCandle.High != firstCandle.Low && _priceSumSeries[bar - 1] != 0)
		{
			if (_priceSumSeries[bar] <= _priceSumSeries[bar - 1])
				sp = candle.Volume / _emaVolume[bar];
			else
			{
				 var spValue = (double)(candle.Volume / _emaVolume[bar]) /
					Math.Exp(0.375 * (double)(
						(_priceSumSeries[bar] + _priceSumSeries[bar - 1]) / (firstCandle.High - firstCandle.Low) *
						(_priceSumSeries[bar] - _priceSumSeries[bar - 1]) / _priceSumSeries[bar - 1]
					));

				 try
				 {
					 sp = (decimal)spValue;
				 }
				 catch (Exception)
				 {
					 sp = spValue > (double)decimal.MaxValue
						 ? decimal.MaxValue
						 : 0;
				 }
			}
		}
		else
			sp = candle.Volume / _emaVolume[bar - 1];

		_emaBp.Calculate(bar, bp);
		_emaSp.Calculate(bar, sp);

		var q = 0m;

		if (_emaBp[bar] > _emaSp[bar])
			q = _emaBp[bar] == 0 ? 0 : _emaSp[bar] / _emaBp[bar];
		else if (_emaBp[bar] < _emaSp[bar])
			q = _emaSp[bar] == 0 ? 0 : _emaBp[bar] / _emaSp[bar];
		else
			q = 1;

		var di = 0m;

		if (_emaSp[bar] <= _emaBp[bar])
			di = 100 * (1 - q);
		else
			di = 100 * (q - 1);

		_renderSeries[bar] = di;
		_smaSeries[bar] = _sma.Calculate(bar, di);
	}

	#endregion
}









Technical/Dispersion.cs









namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Dispersion")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DispersionDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602626")]
	public class Dispersion : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _diffSeries = new("Difference");

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization) { UseMinimizedModeIfEnabled = true };

		private readonly SMA _sma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Dispersion()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_diffSeries[bar] = value - _sma.Calculate(bar, value);
			_diffSeries[bar] *= _diffSeries[bar];

			var diffSum = _diffSeries.CalcSum(_sma.Period - 1, bar);
			_renderSeries[bar] = diffSum / _sma.Period;
		}

		#endregion
	}
}









Technical/DividedByPrice.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("1 Divided by Price")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DividedByPriceDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602309")]
	public class DividedByPrice : Indicator
	{
		#region Fields

		private readonly CandleDataSeries _reversedCandles = new("ReversedCandles", Strings.Candles);

		#endregion

		#region ctor

		public DividedByPrice()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _reversedCandles;
		}

        #endregion

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

	        _reversedCandles.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	        _reversedCandles.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	        _reversedCandles.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
        }
        protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var open = 1 / candle.Open;
			var close = 1 / candle.Close;
			var high = 1 / candle.High;
			var low = 1 / candle.Low;

			_reversedCandles[bar] = new Candle
			{
				Open = open,
				Close = close,
				High = low,
				Low = high
			};
		}

		#endregion
	}
}










Technical/DmIndex.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Directional Movement Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DmIndexDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602285")]
	public class DmIndex : Indicator
	{
		#region Fields

		private readonly ATR _atr = new();

		private readonly ValueDataSeries _dmDown = new("DmUp");
		private readonly ValueDataSeries _dmUp = new("DmDown");

		private readonly ValueDataSeries _downSeries = new("DownSeries", Strings.Down) 
		{ 
			Color = DefaultColors.Red.Convert(),
			DescriptionKey = nameof(Strings.DownTrendSettingsDescription),
		};

		private readonly ValueDataSeries _upSeries = new("UpSeries", Strings.Up)
		{ 
			Color = DefaultColors.Blue.Convert(),
            DescriptionKey = nameof(Strings.UpTrendSettingsDescription),
        };

		private int _period = 14;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DmIndex()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			Add(_atr);
			DataSeries[0] = _upSeries;
			DataSeries.Add(_downSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			_dmUp[bar] = candle.High - prevCandle.High;
			_dmDown[bar] = prevCandle.Low - candle.Low;

			if (bar < _period)
				return;

			var dmUpSum = _dmUp.CalcSum(_period, bar);
			var dmDownSum = _dmDown.CalcSum(_period, bar);

			var smoothedUp = dmUpSum - dmUpSum / _period + _dmUp[bar];
			var smoothedDown = dmDownSum - dmDownSum / _period + _dmDown[bar];

			_upSeries[bar] = smoothedUp / _atr[bar] * 100m;
			_downSeries[bar] = smoothedDown / _atr[bar] * 100m;
		}

		#endregion
	}
}








Technical/DmOscillator.cs









namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Directional Movement Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DmOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602371")]
	public class DmOscillator : Indicator
	{
		#region Fields

		private readonly DmIndex _dm = new() { Period = 14 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
		public int Period
		{
			get => _dm.Period;
			set
			{
				_dm.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DmOscillator()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			Add(_dm);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = ((ValueDataSeries)_dm.DataSeries[0])[bar] - ((ValueDataSeries)_dm.DataSeries[1])[bar];
		}

		#endregion
	}
}









Technical/DomPower.cs









namespace ATAS.Indicators.Technical;

using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[Category(IndicatorCategories.OrderBook)]
[DisplayName("DOM Power")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DomPowerDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602374")]
public class DomPower : Indicator
{
	#region Fields

	private readonly ValueDataSeries _asks = new("AsksId", "Asks")
	{
		UseMinimizedModeIfEnabled = true,
		DescriptionKey = nameof(Strings.AskVisualizationSettingsDescription)
	};

	private readonly ValueDataSeries _bids = new("BidsId", "Bids")
	{
		Color = System.Drawing.Color.Green.Convert(),
		UseMinimizedModeIfEnabled = true,
        DescriptionKey = nameof(Strings.BidVisualizationSettingsDescription)
    };

	private bool _first = true;
	private int _lastCalculatedBar;
	private Filter _levelDepth = new(true)
	{
		Value = 5,
		Enabled = false
	};
	private object _locker = new();

	private ValueDataSeries _maxDelta = new("MaxDelta", "Max Delta")
	{
		Color = System.Drawing.Color.FromArgb(255, 27, 134, 198).Convert(),
		UseMinimizedModeIfEnabled = true,
        DescriptionKey = nameof(Strings.MaxDeltaSettingsDescription)
    };

	private SortedList<decimal, decimal> _mDepthAsk = new();
	private SortedList<decimal, decimal> _mDepthBid = new();

	private ValueDataSeries _minDelta = new("MinDelta", "Min Delta")
	{
		Color = System.Drawing.Color.FromArgb(255, 27, 134, 198).Convert(),
		UseMinimizedModeIfEnabled = true,
        DescriptionKey = nameof(Strings.MinDeltaSettingsDescription)
    };

	private int _lastBar = -1;
    private bool _isLastDeltaCalc;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DepthMarketFilter), GroupName = nameof(Strings.Period), Description = nameof(Strings.DOMMaxFilterDescription), Order = 100)]
	[Range(1, 1000)]
	public Filter LevelDepth
	{
		get => _levelDepth;
		set
		{
			_levelDepth = value;
			DataSeries.ForEach(x => x.Clear());
		}
	}

	#endregion

	#region ctor

	public DomPower()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DataSeries[0] = _asks;
		DataSeries.Add(_bids);
		DataSeries.Add(_maxDelta);
		DataSeries.Add(_minDelta);

		_levelDepth.PropertyChanged += DepthFilterChanged;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar is 0)
		{
			lock (_locker)
			{
				_mDepthAsk.Clear();
				_mDepthBid.Clear();
				var depths = MarketDepthInfo.GetMarketDepthSnapshot();

				foreach (var depth in depths)
				{
					if (depth.DataType is MarketDataType.Ask)
						_mDepthAsk[depth.Price] = depth.Volume;
					else
						_mDepthBid[depth.Price] = depth.Volume;
				}
			}
		}

		if (bar > 0 && bar != _lastBar) 
		{
			lock (_locker)
				_isLastDeltaCalc = false;

            _asks[bar] = _asks[bar - 1];
            _bids[bar] = _bids[bar - 1];
            _minDelta[bar] = _minDelta[bar - 1];
            _maxDelta[bar] = _maxDelta[bar - 1];
        }

		_lastBar = bar;
    }

	protected override void MarketDepthChanged(MarketDataArg depth)
	{
		if (_first)
		{
			_first = false;
			_lastCalculatedBar = CurrentBar - 1;
		}

		if (LevelDepth.Enabled)
		{
			lock (_locker)
			{
				if (depth.Volume is 0)
				{
					if (depth.DataType is MarketDataType.Ask)
						_mDepthAsk.Remove(depth.Price);
					else
						_mDepthBid.Remove(depth.Price);
				}
				else
				{
					if (depth.DataType is MarketDataType.Ask)
						_mDepthAsk[depth.Price] = depth.Volume;
					else
						_mDepthBid[depth.Price] = depth.Volume;
				}
			}
		}

		var lastCandle = CurrentBar - 1;

		var cumAsks = MarketDepthInfo.CumulativeDomAsks;
		var cumBids = MarketDepthInfo.CumulativeDomBids;

		if (LevelDepth.Enabled)
		{
			lock (_locker)
			{
				if (_mDepthAsk.Count <= LevelDepth.Value)
				{
					cumAsks = MarketDepthInfo.CumulativeDomAsks;
				}
				else
				{
					cumAsks = 0;

					for (var i = 0; i < LevelDepth.Value; i++)
						cumAsks += _mDepthAsk.Values[i];
				}

				if (_mDepthBid.Count <= LevelDepth.Value)
				{
					cumBids = MarketDepthInfo.CumulativeDomBids;
                }
				else
				{
					cumBids = 0;
					var lastIdx = _mDepthBid.Values.Count - 1;

					for (var i = 0; i < LevelDepth.Value; i++)
						cumBids += _mDepthBid.Values[lastIdx - i];
				}
			}
		}

		var delta = cumBids - cumAsks;
		var calcDelta = cumAsks != 0 && cumBids != 0;

		if (!calcDelta)
			return;

		for (var i = _lastCalculatedBar; i <= lastCandle; i++)
		{
			_asks[i] = -cumAsks;
			_bids[i] = cumBids;

			if (!_isLastDeltaCalc && i == lastCandle)
			{
                _maxDelta[i] = delta;
                _minDelta[i] = delta;

				lock (_locker)
					_isLastDeltaCalc = true;
            }

			if (delta > _maxDelta[i]) 
				_maxDelta[i] = delta;

			if (delta < _minDelta[i])
				_minDelta[i] = delta;			

            RaiseBarValueChanged(i);
		}

		_lastCalculatedBar = lastCandle;
	}

	#endregion

	#region Private methods

	private void DepthFilterChanged(object sender, PropertyChangedEventArgs e)
	{
		DataSeries.ForEach(x => x.Clear());
		RedrawChart();
	}

	#endregion
}









Technical/DomStrength.cs






namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

[Category(IndicatorCategories.OrderBook)]
[DisplayName("DOM Strength")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DomStrengthDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602375")]
public class DomStrength : Indicator
{
	#region Fields

	private readonly ValueDataSeries _buySeries = new("BuyValues");
    private readonly ValueDataSeries _sellSeries = new("SellValues");

    private decimal _buyVolume;
	private CumulativeDelta _cDelta = new();
	private decimal _cumAsks;
	private decimal _cumBids;
	private bool _initialized;
	private object _locker = new();
	private SortedList<decimal, decimal> _mDepthAsk = new();
	private SortedList<decimal, decimal> _mDepthBid = new();
	private decimal _percent = 50;
	private int _period = 5;
	private RenderPen _rectPen = new(Color.Black);
	private decimal _sellVolume;
	private List<MarketDataArg> _trades = new();

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.DepthMarketFilter), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DOMMaxFilterDescription), Order = 90)]
	[Range(1, 1000)]
	public FilterInt LevelDepth { get; } = new() { Value = 10 };

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
	[Range(1, 1000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			_buySeries.Clear();
			_sellSeries.Clear();

			if (_buySeries.Count > 0)
				OnCalculate(CurrentBar - 1, 0);
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DOMPercentDescription), Order = 110)]
	[Range(0, 100)]
	public decimal Percent
	{
		get => _percent;
		set
		{
			_percent = value;
			_buySeries.Clear();
			_sellSeries.Clear();

			if (_buySeries.Count > 0)
				OnCalculate(CurrentBar - 1, 0);
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color80), GroupName = nameof(Strings.Color), Description = nameof(Strings.PercentColorDescription), Order = 200)]
	public Color Color80 { get; set; } = Color.DarkGreen;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color50), GroupName = nameof(Strings.Color), Description = nameof(Strings.PercentColorDescription), Order = 210)]
	public Color Color50 { get; set; } = Color.LimeGreen;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color20), GroupName = nameof(Strings.Color), Description = nameof(Strings.PercentColorDescription), Order = 220)]
	public Color Color20 { get; set; } = Color.YellowGreen;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColorMinus20), GroupName = nameof(Strings.Color), Description = nameof(Strings.PercentColorDescription), Order = 230)]
	public Color ColorMinus20 { get; set; } = Color.Orange;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColorMinus50), GroupName = nameof(Strings.Color), Description = nameof(Strings.PercentColorDescription), Order = 240)]
	public Color ColorMinus50 { get; set; } = Color.PaleVioletRed;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColorMinus80), GroupName = nameof(Strings.Color), Description = nameof(Strings.PercentColorDescription), Order = 250)]
	public Color ColorMinus80 { get; set; } = Color.Red;

	#endregion

	#region ctor

	public DomStrength()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.LatestBar | DrawingLayouts.Historical);
		DataSeries[0] = _cDelta.DataSeries[1];
		DataSeries[0].Name = "Delta";

		Add(_cDelta);
		LevelDepth.PropertyChanged += FilterDepthChanged;
	}

	#endregion

	#region Protected methods

	protected override void OnApplyDefaultColors()
	{
		if (ChartInfo is null)
			return;

		var candles = (CandleDataSeries)DataSeries[0];

		candles.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
		candles.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
		candles.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
	}

	protected override void OnInitialize()
	{
		_trades.Clear();

		RequestForCumulativeTrades(
			new CumulativeTradesRequest(GetCandle(CurrentBar - 1).Time.Date)
		);
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			lock (_locker)
			{
				_mDepthAsk.Clear();
				_mDepthBid.Clear();
				var depths = MarketDepthInfo.GetMarketDepthSnapshot();

				foreach (var depth in depths)
				{
					if (depth.DataType is MarketDataType.Ask)
						_mDepthAsk[depth.Price] = depth.Volume;
					else
						_mDepthBid[depth.Price] = depth.Volume;
				}
			}
		}

		if (bar != CurrentBar - 1 || !_initialized)
			return;

		CalcCumulativeDepth();

		CalcRatio(bar);
	}

	protected override void OnNewTrade(MarketDataArg trade)
	{
		if (_initialized)
			_trades.Add(trade);

		if (_trades.Count > 100000)
		{
			_trades = _trades
				.Skip(10000)
				.ToList();
		}
	}

	protected override void OnCumulativeTradesResponse(CumulativeTradesRequest request, IEnumerable<CumulativeTrade> cumulativeTrades)
	{
		_trades.AddRange(
			cumulativeTrades.SelectMany(x => x.Ticks)
		);

		_initialized = true;
	}

	protected override void MarketDepthChanged(MarketDataArg depth)
	{
		if (!_initialized)
			return;

		if (LevelDepth.Enabled)
		{
			lock (_locker)
			{
				if (depth.Volume is 0)
				{
					if (depth.DataType is MarketDataType.Ask)
						_mDepthAsk.Remove(depth.Price);
					else
						_mDepthBid.Remove(depth.Price);
				}
				else
				{
					if (depth.DataType is MarketDataType.Ask)
						_mDepthAsk[depth.Price] = depth.Volume;
					else
						_mDepthBid[depth.Price] = depth.Volume;
				}
			}
		}

		CalcCumulativeDepth();

		if (depth.DataType is MarketDataType.Ask)
		{
			var buyRatio = (_cumAsks == 0
				? 0
				: _buyVolume / _cumAsks) * 100;

			_buySeries[CurrentBar - 1] = buyRatio - Percent;
		}

		if (depth.DataType is MarketDataType.Bid)
		{
			var sellRatio = (_cumBids == 0
				? 0
				: _sellVolume / _cumBids) * 100;

			_sellSeries[CurrentBar - 1] = sellRatio - Percent;
		}
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (!_initialized)
			return;

		var buyY = Container.Region.Top + 2;
		var sellY = Container.Region.Bottom - 12;

		for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
		{
			if (_buySeries[i] == 0 && _sellSeries[i] == 0)
				continue;

			var x = ChartInfo.PriceChartContainer.GetXByBar(i);

			if (_buySeries[i] != 0)
			{
				var color = GetColor(_buySeries[i]);

				var rect = new Rectangle(x, buyY, (int)ChartInfo.PriceChartContainer.BarsWidth, 10);
				context.FillRectangle(color, rect);
				context.DrawRectangle(_rectPen, rect);
			}

			if (_sellSeries[i] != 0)
			{
				var color = GetColor(_sellSeries[i]);

				var rect = new Rectangle(x, sellY, (int)ChartInfo.PriceChartContainer.BarsWidth, 10);
				context.FillRectangle(color, rect);
				context.DrawRectangle(_rectPen, rect);
			}
		}
	}

	#endregion

	#region Private methods

	private void CalcRatio(int bar)
	{
		var startBar = Math.Max(0, bar - Period);
		var startTime = GetCandle(startBar).Time;

		_buyVolume = _trades
			.Where(x => x.Time >= startTime && x.Direction is TradeDirection.Buy)
			.Sum(x => x.Volume);

		_sellVolume = _trades
			.Where(x => x.Time >= startTime && x.Direction is TradeDirection.Sell)
			.Sum(x => x.Volume);

		var buyRatio = (_cumAsks == 0
			? 0
			: _buyVolume / _cumAsks) * 100;

		var sellRatio = (_cumBids == 0
			? 0
			: _sellVolume / _cumBids) * 100;

		_buySeries[bar] = buyRatio - Percent;
		_sellSeries[bar] = sellRatio - Percent;
	}

	private Color GetColor(decimal percent)
	{
		return percent switch
		{
			>= 80 => Color80,
			< 80 and >= 50 => Color50,
			< 50 and >= 20 => Color20,
			< 20 and >= -20 => ColorMinus20,
			< -20 and >= -50 => ColorMinus50,
			_ => ColorMinus80
		};
	}

	private void FilterDepthChanged(object sender, PropertyChangedEventArgs e)
	{
		if (sender is not FilterInt)
			return;

		_buySeries.Clear();
		_sellSeries.Clear();
		RecalculateValues();

		if(Container is not null)
			RedrawChart(new RedrawArg(Container.Region));
	}

	private void CalcCumulativeDepth()
	{
		_cumAsks = MarketDepthInfo.CumulativeDomAsks;
		_cumBids = MarketDepthInfo.CumulativeDomBids;

		if (LevelDepth.Enabled)
		{
			lock (_locker)
			{
				if (_mDepthAsk.Count <= LevelDepth.Value)
				{
					_cumAsks = _mDepthAsk.Values
						.DefaultIfEmpty(0)
						.Sum();
				}
				else
				{
					_cumAsks = 0;

					for (var i = 0; i <= LevelDepth.Value; i++)
						_cumAsks += _mDepthAsk.Values[i];
				}

				if (_mDepthBid.Count <= LevelDepth.Value)
				{
					_cumBids = _mDepthAsk.Values
						.DefaultIfEmpty(0)
						.Sum();
				}
				else
				{
					_cumBids = 0;
					var lastIdx = _mDepthBid.Values.Count - 1;

					for (var i = 0; i <= LevelDepth.Value; i++)
						_cumBids += _mDepthBid.Values[lastIdx - i];
				}
			}
		}
	}

	#endregion
}









Technical/Donchian.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Donchian Channel")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DonchianDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602376")]
	public class Donchian : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _averageSeries = new("AverageSeries", "Average")
		{ 
			Color = DefaultColors.Blue.Convert(),
			DescriptionKey = nameof(Strings.MidChannelSettingsDescription),
		};

		private readonly ValueDataSeries _highSeries = new("HighSeries", "High") 
		{ 
			Color = DefaultColors.Red.Convert(),
            DescriptionKey = nameof(Strings.TopChannelSettingsDescription),
        };

        private readonly ValueDataSeries _lowSeries = new("LowSeries", "Low") 
		{
			Color = DefaultColors.Green.Convert(),
            DescriptionKey = nameof(Strings.BottomChannelSettingsDescription),
        };

		private int _period = 20;
		private bool _showAverage;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowAverage), Description = nameof(Strings.ShowMidlineDescription))]
		public bool ShowAverage
		{
			get => _showAverage;
			set
			{
				_showAverage = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription))]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Donchian()
			: base(true)
		{
			DenyToChangePanel = true;
			DataSeries[0] = _highSeries;
			DataSeries.Add(_lowSeries);
			DataSeries.Add(_averageSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var high = decimal.MinValue;
			var low = decimal.MaxValue;

			for (var i = bar; i >= bar - (bar < _period ? bar : _period); i--)
			{
				var candle = GetCandle(i);
				var cHigh = candle.High != 0 ? candle.High : Math.Max(candle.Open, candle.Close);
				var cLow = candle.Low != 0 ? candle.Low : Math.Min(candle.Open, candle.Close);

				if (cHigh > high)
					high = cHigh;

				if (cLow < low)
					low = cLow;
			}

			_highSeries[bar] = high;
			_lowSeries[bar] = low;

			if (_showAverage)
				_averageSeries[bar] = (high + low) / 2;
		}

		#endregion
	}
}








Technical/DoubleStochastic.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Double Stochastic")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DoubleStochasticDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602610")]
	public class DoubleStochastic : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 10 };
		private readonly EMA _emaSecond = new() { Period = 10 };

		private readonly Highest _max = new() { Period = 10 };
		private readonly Lowest _min = new() { Period = 10 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _max.Period;
			set
			{
				_max.Period = _min.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMAPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int SmaPeriod
		{
			get => _ema.Period;
			set
			{
				_ema.Period = _emaSecond.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DoubleStochastic()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var max = _max.Calculate(bar, candle.High);
			var min = _min.Calculate(bar, candle.Low);

			var fastK1 = max - min != 0
				? 100m * (candle.Close - min) / (max - min)
				: 100m * (candle.Close - min);

            var fastD1 = _ema.Calculate(bar, fastK1);

			var maxD1 = ((ValueDataSeries)_ema.DataSeries[0]).MAX(_max.Period, bar);
			var minD1 = ((ValueDataSeries)_ema.DataSeries[0]).MIN(_max.Period, bar);

			var fastK2 = maxD1 - minD1 != 0
				? 100m * (fastD1 - minD1) / (maxD1 - minD1)
				: 100m * (fastD1 - minD1);
			
			_renderSeries[bar] = _emaSecond.Calculate(bar, fastK2);
		}

		#endregion
	}
}







Technical/DoubleStochasticBressert.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Double Stochastic - Bressert")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DoubleStochasticBressertDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602377")]
	public class DoubleStochasticBressert : Indicator
	{
		#region Fields

		private readonly DoubleStochastic _ds = new()
		{
			Period = 10,
			SmaPeriod = 10
		};

		private readonly EMA _ema = new() { Period = 10 };
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ds.Period;
			set
			{
				_ds.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMAPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int SmaPeriod
		{
			get => _ds.SmaPeriod;
			set
			{
				_ds.SmaPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Smooth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int Smooth
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DoubleStochasticBressert()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			Add(_ds);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = _ema.Calculate(bar, _ds[bar]);
		}

		#endregion
	}
}








Technical/DtOscillator.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("DT Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DtOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602379")]
	public class DtOscillator : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _sdSeries = new("SdSeries", Strings.SMMA)
		{
			Color = DefaultColors.Blue.Convert(),
			IgnoredByAlerts = true
		};
		private readonly ValueDataSeries _skSeries = new("SkSeries", Strings.SMA);

		private readonly SMA _smaSd = new() { Period = 3 };
		private readonly SMA _smaSk = new() { Period = 3 };
		private readonly StochasticRsi _stRsi = new()
		{
			RsiPeriod = 8,
			Period = 5
		};

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RSI), GroupName = nameof(Strings.Stochastic), Description = nameof(Strings.StochasticRsiRsiPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int RsiPeriod
		{
			get => _stRsi.RsiPeriod;
			set
			{
				_stRsi.RsiPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Stochastic), Description = nameof(Strings.StochasticRsiPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int Period
		{
			get => _stRsi.Period;
			set
			{
				_stRsi.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod1), GroupName = nameof(Strings.Smooth), Description = nameof(Strings.SMAPeriod1Description), Order = 200)]
		[Range(1, 10000)]
        public int SMAPeriod1
		{
			get => _smaSk.Period;
			set
			{
				_smaSk.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod2), GroupName = nameof(Strings.Smooth), Description = nameof(Strings.SMAPeriod2Description), Order = 210)]
		[Range(1, 10000)]
        public int SMAPeriod2
		{
			get => _smaSd.Period;
			set
			{
				_smaSd.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public DtOscillator()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _skSeries;
			DataSeries.Add(_sdSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var stochRsi = _stRsi.Calculate(bar, value);
			_skSeries[bar] = _smaSk.Calculate(bar, 100 * stochRsi);
			_sdSeries[bar] = _smaSd.Calculate(bar, _skSeries[bar]);
		}

		#endregion
	}
}








Technical/DynamicLevels.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering;

using Utils.Common.Logging;

[DisplayName("Dynamic Levels")]
[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.DynamicLevelsDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602380")]
public class DynamicLevels : Indicator
{
	#region Nested types

	#region Candle

	public class DynamicCandle
	{
		#region Nested types

		private class PriceInfo
		{
			#region Properties

			public decimal Price { get; }

			public decimal Volume { get; set; }

			public decimal Value { get; set; }

			#endregion

			#region ctor

			public PriceInfo(decimal price)
			{
				Price = price;
			}

			#endregion
		}

		#endregion

		#region Fields

		private readonly SortedList<decimal, PriceInfo> _allPrice = new();

		private decimal _cachedVah;
		private decimal _cachedVal;
		private decimal _cachedVol;
		private decimal _maxPrice;

		private long _cacheTs;

		private PriceInfo _maxPriceInfo = new(0);

		public MiddleClusterType Type = MiddleClusterType.Volume;

		#endregion

		#region Properties

		public decimal MaxValue { get; set; }

		public decimal TrueMaxValue { get; set; }

		public decimal MaxValuePrice { get; set; }

		public decimal High { get; set; }

		public decimal Low { get; set; }

		public decimal Open { get; set; }

		public decimal Close { get; set; }

		public decimal Volume { get; set; }

		#endregion

		#region Public methods

		public void AddCandle(IndicatorCandle candle, decimal tickSize)
		{
			if (Open == 0)
				Open = candle.Open;
			Close = candle.Close;

			for (var price = candle.High; price >= candle.Low; price -= tickSize)
			{
				var info = candle.GetPriceVolumeInfo(price);

				if (info == null)
					continue;

				if (price > High)
					High = price;

				if (price < Low || Low == 0)
					Low = price;

				Volume += info.Volume;

				if (!_allPrice.TryGetValue(price, out var priceInfo))
				{
					priceInfo = new PriceInfo(price);
					_allPrice.Add(price, priceInfo);
				}

				priceInfo.Volume += info.Volume;

				if (priceInfo.Volume > _maxPriceInfo.Value)
				{
					_maxPrice = price;
					_maxPriceInfo = priceInfo;
				}

				switch (Type)
				{
					case MiddleClusterType.Bid:
					{
						priceInfo.Value += info.Bid;
						break;
					}
					case MiddleClusterType.Ask:
					{
						priceInfo.Value += info.Ask;
						break;
					}
					case MiddleClusterType.Delta:
					{
						priceInfo.Value += info.Ask - info.Bid;
						break;
					}
					case MiddleClusterType.Volume:
					{
						priceInfo.Value += info.Volume;
						break;
					}
					case MiddleClusterType.Tick:
					{
						priceInfo.Value += info.Ticks;
						break;
					}
					case MiddleClusterType.Time:
					{
						priceInfo.Value += info.Time;
						break;
					}
					default:
						throw new ArgumentOutOfRangeException();
				}

				if (Math.Abs(priceInfo.Value) > MaxValue)
				{
					MaxValue = Math.Abs(priceInfo.Value);
					TrueMaxValue = priceInfo.Value;
					MaxValuePrice = price;
				}
			}
		}

		public void AddTick(MarketDataArg tick)
		{
			if (tick.DataType != MarketDataType.Trade)
				return;

			var price = tick.Price;

			if (price < Low || Low == 0)
				Low = price;

			if (price > High)
				High = price;

			Volume += tick.Volume;
			var volume = tick.Volume;
			var bid = 0m;
			var ask = 0m;

			if (tick.Direction == TradeDirection.Buy)
				ask = volume;
			else if (tick.Direction == TradeDirection.Sell)
				bid = volume;

			if (!_allPrice.TryGetValue(price, out var priceInfo))
			{
				priceInfo = new PriceInfo(price);
				_allPrice.Add(price, priceInfo);
			}

			priceInfo.Volume += volume;

			if (priceInfo.Volume > _maxPriceInfo.Value)
			{
				_maxPrice = price;
				_maxPriceInfo = priceInfo;
			}

			switch (Type)
			{
				case MiddleClusterType.Bid:
				{
					priceInfo.Value += bid;
					break;
				}
				case MiddleClusterType.Ask:
				{
					priceInfo.Value += ask;
					break;
				}
				case MiddleClusterType.Delta:
				{
					priceInfo.Value += ask - bid;
					break;
				}
				case MiddleClusterType.Volume:
				{
					priceInfo.Value += volume;
					break;
				}
				case MiddleClusterType.Tick:
				{
					priceInfo.Value++;
					break;
				}
				case MiddleClusterType.Time:
				{
					priceInfo.Value++;
					break;
				}
				default:
					throw new ArgumentOutOfRangeException();
			}

			if (Math.Abs(priceInfo.Value) > MaxValue)
			{
				MaxValue = Math.Abs(priceInfo.Value);
				TrueMaxValue = priceInfo.Value;
				MaxValuePrice = price;
			}
		}

		public (decimal, decimal) GetValueArea(decimal tickSize, int valueAreaPercent, int valueAreaStep, int valueAreaDelay, bool useCache)
		{
			if (Volume == _cachedVol)
				return (_cachedVah, _cachedVal);

			if (useCache && _cachedVol != 0 && _cacheTs != 0 && Stopwatch.GetElapsedTime(_cacheTs).TotalMilliseconds < valueAreaDelay)
				return (_cachedVah, _cachedVal);
			
			var vah = 0m;
			var val = 0m;

			if (High != 0 && Low != 0)
			{
				var k = valueAreaPercent / 100.0m;
				vah = val = _maxPrice;
				var vol = _maxPriceInfo.Volume;
				var valueAreaVolume = Volume * k;

				var upperPrice = 0m;
				var lowerPrice = 0m;
				var upperIndex = 0;
				var lowerIndex = 0;

				while (vol <= valueAreaVolume)
				{
					if (vah >= High && val <= Low)
						break;

					var upperVol = 0m;
					var lowerVol = 0m;

					var newVah = upperPrice != vah;
					var newVal = lowerPrice != val;

					upperPrice = vah;
					lowerPrice = val;
					var c = valueAreaStep;

					var count = _allPrice.Count;

					if (newVah)
						upperIndex = _allPrice.IndexOfKey(upperPrice);

					var upLoopIdx = upperIndex;
					var upLoopPrice = upperPrice;

					for (var i = 0; i < c; i++)
					{
						if (upLoopIdx + 1 >= count)
							break;

						upLoopIdx++;

						var info = _allPrice.Values[upLoopIdx];
						upLoopPrice = info.Price;

						upperVol += info.Volume;
					}

					if (newVal)
						lowerIndex = _allPrice.IndexOfKey(lowerPrice);

					var downLoopIdx = lowerIndex;
					var downLoopPrice = lowerPrice;

					for (var i = 0; i < c; i++)
					{
						if (downLoopIdx - 1 < 0)
							break;

						downLoopIdx--;

						var info = _allPrice.Values[downLoopIdx];
						downLoopPrice = info.Price;

						lowerVol += info.Volume;
					}

					if (upperVol == lowerVol && upperVol == 0)
					{
						vah = Math.Min(upLoopPrice, High);
						val = Math.Max(downLoopPrice, Low);
					}
					else if (upperVol >= lowerVol)
					{
						vah = upLoopPrice;
						vol += upperVol;
					}
					else
					{
						val = downLoopPrice;
						vol += lowerVol;
					}

					if (vol >= valueAreaVolume)
						break;
				}
			}

			_cachedVol = Volume;
			_cachedVah = vah;
			_cachedVal = val;
			_cacheTs = Stopwatch.GetTimestamp();

			return (vah, val);
		}

		public void Clear()
		{
			_allPrice.Clear();
			MaxValue = High = Low = Volume = _cachedVol = _cachedVah = _cachedVal = _maxPrice = 0;
			_maxPriceInfo = new PriceInfo(0);
		}

		#endregion
	}

	#endregion

	[Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
	[Serializable]
	public enum MiddleClusterType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
		Bid,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
		Ask,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Delta))]
		Delta,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
		Volume,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
		Tick,

		[Browsable(false)]
		[Obsolete]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Time))]
		Time
	}

	[Serializable]
	[Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
	public enum Period
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Hourly))]
		Hourly,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.H4))]
		H4,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Daily))]
		Daily,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Weekly))]
		Weekly,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Monthly))]
		Monthly,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AllPeriodtxt))]
		All
	}

	[Serializable]
	[Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
	public enum VolumeVizualizationType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AtStart))]
		AtStart,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Accumulated))]
		Accumulated
	}

	#endregion

	#region Fields

	private readonly DynamicCandle _closedCandle = new();
	private readonly ValueDataSeries _dynamicLevels;
	private readonly object _syncRoot = new();

	private readonly RangeDataSeries _valueArea = new("ValueArea", "Value area")
	{
		RangeColor = CrossColor.FromArgb(30, 128, 0, 2),
		DescriptionKey = nameof(Strings.RangeAreaDescription)
	};

	private readonly ValueDataSeries _valueAreaBottom = new("ValueAreaBottom", "Value Area 2nd line") 
	{
		Color = System.Drawing.Color.Maroon.Convert(), 
		Width = 2,
        DescriptionKey = nameof(Strings.BottomChannelSettingsDescription)
    };

	private readonly ValueDataSeries _valueAreaTop = new("ValueAreaTop", "Value Area 1st line") 
	{ 
		Color = System.Drawing.Color.Maroon.Convert() ,
		Width = 2,
        DescriptionKey = nameof(Strings.TopChannelSettingsDescription)
    };

	private int _days;
	private decimal _filter;
	private int _lastAlertBar = -1;
	private decimal _lastApproximateLevel;
	private int _lastBar = -1;
	private int _lastCalculatedBar;

	private DrawingText _lastLabel;
	private int _lastPocAlert;

	private DateTime _lastTickTime;
	private DateTime _lastTime;
	private int _lastVahAlert;
	private int _lastValAlert;
	private decimal _lastValue;
	private Period _period = Period.Daily;
	private decimal _prevClose;

	private bool _showVolumes = true;
	private int _targetBar;
	private bool _tickBasedCalculation;

	private MiddleClusterType _type = MiddleClusterType.Volume;
	private VolumeVizualizationType _visualizationType = VolumeVizualizationType.Accumulated;
	private System.Drawing.Color _textColor = System.Drawing.Color.FromArgb(255, 75, 72, 72);

	#endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
    public int Days
	{
		get => _days;
		set
		{
			if (value < 0)
				return;

			_days = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Type), GroupName = nameof(Strings.Filters), Description = nameof(Strings.SourceTypeDescription), Order = 110)]
	public MiddleClusterType Type
	{
		get => _type;
		set
		{
			_type = value;
			_closedCandle.Type = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Filters), Description = nameof(Strings.PeriodTypeDescription), Order = 120)]
	public Period PeriodFrame
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MinimumFilterDescription), Order = 130)]
	public decimal Filter
	{
		get => _filter;
		set
		{
			_filter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolume), GroupName = nameof(Strings.Other), Description = nameof(Strings.ShowVolumesDescription), Order = 200)]
	public bool ShowVolumes
	{
		get => _showVolumes;
		set
		{
			_showVolumes = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VolumeVisualizationType), GroupName = nameof(Strings.Other), Description = nameof(Strings.CalculationModeDescription), Order = 210)]
	public VolumeVizualizationType VizualizationType
	{
		get => _visualizationType;
		set
		{
			_visualizationType = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ApproximationAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.IsApproximationAlertDescription), Order = 300)]
	public bool UseApproximationAlert { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ApproximationFilter), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.ApproximationFilterDescription), Order = 310)]
	public int ApproximationFilter { get; set; } = 3;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PocChangeAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UsePocChangeAlertDescription), Order = 320)]
	public bool UseAlerts { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PocAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UsePocTouchAlertDescription), Order = 330)]
	public bool UsePocTouchAlert { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ValAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseVALTouchAlertDescription), Order = 340)]
	public bool UseValTouchAlert { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VahAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseVAHTouchAlertDescription), Order = 350)]
	public bool UseVahTouchAlert { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 360)]
	public string AlertFile { get; set; } = "alert1";

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 370)]
	public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 380)]
	public CrossColor AlertBGColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LabelTextColorDescription), Order = 600)]
	public CrossColor TextColor 
	{
		get=> _textColor.Convert();
		set
		{
			_textColor = value.Convert();

			foreach (var key in Labels.Keys)
				Labels[key].Textcolor = _textColor;
		}
	} 

	#endregion

	#region ctor

	public DynamicLevels()
		: base(true)
	{
		DenyToChangePanel = true;

		_days = 20;

		_dynamicLevels = (ValueDataSeries)DataSeries[0];
		_dynamicLevels.VisualType = VisualMode.Square;
		_dynamicLevels.Color = System.Drawing.Color.Orange.Convert();
		_dynamicLevels.Width = 2;
        _dynamicLevels.Name = "Dynamic levels";
		_dynamicLevels.DescriptionKey = nameof(Strings.POCLineSettingsDescription);
		_dynamicLevels.ShowZeroValue = false;

        _dynamicLevels.PropertyChanged += LevelsSeriesPropertyChanged;

		DataSeries.Add(_valueArea);
		DataSeries.Add(_valueAreaTop);
		DataSeries.Add(_valueAreaBottom);
	}

    #endregion

    #region Protected methods

    protected override void OnInitialize()
    {
		DataSeries.ForEach(x =>
		{
			if (x is ValueDataSeries ds)
				ds.ShowZeroValue = false;
		});
    }

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    var downColor = ChartInfo.ColorsStore.DownCandleColor;

	    var seriesColor = CrossColor.FromArgb(
		    (byte)(downColor.A / 4 * 3),
		    (byte)(downColor.R / 4 * 3),
		    (byte)(downColor.G / 4 * 3),
		    (byte)(downColor.B / 4 * 3)).Convert();

	    _valueAreaTop.Color = _valueAreaBottom.Color = seriesColor.Convert();
        _valueArea.RangeColor = seriesColor.SetTransparency(0.9m).Convert();
    }

    protected override void OnRecalculate()
	{
		lock (_syncRoot)
		{
			_tickBasedCalculation = false;
			_lastCalculatedBar = -1;
			_lastBar = -1;
			_closedCandle.Clear();
			DataSeries.ForEach(x => x.Clear());
        }
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_lastPocAlert = 0;
			_lastValAlert = 0;
			_lastVahAlert = 0;
			_prevClose = GetCandle(CurrentBar - 1).Close;
			_lastTime = GetCandle(bar).Time;

			_targetBar = 0;

			if (_days > 0)
			{
				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}

				if (_targetBar > 0)
				{
					_dynamicLevels.SetPointOfEndLine(_targetBar - 1);
					_valueAreaTop.SetPointOfEndLine(_targetBar - 1);
					_valueAreaBottom.SetPointOfEndLine(_targetBar - 1);
				}
			}
		}

		if (bar < _targetBar)
			return;

		lock (_syncRoot)
		{
			if (_tickBasedCalculation)
				return;

			if (CheckUpdatePeriod(bar))
			{
				_closedCandle.Clear();
				_closedCandle.Type = Type;
			}

			var candle = GetCandle(bar);

			_lastTickTime = candle.LastTime;

			_closedCandle.AddCandle(candle, InstrumentInfo.TickSize);
			CalculateValues(bar);
		}
	}

	protected override void OnFinishRecalculate()
	{
		lock (_syncRoot)
			_tickBasedCalculation = true;
	}

	protected override void OnNewTrades(IEnumerable<MarketDataArg> trades)
	{
		if (ChartInfo is null)
			return;

		if (CurrentBar == 0)
			return;

		lock (_syncRoot)
		{
			if (!_tickBasedCalculation)
				return;

			var lastTime = GetCandle(_lastCalculatedBar).LastTime;

			foreach (var trade in trades)
			{
				try
				{
					if (trade.Time > lastTime)
					{
						CalculateValues(_lastCalculatedBar);

						if (_lastCalculatedBar < CurrentBar - 1)
						{
							_lastCalculatedBar++;
							lastTime = GetCandle(_lastCalculatedBar).LastTime;
						}
						else
						{
							this.LogError($"Last bar number is not exist C:{CurrentBar} L:{_lastCalculatedBar}");
#if DEBUG
							// if you are here please recall what you were doing
							// grab the local values of variables and
							// tell about this to @esper (telegram)
							Debugger.Break();
#else
								return;
#endif
						}
					}

					if (CheckUpdatePeriod(trade.Time))
					{
						_closedCandle.Clear();
						_closedCandle.Type = Type;
					}

					_closedCandle.AddTick(trade);

					_lastTickTime = trade.Time;
				}
				catch (Exception e)
				{
					this.LogError("Dynamic Levels error.", e);
				}
			}

			for (var i = _lastCalculatedBar; i <= CurrentBar - 1; i++)
			{
				if (!_tickBasedCalculation)
					return;

				CalculateValues(i);
			}
		}
	}

	#endregion

	#region Private methods

	private void LevelsSeriesPropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		if (e.PropertyName is not "Color")
			return;

		foreach (var (labelKey, labelValue) in Labels)
		{
			if (Labels[labelKey] is null)
				continue;

			Labels[labelKey].FillColor = ((ValueDataSeries)sender).Color.Convert();
		}
	}

	private void CalculateValues(int i)
	{
		_lastCalculatedBar = i;

		var maxPrice = _closedCandle.MaxValuePrice;
		var value = _closedCandle.MaxValue;
		var valueString = ChartInfo.TryGetMinimizedVolumeString(value);

		if (Type == MiddleClusterType.Delta)
			valueString = ChartInfo.TryGetMinimizedVolumeString(_closedCandle.TrueMaxValue);

		var validFilter = value >= Filter;

        _dynamicLevels[i] = validFilter ? maxPrice : 0;

		if(!validFilter)
			_dynamicLevels.SetPointOfEndLine(i - 1);

        if (i == 0)
		{
			var close = GetCandle(0).Close;
			this[0] = _valueAreaTop[0] = _valueAreaBottom[0] = close;

			_valueArea[0] = new RangeValue
				{ Lower = close, Upper = close };

			return;
		}

		var prevPrice = this[i - 1];

		if (prevPrice > 0.000001m && Math.Abs(prevPrice - maxPrice) > InstrumentInfo.TickSize / 2 && value > Filter)
		{
			if (ShowVolumes)
			{
				var cl = System.Drawing.Color.FromArgb(_dynamicLevels.Color.A, _dynamicLevels.Color.R, _dynamicLevels.Color.G, _dynamicLevels.Color.B);

				_lastLabel = AddText(i.ToString(CultureInfo.InvariantCulture),
					valueString, prevPrice < maxPrice,
					i, maxPrice, 0, 0, _textColor,
					System.Drawing.Color.Black, cl, 11, DrawingText.TextAlign.Left);
			}

			if (UseAlerts && i > _lastAlertBar && i == CurrentBar - 1)
			{
				_lastAlertBar = i;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Changed max level to {maxPrice}", AlertBGColor, AlertForeColor);
			}
		}
		else
		{
			if (ShowVolumes)
			{
				if (VizualizationType == VolumeVizualizationType.Accumulated)
				{
					if (_lastLabel != null && value != _lastValue)
					{
						_lastLabel.Text = ChartInfo.TryGetMinimizedVolumeString(value); 
						_lastValue = value;
					}
				}
			}
		}

		var va = _closedCandle.GetValueArea(InstrumentInfo.TickSize, PlatformSettings.ValueAreaPercent, PlatformSettings.ValueAreaStep, PlatformSettings.ValueAreaUpdateDelayMs, _tickBasedCalculation);

		_valueArea[i].Upper = va.Item1;
		_valueArea[i].Lower = va.Item2;
		_valueAreaTop[i] = va.Item1;
		_valueAreaBottom[i] = va.Item2;

		if (i != CurrentBar - 1)
			return;

		var candle = GetCandle(i);

		if (UseApproximationAlert)
		{
			if (maxPrice != _lastApproximateLevel && Math.Abs(candle.Close - maxPrice) / InstrumentInfo.TickSize <= ApproximationFilter)
			{
				_lastApproximateLevel = maxPrice;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Approximate to max Level {maxPrice}", AlertBGColor, AlertForeColor);
			}
		}

		if (UsePocTouchAlert && _lastPocAlert != i)
		{
			if ((candle.Close >= _dynamicLevels[i] && _prevClose < _dynamicLevels[i])
			    ||
			    (candle.Close <= _dynamicLevels[i] && _prevClose > _dynamicLevels[i]))
			{
                AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached POC level: {_dynamicLevels[i]}", AlertBGColor, AlertForeColor);

                _lastPocAlert = i;
            }
		}

		if (UseValTouchAlert && _lastValAlert != i)
		{
			if ((candle.Close >= _valueAreaBottom[i] && _prevClose < _valueAreaBottom[i])
			    ||
			    (candle.Close <= _valueAreaBottom[i] && _prevClose > _valueAreaBottom[i]))
			{
                AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached VAL level: {_valueAreaBottom[i]}", AlertBGColor, AlertForeColor);

                _lastValAlert = i;
            }
		}

		if (UseVahTouchAlert && _lastVahAlert != i)
		{
			if ((candle.Close >= _valueAreaTop[i] && _prevClose < _valueAreaTop[i])
			    ||
			    (candle.Close <= _valueAreaTop[i] && _prevClose > _valueAreaTop[i]))
			{
                AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached VAH level: {_valueAreaTop[i]}", AlertBGColor, AlertForeColor);

                _lastVahAlert = i;
            }
		}

		_prevClose = candle.Close;
	}

	private bool CheckUpdatePeriod(int i)
	{
		if (_lastBar == i)
			return false;

		_lastBar = i;

		if (i <= 0)
			return false;

		switch (PeriodFrame)
		{
			case Period.Daily when IsNewSession(i):
			case Period.Weekly when IsNewWeek(i):
			case Period.Monthly when IsNewMonth(i):
			case Period.Hourly when GetCandle(i).Time.Hour != GetCandle(i - 1).Time.Hour:
				return true;

			case Period.H4 when (GetCandle(i).Time - _lastTime).TotalHours >= 4:
				_lastTime = _lastTime.AddHours(4);
				return true;

			default:
				return false;
		}
	}

	private bool CheckUpdatePeriod(DateTime time)
	{
		switch (PeriodFrame)
		{
			case Period.Daily when DataProvider.IsNewSession(_lastTickTime, time):
			case Period.Weekly when DataProvider.IsNewSession(_lastTickTime, time):
			case Period.Monthly when DataProvider.IsNewMonth(_lastTickTime, time):
			case Period.Hourly when time.Hour != _lastTickTime.Hour:
				return true;

			case Period.H4 when (time - _lastTime).TotalHours >= 4:
				_lastTime = _lastTime.AddHours(4);
				return true;

			default:
				return false;
		}
	}

	#endregion
}










Technical/DynamicLevelsChannel.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;

    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering;

    [Category(IndicatorCategories.VolumeOrderFlow)]
    [DisplayName("Dynamic Levels Channel")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.DynamicLevelsChannelDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602381")]
    public class DynamicLevelsChannel : Indicator
    {
        #region Nested types

        private class VolumeInfo
        {
            #region Properties

            public decimal Price { get; set; }

            public int Bar { get; set; }

            public decimal Volume { get; set; }

            public decimal Bid { get; set; }

            public decimal Ask { get; set; }

            public int Time { get; set; }

            #endregion
        }

        private class Signal
        {
            #region Properties

            public TradeDirection Direction { get; set; }

            public decimal Price { get; set; }

            public decimal PocTicks { get; set; }

            #endregion
        }

        public enum CalculationMode
        {
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
            Volume,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PositiveDelta))]
            PosDelta,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.NegativeDelta))]
            NegDelta,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Delta))]
            Delta,

            [Browsable(false)]
            [Obsolete]
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Time))]
            Time
        }

        #endregion

        #region Static and constants

        private const decimal _percent = 70m;
        private const int _priceInterval = 2;

        #endregion

        #region Fields

        private readonly RangeDataSeries _areaSeries = new("AreaSeries", "Range");
        private readonly ValueDataSeries _buySeries = new("BuySeries", Strings.Buys)
        {
            DescriptionKey = Strings.BuySignalSettingsDescription
        };
        private readonly ValueDataSeries _sellSeries = new("SellSeries", Strings.Sells)
        {
            DescriptionKey = Strings.SellSignalSettingsDescription
        };

        private readonly ValueDataSeries _downSeries = new("DownSeries", "VAL")
        {
            DescriptionKey = Strings.VALLineSettingsDescription
        };

        private readonly ValueDataSeries _pocSeries = new("PocSeries", "POC")
        {
            DescriptionKey = Strings.POCLineSettingsDescription
        };

        private readonly ValueDataSeries _upSeries = new("UpSeries", "VAH")
        {
            DescriptionKey = Strings.VAHLineSettingsDescription
        };

        private readonly List<VolumeInfo> _priceInfo = new();
        private readonly List<Signal> _signals = new();
        private CalculationMode _calculationMode;
        private int _days;
        private int _lastBar;
        private decimal _lastVah;
        private decimal _lastVal;
        private decimal _lastVol;
        private decimal _maxPrice;
        private int _lastAlertBar;
        private decimal _lastApproximateLevel;
        private int _lastPocAlert;
        private int _lastVahAlert;
        private int _lastValAlert;
        private decimal _prevClose;

        private int _period;
        private int _targetBar;
        private decimal _tickSize;
        private List<VolumeInfo> _volumeGroup = new();

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SourceTypeDescription), Order = 100)]
        public CalculationMode CalcMode
        {
            get => _calculationMode;
            set
            {
                _calculationMode = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
        public int Period
        {
            get => _period;
            set
            {
                if (value <= 0)
                    return;

                _period = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        public int Days
        {
            get => _days;
            set
            {
                if (value < 0)
                    return;

                _days = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AreaColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.AreaColorDescription))]
        public CrossColor AreaColor
        {
            get => _areaSeries.RangeColor;
            set => _areaSeries.RangeColor = value;
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ApproximationAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.IsApproximationAlertDescription), Order = 300)]
        public bool UseApproximationAlert { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ApproximationFilter), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.ApproximationFilterDescription), Order = 310)]
        public int ApproximationFilter { get; set; } = 3;

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PocChangeAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UsePocChangeAlertDescription), Order = 320)]
        public bool UseAlerts { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PocAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UsePocTouchAlertDescription), Order = 330)]
        public bool UsePocTouchAlert { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ValAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseVALTouchAlertDescription), Order = 340)]
        public bool UseValTouchAlert { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VahAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseVAHTouchAlertDescription), Order = 350)]
        public bool UseVahTouchAlert { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 360)]
        public string AlertFile { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 370)]
        public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 380)]
        public CrossColor AlertBGColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

        #endregion

        #region ctor

        public DynamicLevelsChannel()
            : base(true)
        {
            DenyToChangePanel = true;

            _days = 20;
            _period = 40;
            _lastBar = -1;

            _areaSeries.RangeColor = CrossColor.FromArgb(100, 255, 100, 100);
            _areaSeries.IsHidden = true;
            DataSeries[0] = _areaSeries;
            _upSeries.ShowZeroValue = _downSeries.ShowZeroValue = _pocSeries.ShowZeroValue = false;
            _upSeries.Width = _downSeries.Width = _pocSeries.Width = 2;
            _pocSeries.Color = System.Drawing.Color.Aqua.Convert();

            _buySeries.VisualType = VisualMode.UpArrow;
            _buySeries.Color = System.Drawing.Color.Green.Convert();
            _sellSeries.VisualType = VisualMode.DownArrow;
            _sellSeries.Color = System.Drawing.Color.Red.Convert();
            _buySeries.ShowZeroValue = _sellSeries.ShowZeroValue = false;

            DataSeries.Add(_upSeries);
            DataSeries.Add(_downSeries);
            DataSeries.Add(_pocSeries);
            DataSeries.Add(_buySeries);
            DataSeries.Add(_sellSeries);
        }

        #endregion

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
            if (ChartInfo is null)
                return;

            var downCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
            _upSeries.Color = _downSeries.Color = _sellSeries.Color = downCandleColor;
            _buySeries.Color = ChartInfo.ColorsStore.UpCandleColor.Convert();
            _pocSeries.Color = ChartInfo.ColorsStore.DrawingObjectColor.Convert();

            _areaSeries.RangeColor = ChartInfo.ColorsStore.DownCandleColor.SetTransparency(0.9m).Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
        {
            if (bar == 0)
            {
                DataSeries.ForEach(x => x.Clear());
                _lastVah = 0;
                _lastVal = 0;
                _lastVol = 0;
                _tickSize = InstrumentInfo.TickSize;
                _priceInfo.Clear();
                _upSeries.SetPointOfEndLine(_period - 1);
                _downSeries.SetPointOfEndLine(_period - 1);
                _pocSeries.SetPointOfEndLine(_period - 1);
                _signals.Clear();

                _lastPocAlert = 0;
                _lastValAlert = 0;
                _lastVahAlert = 0;
                _lastAlertBar = 0;
                _prevClose = GetCandle(CurrentBar - 1).Close;

                _targetBar = 0;

                if (_days > 0)
                {
                    var days = 0;

                    for (var i = CurrentBar - 1; i >= 0; i--)
                    {
                        _targetBar = i;

                        if (!IsNewSession(i))
                            continue;

                        days++;

                        if (days == _days)
                            break;
                    }

                    if (_targetBar > 0)
                    {
                        _upSeries.SetPointOfEndLine(_targetBar - 1);
                        _downSeries.SetPointOfEndLine(_targetBar - 1);
                        _pocSeries.SetPointOfEndLine(_targetBar - 1);
                    }
                }

                return;
            }

            if (bar < _targetBar)
                return;

            var candle = GetCandle(bar - 1);

            if (bar == _lastBar)
                _priceInfo.RemoveAll(x => x.Bar == bar);

            for (var i = candle.Low; i <= candle.High; i += _tickSize)
            {
                var priceInfo = candle.GetPriceVolumeInfo(i);

                if (priceInfo != null)
                {
                    _priceInfo.Add(new VolumeInfo
                    {
                        Price = i,
                        Volume = priceInfo.Volume,
                        Bar = bar,
                        Ask = priceInfo.Ask,
                        Bid = priceInfo.Bid,
                        Time = priceInfo.Time
                    });
                }
            }

            _lastBar = bar;

            if (bar < _period)
                return;

            _priceInfo.RemoveAll(x => x.Bar == bar - Period);

            _volumeGroup = _priceInfo
                .GroupBy(x => x.Price)
                .Select(p => new VolumeInfo
                {
                    Price = p.First().Price,
                    Volume = p.Sum(v => v.Volume),
                    Time = p.Sum(t => t.Time),
                    Ask = p.Sum(a => a.Ask),
                    Bid = p.Sum(b => b.Bid)
                })
                .OrderByDescending(x => x.Volume)
                .ToList();

            var maxPriceInfo = _volumeGroup
                .FirstOrDefault();

            if (maxPriceInfo != null)
                _maxPrice = maxPriceInfo.Price;

            VolumeInfo pocValue;

            switch (_calculationMode)
            {
                case CalculationMode.Time:
                case CalculationMode.Volume:
                    _pocSeries[bar] = _maxPrice;
                    break;
                case CalculationMode.PosDelta:
                    pocValue = _volumeGroup
                        .OrderByDescending(x => x.Ask - x.Bid)
                        .FirstOrDefault();

                    if (pocValue != null && pocValue.Ask - pocValue.Bid > 0)
                        _pocSeries[bar] = pocValue.Price;
                    break;
                case CalculationMode.NegDelta:
                    pocValue = _volumeGroup
                        .OrderBy(x => x.Ask - x.Bid)
                        .FirstOrDefault();

                    if (pocValue != null && pocValue.Ask - pocValue.Bid < 0)
                        _pocSeries[bar] = pocValue.Price;
                    break;
                case CalculationMode.Delta:
                    pocValue = _volumeGroup
                        .OrderByDescending(x => Math.Abs(x.Ask - x.Bid))
                        .FirstOrDefault();

                    if (pocValue != null)
                        _pocSeries[bar] = pocValue.Price;
                    break;
            }

            GetArea();

            _areaSeries[bar] = new RangeValue
            { Lower = _lastVal, Upper = _lastVah };
            _upSeries[bar] = _lastVah;
            _downSeries[bar] = _lastVal;

            if (candle.High > _upSeries[bar] && candle.Low <= _upSeries[bar]
                ||
                candle.Low < _downSeries[bar] && candle.High >= _downSeries[bar])
            {
                var signal = new Signal
                {
                    Direction = Math.Abs(candle.High - _upSeries[bar]) < Math.Abs(candle.Low - _downSeries[bar])
                        ? TradeDirection.Buy
                        : TradeDirection.Sell
                };

                signal.Price = signal.Direction == TradeDirection.Buy
                    ? _upSeries[bar]
                    : _downSeries[bar];

                signal.PocTicks = Math.Abs(signal.Price - _pocSeries[bar]) / _tickSize;

                _signals.Add(signal);
            }

            if (candle.High > _upSeries[bar])
                _signals.RemoveAll(x => x.Direction == TradeDirection.Sell);

            if (candle.Low < _downSeries[bar])
                _signals.RemoveAll(x => x.Direction == TradeDirection.Buy);

            for (var i = _signals.Count - 1; i >= 0; i--)
            {
                var signal = _signals[i];

                if (signal.Direction == TradeDirection.Buy)
                {
                    if (Math.Abs(candle.High - _upSeries[bar]) / _tickSize >= signal.PocTicks && _buySeries[bar] == 0)
                    {
                        _buySeries[bar] = candle.Low - _tickSize * 2;
                        _signals.RemoveAt(i);
                    }
                }

                if (signal.Direction == TradeDirection.Sell)
                {
                    if (Math.Abs(_downSeries[bar] - candle.Low) / _tickSize >= signal.PocTicks && _sellSeries[bar] == 0)
                    {
                        _sellSeries[bar] = candle.High + _tickSize * 2;
                        _signals.RemoveAt(i);
                    }
                }
            }

            if (bar != CurrentBar - 1)
                return;

            var currentPocPrice = _pocSeries[bar];

            if (UseAlerts && bar > _lastAlertBar)
            {
                var prevPrice = _pocSeries[bar - 1];

                if (prevPrice > 0.000001m && Math.Abs(prevPrice - currentPocPrice) > _tickSize / 2)
                {
                    _lastAlertBar = bar;
                    AddAlert(AlertFile, InstrumentInfo.Instrument, $"Changed max level to {currentPocPrice}", AlertBGColor, AlertForeColor);
                }
            }

            if (UseApproximationAlert)
            {
                if (currentPocPrice != _lastApproximateLevel && Math.Abs(candle.Close - currentPocPrice) / _tickSize <= ApproximationFilter)
                {
                    _lastApproximateLevel = currentPocPrice;
                    AddAlert(AlertFile, InstrumentInfo.Instrument, $"Approximate to max Level {currentPocPrice}", AlertBGColor, AlertForeColor);
                }
            }

            if (UsePocTouchAlert && _lastPocAlert != bar)
            {
                if ((candle.Close >= currentPocPrice && _prevClose < currentPocPrice)
                    ||
                    (candle.Close <= currentPocPrice && _prevClose > currentPocPrice))
                {
                    AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached POC level: {currentPocPrice}", AlertBGColor, AlertForeColor);

                    _lastPocAlert = bar;
                }
            }

            if (UseValTouchAlert && _lastValAlert != bar)
            {
                if ((candle.Close >= _downSeries[bar] && _prevClose < _downSeries[bar])
                    ||
                    (candle.Close <= _downSeries[bar] && _prevClose > _downSeries[bar]))
                {
                    AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached VAL level: {_downSeries[bar]}", AlertBGColor, AlertForeColor);

                    _lastValAlert = bar;
                }
            }

            if (UseVahTouchAlert && _lastVahAlert != bar)
            {
                if ((candle.Close >= _upSeries[bar] && _prevClose < _upSeries[bar])
                    ||
                    (candle.Close <= _upSeries[bar] && _prevClose > _upSeries[bar]))
                {
                    AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached VAH level: {_upSeries[bar]}", AlertBGColor, AlertForeColor);

                    _lastVahAlert = bar;
                }
            }

            _prevClose = candle.Close;
        }

        #endregion

        #region Private methods

        private void GetArea()
        {
            var totalVolume = _volumeGroup.Sum(x => x.Volume);

            if (totalVolume == _lastVol || totalVolume == 0)
                return;

            var vah = 0m;
            var val = 0m;
            var high = _volumeGroup.Max(x => x.Price);
            var low = _volumeGroup.Min(x => x.Price);

            if (high != 0 && low != 0)
            {
                vah = val = _maxPrice;

                var vol = _volumeGroup
                    .Where(x => x.Price == _maxPrice)
                    .Sum(x => x.Volume);

                var valueAreaVolume = totalVolume * _percent * 0.01m;

                while (vol <= valueAreaVolume)
                {
                    if (vah >= high && val <= low)
                        break;

                    var upperVol = 0m;
                    var lowerVol = 0m;
                    var upperPrice = vah;
                    var lowerPrice = val;

                    for (var i = 0; i <= _priceInterval; i++)
                    {
                        if (high > upperPrice + _tickSize)
                        {
                            upperPrice += _tickSize;

                            upperVol += _volumeGroup
                                .Where(x => x.Price == upperPrice)
                                .Sum(x => x.Volume);
                        }

                        if (low > lowerPrice - _tickSize)
                            continue;

                        lowerPrice -= _tickSize;

                        lowerVol += _volumeGroup
                            .Where(x => x.Price == lowerPrice)
                            .Sum(x => x.Volume);
                    }

                    if (lowerVol == 0 && upperVol == 0)
                    {
                        vah = Math.Min(upperPrice, high);
                        val = Math.Max(lowerPrice, low);
                        break;
                    }

                    if (upperVol >= lowerVol)
                    {
                        vah = upperPrice;
                        vol += upperVol;
                    }
                    else
                    {
                        val = lowerPrice;
                        vol += lowerVol;
                    }

                    if (vol >= valueAreaVolume)
                        break;
                }
            }

            _lastVol = totalVolume;
            _lastVah = vah;
            _lastVal = val;
        }

        #endregion
    }
}








Technical/EMA.cs










namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("EMA")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.EMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602641")]
	public class EMA : Indicator
	{
		#region Fields

		private int _period = 10;
		private bool _onLine;
		private int _lastAlert;

		private ValueDataSeries _renderSeries = new("RenderSeries", "EMA");
		private System.Drawing.Color _bullishColor = DefaultColors.Green;
		private System.Drawing.Color _bearishColor = DefaultColors.Red;
		private bool _coloredDirection = true;

		#endregion

        #region Properties

        [Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		public int Period
		{
			get => _period;
			set
			{
				if (_period == value)
					return;

				if (value <= 0)
					return;

				_period = value;

				RaisePropertyChanged(nameof(Period));
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColoredDirection), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColoredDirectionDescription), Order = 200)]
		[Range(1, 10000)]
		public bool ColoredDirection
		{
			get => _coloredDirection;
			set
			{
				_coloredDirection = value;

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription), Order = 210)]
		public CrossColor BullishColor
		{
			get => _bullishColor.Convert();
			set
			{
				_bullishColor = value.Convert();
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription), Order = 220)]
		public CrossColor BearishColor
		{
			get => _bearishColor.Convert();
			set
			{
				_bearishColor = value.Convert();
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.UseAlertsDescription),
            Order = 100)]
		public bool UseAlerts { get; set; }
		
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 110)]
		[Range(0, 100000)]
		public bool RepeatAlert { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 120)]
		[Range(0, 100000)]
		public int AlertSensitivity { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.AlertFileDescription),
            Order = 130)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 140)]
		public CrossColor FontColor { get; set; } = System.Drawing.Color.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 150)]
		public CrossColor BackgroundColor { get; set; } = System.Drawing.Color.DimGray.Convert();

		#endregion

		#region ctor

		public EMA()
		{
            DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = bar == 0
				? value
				: value * (2.0m / (1 + Period)) + (1 - 2.0m / (1 + Period)) * _renderSeries[bar - 1];

			if (ColoredDirection && bar != 0)
			{
				_renderSeries.Colors[bar] = _renderSeries[bar] > _renderSeries[bar - 1]
					? _bullishColor
					: _bearishColor;
			}

            if (bar != CurrentBar - 1 || !UseAlerts)
				return;

			if (_lastAlert == bar && !RepeatAlert)
				return;

			var close = GetCandle(bar).Close;
			var onLine = Math.Abs(_renderSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivity;
			
            if (onLine && !_onLine)
			{
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"EMA approximation alert: {_renderSeries[bar]:0.#####}", BackgroundColor, FontColor);
				_lastAlert = bar;
			}

			_onLine = onLine;
		}

		#endregion
	}
}








Technical/EMV.cs








namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Arms Ease of Movement")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.EMVDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602315")]
public class EMV : Indicator
{
	#region Nested types

	public enum MovingType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA))]
		Ema,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LinearReg))]
		LinReg,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA))]
		Wma,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA))]
		Sma,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMMA))]
		Smma
	}

	#endregion

	#region Fields

	private readonly ValueDataSeries _renderSeries = new("RenderSeries", "ADXR");

	private object _movingIndicator;
	private MovingType _movingType = MovingType.Ema;

	private int _period = 9;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MovingType), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MovingTypeDescription), Order = 100)]
	public MovingType MaType
	{
		get => _movingType;
		set
		{
			_movingType = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
	[Range(1, 10000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public EMV()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DataSeries[0] = _renderSeries;
	}

	#endregion

	#region Protected methods

	protected override void OnRecalculate()
	{
		_movingIndicator = _movingType switch
		{
			MovingType.Ema => new EMA { Period = _period },
			MovingType.LinReg => new LinearReg { Period = _period },
			MovingType.Wma => new WMA { Period = _period },
			MovingType.Sma => new SMA { Period = _period },
			MovingType.Smma => new SMMA { Period = _period },
			_ => _movingIndicator
		};
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			IndicatorCalculate(bar, _movingType, 0);
			return;
		}

		var candle = GetCandle(bar);
		var prevCandle = GetCandle(bar - 1);
		var midPoint = (candle.High + candle.Low) / 2m - (prevCandle.High + prevCandle.Low) / 2m;
		var ratio = candle.High - candle.Low == 0 ? 0 : candle.Volume / (candle.High - candle.Low);
		var emv = ratio == 0 ? 0 : midPoint / ratio;
		_renderSeries[bar] = IndicatorCalculate(bar, _movingType, emv);
	}

	#endregion

	#region Private methods

	private decimal IndicatorCalculate(int bar, MovingType type, decimal value)
	{
		var movingValue = type switch
		{
			MovingType.Ema => ((EMA)_movingIndicator).Calculate(bar, value),
			MovingType.LinReg => ((LinearReg)_movingIndicator).Calculate(bar, value),
			MovingType.Wma => ((WMA)_movingIndicator).Calculate(bar, value),
			MovingType.Sma => ((SMA)_movingIndicator).Calculate(bar, value),
			MovingType.Smma => ((SMMA)_movingIndicator).Calculate(bar, value),
			_ => 0m
		};

		return movingValue;
	}

	#endregion
}









Technical/ElderRay.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Elder Ray")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ElderRayDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602580")]
	public class ElderRay : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _bearSeries = new("BearSeries", Strings.Bearlish)
		{
			DescriptionKey=nameof(Strings.BearishMovementSettingsDescription)
		};

		private readonly ValueDataSeries _bullSeries = new("BullSeries", Strings.Bullish) 
		{ 
			Color = DefaultColors.Green.Convert(),
            DescriptionKey = nameof(Strings.BullishMovementSettingsDescription)
        };

		private readonly EMA _ema = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ElderRay()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _bullSeries;
			DataSeries.Add(_bearSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_ema.Calculate(bar, candle.Close);
			_bullSeries[bar] = candle.High - _ema[bar];
			_bearSeries[bar] = candle.Low - _ema[bar];
		}

		#endregion
	}
}







Indicators/Technical
/Ergodic.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Ergodic")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ErgodicDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602382")]
	public class Ergodic : Indicator
	{
		#region Fields

		private readonly EMA _emaLong = new() { Period = 20 };
		private readonly EMA _emaLongAbs = new() { Period = 20 };

		private readonly EMA _emaShort = new() { Period = 5 };
		private readonly EMA _emaShortAbs = new() { Period = 5 };
		private readonly EMA _emaSignal = new() { Period = 5 };

        private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int ShortPeriod
		{
			get => _emaShort.Period;
			set
			{
				_emaShort.Period = _emaShortAbs.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _emaLong.Period;
			set
			{
				_emaLong.Period = _emaLongAbs.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SignalPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SignalPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int SignalPeriod
		{
			get => _emaSignal.Period;
			set
			{
				_emaSignal.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Ergodic()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var diff = value - (decimal)SourceDataSeries[bar - 1];

			_emaLong.Calculate(bar, diff);
			_emaLongAbs.Calculate(bar, Math.Abs(diff));

			_emaShort.Calculate(bar, _emaLong[bar]);
			_emaShortAbs.Calculate(bar, _emaLongAbs[bar]);

			var tsi = _emaShort[bar] / _emaShortAbs[bar];

			_emaSignal.Calculate(bar, tsi);

			_renderSeries[bar] = tsi - _emaSignal[bar];
		}

		#endregion
	}
}









Technical/Exhaustion.cs








namespace ATAS.Indicators.Technical;

using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using Utils.Common.Collections;

using FilterColor2 = ATAS.Indicators.FilterColor;

[Category(IndicatorCategories.VolumeOrderFlow)]
[DisplayName("Exhaustion")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ExhaustionIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000641184-exhaustion")]
public class Exhaustion : Indicator
{
    #region Nested types

    public enum CalcModes
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
        Bid,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
        Ask,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidAndAsk))]
        BidAndAsk,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
        Volume
    }

    #endregion

    #region Fields
    private const string _indicatorName = "Exhaustion";
    private readonly PriceSelectionDataSeries _topSelection = new("TopSelection ", "Top");
    private readonly PriceSelectionDataSeries _bottomSelection = new("BottomSelection", "Bottom");

    private int _lastBar = -1;
    private decimal _step;
    private bool _toAlert;
    private string _alertMessage = string.Empty;
    private bool _alerted;

    private CalcModes _calcMode = CalcModes.BidAndAsk;
    private int _amoutOfPrices = 5;
    private bool _useAlerts;
    private FilterString _alertFile;
    private FilterBool _onBarCloseAlert;

    private ObjectType _visualType = ObjectType.Rectangle;
    private CrossColor _topColor = DefaultColors.Maroon.Convert();
    private FilterColor2 _topClusterColor;
    private CrossColor _bottomColor = DefaultColors.Lime.Convert();
    private FilterColor2 _bottomClusterColor;
    private bool _showPriceSelection = true;
    private int _size = 10;
    private int _visualObjectsTransparency = 70;

    #endregion

    #region Properties

    #region Settings

    [Parameter]
    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.CalculationMode), Description = nameof(Strings.CalculationModeDescription))]
    public CalcModes CalcMode
    {
        get => _calcMode;
        set
        {
            _calcMode = value;
            RecalculateValues();
        }
    }

    [Parameter]
    [Range(2, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.DepthLevelsCount), Description = nameof(Strings.PriceLevelsCountDescription))]
    public int AmoutOfPrices 
    { 
        get => _amoutOfPrices;
        set
        {
            _amoutOfPrices = value;
            RecalculateValues();
        }
    }

    #endregion

    #region Visualization

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.VisualMode), Description = nameof(Strings.VisualModeDescription))]
    public ObjectType VisualType
    {
        get => _visualType;
        set
        {
            _visualType = value;
            
            ForAllPriceSelectionValuesAction(_topSelection, (x) => x.VisualObject = value);
            ForAllPriceSelectionValuesAction(_bottomSelection, (x) => x.VisualObject = value);
        }
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.ShowPriceSelection), Description = nameof(Strings.ShowPriceSelectionDescription))]
    public bool ShowPriceSelection
    {
        get => _showPriceSelection;
        set
        {
            _showPriceSelection = value;
            TopClusterColor.SetEnabled(value);
            BottomClusterColor.SetEnabled(value);

            SetDataSeriesPriceSelectionColor(_topClusterColor?.Value ?? CrossColors.Transparent, _topSelection, value);
            SetDataSeriesPriceSelectionColor(_bottomClusterColor?.Value ?? CrossColors.Transparent, _bottomSelection, value);
        }
    }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Size), Description = nameof(Strings.SizeDescription))]
    public int Size
    {
        get => _size;
        set
        {
            _size = value;

            ForAllPriceSelectionValuesAction(_topSelection, (x) => x.Size = value);
            ForAllPriceSelectionValuesAction(_bottomSelection, (x) => x.Size = value);
        }
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.VisualObjectsTransparency), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    [Range(0, 100)]
    public int VisualObjectsTransparency
    {
        get => _visualObjectsTransparency;
        set
        {
            _visualObjectsTransparency = value;

            SetDataSeriesObjectColor(_topColor, value, _topSelection);
            SetDataSeriesObjectColor(_bottomColor, value, _bottomSelection);
        }
    }

    #endregion

    #region ResistanceLevel

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ResistanceLevel), Name = nameof(Strings.ObjectsColor), Description = nameof(Strings.VisualObjectsDescription))]
    public CrossColor TopColor
    {
        get => _topColor;
        set
        {
            _topColor = value;

            SetDataSeriesObjectColor(value, _visualObjectsTransparency, _topSelection);
        }
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.ResistanceLevel), Name = nameof(Strings.PriceSelectionColor), Description = nameof(Strings.PriceSelectionColorDescription))]
    public FilterColor2 TopClusterColor
    {
        get => _topClusterColor;
        set => SetTrackedProperty(ref _topClusterColor, value, (_) =>
        {
            SetDataSeriesPriceSelectionColor(value.Value, _topSelection);
            RedrawChart();
        });
    }

    #endregion

    #region SupportLevel

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.SupportLevel), Name = nameof(Strings.ObjectsColor), Description = nameof(Strings.VisualObjectsDescription))]
    public CrossColor BottomColor
    {
        get => _bottomColor;
        set
        {
            _bottomColor = value;

            SetDataSeriesObjectColor(value, _visualObjectsTransparency, _bottomSelection);
        }
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.SupportLevel), Name = nameof(Strings.PriceSelectionColor), Description = nameof(Strings.PriceSelectionColorDescription))]
    public FilterColor2 BottomClusterColor
    {
        get => _bottomClusterColor;
        set => SetTrackedProperty(ref _bottomClusterColor, value, (_) =>
        {
            SetDataSeriesPriceSelectionColor(value.Value, _bottomSelection);
            RedrawChart();
        });
    }

    #endregion

    #region Alerts

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Alerts), Name = nameof(Strings.UseAlert), Description = nameof(Strings.UseAlertDescription))]
    public bool UseAlerts 
    { 
        get => _useAlerts; 
        set
        {
            _useAlerts = value;
            AlertFile.SetEnabled(value);
            OnBarCloseAlert.SetEnabled(value);
        }
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Alerts), Name = nameof(Strings.AlertFile), Description = nameof(Strings.AlertFileDescription))]
    public FilterString AlertFile 
    { 
        get => _alertFile;
        set => SetProperty(ref _alertFile, value);
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Alerts), Name = nameof(Strings.OnBarClose), Description = nameof(Strings.OnBarCloseDescription))]
    public FilterBool OnBarCloseAlert
    { 
        get => _onBarCloseAlert;
        set => SetProperty(ref _onBarCloseAlert, value);
    }

    #endregion

    #endregion

    #region ctor

    public Exhaustion() : base(true)
    {
        DenyToChangePanel = true;
        _topSelection.IsHidden = true;
        _bottomSelection.IsHidden = true;

        DataSeries[0] = _topSelection;
        DataSeries.Add(_bottomSelection);

        AlertFile = new (false) { Value = "alert1" };
        OnBarCloseAlert = new (false) { Value = true };
        TopClusterColor = new(false) { Value = DefaultColors.Red.Convert() };
        BottomClusterColor = new(false) { Value = DefaultColors.Green.Convert() };
    }

    #endregion

    #region Protected methods

    protected override void OnInitialize()
    {
        AlertFile.SetEnabled(UseAlerts);
        OnBarCloseAlert.SetEnabled(UseAlerts);
        TopClusterColor.SetEnabled(ShowPriceSelection);
        BottomClusterColor.SetEnabled(ShowPriceSelection);
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (bar != _lastBar) 
        {
            if (bar == 0)
                _step = ChartInfo.PriceChartContainer.Step;
            else if (bar == CurrentBar - 1 && UseAlerts)
            {
                if (_toAlert)
                    AddAlert(AlertFile.Value, _alertMessage);

                _alerted = false;
            }
        }

        if (bar == CurrentBar - 1)
        {
            _topSelection[bar].Clear();
            _bottomSelection[bar].Clear();
            _toAlert = false;
            _alertMessage = string.Empty;
        }

        switch (CalcMode)
        {
            case CalcModes.Bid:
                CalcFromLow(bar, CalcModes.Bid, "Bids", SelectionType.Bid);               

                break;
            case CalcModes.Ask:
                CalcFromHigh(bar, CalcModes.Ask, "Asks", SelectionType.Ask);

                break;
            case CalcModes.BidAndAsk:
                CalcFromLow(bar, CalcModes.Bid, "Bids", SelectionType.Bid);
                CalcFromHigh(bar, CalcModes.Ask, "Asks", SelectionType.Ask);

                break;
            case CalcModes.Volume:
                CalcFromLow(bar, CalcModes.Volume, "Lots", SelectionType.Full);
                CalcFromHigh(bar, CalcModes.Volume, "Lots", SelectionType.Full);

                break;
        }

        _lastBar = bar;
    }

    #endregion

    #region Private methods

    private void CalcFromHigh
    (
        int bar,
        CalcModes sourceType,
        string sourceMode,
        SelectionType selectionType
    )
    {
        var candle = GetCandle(bar);
        var pvInfos = new List<(decimal, decimal)>();
        var prevSourceValue = 0m;
        var count = 0;

        for (decimal i = candle.High; i >= candle.Low; i -= _step)
        {
            var info = candle.GetPriceVolumeInfo(i);
            count++;

            if (count > _amoutOfPrices)
                break;

            if (info is null)
                return;

            var sourceValue = GetSourceValue(sourceType, info);

            if (i == candle.High)
            {
                prevSourceValue = sourceValue;
                pvInfos.Add((info.Price, sourceValue));
                continue;
            }

            if (sourceValue > prevSourceValue)
            {
                pvInfos.Add((info.Price, sourceValue));
                prevSourceValue = sourceValue;
            }
            else
                break;
        }

        if (pvInfos.Count != _amoutOfPrices)
            return;

        var newPriceSelection = GetNewPriceSelection(pvInfos, selectionType, _topColor, _topClusterColor.Value, sourceMode);
        _topSelection[bar].AddRange(newPriceSelection);

        AddClusterAlert(bar, newPriceSelection);
    }

    private void CalcFromLow
    (
        int bar, 
        CalcModes sourceType,
        string sourceMode,
        SelectionType selectionType
    )
    {
        var candle = GetCandle(bar);
        var pvInfos = new List<(decimal, decimal)>();
        var prevSourceValue = 0m;
        var count = 0;

        for (decimal i = candle.Low; i <= candle.High; i += _step)
        {
            var info = candle.GetPriceVolumeInfo(i);
            count++;

            if (count > _amoutOfPrices)
                break;

            if (info is null)
                return;

            var sourceValue = GetSourceValue(sourceType, info);

            if (i == candle.Low)
            {
                prevSourceValue = sourceValue;
                pvInfos.Add((info.Price, sourceValue));
                continue;
            }

            if (sourceValue > prevSourceValue)
            {
                pvInfos.Add((info.Price, sourceValue));
                prevSourceValue = sourceValue;
            }
            else
                break;
        }

        if (pvInfos.Count != _amoutOfPrices)
            return;

        pvInfos.Reverse();
        var newPriceSelection = GetNewPriceSelection(pvInfos, selectionType, _bottomColor, _bottomClusterColor.Value, sourceMode);
        _bottomSelection[bar].AddRange(newPriceSelection);

        AddClusterAlert(bar, newPriceSelection);      
    }

    private void AddClusterAlert(int bar, PriceSelectionValue[] newPriceSelection)
    {
        if (!UseAlerts || bar != CurrentBar - 1 || _alerted)
            return;

        var alertMessage = string.Join(Environment.NewLine, newPriceSelection.Select(ps => ps.Tooltip));

        if (!OnBarCloseAlert.Value)
        {
            AddAlert(AlertFile.Value, alertMessage);
            _alerted = true;
        }
        else
        {
            _toAlert = true;
            _alertMessage += $"{alertMessage}{Environment.NewLine}";
        }
    }

    private decimal GetSourceValue(CalcModes sourceType, PriceVolumeInfo info)
    {
        return sourceType switch
        {
            CalcModes.Bid => info.Bid,
            CalcModes.Ask => info.Ask,
            _ => info.Volume,
        };
    }

    private PriceSelectionValue[] GetNewPriceSelection(List<(decimal, decimal)> pvInfos, SelectionType selectionType, CrossColor objectColor, CrossColor clusterColor, string sourceMode)
    {
        var result = new PriceSelectionValue[pvInfos.Count];

        for (int i = 0; i < pvInfos.Count; i++)
        {
            var indName = i == 0 ? $"{_indicatorName}{Environment.NewLine}" : string.Empty;
            var volume = pvInfos[i].Item2;
            var tooltip = $"{ChartInfo.TryGetMinimizedVolumeString(volume)} {sourceMode}";

            result[i] = new PriceSelectionValue(pvInfos[i].Item1)
            {
                VisualObject = VisualType,
                Size = Size,
                SelectionSide = selectionType,
                ObjectColor = objectColor,
                ObjectsTransparency = _visualObjectsTransparency,
                PriceSelectionColor = ShowPriceSelection ? clusterColor : CrossColors.Transparent,
                Tooltip = $"{indName}{tooltip}",
                Context = volume,
                MinimumPrice = pvInfos.Select(e => e.Item1).Min(),
                MaximumPrice = pvInfos.Select(e => e.Item1).Max()
            };
        }

        return result;
    }

    private void ForAllPriceSelectionValuesAction(PriceSelectionDataSeries dataSeries, Action<PriceSelectionValue> action)
    {
        for (var i = 0; i < dataSeries.Count; i++)
        {
            dataSeries[i].ForEach(action);
        }
    }

    private void SetDataSeriesObjectColor(CrossColor color, int transparency, PriceSelectionDataSeries dataSeries)
    {
        for (var i = 0; i < dataSeries.Count; i++)
            dataSeries[i].ForEach(x =>
            {
                x.ObjectColor = color;
                x.ObjectsTransparency = transparency;
            });
    }

    private void SetDataSeriesPriceSelectionColor(CrossColor color, PriceSelectionDataSeries dataSeries, bool showPriceSelection = true)
    {
        ForAllPriceSelectionValuesAction(dataSeries, (x) =>
        {
            x.PriceSelectionColor = showPriceSelection ? color : CrossColors.Transparent;
        });
    }

    #endregion
}








Technical/ExternalCharts.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

using Color = System.Drawing.Color;

[DisplayName("External Chart")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ExternalChartsDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602383")]
public class ExternalCharts : Indicator
{
	#region Nested types

	public class RectangleInfo
	{
		#region Properties

		public decimal ClosePrice { get; set; }

		public int FirstPos { get; set; }

		public decimal Low { get; set; }

		public decimal OpenPrice { get; set; }

		public int SecondPos { get; set; }

		public decimal High { get; set; }

		#endregion
	}

	public enum TimeFrameScale
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.M1))]
		M1 = 1,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.M5))]
		M5 = 5,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.M10))]
		M10 = 10,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.M15))]
		M15 = 15,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.M30))]
		M30 = 30,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Hourly))]
		Hourly = 60,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.H2))]
		H2 = 120,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.H4))]
		H4 = 240,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.H6))]
		H6 = 360,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Daily))]
		Daily = 1440,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Weekly))]
		Weekly = 10080,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Monthly))]
		Monthly = 0
	}

	#endregion

	#region Static and constants

	private static readonly Dictionary<TimeFrameScale, TimeSpan> _periodTimeSpans = new()
	{
		{ TimeFrameScale.M1, TimeSpan.FromMinutes(1) },
		{ TimeFrameScale.M5, TimeSpan.FromMinutes(5) },
		{ TimeFrameScale.M10, TimeSpan.FromMinutes(10) },
		{ TimeFrameScale.M15, TimeSpan.FromMinutes(15) },
		{ TimeFrameScale.M30, TimeSpan.FromMinutes(30) },
		{ TimeFrameScale.Hourly, TimeSpan.FromHours(1) },
		{ TimeFrameScale.H2, TimeSpan.FromHours(2) },
		{ TimeFrameScale.H4, TimeSpan.FromHours(4) },
		{ TimeFrameScale.H6, TimeSpan.FromHours(6) }
	};

	#endregion

	#region Fields

	private readonly object _locker = new();
	private readonly List<RectangleInfo> _rectangles = new();
	private int _avgWidth;

	private DateTime _barStartTime;
	private int _days = 20;
	private CrossColor _downColor = DefaultColors.Red.Convert();
	private RenderPen _downPen = new(DefaultColors.Red, 1);
	private CrossColor _gridColor = CrossColor.FromArgb(50, 128, 128, 128);
	private RenderPen _gridPen = new(Color.FromArgb(50, 128, 128, 128), 1);
	private int _lastBar = -1;
	private DashStyle _style = DashStyle.Solid;
	private int _targetBar;
	private TimeFrameScale _tFrame = TimeFrameScale.Hourly;

	private CrossColor _upColor = Color.RoyalBlue.Convert();
	private RenderPen _upPen = new(Color.RoyalBlue, 1);
	private int _width = 1;

	#endregion

	#region Properties

	private bool IsSessionTframe => TFrame is TimeFrameScale.Daily or TimeFrameScale.Weekly or TimeFrameScale.Monthly;

	//Old property
	[Browsable(false)]
	public CrossColor AreaColor { get; set; }

	[Range(0, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue,
		Description = nameof(Strings.DaysLookBackDescription))]
	public int Days
	{
		get => _days;
		set
		{
			_days = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowGrid), GroupName = nameof(Strings.Grid),
		Description = nameof(Strings.DisplayClusterBorderDescription), Order = 7)]
	public bool ShowGrid { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Grid),
		Description = nameof(Strings.GridColorDescription), Order = 8)]
	public CrossColor GridColor
	{
		get => _gridColor;
		set
		{
			_gridColor = value;
			_gridPen = new RenderPen(value.Convert(), 1);
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowAsCandle), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.ShowAsCandleDescription), Order = 9)]
	public bool ExtCandleMode { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BullishColorDescription), Order = 30)]
	public CrossColor UpCandleColor
	{
		get => _upColor;
		set
		{
			_upColor = value;
			_upPen = new RenderPen(value.Convert(), Width, Style.To());
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BearishColorDescription), Order = 40)]
	public CrossColor DownCandleColor
	{
		get => _downColor;
		set
		{
			_downColor = value;
			_downPen = new RenderPen(value.Convert(), Width, Style.To());
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackgroundBullish), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BullishFillColorDescription), Order = 45)]
	public Color UpBackground { get; set; } = Color.FromArgb(100, Color.LightSkyBlue);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackgroundBearlish), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BearishFillColorDescription), Order = 47)]
	public Color DownBackground { get; set; } = Color.FromArgb(100, Color.DarkRed);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BorderWidthPixelDescription), Order = 50)]
	[Range(1, 100)]
	public int Width
	{
		get => _width;
		set
		{
			_width = value;
			_upPen = new RenderPen(UpCandleColor.Convert(), value, Style.To());
			_downPen = new RenderPen(DownCandleColor.Convert(), value, Style.To());
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.DashStyle), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.BorderStyleDescription), Order = 60)]
	public LineDashStyle Style
	{
		get => _style.To();
		set
		{
			_style = value.To();

			_upPen = new RenderPen(UpCandleColor.Convert(), Width, value.To());
			_downPen = new RenderPen(DownCandleColor.Convert(), Width, value.To());
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FillCandles), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.IsNeedFillDescription), Order = 65)]
	public bool FillCandles { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowAboveChart), GroupName = nameof(Strings.Visualization),
		Description = nameof(Strings.DrawAbovePriceDescription), Order = 70)]
	public bool Above
	{
		get => DrawAbovePrice;
		set
		{
			DrawAbovePrice = value;
			RedrawChart();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ExternalPeriod), GroupName = nameof(Strings.TimeFrame),
		Description = nameof(Strings.SelectTimeframeDescription), Order = 5)]
	public TimeFrameScale TFrame
	{
		get => _tFrame;
		set
		{
			_tFrame = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public ExternalCharts()
		: base(true)
	{
		DrawAbovePrice = true;
		DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.LatestBar | DrawingLayouts.Historical);

		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (DataProvider is null)
			return;

		lock (_locker)
		{
			var candle = GetCandle(bar);

			if (bar == 0)
			{
				_rectangles.Clear();
				_targetBar = 0;

				if (_days > 0)
				{
					var days = 0;

					for (var i = CurrentBar - 1; i >= 0; i--)
					{
						_targetBar = i;

						if (!IsNewSession(i))
							continue;

						days++;

						if (days == _days)
							break;
					}
				}
			}

			if (bar < _targetBar)
				return;

			if (bar == _targetBar)
			{
				if (!IsSessionTframe)
					_barStartTime = DataProvider.GetCustomStartTime(candle.Time, _periodTimeSpans[TFrame]);

				AddRect(bar);
				return;
			}

			if (IsSessionTframe)
			{
				if ((TFrame is TimeFrameScale.Daily && IsNewSession(bar))
				    ||
				    (TFrame is TimeFrameScale.Weekly && IsNewWeek(bar))
				    ||
				    (TFrame is TimeFrameScale.Monthly && IsNewMonth(bar))
				    ||
				    bar == _targetBar)
					AddRect(bar);
				else
					UpdateLastRect(bar);
			}
			else
			{
				if (bar == _lastBar)
				{
					UpdateLastRect(bar);
					return;
				}

				if (_barStartTime != DataProvider.GetCustomStartTime(candle.Time, _periodTimeSpans[TFrame]))
				{
					_barStartTime = DataProvider.GetCustomStartTime(candle.Time, _periodTimeSpans[TFrame]);
					AddRect(bar);
				}
				else
					UpdateLastRect(bar);

				_lastBar = bar;
			}
		}
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo is null || InstrumentInfo is null)
			return;

		if (ChartInfo.PriceChartContainer.TotalBars == ChartInfo.PriceChartContainer.LastVisibleBarNumber)
		{
			if (layout != DrawingLayouts.LatestBar)
				return;
		}
		else
		{
			if (layout != DrawingLayouts.Historical)
				return;
		}

		lock (_locker)
		{
			var chartType = ChartInfo.ChartVisualMode;
			var useShift = chartType is ChartVisualModes.Clusters or ChartVisualModes.Line;

			for (var r = _rectangles.Count - 1; r >= 0; r--)
			{
				var rect = _rectangles[r];

				if (rect.FirstPos > ChartInfo.PriceChartContainer.LastVisibleBarNumber)
					continue;

				if (rect.SecondPos < ChartInfo.PriceChartContainer.FirstVisibleBarNumber)
					break;

				var x1 = ChartInfo.GetXByBar(rect.FirstPos);
				var x2 = ChartInfo.GetXByBar(rect.SecondPos + 1);

				if (r == _rectangles.Count - 1)
				{
					var rightX = x1 + (int)(_avgWidth * (ChartInfo.PriceChartContainer.BarSpacing + ChartInfo.PriceChartContainer.BarsWidth));
					x2 = Math.Max(rightX, x2);
				}

				var yBot = ChartInfo.GetYByPrice(rect.Low - (useShift ? InstrumentInfo.TickSize : 0), useShift);
				var yTop = ChartInfo.GetYByPrice(rect.High, useShift);

				if (ShowGrid && chartType == ChartVisualModes.Clusters)
				{
					for (var i = rect.Low - InstrumentInfo.TickSize; i <= rect.High; i += InstrumentInfo.TickSize)
					{
						var y = ChartInfo.GetYByPrice(i);
						context.DrawLine(_gridPen, x1, y, x2, y);
					}

					for (var i = rect.FirstPos; i <= rect.SecondPos + 1; i++)
					{
						var x = ChartInfo.GetXByBar(i);
						context.DrawLine(_gridPen, x, yBot, x, yTop);
					}
				}

				var bearish = rect.OpenPrice > rect.ClosePrice;

				var renderPen = bearish
					? _downPen
					: _upPen;

				var renderRectangle = new Rectangle(x1, yTop, x2 - x1, yBot - yTop);

				if (ExtCandleMode)
				{
					var y1 = ChartInfo.GetYByPrice(Math.Min(rect.OpenPrice, rect.ClosePrice), false);
					var y2 = ChartInfo.GetYByPrice(Math.Max(rect.OpenPrice, rect.ClosePrice), false);
					renderRectangle = new Rectangle(x1, y2, x2 - x1, y1 - y2);

					var midX = (x2 + x1) / 2;
					context.DrawLine(renderPen, midX, y2, midX, yTop);
					context.DrawLine(renderPen, midX, y1, midX, yBot);
				}

				if (FillCandles)
					context.FillRectangle(bearish ? DownBackground : UpBackground, renderRectangle);

				context.DrawRectangle(renderPen, renderRectangle);
			}
		}
	}

	#endregion

	#region Private methods

	private void UpdateLastRect(int bar)
	{
		var candle = GetCandle(bar);

		_rectangles[^1].ClosePrice = candle.Close;
		_rectangles[^1].SecondPos = bar;

		if (_rectangles[^1].High < candle.High)
			_rectangles[^1].High = candle.High;

		if (_rectangles[^1].Low > candle.Low)
			_rectangles[^1].Low = candle.Low;
	}

	private void AddRect(int bar)
	{
		var candle = GetCandle(bar);

		if (_rectangles.Count is not 0)
		{
			_avgWidth = 1 + (int)_rectangles
				.TakeLast(20)
				.Average(r => r.SecondPos - r.FirstPos);
		}

		_rectangles.Add(new RectangleInfo
		{
			FirstPos = bar,
			SecondPos = bar,
			Low = candle.Low,
			High = candle.High,
			OpenPrice = candle.Open,
			ClosePrice = candle.Close
		});
	}

	#endregion
}










Technical/FCV.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Full Contract Value")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.FCVDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602389")]
	public class FCV : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
        private decimal _multiplier;

		#endregion

		#region Properties

		[ReadOnly(true)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TickSize), GroupName = nameof(Strings.Settings), Description = nameof(Strings.TickSizeDescription), Order = 100)]
        public decimal CurrentTickSize { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomTickSize), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CustomTickSizeDescription), Order = 110)]
		[Range(0.000000001, 1000000000)]
		public Filter CustomTickFilter { get; set; } = new Filter() { Value = 1 };

        [Browsable(false)]
		public bool CustomScale
		{
			get => CustomTickFilter.Enabled;
			set => CustomTickFilter.Enabled = value;
        }

        [Browsable(false)]
		[Range(0.000000001, 1000000000)]
		public decimal Multiplier
		{
			get => CustomTickFilter.Value;
			set => CustomTickFilter.Value = value;
        }

		#endregion

		#region ctor

		public FCV()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
        }

        #endregion

        #region Protected methods

        protected override void OnInitialize()
        {
			CustomTickFilter.PropertyChanged += (o, _) =>
			{
				_multiplier = ((Filter)o).Value;

                RecalculateValues();
				RedrawChart();
            };

			CurrentTickSize = InstrumentInfo.TickSize;
			_multiplier = CustomTickFilter.Value;
        }

        protected override void OnCalculate(int bar, decimal value)
		{
            if (bar == 0 && !CustomTickFilter.Enabled)
                _multiplier = InstrumentInfo.TickSize;

			_renderSeries[bar] = value * Math.Max(InstrumentInfo.TickSize, _multiplier) / InstrumentInfo.TickSize;
        }

        #endregion
    }
}









Technical/FairValueGap.cs









namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;
using System.Text.RegularExpressions;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using Color = System.Drawing.Color;

[DisplayName("Fair Value Gap")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.FairValueGapDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618795")]
public class FairValueGap : Indicator
{
    #region Nested Types

    public enum TimeFrameScale
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M1))]
        M1 = 1,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M5))]
        M5 = 5,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M10))]
        M10 = 10,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M15))]
        M15 = 15,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M30))]
        M30 = 30,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Hourly))]
        Hourly = 60,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H2))]
        H2 = 120,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H4))]
        H4 = 240,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H6))]
        H6 = 360,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Daily))]
        Daily = 1440,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Weekly))]
        Weekly = 10080,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Monthly))]
        Monthly = 0
    }

    internal class TFPeriod
    {
        private int _startBar;
        private int _endBar;
        private decimal _open;
        private decimal _high = decimal.MinValue;
        private decimal _low = decimal.MaxValue;
        private decimal _close;
        private decimal _volume;
        private decimal _curBarVolume;
        private int _highBar;
        private int _lowBar;
        private int _lastBar = -1;

        internal int StartBar => _startBar;
        internal int EndBar => _endBar;
        internal decimal Open => _open;
        internal decimal High => _high;
        internal decimal Low => _low;
        internal decimal Close => _close;
        internal decimal Volume => _volume + _curBarVolume;
        internal int HighBar => _highBar;
        internal int LowBar => _lowBar;

        internal TFPeriod(int bar, IndicatorCandle candle)
        {
            _startBar = bar;
            _open = candle.Open;
            AddCandle(bar, candle);
        }

        internal void AddCandle(int bar, IndicatorCandle candle)
        {
            if (candle.High > _high)
            {
                _high = candle.High;
                _highBar = bar;
            }

            if (candle.Low < _low)
            {
                _low = candle.Low;
                _lowBar = bar;
            }

            _close = candle.Close;
            _endBar = bar;

            if (bar != _lastBar)
                _volume += _curBarVolume;

            _curBarVolume = candle.Volume;

            _lastBar = bar;
        }
    }

    internal class Signal
    {
        private decimal _high;
        private decimal _low;

        internal int StartBar { get; set; }
        internal int EndBar { get; set; }
        internal decimal HighPrice { get; set; }
        internal decimal LowPrice { get; set; }
        internal decimal FirstHighPrice => _high;
        internal decimal FirstLowPrice => _low;
        internal decimal MidPrice => (_high + _low) / 2;

        internal Signal(decimal high, decimal low)
        {
            _high = high;
            _low = low;
        }
    }

    internal class TimeFrameObj
    {
        private readonly List<TFPeriod> _periods = new();
        private readonly TimeFrameScale _timeFrame;
        private readonly int _secondsPerTframe;
        private readonly Func<int, bool> IsNewSession;
        private readonly Func<int, bool> IsNewWeek;
        private readonly Func<int, bool> IsNewMonth;
        private readonly Func<int, IndicatorCandle> GetCandle;

        internal readonly List<Signal> _upperSignals = new();
        internal readonly List<Signal> _lowerSignals = new();
        private bool _isNewPeriod;

        internal TFPeriod this[int index]
        {
            get => _periods[Count - 1 - index];
            set => _periods[Count - 1 - index] = value;
        }

        internal int Count => _periods.Count;
        internal bool IsNewPeriod => _isNewPeriod;
        internal int SecondsPerTframe => _secondsPerTframe;

        internal TimeFrameObj(TimeFrameScale timeFrame,
                            Func<int, bool> isNewSession,
                            Func<int, bool> isNewWeek,
                            Func<int, bool> isNewMonth,
                            Func<int, IndicatorCandle> getCandle)
        {
            _timeFrame = timeFrame;
            _secondsPerTframe = 60 * (int)timeFrame;
            IsNewSession = isNewSession;
            IsNewWeek = isNewWeek;
            IsNewMonth = isNewMonth;
            GetCandle = getCandle;
        }

        internal void AddBar(int bar)
        {
            _isNewPeriod = false;
            var candle = GetCandle(bar);

            if (bar == 0)
                CreateNewPeriod(bar, candle);

            var beginTime = GetBeginTime(candle.Time, _timeFrame);
            var isNewBar = false;
            var isCustomPeriod = false;
            var endBar = _periods.Last().EndBar;

            if (_timeFrame == TimeFrameScale.Weekly)
            {
                isCustomPeriod = true;
                isNewBar = IsNewWeek(bar);
            }
            else if (_timeFrame == TimeFrameScale.Monthly)
            {
                isCustomPeriod = true;
                isNewBar = IsNewMonth(bar);
            }
            else if (_timeFrame == TimeFrameScale.Daily)
            {
                isCustomPeriod = true;
                isNewBar = IsNewSession(bar);
            }

            if (isNewBar || !isCustomPeriod && (beginTime >= GetCandle(endBar).LastTime))
            {
                if (!_periods.Exists(p => p.StartBar == bar))
                    CreateNewPeriod(bar, candle);
            }
            else
                _periods.Last().AddCandle(bar, candle);
        }

        private void CreateNewPeriod(int bar, IndicatorCandle candle)
        {
            _periods.Add(new TFPeriod(bar, candle));
            _isNewPeriod = true;
        }

        private DateTime GetBeginTime(DateTime time, TimeFrameScale period)
        {
            if (period == TimeFrameScale.Monthly)
                return new DateTime(time.Year, time.Month, 1);

            var tim = time;
            tim = tim.AddMilliseconds(-tim.Millisecond);
            tim = tim.AddSeconds(-tim.Second);

            var begin = (tim - new DateTime()).TotalMinutes % (int)period;
            var res = tim.AddMinutes(-begin);
            return res;
        }
    }

    #endregion

    #region Fields

    internal readonly List<Signal> _upperSignals = new();
    internal readonly List<Signal> _lowerSignals = new();

    private bool _isFixedTimeFrame;
    private int _secondsPerCandle;
    private TimeFrameObj _higherTfObj;
    private FontSetting _labelFont = new() { FontFamily = "Arial", Size = 10 };
    private PenSettings _bullishCurrentTfPen = new() { Color = DefaultColors.Green.Convert() };
    private PenSettings _bearishCurrentTfPen = new() { Color = DefaultColors.Red.Convert() };
    private PenSettings _bullishHigherTfPen = new() { Color = DefaultColors.Olive.Convert() };
    private PenSettings _bearishHigherTfPen = new() { Color = DefaultColors.Purple.Convert() };
    private PenSettings _midpointPen = new() { Color = DefaultColors.Gray.Convert() };
    private Color _bullishColorCurrentTFTransp;
    private Color _bearishColorCurrentTFTransp;
    private Color _bullishColorHigherTFTransp;
    private Color _bearishColorHigherTFTransp;

    private TimeFrameScale _timeframe;
    private bool _midpointTouch;
    private int _transparency = 5;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFrame), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SelectTimeframeDescription))]
    public TimeFrameScale HigherTimeframe 
    { 
        get => _timeframe;
        set
        {
            _timeframe = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MidpointTouch), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowMidlineDescription))]
    public bool MidpointTouch 
    { 
        get => _midpointTouch; 
        set
        {
            _midpointTouch = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideOlds), GroupName = nameof(Strings.Settings), Description = nameof(Strings.HideOldsElementsDescription))]
    public bool HideOlds { get; set; }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.Settings), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int Transparency
    { 
        get => _transparency;
        set
        {
            _transparency = value;
            _bullishColorCurrentTFTransp = GetColorTransparency(_bullishCurrentTfPen.Color.Convert(), _transparency);
            _bearishColorCurrentTFTransp = GetColorTransparency(_bearishCurrentTfPen.Color.Convert(), _transparency);
            _bullishColorHigherTFTransp = GetColorTransparency(_bullishHigherTfPen.Color.Convert(), _transparency);
            _bearishColorHigherTFTransp = GetColorTransparency(_bearishHigherTfPen.Color.Convert(), _transparency);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.CurrentTimeFrame), Description = nameof(Strings.ShowGapsDescription))]
    public bool ShowCurrentTF{ get; set; } = true;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.CurrentTimeFrame), Description = nameof(Strings.BullishColorDescription))]
    public Color BullishColorCurrentTF 
    {
        get => _bullishCurrentTfPen.Color.Convert();
        set
        {
            _bullishCurrentTfPen.Color = value.Convert();
            _bullishColorCurrentTFTransp = GetColorTransparency(_bullishCurrentTfPen.Color.Convert(), _transparency);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.CurrentTimeFrame), Description = nameof(Strings.BearishColorDescription))]
    public Color BearishColorCurrentTF 
    {
        get => _bearishCurrentTfPen.Color.Convert();
        set
        {
            _bearishCurrentTfPen.Color = value.Convert();
            _bearishColorCurrentTFTransp = GetColorTransparency(_bearishCurrentTfPen.Color.Convert(), _transparency);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.HigherTimeFrame), Description = nameof(Strings.ShowGapsDescription))]
    public bool ShowHigherTF { get; set; } = true;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.HigherTimeFrame), Description = nameof(Strings.BullishColorDescription))]
    public Color BullishColorHigherTF 
    { 
        get => _bullishHigherTfPen.Color.Convert();
        set
        {
            _bullishHigherTfPen.Color = value.Convert();
            _bullishColorHigherTFTransp = GetColorTransparency(_bullishHigherTfPen.Color.Convert(), _transparency);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.HigherTimeFrame), Description = nameof(Strings.BearishColorDescription))]
    public Color BearishColorHigherTF 
    { 
        get => _bearishHigherTfPen.Color.Convert(); 
        set
        {
            _bearishHigherTfPen.Color = value.Convert();
            _bearishColorHigherTFTransp = GetColorTransparency(_bearishHigherTfPen.Color.Convert(), _transparency);
        }
    }

    [Range(1, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Midpoint), Description = nameof(Strings.LineWidthDescription))]
    public int MidPointWidth 
    { 
        get => _midpointPen.Width; 
        set => _midpointPen.Width = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Midpoint), Description = nameof(Strings.LineColorDescription))]
    public Color MidPointColor
    { 
        get => _midpointPen.Color.Convert();
        set => _midpointPen.Color = value.Convert();
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Label), Description = nameof(Strings.IsNeedShowLabelDescription))]
    public bool ShowLabel { get; set; } = true;

    [Range(1, 50)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Size), GroupName = nameof(Strings.Label), Description = nameof(Strings.TextSizeDescription))]
    public int LabelSize 
    {
        get => _labelFont.Size;
        set => _labelFont.Size = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Label), Description = nameof(Strings.LabelTextColorDescription))]
    public Color LabelColor { get; set; } = DefaultColors.Gray;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetX), GroupName = nameof(Strings.Label), Description = nameof(Strings.LabelOffsetXDescription))]
    public int LabelOffsetX { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetY), GroupName = nameof(Strings.Label), Description = nameof(Strings.LabelOffsetYDescription))]
    public int LabelOffsetY { get; set; } = 10;

    #endregion

    #region ctor

    public FairValueGap() : base(true)
    {

        DenyToChangePanel = true;
        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
        EnableCustomDrawing = true;
        SubscribeToDrawingEvents(DrawingLayouts.Final);

        _bullishColorCurrentTFTransp = GetColorTransparency(_bullishCurrentTfPen.Color.Convert(), _transparency);
        _bearishColorCurrentTFTransp = GetColorTransparency(_bearishCurrentTfPen.Color.Convert(), _transparency);
        _bullishColorHigherTFTransp = GetColorTransparency(_bullishHigherTfPen.Color.Convert(), _transparency);
        _bearishColorHigherTFTransp = GetColorTransparency(_bearishHigherTfPen.Color.Convert(), _transparency);
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        GetCandleSeconds();
        _higherTfObj = new(HigherTimeframe, IsNewSession, IsNewWeek, IsNewMonth, GetCandle);
        _upperSignals.Clear();
        _lowerSignals.Clear();
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        var currentCandle = GetCandle(bar);

        if (_isFixedTimeFrame)
        {
            HigherTfCalculate(bar);
            TryCloseGaps(bar, currentCandle, _higherTfObj._upperSignals, _higherTfObj._lowerSignals);
        }

        CurrentTfCalculate(bar, currentCandle);
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
        if (ChartInfo is null) return;

        if (ShowCurrentTF)
        {
            DrawGaps(context, _upperSignals, ChartInfo.TimeFrame, _bullishColorCurrentTFTransp, _bullishCurrentTfPen);
            DrawGaps(context, _lowerSignals, ChartInfo.TimeFrame, _bearishColorCurrentTFTransp, _bearishCurrentTfPen);
        }

        if (ShowHigherTF)
        {
            DrawGaps(context, _higherTfObj._upperSignals, HigherTimeframe.ToString(), _bullishColorHigherTFTransp, _bullishHigherTfPen);
            DrawGaps(context, _higherTfObj._lowerSignals, HigherTimeframe.ToString(), _bearishColorHigherTFTransp, _bearishHigherTfPen);
        }
    }

    #endregion

    #region Private Methods

    private void DrawGaps(RenderContext context, List<Signal> gaps, string timeFrame, Color color, PenSettings penSet)
    {
        var signals = gaps.Where(s => s.StartBar <= LastVisibleBarNumber && s.EndBar == 0 || s.EndBar >= FirstVisibleBarNumber).ToList();

        foreach (var signal in signals)
        {
            if (HideOlds && signal.EndBar > 0)
                continue;

            var x = ChartInfo.GetXByBar(signal.StartBar);
            var x2 = signal.EndBar > 0 ? ChartInfo.GetXByBar(signal.EndBar) : ChartInfo.Region.Width;
            var y = ChartInfo.GetYByPrice(signal.HighPrice, false);
            var w = x2 - x;
            var h = ChartInfo.GetYByPrice(signal.LowPrice, false) - y;
            var rec = new Rectangle(x, y, w, h);
            context.DrawFillRectangle(penSet.RenderObject, color, rec);

            if (_midpointTouch)
            {
                var isBodyEven = (signal.FirstHighPrice - signal.FirstLowPrice) / InstrumentInfo.TickSize % 2 == 0;
                var midPriceRound = RoundToFraction(signal.MidPrice, InstrumentInfo.TickSize);
                var midPrice = signal.MidPrice < midPriceRound
                   ? midPriceRound - InstrumentInfo.TickSize
                   : midPriceRound;

                var y2 = ChartInfo.GetYByPrice(midPrice, !isBodyEven);
                context.DrawLine(_midpointPen.RenderObject, x, y2, x2, y2);
            }

            if (ShowLabel)
            {
                var text = $"{timeFrame} FVG";
                var labelSize = context.MeasureString(text, _labelFont.RenderObject);
                var lX = x + ChartInfo.PriceChartContainer.BarsWidth * LabelOffsetX;
                var lY = y + ChartInfo.PriceChartContainer.PriceRowHeight * LabelOffsetY;
                var lRec = new Rectangle((int)lX, (int)lY, labelSize.Width, labelSize.Height);
                context.DrawString(text, _labelFont.RenderObject, LabelColor, lRec);
            }
        }
    }

    private Color GetColorTransparency(Color color, int tr = 5) => Color.FromArgb((byte)(tr * 25), color.R, color.G, color.B);

    private void CurrentTfCalculate(int bar, IndicatorCandle currentCandle)
    {
        if (bar < 2) return;

        var candle1 = GetCandle(bar - 2);

        if (candle1.High < currentCandle.Low)
            CreateNewGap(_upperSignals, bar, currentCandle.Low, candle1.High);
        else
            _upperSignals.RemoveAll(s => s.StartBar == bar);


        if (candle1.Low > currentCandle.High)
            CreateNewGap(_lowerSignals, bar, candle1.Low, currentCandle.High);
        else
            _lowerSignals.RemoveAll(s => s.StartBar == bar);

        TryCloseGaps(bar, currentCandle, _upperSignals, _lowerSignals);
    }

    private void TryCloseGaps(int bar, IndicatorCandle candle, List<Signal> upperSignals, List<Signal> lowerSignals)
    {
        foreach (var signal in upperSignals)
        {
            if (signal.EndBar > 0 || candle.Low >= signal.HighPrice)
                continue;

            var triggerPrice = _midpointTouch ? signal.MidPrice : signal.LowPrice;

            if (candle.Low <= triggerPrice)
            {
                signal.EndBar = bar;

                if (candle.Low > signal.LowPrice)
                    signal.HighPrice = candle.Low;
            }
            else
                signal.HighPrice = candle.Low;
        }

        foreach (var signal in lowerSignals)
        {
            if (signal.EndBar > 0 || candle.High <= signal.LowPrice)
                continue;

            var triggerPrice = _midpointTouch ? signal.MidPrice : signal.HighPrice;

            if (candle.High >= triggerPrice)
            {
                signal.EndBar = bar;

                if (candle.High < signal.HighPrice)
                    signal.LowPrice = candle.High;
            }
            else
                signal.LowPrice = candle.High;
        }
    }

    private void HigherTfCalculate(int bar)
    {
        if (_secondsPerCandle > _higherTfObj.SecondsPerTframe) return;

        _higherTfObj.AddBar(bar);

        if (!_higherTfObj.IsNewPeriod || _higherTfObj.Count < 3) return;

        if (_higherTfObj[2].High < _higherTfObj[0].Low)
            CreateNewGap(_higherTfObj._upperSignals, bar, _higherTfObj[0].Low, _higherTfObj[2].High);
        else if (_higherTfObj[2].Low > _higherTfObj[0].High)
            CreateNewGap(_higherTfObj._lowerSignals, bar, _higherTfObj[2].Low, _higherTfObj[0].High);
    }

    private void CreateNewGap(List<Signal> signals, int bar, decimal top, decimal bottom)
    {
        var signal = signals.FirstOrDefault(s => s.StartBar == bar);

        if (signal is not null)
        {
            signal.HighPrice = top;
            signal.LowPrice = bottom;
        }
        else
        {
            signal = new Signal(top, bottom)
            {
                StartBar = bar,
                HighPrice = top,
                LowPrice = bottom,
            };

            signals.Add(signal);
        }
    }

    private void GetCandleSeconds()
    {
        if (ChartInfo is null) return;

        var timeFrame = ChartInfo.TimeFrame;

        if (ChartInfo.ChartType == "Seconds")
        {
            _isFixedTimeFrame = true;

            _secondsPerCandle = ChartInfo.TimeFrame switch
            {
                "5" => 5,
                "10" => 10,
                "15" => 15,
                "30" => 30,
                _ => 0
            };

            if (_secondsPerCandle == 0)
            {
                if (int.TryParse(Regex.Match(timeFrame, @"\d{1,}$").Value, out var periodSec))
                {
                    _secondsPerCandle = periodSec;
                    return;
                }
            }
        }

        if (ChartInfo.ChartType != "TimeFrame")
            return;

        _isFixedTimeFrame = true;

        _secondsPerCandle = ChartInfo.TimeFrame switch
        {
            "M1" => 60 * (int)TimeFrameScale.M1,
            "M5" => 60 * (int)TimeFrameScale.M5,
            "M10" => 60 * (int)TimeFrameScale.M10,
            "M15" => 60 * (int)TimeFrameScale.M15,
            "M30" => 60 * (int)TimeFrameScale.M30,
            "Hourly" => 60 * (int)TimeFrameScale.Hourly,
            "H2" => 60 * (int)TimeFrameScale.H2,
            "H4" => 60 * (int)TimeFrameScale.H4,
            "H6" => 60 * (int)TimeFrameScale.H6,
            "Daily" => 60 * (int)TimeFrameScale.Daily,
            "Weekly" => 60 * (int)TimeFrameScale.Weekly,
            _ => 0
        };

        if (_secondsPerCandle != 0)
            return;

        if (!int.TryParse(Regex.Match(timeFrame, @"\d{1,}$").Value, out var period))
            return;

        if (timeFrame.Contains('M'))
        {
            _secondsPerCandle = 60 * (int)TimeFrameScale.M1 * period;
            return;
        }

        if (timeFrame.Contains('H'))
        {
            _secondsPerCandle = 60 * (int)TimeFrameScale.Daily * period;
            return;
        }

        if (timeFrame.Contains('D'))
            _secondsPerCandle = 60 * (int)TimeFrameScale.Daily * period;
    }
    private decimal RoundToFraction(decimal value, decimal fraction) => Math.Round(value / fraction) * fraction;

    #endregion
}









Technical/FisherTransform.cs








namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Fisher Transform")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.FisherTransformDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602385")]
public class FisherTransform : Indicator
{
	#region Fields

	private readonly ValueDataSeries _fisher = new("FisherId", "Fisher")
	{
		DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
	};

    private readonly ValueDataSeries _triggers = new("TriggersId", "Triggers")
	{
		Color = System.Drawing.Color.DodgerBlue.Convert(),
        DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
    };

	private readonly ValueDataSeries _values = new("Values");

    private readonly Highest _highest = new() { Period = 10 };
	private readonly decimal _lastBar = -1;
	private readonly Lowest _lowest = new() { Period = 10 };

	private decimal _lastFisher;
	private decimal _lastValue;

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Common), Description = nameof(Strings.PeriodDescription))]
	[Range(1, 10000)]
	public int Period
	{
		get => _highest.Period;
		set
		{
			_highest.Period = value;
			_lowest.Period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public FisherTransform()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = _triggers;
		DataSeries.Add(_fisher);
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar <= Period)
			return;

		if (bar != _lastBar && bar > 0)
		{
			_lastValue = _values[bar - 1];
			_lastFisher = _fisher[bar - 1];
		}

		var candle = GetCandle(bar);

		var sMax = _highest.Calculate(bar, candle.High);
		var sMin = _lowest.Calculate(bar, candle.Close);

		if (sMax == sMin)
			sMax += ChartInfo.PriceChartContainer.Step;

		var wpr = (candle.Close - sMin) / (sMax - sMin);

		var valueSeries = 0.66m * (wpr - 0.5m) + 0.67m * _lastValue;

		if (valueSeries is >= 1 or <= -1)
			valueSeries = Math.Sign(valueSeries) * 0.999m;

		var fisherSeries = 0.5 * Math.Log((1.0 + Convert.ToDouble(valueSeries)) / (1.0 - Convert.ToDouble(valueSeries))) +
			0.5 * Convert.ToDouble(_lastFisher);

		_values[bar] = valueSeries;
		_fisher[bar] = Convert.ToDecimal(fisherSeries);
		_triggers[bar] = _lastFisher;
	}

	#endregion
}









Indicators/Technical
/FisherTransformInverse.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Inverse Fisher Transform")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.FisherTransformInverseDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602407")]
	public class FisherTransformInverse : Indicator
	{
		#region Fields

		private readonly Highest _highest = new() { Period = 10 };
		private readonly Lowest _lowest = new() { Period = 10 };

		private readonly ValueDataSeries _ift = new("Ift", Strings.Indicator)
		{
			DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
		};

		private readonly ValueDataSeries _iftSmoothed = new("IftSmoothed", Strings.SMA)
		{
			Color = DefaultColors.Green.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.SmaSetingsDescription)
        };
		
		private readonly SMA _sma = new();
		private readonly WMA _wma = new();

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow), GroupName = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription), Order = 90)]
		[Range(1, 10000)]
		public int HighLowPeriod
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA), GroupName = nameof(Strings.Period), Description = nameof(Strings.WMAPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int WmaPeriod
		{
			get => _wma.Period;
			set
			{
				_wma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA), GroupName = nameof(Strings.Period), Description = nameof(Strings.SMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int SmaPeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public FisherTransformInverse()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _ift;
			DataSeries.Add(_iftSmoothed);
		}

		#endregion

		#region Protected methods

		#region Overrides of BaseIndicator

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		#endregion

		protected override void OnCalculate(int bar, decimal value)
		{
			var high = _highest.Calculate(bar, value);
			var low = _lowest.Calculate(bar, value);
			var eps = 0m;

			if (high != low)
				eps = 10m * (value - low) / (high - low) - 5;

			var epsSmoothed = _wma.Calculate(bar, eps);

			_ift[bar] = 0m;

			if (bar > 0)
			{
				if (high != low)
				{
					var expEps = (decimal)Math.Exp(Convert.ToDouble(2 * epsSmoothed));
					_ift[bar] = (expEps - 1) / (expEps + 1);
				}
				else
					_ift[bar] = _ift[bar - 1];
			}

			_iftSmoothed[bar] = _sma.Calculate(bar, _ift[bar]);
		}

		#endregion
	}
}










Technical/FisherTransformInverseRsi.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Inverse Fisher Transform with RSI")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.FisherTransformInverseRsiDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602408")]
	public class FisherTransformInverseRsi : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _ift = new("Ift", Strings.Visualization);

		private readonly RSI _rsi = new() { Period = 10 };
		private readonly WMA _wma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RSI), GroupName = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription), Order = 90)]
		[Range(1, 10000)]
		public int HighLowPeriod
		{
			get => _rsi.Period;
			set
			{
				_rsi.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA), GroupName = nameof(Strings.Period), Description = nameof(Strings.WMAPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int WmaPeriod
		{
			get => _wma.Period;
			set
			{
				_wma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public FisherTransformInverseRsi()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _ift;
		}

		#endregion

		#region Protected methods

		#region Overrides of BaseIndicator

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		#endregion

		protected override void OnCalculate(int bar, decimal value)
		{
			var rsiValue = (_rsi.Calculate(bar, value) - 50) / 10;
			var rsiSmoothed = _wma.Calculate(bar, rsiValue);

			var expValue = (decimal)Math.Exp((double)(2 * rsiSmoothed));

			_ift[bar] = (expValue - 1) / (expValue + 1);
		}

		#endregion
	}
}










Technical/ForceIndex.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Force Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ForceIndexDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602387")]
	public class ForceIndex : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 10 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private bool _useEma;

		#endregion

		#region Properties

		[Range(1, 10000)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMAPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription), Order = 10)]
		public FilterInt PeriodFilter { get; set; } = new();

		[Browsable(false)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseMA), GroupName = nameof(Strings.Settings), Order = 100)]
		public bool UseEma
		{
			get => _useEma;
			set
			{
				_useEma = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Browsable(false)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.Settings), Order = 110)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ForceIndex()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
			PeriodFilter.Value = _ema.Period;
        }

        #endregion

        #region Protected methods

        protected override void OnInitialize()
        {
			PeriodFilter.PropertyChanged += (o, e) =>
			{
                if (o is not FilterInt filter)
                    return;

                switch (e.PropertyName)
				{
					case nameof(filter.Enabled):
                        UseEma = filter.Enabled;
                        break;
                    case nameof(filter.Value):
                        Period = filter.Value;
                        break;
                }

				RedrawChart();
            };
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			_ema.Calculate(bar, 0);

			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var force = candle.Volume * (candle.Close - prevCandle.Close);
			
			_renderSeries[bar] = _useEma 
				? _ema.Calculate(bar, force)
				: force;
		}

		#endregion
	}
}










Technical/Fractals.cs








namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context.GDIPlus;
    using OFT.Rendering.Settings;

    using Utils.Common.Collections;

    using Pen = System.Drawing.Pen;

    [DisplayName("Fractals")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.FractalsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602388")]
	public class Fractals : Indicator
	{
		#region Nested types

		public enum ShowMode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.High))]
			High,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low))]
			Low,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
			All,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.None))]
			None
		}

		#endregion

		#region Fields

		private readonly ValueDataSeries _fractalDown = new("FractalDown", "Fractal Down")
		{
			VisualType = VisualMode.Dots,
			ShowZeroValue = false,
			Width = 5
		};

		private readonly ValueDataSeries _fractalUp = new("FractalUp", "Fractal Up")
		{
			Color = System.Drawing.Color.LimeGreen.Convert(),
			VisualType = VisualMode.Dots,
			ShowZeroValue = false,
			Width = 5
		};

		private Pen _highPen;
		private Pen _lowPen;
		private ShowMode _mode = ShowMode.All;
        private bool _showLine;
		private decimal _tickSize;
		private int _lastBar;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Line), Description = nameof(Strings.IsNeedShowLinesDescription), Order = 100)]
		public bool ShowLine
		{
			get => _showLine;
			set
			{
				_showLine = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.High), GroupName = nameof(Strings.Line), Description = nameof(Strings.PenSettingsDescription), Order = 110)]
		public PenSettings HighPen { get; set; } = new() { Color = System.Drawing.Color.LimeGreen.Convert() };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low), GroupName = nameof(Strings.Line), Description = nameof(Strings.PenSettingsDescription), Order = 120)]
		public PenSettings LowPen { get; set; } = new() { Color = DefaultColors.Red.Convert() };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualMode), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualModeDescription), Order = 200)]
		public ShowMode Mode
		{
			get => _mode;
			set
			{
				_mode = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Fractals()
			: base(true)
		{
			DenyToChangePanel = true;
			_highPen = HighPen.RenderObject.ToPen();
			_lowPen = LowPen.RenderObject.ToPen();

			HighPen.PropertyChanged += HighPenChanged;
			LowPen.PropertyChanged += LowPenChanged;

			DataSeries[0] = _fractalUp;
			DataSeries.Add(_fractalDown);
		}

		#endregion
		
		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_tickSize = ChartInfo.PriceChartContainer.Step;
				DataSeries.ForEach(x => x.Clear());
				HorizontalLinesTillTouch.Clear();
			}

			if (Mode is ShowMode.None)
				return;

			if (bar < 4)
				return;

			var isNewBar = _lastBar != bar;
			_lastBar = bar;

			var fractalBar = bar - 2;

			var bar0 = GetCandle(bar);
			var bar1 = GetCandle(bar - 1);
			var bar2 = GetCandle(bar - 2);
			var bar3 = GetCandle(bar - 3);
			var bar4 = GetCandle(bar - 4);

			if (bar2.High > bar4.High &&
			    bar2.High > bar3.High &&
			    bar2.High > bar1.High &&
			    bar2.High > bar0.High &&
			    Mode is ShowMode.High or ShowMode.All)
			{
				_fractalUp[fractalBar] = bar2.High + 3 * _tickSize;

				if (ShowLine)
				{
					var line = new LineTillTouch(fractalBar, bar2.High, _highPen) { Context = true };

					if (!isNewBar && IsCurrentLine(fractalBar, true))
					{
						HorizontalLinesTillTouch[^1] = line;
					}
					else
					{
						HorizontalLinesTillTouch.Add(line);
					}
				}
			}
			else
			{
				_fractalUp[fractalBar] = 0;

				if (ShowLine && !isNewBar)
				{
					if (IsCurrentLine(fractalBar, true))
						HorizontalLinesTillTouch.RemoveAt(HorizontalLinesTillTouch.Count - 1);
				}
			}

			if (bar2.Low < bar4.Low &&
			    bar2.Low < bar3.Low &&
			    bar2.Low < bar1.Low &&
			    bar2.Low < bar0.Low &&
			    Mode is ShowMode.Low or ShowMode.All)
			{
				_fractalDown[fractalBar] = bar2.Low - 3 * _tickSize;

				if (ShowLine)
				{
					var line = new LineTillTouch(fractalBar, bar2.Low, _lowPen) { Context = false };

					if (!isNewBar && IsCurrentLine(fractalBar, false))
					{
						HorizontalLinesTillTouch[^1] = line;
					}
					else
					{
						HorizontalLinesTillTouch.Add(line);
					}
				}
			}
			else
			{
				_fractalDown[fractalBar] = 0;

				if (ShowLine && !isNewBar)
				{
					if (IsCurrentLine(fractalBar, false))
						HorizontalLinesTillTouch.RemoveAt(HorizontalLinesTillTouch.Count - 1);
				}
			}
		}

        #endregion

        #region Private methods

        private bool IsCurrentLine(int bar, bool isHighLine)
        {
	        return HorizontalLinesTillTouch.Count is not 0 &&
		        (bool)HorizontalLinesTillTouch[^1].Context == isHighLine &&
		        HorizontalLinesTillTouch[^1].FirstBar == bar;
        }

        private void HighPenChanged(object sender, PropertyChangedEventArgs e)
		{
			var highPen = HighPen.RenderObject.ToPen();

			HorizontalLinesTillTouch
				.Where(x => (bool)x.Context)
				.ForEach(x => x.Pen = highPen);

			_highPen = highPen;
		}

		private void LowPenChanged(object sender, PropertyChangedEventArgs e)
		{
			var lowPen = LowPen.RenderObject.ToPen();

			HorizontalLinesTillTouch
				.Where(x => !(bool)x.Context)
				.ForEach(x => x.Pen = lowPen);

			_lowPen = lowPen;
		}

		#endregion
	}
}









Technical/GMMA.cs









namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Guppy Multiple Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.GMMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602390")]
	public class GMMA : Indicator
	{
		#region Fields

		private readonly EMA _emaLong1 = new();
		private readonly EMA _emaLong2 = new();
		private readonly EMA _emaLong3 = new();
		private readonly EMA _emaLong4 = new();
		private readonly EMA _emaLong5 = new();
		private readonly EMA _emaLong6 = new();

		private readonly EMA _emaShort1 = new();
		private readonly EMA _emaShort2 = new();
		private readonly EMA _emaShort3 = new();
		private readonly EMA _emaShort4 = new();
		private readonly EMA _emaShort5 = new();
		private readonly EMA _emaShort6 = new();

		private readonly ValueDataSeries _renderLong1 = new("RenderLong1", "Long1");
		private readonly ValueDataSeries _renderLong2 = new("RenderLong2", "Long2");
		private readonly ValueDataSeries _renderLong3 = new("RenderLong3", "Long3");
		private readonly ValueDataSeries _renderLong4 = new("RenderLong4", "Long4");
		private readonly ValueDataSeries _renderLong5 = new("RenderLong5", "Long5");
		private readonly ValueDataSeries _renderLong6 = new("RenderLong6", "Long6");

		private readonly ValueDataSeries _renderShort1 = new("RenderShort1", "Short1");
		private readonly ValueDataSeries _renderShort2 = new("RenderShort2", "Short2");
		private readonly ValueDataSeries _renderShort3 = new("RenderShort3", "Short3");
		private readonly ValueDataSeries _renderShort4 = new("RenderShort4", "Short4");
		private readonly ValueDataSeries _renderShort5 = new("RenderShort5", "Short5");
		private readonly ValueDataSeries _renderShort6 = new("RenderShort6", "Short6");

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Colors), Description = nameof(Strings.ShortPeriodColorDescription), Order = 50)]
		public CrossColor ShortColor
		{
			get => _renderShort1.Color;
			set =>
				_renderShort1.Color = _renderShort2.Color = _renderShort3.Color =
					_renderShort4.Color = _renderShort5.Color = _renderShort6.Color = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Colors), Description = nameof(Strings.LongPeriodColorDescription), Order = 60)]
		public CrossColor LongColor
		{
			get => _renderLong1.Color;
			set =>
				_renderLong1.Color = _renderLong2.Color = _renderLong3.Color =
					_renderLong4.Color = _renderLong5.Color = _renderLong6.Color = value;
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod1), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int EmaPeriod1
		{
			get => _emaShort1.Period;
			set
			{
				_emaShort1.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod2), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int EmaPeriod2
		{
			get => _emaShort2.Period;
			set
			{
				_emaShort2.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod3), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.PeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int EmaPeriod3
		{
			get => _emaShort3.Period;
			set
			{
				_emaShort3.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod4), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.PeriodDescription), Order = 130)]
		[Range(1, 10000)]
        public int EmaPeriod4
		{
			get => _emaShort4.Period;
			set
			{
				_emaShort4.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod5), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.PeriodDescription), Order = 140)]
		[Range(1, 10000)]
        public int EmaPeriod5
		{
			get => _emaShort5.Period;
			set
			{
				_emaShort5.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod6), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.PeriodDescription), Order = 150)]
		[Range(1, 10000)]
		public int EmaPeriod6
		{
			get => _emaShort6.Period;
			set
			{
				_emaShort6.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod1), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.PeriodDescription), Order = 200)]
		[Range(1, 10000)]
        public int EmaLongPeriod1
		{
			get => _emaLong1.Period;
			set
			{
				_emaLong1.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod2), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.PeriodDescription), Order = 210)]
		[Range(1, 10000)]
        public int EmaLongPeriod2
		{
			get => _emaLong2.Period;
			set
			{
				_emaLong2.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod3), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.PeriodDescription), Order = 220)]
		[Range(1, 10000)]
        public int EmaLongPeriod3
		{
			get => _emaLong3.Period;
			set
			{
				_emaLong3.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod4), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.PeriodDescription), Order = 230)]
		[Range(1, 10000)]
        public int EmaLongPeriod4
		{
			get => _emaLong4.Period;
			set
			{
				_emaLong4.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod5), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.PeriodDescription), Order = 240)]
		[Range(1, 10000)]
        public int EmaLongPeriod5
		{
			get => _emaLong5.Period;
			set
			{
				_emaLong5.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod6), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.PeriodDescription), Order = 250)]
		[Range(1, 10000)]
        public int EmaLongPeriod6
		{
			get => _emaLong6.Period;
			set
			{
				_emaLong6.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public GMMA()
		{
			DenyToChangePanel = true;

			LongColor = DefaultColors.Red.Convert();
			ShortColor = DefaultColors.Blue.Convert();

			_emaShort1.Period = 3;
			_emaShort2.Period = 5;
			_emaShort3.Period = 7;
			_emaShort4.Period = 10;
			_emaShort5.Period = 12;
			_emaShort6.Period = 15;

			_emaLong1.Period = 30;
			_emaLong2.Period = 35;
			_emaLong3.Period = 40;
			_emaLong4.Period = 45;
			_emaLong5.Period = 50;
			_emaLong6.Period = 60;

			DataSeries[0] = _renderShort1;
			DataSeries.Add(_renderShort2);
			DataSeries.Add(_renderShort3);
			DataSeries.Add(_renderShort4);
			DataSeries.Add(_renderShort5);
			DataSeries.Add(_renderShort6);

			DataSeries.Add(_renderLong1);
			DataSeries.Add(_renderLong2);
			DataSeries.Add(_renderLong3);
			DataSeries.Add(_renderLong4);
			DataSeries.Add(_renderLong5);
			DataSeries.Add(_renderLong6);

			DataSeries.ForEach(x => x.IsHidden = true);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderShort1[bar] = _emaShort1.Calculate(bar, value);
			_renderShort2[bar] = _emaShort2.Calculate(bar, value);
			_renderShort3[bar] = _emaShort3.Calculate(bar, value);
			_renderShort4[bar] = _emaShort4.Calculate(bar, value);
			_renderShort5[bar] = _emaShort5.Calculate(bar, value);
			_renderShort6[bar] = _emaShort6.Calculate(bar, value);

			_renderLong1[bar] = _emaLong1.Calculate(bar, value);
			_renderLong2[bar] = _emaLong2.Calculate(bar, value);
			_renderLong3[bar] = _emaLong3.Calculate(bar, value);
			_renderLong4[bar] = _emaLong4.Calculate(bar, value);
			_renderLong5[bar] = _emaLong5.Calculate(bar, value);
			_renderLong6[bar] = _emaLong6.Calculate(bar, value);
		}

		#endregion
	}
}









Technical/Gaps.cs








namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

[DisplayName("Gaps")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.GapsIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618858")]
public class Gaps : Indicator
{
    #region Nested Types

    internal class Box
    {
        internal int Left { get; set; }
        internal decimal Top { get; set; }
        internal int Right { get; set; }
        internal decimal Bottom { get; set; }
    }

    internal class Gap
    {
        internal bool IsActive { get; set; } = true;
        internal bool IsVisible { get; set; } = true;
        internal bool IsBull { get; set; }
        internal List<Box> Boxes { get; set; } = new();
    }

    #endregion

    #region Fields

    private const string _newGapMessage = "A new gap has appeared.";
    private const string _closeGapMessage = "A gap was closed.";
    private const int _smaPeriod = 14;
    private readonly List<Gap> _gaps = new();
    private readonly PenSettings _bullishPen = new() { Color = Drawing.DefaultColors.Green.Convert(), Width = 2 };
    private readonly PenSettings _bearishPen = new() { Color = Drawing.DefaultColors.Red.Convert(), Width = 2 };
    private readonly FontSetting _labelFont = new() { FontFamily = "Arial", Size = 10 };
    private readonly RenderStringFormat _format = new()
    {
        Alignment = StringAlignment.Center,
        LineAlignment = StringAlignment.Center,
    };

    private int _lastBar = -1;
    private SMA _sma;
    private System.Drawing.Color _bullishColorTransp;
    private System.Drawing.Color _bearishColorTransp;

    private bool _closeGapsPartially;
    private int _minDeviation = 30;
    private bool _limitMaxGapBodyLength;
    private int _transparency = 6;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ClosePartially), GroupName = nameof(Strings.Settings), Description = nameof(Strings.UsePartialGapClosureDescription))]
    public bool CloseGapsPartially
    {
        get => _closeGapsPartially;
        set
        {
            _closeGapsPartially = value;
            RecalculateValues();
        }
    }

    [Range(1, 100)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimalDeviation), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinimalGapDeviationDescription))]
    public int MinDeviation
    {
        get => _minDeviation;
        set
        {
            _minDeviation = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LimitMaxGapBodyLength), GroupName = nameof(Strings.Settings), Description = nameof(Strings.IsLimitMaxLengthDescription))]
    public bool LimitMaxGapBodyLength
    {
        get => _limitMaxGapBodyLength;
        set
        {
            _limitMaxGapBodyLength = value;
            SetFiltersVizible();
            RecalculateValues();
        }
    }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxGapBodyLength), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MaxLengthDescription))]
    public FilterInt MaxGapBodyLengthFilter { get; set; } = new(false);

    [Browsable(false)]
    [Obsolete]
    public int MaxGapBodyLength
    {
        get => MaxGapBodyLengthFilter.Value;
        set => MaxGapBodyLengthFilter.Value = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideGaps), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.HideGapsDescription))]
    public bool HideGaps { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription))]
    public CrossColor BullishColor 
    { 
        get => _bullishPen.Color;
        set
        {
            _bullishPen.Color = value;
            _bullishColorTransp = GetColorTransparency(_bullishPen.Color, _transparency).Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription))]
    public CrossColor BearlishColor
    { 
        get => _bearishPen.Color; 
        set
        {
            _bearishPen.Color = value;
            _bearishColorTransp = GetColorTransparency(_bearishPen.Color, _transparency).Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideBorder), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.HideBorderDescription))]
    public bool HideBorder { get; set; }

    [Range(1, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BorderWidth), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BorderWidthPixelDescription))]
    public int BorderWidth 
    {
        get => _bearishPen.Width;
        set
        {
            _bearishPen.Width = value;
            _bullishPen.Width = value;
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int Transparency 
    {
        get => _transparency; 
        set
        {
            _transparency = value;
            _bullishColorTransp = GetColorTransparency(_bullishPen.Color, value).Convert();
            _bearishColorTransp = GetColorTransparency(_bearishPen.Color, value).Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Label), Description = nameof(Strings.IsNeedShowLabelDescription))]
    public bool ShowLabel { get; set; } = true;

    [Range(1, 50)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Size), GroupName = nameof(Strings.Label), Description = nameof(Strings.TextSizeDescription))]
    public int LabelSize
    {
        get => _labelFont.Size;
        set => _labelFont.Size = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Label), Description = nameof(Strings.LabelTextColorDescription))]
    public CrossColor LabelColor { get; set; } = Drawing.DefaultColors.Gray.Convert();

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetX), GroupName = nameof(Strings.Label), Description = nameof(Strings.LabelOffsetXDescription))]
    public int LabelOffsetX { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetY), GroupName = nameof(Strings.Label), Description = nameof(Strings.LabelOffsetYDescription))]
    public int LabelOffsetY { get; set; } = 10;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription))]
    public bool UseAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription))]
    public string AlertFile { get; set; } = "alert1";

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription))]
    public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription))]
    public CrossColor AlertBGColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

    #endregion

    #region ctor

    public Gaps() : base(true)
    {
        DenyToChangePanel = true;
        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).ShowZeroValue = false;

        SubscribeToDrawingEvents(DrawingLayouts.Final);
        EnableCustomDrawing = true;

        _bearishColorTransp = GetColorTransparency(_bearishPen.Color, _transparency).Convert();
        _bullishColorTransp = GetColorTransparency(_bullishPen.Color, _transparency).Convert();

        SetFiltersVizible();
        MaxGapBodyLengthFilter.Value = 300;
        MaxGapBodyLengthFilter.PropertyChanged += Filter_PropertyChanged;
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        _gaps.Clear();
        _sma = new() { Period = _smaPeriod };
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        var candle = GetCandle(bar);
        var smaValue = _sma.Calculate(bar, candle.High - candle.Low);

        if (bar == 0) return;

        TryCloseAllGaps(bar, candle);

        if (bar != _lastBar)
        {
            var prevCandle = GetCandle(bar - 1);
            TryRegisterNewGap(bar, candle, prevCandle, smaValue);

            _lastBar = bar;
        }
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
       if(ChartInfo is null) return;

        if (!HideGaps)
            DrawGaps(context);
    }

    #endregion

    #region Private Methods

    private void Filter_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName != "Value")
            return;

        RecalculateValues();
        RedrawChart();
    }

    private void SetFiltersVizible()
    {
        if (MaxGapBodyLengthFilter is { })
            MaxGapBodyLengthFilter.Enabled = _limitMaxGapBodyLength;
    }

    private void TryCloseAllGaps(int bar, IndicatorCandle candle)
    {
        foreach (var gap in _gaps) 
        {
            if(!gap.IsActive) continue;

            var activeBox = gap.Boxes.Last();
            activeBox.Right = bar;

            if (_limitMaxGapBodyLength && (bar - activeBox.Left) >= MaxGapBodyLengthFilter.Value)
            {
                if (!_closeGapsPartially)
                    FullClose(bar, candle, gap);
                else
                    gap.IsVisible = false;

                continue;
            }

            if ((gap.IsBull && candle.Low < activeBox.Top) || (!gap.IsBull && candle.High > activeBox.Bottom))
            {
                if (_closeGapsPartially)
                {
                    if ((gap.IsBull && candle.Low >= activeBox.Bottom) || (!gap.IsBull && candle.High <= activeBox.Top))
                        PartialClose(bar, candle, gap);
                    else 
                        FullClose(bar, candle, gap);
                }
                else
                    FullClose(bar, candle, gap);
            }
        }

        if (_gaps.RemoveAll(g => !g.IsVisible) > 0)
            if (UseAlerts && bar == CurrentBar - 1)
                AddAlert(AlertFile, InstrumentInfo.Instrument, _closeGapMessage, AlertBGColor, AlertForeColor);
    }

    private void PartialClose(int bar, IndicatorCandle candle, Gap gap)
    {
        var activeBox = gap.Boxes.Last();
        var box = new Box
        {
            Left = bar,
            Top = gap.IsBull ? candle.Low : activeBox.Top,
            Right = bar,
            Bottom = gap.IsBull ? activeBox.Bottom : candle.High
        };

        gap.Boxes.Add(box);
    }

    private void FullClose(int bar, IndicatorCandle candle, Gap gap)
    {
        gap.IsActive = false;

        if (UseAlerts && bar == CurrentBar - 1) 
            AddAlert(AlertFile, InstrumentInfo.Instrument, _closeGapMessage, AlertBGColor, AlertForeColor);
    }

    private void TryRegisterNewGap(int bar, IndicatorCandle candle, IndicatorCandle prevCandle, decimal smaValue)
    {
        if (IsGapConditions(candle.Low, prevCandle.High, smaValue))
            CreateNewGap(bar - 1, candle.Low, bar, prevCandle.High, true);
        else if (IsGapConditions(prevCandle.Low, candle.High, smaValue))
            CreateNewGap(bar - 1, prevCandle.Low, bar, candle.High, false);
    }

    private bool IsGapConditions(decimal top, decimal bottom, decimal smaValue) => (top - bottom) >= (smaValue / 100 * _minDeviation);

    private void CreateNewGap(int left, decimal top, int right, decimal bottom, bool isBull)
    {
        var box = new Box
        {
            Left = left,
            Top = top,
            Right = right,
            Bottom = bottom,
        };

        var gap = new Gap { IsBull = isBull };
        gap.Boxes.Add(box);

        _gaps.Add(gap);

        if ((UseAlerts && right == CurrentBar - 1))
            AddAlert(AlertFile, InstrumentInfo.Instrument, _newGapMessage, AlertBGColor, AlertForeColor);
    }

    private void DrawGaps(RenderContext context)
    {
        var gaps = _gaps.Where(g => g.Boxes.First().Left <= LastVisibleBarNumber && g.Boxes.Last().Right >= FirstVisibleBarNumber).ToList();

        foreach (var gap in gaps)
        {
            var color = gap.IsBull ? _bullishColorTransp : _bearishColorTransp;
            var pen = gap.IsBull ? _bullishPen.RenderObject : _bearishPen.RenderObject;
            var isClusterMode = ChartInfo.ChartVisualMode == ChartVisualModes.Clusters;
            var xGap = ChartInfo.GetXByBar(gap.Boxes[0].Left, isClusterMode);
            var yGap = ChartInfo.GetYByPrice(gap.Boxes[0].Top, isClusterMode);

            foreach (var box in gap.Boxes)
            {
                var x = ChartInfo.GetXByBar(box.Left, isClusterMode);
                var y = ChartInfo.GetYByPrice(box.Top, isClusterMode);
                var w = ChartInfo.GetXByBar(box.Right, isClusterMode) - x;
                var h = ChartInfo.GetYByPrice(box.Bottom, isClusterMode) - y;
                var rec = new Rectangle(x, y, w, h);

                if (HideBorder)
                    context.FillRectangle(color, rec);
                else
                    context.DrawFillRectangle(pen, color, rec);
            }

            if (ShowLabel)
            {
                var timeFrame = ChartInfo.TimeFrame;
                var text = $"{timeFrame} Gap";
                var labelSize = context.MeasureString(text, _labelFont.RenderObject);
                var lX = xGap + ChartInfo.PriceChartContainer.BarsWidth * LabelOffsetX;
                var lY = yGap + ChartInfo.PriceChartContainer.PriceRowHeight * LabelOffsetY;
                var lRec = new Rectangle((int)lX, (int)lY, labelSize.Width, labelSize.Height);
                context.DrawString(text, _labelFont.RenderObject, LabelColor.Convert(), lRec, _format);
            }
        }
    }

    private CrossColor GetColorTransparency(CrossColor color, int tr = 5)
    {
        var colorA = Math.Max(color.A - (tr * 25), 0);

        return CrossColor.FromArgb((byte)colorA, color.R, color.G, color.B);
    }

    #endregion
}










Technical/GlobalUsings.cs







#if CROSS_PLATFORM

global using CrossColor = System.Drawing.Color;
global using CrossKey = Avalonia.Input.Key;
global using CrossColors = System.Drawing.Color;
global using CrossKeyEventArgs = Avalonia.Input.KeyEventArgs;

#else

global using CrossColor = System.Windows.Media.Color;
global using CrossKey = System.Windows.Input.Key;
global using CrossColors = System.Windows.Media.Colors;
global using CrossKeyEventArgs = System.Windows.Input.KeyEventArgs;

#endif







Technical/GreatestSwing.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Greatest Swing Value")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.GreatestSwingDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602635")]
	public class GreatestSwing : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _buy = new("BuySwing");
		private readonly ValueDataSeries _sell = new("SellSwing");

		private readonly ValueDataSeries _buySeries = new("BuySeries", Strings.Buys)
		{
			Color = DefaultColors.Green.Convert(),
			DescriptionKey = nameof(Strings.TopChannelSettingsDescription)
		};

		private readonly ValueDataSeries _sellSeries = new("SellSeries", Strings.Sells)
		{
            DescriptionKey = nameof(Strings.BottomChannelSettingsDescription)
        };

		private decimal _multiplier = 5;
        private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription), Order = 110)]
		[Range(0.0000001, 10000000)]
        public decimal Multiplier
		{
			get => _multiplier;
			set
			{
				_multiplier = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public GreatestSwing()
			: base(true)
		{
			DenyToChangePanel = true;
			
			DataSeries[0] = _buySeries;
			DataSeries.Add(_sellSeries);
		}

		#endregion

		#region Protected methods
		
		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_buy.Clear();
				_sell.Clear();
				return;
			}

			var candle = GetCandle(bar);

			if (candle.Close < candle.Open)
				_buy[bar] = candle.High - candle.Open;

			if (candle.Close > candle.Open)
				_sell[bar] = candle.Open - candle.Low;

			var buyMa = SkipZeroMa(bar - 1, _buy);
			var sellMa = SkipZeroMa(bar - 1, _sell);

			_buySeries[bar] = candle.Open + _multiplier * buyMa;
			_sellSeries[bar] = candle.Open - _multiplier * sellMa;
		}

		#endregion

		#region Private methods

		private decimal SkipZeroMa(int bar, ValueDataSeries series)
		{
			var nonZeroValues = 0;
			var sum = 0m;

			for (var i = Math.Max(0, bar - _period); i <= bar; i++)
			{
				if (series[i] == 0)
					continue;

				nonZeroValues++;
				sum += series[i];
			}

			if (nonZeroValues == 0)
				return 0;

			return sum / nonZeroValues;
		}

		#endregion
	}
}










Technical/HMA.cs








namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.Drawing;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Hull Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602550")]
	public class HMA : Indicator
	{
		#region Fields

		private ValueDataSeries _renderSeries = new("RenderSeries", "Hull Moving Average");

		private readonly WMA _wmaHull = new();
		private readonly WMA _wmaPrice = new();

		private readonly WMA _wmaPriceHalf = new();
		private bool _coloredDirection = true;
		private Color _bullishColor = DefaultColors.Green;
		private Color _bearishColor = DefaultColors.Red;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _wmaPrice.Period;
			set
			{
				_wmaPrice.Period = value;
				_wmaHull.Period = Convert.ToInt32(Math.Sqrt(value));
				_wmaPriceHalf.Period = value / 2;
				RecalculateValues();
			}
		}


		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColoredDirection), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColoredDirectionDescription), Order = 200)]
		[Range(1, 10000)]
		public bool ColoredDirection
        {
			get => _coloredDirection;
			set
			{
				_coloredDirection = value;

                RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription), Order = 210)]
		public CrossColor BullishColor
		{
			get => _bullishColor.Convert();
			set
			{
				_bullishColor = value.Convert();
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription), Order = 220)]
		public CrossColor BearishColor
		{
			get => _bearishColor.Convert();
			set
			{
				_bearishColor = value.Convert();
				RecalculateValues();
			}
		}
        #endregion

        #region ctor

        public HMA()
			: base(true)
		{
			DenyToChangePanel = true;
			Period = 16;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var wmaPriceHalf = _wmaPriceHalf.Calculate(bar, candle.Close);
			var wmaPrice = _wmaPrice.Calculate(bar, candle.Close);

			var wmaHull = _wmaHull.Calculate(bar, 2.0m * wmaPriceHalf - wmaPrice);
			_renderSeries[bar] = wmaHull;

			if (bar == 0 || !ColoredDirection)
				return;

			_renderSeries.Colors[bar] = _renderSeries[bar] > _renderSeries[bar - 1] 
				? _bullishColor
				: _bearishColor;
		}

        #endregion
    }
}









Technical/HRanges.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using OFT.Attributes;
    using OFT.Localization;
    using Utils.Common.Collections;
	
    [DisplayName("HRanges")]
	
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HRangesDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602573")]
	public class HRanges : Indicator
	{
		#region Nested types

		public enum Direction
		{
			Up,
			Down,
			Flat
		}

		#endregion

		#region Fields

		private readonly Dictionary<int, IEnumerable<PriceVolumeInfo>> _priceVolumeInfoCache = new();

		private readonly ValueDataSeries _downRangeBottom = new("DownRangeBottom", "DownBot");
		private readonly ValueDataSeries _downRangeTop = new("DownRangeTop", "DownTop");
		private readonly ValueDataSeries _flatRangeBottom = new("FlatRangeBottom", "FlatBot");
		private readonly ValueDataSeries _flatRangeTop = new("FlatRangeTop", "FlatTop");
		private readonly ValueDataSeries _maxVolumeRange = new("MaxVolumeRange", "MaxVol");
		private readonly ValueDataSeries _upRangeBottom = new("UpRangeBottom", "UpBot");
		private readonly ValueDataSeries _upRangeTop = new("UpRangeTop", "UpTop");

		private int _currentBar = -1;
		private int _currentCountBar;
		private int _days;
		private int _direction;
		private decimal _hRange;
		private bool _isRange;
		private int _lastBar;
		private decimal _lRange;
		private int _startingRange;
		private int _targetBar;
		private decimal _volumeFilter;
		private bool _hideAllBarsFilter;
		private int _barsRange;
		private bool _hideAllVolume;

		#endregion

		#region Properties

		[Range(0, 10000)]
		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        public int Days
		{
			get => _days;
			set
			{
				_days = value;
				RecalculateValues();
			}
		}

        [Parameter]
		[Range(0, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.VolumeFilter), Description = nameof(Strings.MaxMaxVolumeFilterDescription))]
		public decimal VolumeFilter
		{
			get => _volumeFilter;
			set
			{
				_volumeFilter = value;
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideAll), GroupName = nameof(Strings.VolumeFilter), Description = nameof(Strings.HideMaxVolumeUnfilteredRangesDescription))]
		public bool HideAllVolume
		{
			get => _hideAllVolume;
			set
			{
				_hideAllVolume = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(0, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.BarsCountFilter), Description = nameof(Strings.BarsRangeDescription))]
		public int BarsRange
		{
			get => _barsRange;
			set
			{
				_barsRange = value;
				RecalculateValues();
			}
		}
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HideAll), GroupName = nameof(Strings.BarsCountFilter), Description = nameof(Strings.HideBarsCountUnfilteredRangesDescription))]
		public bool HideAllBarsFilter
		{
			get => _hideAllBarsFilter;
			set
			{
				_hideAllBarsFilter = value;
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BreakUpColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription))]
        public CrossColor SwingUpColor
        {
            get => _upRangeTop.Color;
            set => _upRangeTop.Color = _upRangeBottom.Color = value;
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxVolColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.MaxVolColorDescription))]
        public CrossColor VolumeColor
        {
            get => _maxVolumeRange.Color;
            set => _maxVolumeRange.Color = value;
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BreakDnColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription))]
        public CrossColor SwingDnColor
        {
            get => _downRangeTop.Color;
            set => _downRangeTop.Color = _downRangeBottom.Color = value;
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FlatColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.NeutralColorDescription))]
        public CrossColor NeutralColor
        {
            get => _flatRangeTop.Color;
            set => _flatRangeTop.Color = _flatRangeBottom.Color = value;
        }

        [Range(1, 100)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.WidthDataSeriesDescription))]
        public int Width
        {
            get => _upRangeTop.Width;
            set => _upRangeTop.Width = _upRangeBottom.Width = _downRangeTop.Width = _downRangeBottom.Width =
                _flatRangeTop.Width = _flatRangeBottom.Width = _maxVolumeRange.Width = value;
        }

        #endregion

        #region ctor

        public HRanges()
			: base(true)
		{
			DenyToChangePanel = true;
			Width = 2;
			_days = 20;

			_upRangeTop.Color = _upRangeBottom.Color = System.Drawing.Color.Green.Convert();
			_downRangeTop.Color = _downRangeBottom.Color = System.Drawing.Color.Red.Convert();
			_flatRangeTop.Color = _flatRangeBottom.Color = System.Drawing.Color.Gray.Convert();
			_maxVolumeRange.Color = System.Drawing.Color.DodgerBlue.Convert();

			_upRangeTop.IsHidden = _upRangeBottom.IsHidden = true;
			_downRangeTop.IsHidden = _downRangeBottom.IsHidden = true;
			_flatRangeTop.IsHidden = _flatRangeBottom.IsHidden = true;
			_maxVolumeRange.IsHidden = true;

			_upRangeTop.ShowZeroValue = _upRangeBottom.ShowZeroValue = false;
			_downRangeTop.ShowZeroValue = _downRangeBottom.ShowZeroValue = false;
			_flatRangeTop.ShowZeroValue = _flatRangeBottom.ShowZeroValue = false;
			_maxVolumeRange.ShowZeroValue = false;

			_upRangeTop.VisualType = _upRangeBottom.VisualType = VisualMode.Hash;
			_downRangeTop.VisualType = _downRangeBottom.VisualType = VisualMode.Hash;
			_flatRangeTop.VisualType = _flatRangeBottom.VisualType = VisualMode.Hash;
			_maxVolumeRange.VisualType = VisualMode.Hash;

			DataSeries[0] = _upRangeTop;
			DataSeries.Add(_upRangeBottom);
			DataSeries.Add(_downRangeTop);
			DataSeries.Add(_downRangeBottom);
			DataSeries.Add(_flatRangeTop);
			DataSeries.Add(_flatRangeBottom);
			DataSeries.Add(_maxVolumeRange);
		}

        #endregion

        #region Protected methods

        protected override void OnInitialize()
        {
			_upRangeTop.ShowZeroValue = _upRangeBottom.ShowZeroValue = false;
	        _downRangeTop.ShowZeroValue = _downRangeBottom.ShowZeroValue = false;
	        _flatRangeTop.ShowZeroValue = _flatRangeBottom.ShowZeroValue = false;
	        _maxVolumeRange.ShowZeroValue = false;
        }

        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

	        SwingUpColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	        SwingDnColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	        NeutralColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				_isRange = false;
				_direction = 0;
				_hRange = 0;
				_lRange = 0;
				_startingRange = 0;
				_currentCountBar = 0;

				_targetBar = 0;

				if (_days > 0)
				{
					var days = 0;

					for (var i = CurrentBar - 1; i >= 0; i--)
					{
						_targetBar = i;

						if (!IsNewSession(i))
							continue;

						days++;

						if (days == _days)
							break;
					}
				}
			}

			_currentBar = bar - 1;

			if (_currentBar < 5 || _lastBar == _currentBar)
				return;

			_lastBar = bar;

			if (bar < _targetBar)
				return;

			if (IsNewSession(_currentBar))
			{
				_isRange = false;
				_direction = 0;
				_hRange = 0;
				_lRange = 0;
				_startingRange = 0;
				_currentCountBar = 0;
			}

			var candle = GetCandle(_currentBar - 1);
			var prevCandle = GetCandle(_currentBar - 2);

			if (!_isRange)
			{
				if (_direction == 1 && candle.Close < prevCandle.High)
				{
					_isRange = true;
					_hRange = Math.Max(candle.High, prevCandle.High);
					_lRange = candle.Low;
					_startingRange = _currentBar;

					_priceVolumeInfoCache.RemoveWhere(x => x.Key < _startingRange);

					if (_currentCountBar > 0)
						_currentCountBar = -1;
					else
						_currentCountBar--;
				}
				else if (_direction == -1 && candle.Close > prevCandle.Low)
				{
					_isRange = true;
					_hRange = candle.High;
					_lRange = Math.Min(candle.Low, prevCandle.Low);
					_startingRange = _currentBar;

					_priceVolumeInfoCache.RemoveWhere(x => x.Key < _startingRange);

					if (_currentCountBar < 0)
						_currentCountBar = 1;
					else
						_currentCountBar++;
				}
				else
					_direction = GetLastDirection();
			}

			if (_isRange && _currentBar - _startingRange >= 2)
			{
				if (candle.Close < _lRange && prevCandle.Close < _lRange)
				{
					_isRange = false;

					RenderLevel(Direction.Down);

					_hRange = 0;
					_lRange = 0;
					_direction = GetLastDirection();

					Calculate(_currentBar, value);
					return;
				}

				if (candle.Close > _hRange && prevCandle.Close > _hRange)
				{
					_isRange = false;
					RenderLevel(Direction.Up);

					_hRange = 0;
					_lRange = 0;
					_direction = GetLastDirection();
					Calculate(_currentBar, value);
					return;
				}

				if (prevCandle.Close < _lRange && candle.Close >= _lRange)
					_lRange = Math.Min(Math.Min(prevCandle.Low, candle.Low), _lRange);

				if (prevCandle.Close > _hRange && candle.Close <= _hRange)
					_hRange = Math.Max(Math.Max(prevCandle.High, candle.High), _hRange);
			}

			if (_hRange != 0 && _lRange != 0)
			{
				if (candle.Close <= _hRange)
					_hRange = Math.Max(_hRange, candle.High);

				if (candle.Close >= _lRange)
					_lRange = Math.Min(_lRange, candle.Low);

				RenderLevel(Direction.Flat);
			}
		}

		#endregion

		#region Private methods

		private void RenderLevel(Direction direction)
		{
			var dict = new Dictionary<decimal, decimal>();

			for (var i = _startingRange; i < _currentBar; i++)
			{
				switch (direction)
				{
					case Direction.Up:
						_upRangeTop[i] = _hRange;
						_upRangeBottom[i] = _lRange;
						_flatRangeTop[i] = 0;
						_flatRangeBottom[i] = 0;
						break;

					case Direction.Down:
						_downRangeTop[i] = _hRange;
						_downRangeBottom[i] = _lRange;
						_flatRangeTop[i] = 0;
						_flatRangeBottom[i] = 0;
						break;

					case Direction.Flat:
						_flatRangeTop[i] = _hRange;
						_flatRangeBottom[i] = _lRange;
						break;
				}

				var candle = GetCandle(i);
				var volumeInfos = i != CurrentBar - 1
					? _priceVolumeInfoCache.GetOrAdd(i, _ => candle.GetAllPriceLevels())
					: candle.GetAllPriceLevels();

				foreach (var volumeInfo in volumeInfos)
					dict.IncrementValue(volumeInfo.Price, volumeInfo.Volume);
			}

			if (dict.Count == 0)
				return;

			var maxVol = dict.Aggregate((l, r) => l.Value >= r.Value ? l : r);

			if (maxVol.Value >= VolumeFilter && _currentBar - _startingRange >= BarsRange)
			{
				for (var i = _startingRange; i < _currentBar; i++)
					_maxVolumeRange[i] = maxVol.Key;
			}
			else 
			{
				if (HideAllBarsFilter && _currentBar - _startingRange < BarsRange || HideAllVolume && maxVol.Value < VolumeFilter)
					for (var i = _startingRange; i < _currentBar; i++)
						DataSeries.ForEach(x => ((ValueDataSeries)x)[i] = 0);
				else
					for (var i = _startingRange; i < _currentBar; i++)
						_maxVolumeRange[i] = 0;
			}
		}

		private int GetLastDirection()
		{
			for (var i = _currentBar - 1; i > 0; i--)
			{
				var candle = GetCandle(i);
				var prevCandle = GetCandle(i - 1);

				if (candle.Close > prevCandle.High)
					return 1;

				if (candle.Close < prevCandle.Low)
					return -1;
			}

			return 0;
		}

		#endregion
	}
}








Technical/HVR.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Historical Volatility Ratio")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HVRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602393")]
	public class HVR : Indicator
	{
		#region Fields
		
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly StdDev _shortDev = new() { Period = 6 };
		private readonly StdDev _longDev = new() { Period = 100 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortStdDevPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int ShortPeriod
		{
			get => _shortDev.Period;
			set
			{
				_shortDev.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongStdDevPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _longDev.Period;
			set
			{
				_longDev.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public HVR()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var lr = (decimal)Math.Log((double)(candle.Close / prevCandle.Close));
			_renderSeries[bar] = _shortDev.Calculate(bar, lr) / _longDev.Calculate(bar, lr);
		}

		#endregion
	}
}









Technical/HeikenAshi.cs









namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Heiken Ashi")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HeikenAshiDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602391")]
	public class HeikenAshi : Indicator
	{
		#region Fields

		private readonly CrossColor _transparent = System.Drawing.Color.Transparent.Convert();

        private readonly PaintbarsDataSeries _bars = new("BarsId", "Bars") { IsHidden = true };
		private readonly CandleDataSeries _candles = new("Candles", "Heiken Ashi");
		private int _days;
		private int _targetBar;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        public int Days
		{
			get => _days;
			set
			{
				if (value < 0)
					return;

				_days = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public HeikenAshi()
			: base(true)
		{
			_days = 20;
			DenyToChangePanel = true;
			DataSeries[0] = _bars;
			DataSeries.Add(_candles);
		}

        #endregion

        #region Protected methods
		
        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

	        _candles.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	        _candles.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	        _candles.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			_bars[bar] = _transparent;

			if (bar == 0)
			{
				if (_days > 0)
				{
					var days = 0;

					for (var i = CurrentBar - 1; i >= 0; i--)
					{
						_targetBar = i;

						if (!IsNewSession(i))
							continue;

						days++;

						if (days == _days)
							break;
					}
				}
			}

			if (bar < _targetBar)
				return;

			if (bar == _targetBar)
			{
				var candle = GetCandle(bar);

				_candles[bar] = new Candle
				{
					Close = candle.Close,
					High = candle.High,
					Low = candle.Low,
					Open = candle.Open
				};
			}
			else
			{
				var candle = GetCandle(bar);
				var prevCandle = _candles[bar - 1];
				var close = (candle.Open + candle.Close + candle.High + candle.Low) * 0.25m;
				var open = (prevCandle.Open + prevCandle.Close) * 0.5m;
				var high = Math.Max(Math.Max(close, open), candle.High);
				var low = Math.Min(Math.Min(close, open), candle.Low);

				_candles[bar] = new Candle
				{
					Close = close,
					High = high,
					Low = low,
					Open = open
				};
			}
		}

		#endregion
	}
}









Technical/HeikenAshiSmoothed.cs









namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Heiken Ashi Smoothed")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HeikenAshiSmoothedDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602392")]
	public class HeikenAshiSmoothed : Indicator
	{
		#region Fields

		private readonly PaintbarsDataSeries _bars = new("BarsId", "Bars")
		{
			IsHidden = true, 
			HideChart = true
		};
		private readonly CandleDataSeries _candles = new("Candles");
		private readonly SMMA _smmaClose = new();
		private readonly SMMA _smmaHigh = new();
		private readonly SMMA _smmaLow = new();
		private readonly SMMA _smmaOpen = new();
		private readonly CandleDataSeries _smoothedCandles = new("SmoothedCandles", Strings.Visualization);
		private readonly WMA _wmaClose = new();
		private readonly WMA _wmaHigh = new();
		private readonly WMA _wmaLow = new();
		private readonly WMA _wmaOpen = new();

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMMA), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMMAPeriodDescription), Order = 100)]
		public int SmmaPeriod
		{
			get => _smmaOpen.Period;
			set
			{
				if (value <= 0)
					return;

				_smmaOpen.Period = _smmaClose.Period = _smmaHigh.Period = _smmaLow.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA), GroupName = nameof(Strings.Settings), Description = nameof(Strings.WMAPeriodDescription), Order = 110)]
		public int WmaPeriod
		{
			get => _wmaOpen.Period;
			set
			{
				if (value <= 0)
					return;

				_wmaOpen.Period = _wmaClose.Period = _wmaHigh.Period = _wmaLow.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowBars), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowBarsDescription), Order = 200)]
		public bool ShowBars
		{
			get => !_bars.HideChart;
			set => _bars.HideChart = !value;
		}

		#endregion

		#region ctor

		public HeikenAshiSmoothed()
			: base(true)
		{
			DenyToChangePanel = true;
			_wmaOpen.Period = _wmaClose.Period = _wmaHigh.Period = _wmaLow.Period = 10;
			_smmaOpen.Period = _smmaClose.Period = _smmaHigh.Period = _smmaLow.Period = 10;
			DataSeries[0] = _bars;
			DataSeries.Add(_smoothedCandles);
		}

        #endregion

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

	        _smoothedCandles.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	        _smoothedCandles.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	        _smoothedCandles.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			
			_smmaOpen.Calculate(bar, candle.Open);
			_smmaClose.Calculate(bar, candle.Close);
			_smmaHigh.Calculate(bar, candle.High);
			_smmaLow.Calculate(bar, candle.Low);

			if (bar == 0)
			{
				_wmaOpen.Calculate(bar, candle.Open);
				_wmaClose.Calculate(bar, candle.Close);
				_wmaHigh.Calculate(bar, candle.High);
				_wmaLow.Calculate(bar, candle.Low);

				_candles[bar] = new Candle
				{
					Close = candle.Close,
					High = candle.High,
					Low = candle.Low,
					Open = candle.Open
				};
			}
			else
			{
				var open = (_candles[bar - 1].Open + _candles[bar - 1].Close) / 2;
				var high = Math.Max(_smmaHigh[bar], _candles[bar].Open);
				var low = Math.Min(_smmaLow[bar], open);
				var close = (_smmaOpen[bar] + _smmaHigh[bar] + _smmaLow[bar] + _smmaClose[bar]) / 4;

				_candles[bar] = new Candle
				{
					Close = close,
					High = high,
					Low = low,
					Open = open
				};

				var smoothedCandle = new Candle();

				smoothedCandle.Open = _wmaOpen.Calculate(bar, open);
				smoothedCandle.Close = _wmaClose.Calculate(bar, close);
				smoothedCandle.High = _wmaHigh.Calculate(bar, high);
				smoothedCandle.Low = _wmaLow.Calculate(bar, low);

				_smoothedCandles[bar] = smoothedCandle;
			}
		}

		#endregion
	}
}










Technical/HerrickPayoff.cs










namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Herrick Payoff Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HerrickPayoffDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602286")]
	public class HerrickPayoff : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _hpiSec = new("HpiSecondary");
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
			IsHidden = true,
			UseMinimizedModeIfEnabled = true
		};
		
		private decimal _divisor = 1;
        private int _smooth = 10;

        private System.Drawing.Color _negColor = DefaultColors.Red;
        private System.Drawing.Color _posColor = DefaultColors.Blue;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 610)]
        public CrossColor PosColor
        {
	        get => _posColor.Convert();
	        set
	        {
		        _posColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 620)]
        public CrossColor NegColor
        {
	        get => _negColor.Convert();
	        set
	        {
		        _negColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Divisor), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DivisorDescription), Order = 110)]
		[Range(0.00000001, 100000000)]
		public decimal Divisor
		{
			get => _divisor;
			set
			{
				_divisor = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Smooth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription), Order = 120)]
		[Range(1, 10000)]
		public int Smooth
		{
			get => _smooth;
			set
			{
				_smooth = value;
				RecalculateValues();
			}
		}
		
		#endregion

		#region ctor

		public HerrickPayoff()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods
		
		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				return;
			}

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var highLow = (candle.High + candle.Low) / 2m;
			var prevHighLow = (prevCandle.High + prevCandle.Low) / 2m;
			var oi = candle.OI;

			var prevOi = prevCandle.OI;
			var calcOI = oi > 0 ? oi : prevOi;

			var maxOi = Math.Max(calcOI, prevOi);

			if (maxOi == 0)
				return;

			_hpiSec[bar] = InstrumentInfo.TickSize * candle.Volume * (highLow - prevHighLow) / _divisor *
				((1 + 2 * Math.Abs(calcOI - prevOi)) / maxOi);

			var lastValue = _renderSeries[bar - 1];
            
			var renderValue = maxOi > 0
	            ? lastValue + _smooth * (_hpiSec[bar] - _hpiSec[bar - 1])
	            : lastValue;

			_renderSeries[bar] = renderValue;
			_renderSeries.Colors[bar] = renderValue > 0 ? _posColor : _negColor;
		}

		#endregion
	}
}










Technical/HighLow.cs









namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Highest High/Lowest Low Over N Bars")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HighLowIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602244")]
	public class HighLow : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _highSeries = new("High");
		private readonly ValueDataSeries _lowSeries = new("Low");

		private readonly ValueDataSeries _maxSeries = new("MaxSeries", Strings.Highest) { Color = DefaultColors.Green.Convert() };
        private readonly ValueDataSeries _minSeries = new("MinSeries", Strings.Lowest);
		private int _period = 15;

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public HighLow()
			:base(true)
		{
			DenyToChangePanel = true;
			
			DataSeries[0] = _maxSeries;
			DataSeries.Add(_minSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_highSeries[bar] = candle.High;
			_lowSeries[bar] = candle.Low;

			_maxSeries[bar] = _highSeries.MAX(_period, bar);
			_minSeries[bar] = _lowSeries.MIN(_period, bar);
		}

		#endregion
	}
}






Technical/Higest.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using Utils.Common.Localization;

	[DisplayName("Highest")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HighestIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602627")]
	public class Highest : Indicator
	{
		#region Fields

		private int _period;

		#endregion

		#region Properties

		[Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Highest()
		{
			Period = 10;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var start = Math.Max(0, bar - Period + 1);
			var count = Math.Min(bar + 1, Period);

			var max = (decimal)SourceDataSeries[start];

			for (var i = start + 1; i < start + count; i++)
				max = Math.Max(max, (decimal)SourceDataSeries[i]);

			this[bar] = max;
		}

		#endregion
	}
}








Technical/HurstExponent.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Hurst Exponent")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.HurstExponentDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602551")]
	public class HurstExponent : Indicator
	{
		#region Nested types

		public enum Period
		{
			[Display(Name = "32")]
			First = 32,

			[Display(Name = "64")]
			Second = 64,

			[Display(Name = "128")]
			Third = 128
		}

		#endregion

		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization) { ShowZeroValue = false };
		private Period _period = Period.First;
        private int _vPeriods;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DegreeOf2PeriodDescription), Order = 100)]
		public Period Length
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public HurstExponent()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();

				_vPeriods = (int)_period switch
				{
					32 => 3,
					64 => 4,
					128 => 5,
					_ => _vPeriods
				};
			}

			if (bar < (int)_period)
			{
				_renderSeries.SetPointOfEndLine(bar);
				return;
			}

			var shortLnSum = 0m;
			var shortAvgLnSum = 0m;
			var avgLnSum = 0m;
			var shortLnSquareSum = 0m;

			for (var pow = 3; Math.Pow(2, pow) <= (int)_period; pow++)
			{
				var shortPeriod = (int)Math.Pow(2, pow);
				var rescaledSum = 0m;

				for (var i = 0; i < (int)_period / shortPeriod; i++)
				{
					var mean = SourceDataSeries.CalcSum(shortPeriod, bar - i * shortPeriod) / shortPeriod;

					var adjSum = 0m;
					var maxSum = 0m;
					var minSum = 0m;
					var squareSum = 0m;

					for (var j = bar - i * shortPeriod; j >= bar - (i + 1) * shortPeriod; j--)
					{
						var diff = (decimal)SourceDataSeries[j] - mean;
						adjSum += diff;

						if (adjSum > maxSum || maxSum == 0)
							maxSum = adjSum;

						if (adjSum < minSum || minSum == 0)
							minSum = adjSum;

						squareSum += diff * diff;
					}

					var range = maxSum - minSum;

					var stdDev = (decimal)Math.Sqrt((double)(squareSum / shortPeriod));
					rescaledSum += range / stdDev;
				}

				var rescaledAvg = rescaledSum / shortPeriod;

				var shortLog = (decimal)Math.Log(shortPeriod);
				var rescaledLog = (decimal)Math.Log((double)rescaledAvg);

				shortLnSum += shortLog;
				avgLnSum += rescaledLog;
				shortAvgLnSum += shortLog * rescaledLog;
				shortLnSquareSum += shortLog * shortLog;
			}

			var exponent = (_vPeriods * shortAvgLnSum - shortLnSum * avgLnSum) / (_vPeriods * shortLnSquareSum - shortLnSum * shortLnSum);
			_renderSeries[bar] = Math.Abs(exponent);
		}

		#endregion
	}
}









Indicators/Technical
/Ichimoku.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Ichimoku Kinko Hyo")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.IchimokuDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602553")]
public class Ichimoku : Indicator
{
	#region Fields

	private readonly ValueDataSeries _baseLine = new("BaseLine", "Base")
	{
		Color = System.Drawing.Color.FromArgb(255, 153, 21, 21).Convert(),
        DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
    };

    private readonly ValueDataSeries _conversionLine = new("ConversionLine", "Conversion") 
	{ 
		Color = System.Drawing.Color.FromArgb(255, 4, 150, 255).Convert(),
        DescriptionKey = nameof(Strings.ConversionLineSettingsDescription)
    };

    private readonly ValueDataSeries _laggingSpan = new("LaggingSpan", "Lagging Span")
	{ 
		Color = System.Drawing.Color.FromArgb(255, 69, 153, 21).Convert(),
        DescriptionKey = nameof(Strings.LaggingLineSettingsDescription)
    };

    private readonly ValueDataSeries _leadLine1 = new("LeadLine1", "Lead1") 
	{
		Color = DefaultColors.Green.Convert(),
        DescriptionKey = nameof(Strings.TopChannelSettingsDescription)
    };

    private readonly ValueDataSeries _leadLine2 = new("LeadLine2", "Lead2") 
	{ 
		Color = DefaultColors.Red.Convert(),
        DescriptionKey = nameof(Strings.BottomChannelSettingsDescription)
    };

    private readonly RangeDataSeries _upSeries = new("UpSeries", "Up")
    {
        RangeColor = System.Drawing.Color.FromArgb(50, 0, 255, 0).Convert(),
        DrawAbovePrice = false,
        DescriptionKey = nameof(Strings.UpAreaSettingsDescription)
    };

	private readonly RangeDataSeries _downSeries = new("DownSeries", "Down")
	{
		RangeColor = System.Drawing.Color.FromArgb(50, 255, 0, 0).Convert(),
		DrawAbovePrice = false,
		DescriptionKey = nameof(Strings.DownAreaSettingsDescription)
	};

    private readonly Highest _baseHigh = new() { Period = 26 };
    private readonly Lowest _baseLow = new() { Period = 26 };
	private readonly Highest _conversionHigh = new() { Period = 9 };
	private readonly Lowest _conversionLow = new() { Period = 9 };
	private readonly Highest _spanHigh = new() { Period = 52 };
	private readonly Lowest _spanLow = new() { Period = 52 };
	
    private int _days;
	private int _displacement = 26;
	private int _targetBar;
	private int _lastBar;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
    [Range(0, 10000)]
	public int Days
	{
		get => _days;
		set
		{
			_days = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = "TenkanSen", GroupName = nameof(Strings.Settings), Description = nameof(Strings.ConversionLinePeriodDescription), Order = 100)]
	[Range(1, 10000)]
	public int Tenkan
	{
		get => _conversionHigh.Period;
		set
		{
			_conversionHigh.Period = _conversionLow.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
	[Display(ResourceType = typeof(Strings), Name = "KijunSen", GroupName = nameof(Strings.Settings), Description = nameof(Strings.BaseLinePeriodDescription), Order = 110)]
	[Range(1, 10000)]
	public int Kijun
	{
		get => _baseHigh.Period;
		set
		{
			_baseHigh.Period = _baseLow.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = "SenkouSpanB", GroupName = nameof(Strings.Settings), Description = nameof(Strings.LaggingLinePeriodDescription), Order = 120)]
    [Range(1, 10000)]
	public int Senkou
	{
		get => _spanHigh.Period;
		set
		{
			_spanHigh.Period = _spanLow.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = "Displacement", GroupName = nameof(Strings.Settings), Description = nameof(Strings.BarShiftDescription), Order = 130)]
    [Range(1, 10000)]
	public int Displacement
	{
		get => _displacement;
		set
		{
			_displacement = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public Ichimoku()
		: base(true)
	{
		DenyToChangePanel = true;
		SupportsExtendedSeries = true;

        DataSeries[0] = _conversionLine;
		DataSeries.Add(_baseLine);
        DataSeries.Add(_laggingSpan);
        DataSeries.Add(_leadLine1);
		DataSeries.Add(_leadLine2);
		DataSeries.Add(_upSeries);
		DataSeries.Add(_downSeries);
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		if (bar == 0)
		{
			DataSeries.ForEach(x => x.Clear());
			_targetBar = 0;

			if (_days > 0)
			{
				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}

				if (_targetBar > 0)
				{
					_conversionLine.SetPointOfEndLine(_targetBar - 1);
					_laggingSpan.SetPointOfEndLine(_targetBar - _displacement - 1);
					_baseLine.SetPointOfEndLine(_targetBar - 1);
				}
			}

			_leadLine1.SetPointOfEndLine(_targetBar + _displacement - 2);
			_leadLine2.SetPointOfEndLine(_targetBar + _displacement - 2);
        }

		_conversionHigh.Calculate(bar, candle.High);
		_conversionLow.Calculate(bar, candle.Low);

		_baseHigh.Calculate(bar, candle.High);
		_baseLow.Calculate(bar, candle.Low);

		_spanHigh.Calculate(bar, candle.High);
		_spanLow.Calculate(bar, candle.Low);

		if (bar < _targetBar)
			return;

		_baseLine[bar] = (_baseHigh[bar] + _baseLow[bar]) / 2;
		_conversionLine[bar] = (_conversionHigh[bar] + _conversionLow[bar]) / 2;

		var lineBar = bar + Displacement - 1;
		_leadLine1[lineBar] = (_conversionLine[bar] + _baseLine[bar]) / 2;
		_leadLine2[lineBar] = (_spanHigh[bar] + _spanLow[bar]) / 2;

		if (bar - _displacement + 1 >= 0)
		{
			var targetBar = bar - _displacement + 1;
			_laggingSpan[targetBar] = candle.Close;

			if (bar != _lastBar && bar == CurrentBar - 1)
			{
				_laggingSpan.RemovePointOfEndLine(targetBar - 1);
				_laggingSpan.SetPointOfEndLine(targetBar);
            }

			_lastBar = bar;
		}

		if (_leadLine1[lineBar] == 0 || _leadLine2[lineBar] == 0)
			return;

		if (_leadLine1[lineBar] > _leadLine2[lineBar])
		{
			_upSeries[lineBar].Upper = _leadLine1[lineBar];
			_upSeries[lineBar].Lower = _leadLine2[lineBar];

			if (_leadLine1[lineBar - 1] < _leadLine2[lineBar - 1])
				_downSeries[lineBar] = _upSeries[lineBar];
		}
		else
		{
			_downSeries[lineBar].Upper = _leadLine2[lineBar];
			_downSeries[lineBar].Lower = _leadLine1[lineBar];

			if (_leadLine1[lineBar - 1] > _leadLine2[lineBar - 1])
				_upSeries[lineBar] = _downSeries[lineBar];
		}
	}

	#endregion
}








Technical/ImbalanceRatio.cs









namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;

using ATAS.DataFeedsCore;

using MoreLinq;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

using Color = System.Drawing.Color;

[DisplayName("Imbalance Ratio")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.ImbalanceRatioIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602404")]
public class ImbalanceRatio : Indicator
{
	#region Fields

	private readonly CrossColor _transparent = Color.Transparent.Convert();

	private Color _buyColor = Color.Blue;
	private RenderFont _font = new("Arial", 9);
	private RenderStringFormat _format = new() { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center };
	private int _imbalanceRatio = 4;
	private PriceSelectionDataSeries _renderSeries = new("RenderSeries", Strings.ImbalanceRange) { IsHidden = true };
	private Color _sellColor = Color.Red;
	private Color _textColor = Color.White;
	private int _transparency = 50;
	private int _volumeFilter;

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ImbalanceRatio), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinRatioValueDescription), Order = 100)]
	[Range(1, 10000)]
	public int Ratio
	{
		get => _imbalanceRatio;
		set
		{
			_imbalanceRatio = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VolumeFilter), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinVolumeFilterDescription), Order = 110)]
	[Range(0, 1000000000)]
	public int VolumeFilter
	{
		get => _volumeFilter;
		set
		{
			_volumeFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BuySignalColorDescription), Order = 200)]
	public CrossColor BuyColor
	{
		get => _buyColor.Convert();
		set
		{
			_buyColor = value.Convert();

			for (var i = 0; i < _renderSeries.Count; i++)
			{
				_renderSeries[i].ForEach(x =>
				{
					if ((OrderDirections)x.Context == OrderDirections.Buy)
					{
						x.PriceSelectionColor =
                            CrossColor.FromArgb((byte)Math.Floor(255 * _transparency / 100m), value.R, value.G, value.B);
					}
				});
			}
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.SellSignalColorDescription), Order = 210)]
	public CrossColor SellColor
	{
		get => _sellColor.Convert();
		set
		{
			_sellColor = value.Convert();

			for (var i = 0; i < _renderSeries.Count; i++)
			{
				_renderSeries[i].ForEach(x =>
				{
					if ((OrderDirections)x.Context == OrderDirections.Sell)
					{
						x.PriceSelectionColor =
							CrossColor.FromArgb((byte)Math.Floor(255 * _transparency / 100m), value.R, value.G, value.B);
					}
				});
			}
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LabelTextColorDescription), Order = 220)]
	public CrossColor TextColor
	{
		get => _textColor.Convert();
		set => _textColor = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ClusterSelectionTransparency), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PriceSelectionTransparencyDescription), Order = 230)]
	[Range(0, 100)]
	public int Transparency
	{
		get => _transparency;
		set
		{
			_transparency = value;

			for (var i = 0; i < _renderSeries.Count; i++)
			{
				_renderSeries[i].ForEach(x =>
					x.PriceSelectionColor = CrossColor.FromArgb((byte)Math.Floor(255 * value / 100m), x.PriceSelectionColor.R,
						x.PriceSelectionColor.G, x.PriceSelectionColor.B));
			}
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTopBlock), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowTopElementsDescription), Order = 240)]
	public bool ShowTop { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowBotBlock), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowBottomElementsDescription), Order = 250)]
	public bool ShowBot { get; set; } = true;

	#endregion

	#region ctor

	public ImbalanceRatio()
		: base(true)
	{
		DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Final);

		DataSeries[0] = _renderSeries;
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    _buyColor = ChartInfo.ColorsStore.FootprintAskColor;
	    _sellColor = ChartInfo.ColorsStore.FootprintBidColor;
	    _textColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor;
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		var barWidth = ChartInfo.GetXByBar(1) - ChartInfo.GetXByBar(0);
		var priceHeight = ChartInfo.GetYByPrice(0) - ChartInfo.GetYByPrice(InstrumentInfo.TickSize);

		for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
		{
			var candle = GetCandle(i);
			var buyRows = _renderSeries[i].Count(x => (OrderDirections)x.Context == OrderDirections.Buy);
			var sellRows = _renderSeries[i].Count(x => (OrderDirections)x.Context == OrderDirections.Sell);

			var y = ChartInfo.GetYByPrice(
				candle.Delta >= 0
					? candle.Low - 2 * InstrumentInfo.TickSize
					: candle.High + 2 * InstrumentInfo.TickSize);

			if ((candle.Delta >= 0 && !ShowBot) || (candle.Delta < 0 && !ShowTop))
				continue;

			var rect = new Rectangle(ChartInfo.GetXByBar(i), y, barWidth, priceHeight);
			context.FillRectangle(candle.Delta >= 0 ? _buyColor : _sellColor, rect);

			var renderText = $"{buyRows}x{sellRows}";
			context.DrawString(renderText, _font, _textColor, rect, _format);
		}
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);
		_renderSeries[bar].Clear();

		for (var i = candle.High; i > candle.Low; i -= InstrumentInfo.TickSize)
		{
			var upperInfo = candle.GetPriceVolumeInfo(i);
			var lowerInfo = candle.GetPriceVolumeInfo(i - InstrumentInfo.TickSize);

			if (lowerInfo == default || upperInfo == default)
				continue;

			if (lowerInfo.Volume + upperInfo.Volume < _volumeFilter || lowerInfo.Bid == 0)
				continue;

			if (upperInfo.Ask / lowerInfo.Bid < _imbalanceRatio)
				continue;

			_renderSeries[bar].Add(new PriceSelectionValue(i)
			{
				Context = OrderDirections.Buy,
				ObjectColor = _transparent,
				PriceSelectionColor = CrossColor.FromArgb((byte)Math.Floor(255 * _transparency / 100m), BuyColor.R, BuyColor.G, BuyColor.B),
				VisualObject = ObjectType.OnlyCluster
			});
		}

		for (var i = candle.Low; i < candle.High; i += InstrumentInfo.TickSize)
		{
			var lowerInfo = candle.GetPriceVolumeInfo(i);
			var upperInfo = candle.GetPriceVolumeInfo(i + InstrumentInfo.TickSize);

			if (lowerInfo == default || upperInfo == default)
				continue;

			if (lowerInfo.Volume + upperInfo.Volume < _volumeFilter || upperInfo.Ask == 0)
				continue;

			if (lowerInfo.Bid / upperInfo.Ask < _imbalanceRatio)
				continue;

			_renderSeries[bar].Add(new PriceSelectionValue(i)
			{
				Context = OrderDirections.Sell,
				ObjectColor = _transparent,
				PriceSelectionColor =
					CrossColor.FromArgb((byte)Math.Floor(255 * _transparency / 100m), SellColor.R, SellColor.G, SellColor.B),
				VisualObject = ObjectType.OnlyCluster
			});
		}
	}

	#endregion
}









Technical/Indicators.Technical.csproj









<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>ATAS.Indicators.Technical</RootNamespace>
    <AssemblyName>ATAS.Indicators.Technical</AssemblyName>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    <LangVersion>latest</LangVersion>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\..\..\GitLab\OFT\OFT.snk</AssemblyOriginatorKeyFile>
    <Configurations>Debug;Release;Publish</Configurations>
    <Platforms>AnyCPU;Cross</Platforms>
  </PropertyGroup>

	<PropertyGroup Condition=" '$(Platform)' == 'Cross' ">
		<UseWPF>False</UseWPF>
		<DefineConstants>$(DefineConstants);CROSS_PLATFORM</DefineConstants>
		<TargetFramework>net8.0</TargetFramework>
	</PropertyGroup>

	<PropertyGroup Condition=" '$(Platform)' != 'Cross' ">
		<UseWPF>True</UseWPF>
		<TargetFramework>net8.0-windows</TargetFramework>
	</PropertyGroup>

  <PropertyGroup Condition=" '$(Configuration)' == 'Publish' ">
    <Optimize Condition=" '$(Optimize)' == '' ">true</Optimize>
  </PropertyGroup>

  <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk.WindowsDesktop" Condition=" '$(Platform)' != 'Cross' " />
  <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk.WindowsDesktop" Condition=" '$(Platform)' != 'Cross' " />
  
  <ItemGroup>
    <ProjectReference Include="..\..\..\GitLab\OFT\Attributes\Attributes.csproj" />
    <ProjectReference Include="..\..\..\GitLab\OFT\DataFeedsCore\DataFeedsCore.csproj" />
    <ProjectReference Include="..\..\..\GitLab\OFT\Indicators\Indicators.csproj" />
    <ProjectReference Include="..\..\..\GitLab\oft\Localization\Localization.csproj" />
    <ProjectReference Include="..\..\..\GitLab\oft\Renders\Rendering\Rendering.csproj" />
    <ProjectReference Include="..\..\..\GitLab\Utils\Common\Common.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\..\..\GitLab\OFT\OFTAssemblyInfo.cs" Link="Properties\OFTAssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>PublicResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

  <ItemGroup Condition=" '$(Platform)' == 'Cross' ">
	  <Compile Remove="**\*.Windows.cs" />
	  <None Include="**\*.Windows.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />

	  <Compile Remove="**\*.xaml.cs" />
	  <None Include="**\*.xaml.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />

	  <Compile Remove="**\*.xaml" />
	  <None Include="**\*.xaml" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
  </ItemGroup>

  <ItemGroup Condition=" '$(Platform)' != 'Cross' ">
	  <Compile Remove="**\*.Common.cs" />
	  <None Include="**\*.Common.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
	  <ProjectReference Include="..\..\..\GitLab\Utils\Windows\Windows.csproj" />
  </ItemGroup>
</Project>








Technical/Indicators.Technical.csproj.DotSettings





<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeInspection/CSharpLanguageProject/LanguageLevel/@EntryValue">Preview</s:String></wpf:ResourceDictionary>






Technical/Inertia.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Inertia")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.InertiaIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602555")]
	public class Inertia : Indicator
	{
		#region Fields

		private readonly LinearReg _linReg = new() { Period = 14 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly RVI2 _rvi = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RVI), GroupName = nameof(Strings.Period), Description = nameof(Strings.RVIPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int RviPeriod
		{
			get => _rvi.Period;
			set
			{
				_rvi.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LinearReg), GroupName = nameof(Strings.Period), Description = nameof(Strings.LinearRegPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int LinearRegPeriod
		{
			get => _linReg.Period;
			set
			{
				_linReg.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Inertia()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			Add(_rvi);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = _linReg.Calculate(bar, _rvi[bar]);
		}

		#endregion
	}
}








Technical/Inertia2.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Inertia V2")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.InertiaV2IndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602405")]
	public class Inertia2 : Indicator
	{
		#region Fields

		private readonly LinearReg _linReg = new() { Period = 14 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly RVI2 _rvi = new();
		private readonly StdDev _stdDev = new();
		private readonly ValueDataSeries _stdDown = new("StdDown");
		private readonly ValueDataSeries _stdUp = new("StdUp");
		private int _rviPeriod = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RVI), GroupName = nameof(Strings.Period), Description = nameof(Strings.RVIPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int RviPeriod
		{
			get => _rviPeriod;
			set
			{
				_rviPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LinearReg), GroupName = nameof(Strings.Period), Description = nameof(Strings.LinearRegPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int LinearRegPeriod
		{
			get => _linReg.Period;
			set
			{
				_linReg.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.StdDev), GroupName = nameof(Strings.Period), Description = nameof(Strings.StdDevPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int StdDevPeriod
		{
			get => _stdDev.Period;
			set
			{
				_stdDev.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Inertia2()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			Add(_rvi);
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_stdDev.Calculate(bar, candle.Close);

			if (bar == 0)
			{
				_stdUp.Clear();
				_stdDown.Clear();
				_renderSeries.Clear();
				return;
			}

			var prevCandle = GetCandle(bar - 1);

			var rviUp = 0m;
			var rviDown = 0m;

			if (candle.Close > prevCandle.Close)
				rviUp = _stdDev[bar];
			else
				rviDown = _stdDev[bar];

			_stdUp[bar] = (_stdUp[bar - 1] * (_rviPeriod - 1) + rviUp) / _rviPeriod;
			_stdDown[bar] = (_stdDown[bar - 1] * (_rviPeriod - 1) + rviDown) / _rviPeriod;

			var rvix = 0m;

			if (_stdUp[bar] + _stdDown[bar] != 0)
				rvix = 100m * _stdUp[bar] / (_stdUp[bar] + _stdDown[bar]);

			_renderSeries[bar] = _linReg.Calculate(bar, rvix);
		}

		#endregion
	}
}








Technical/InitialBalance.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Settings;

using Pen = System.Drawing.Pen;

[DisplayName("Initial Balance")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.InitialBalanceIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602294")]
public class InitialBalance : Indicator
{
	#region Nested types

	public enum PeriodType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Minutes))]
		Minutes,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bars))]
		Bars
	}

	#endregion

	#region Fields

	private readonly ValueDataSeries _ibh = new("Ibh", "IBH")
	{
		Color = DefaultColors.Blue.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1,
		DescriptionKey = nameof(Strings.TopBandDscription)
	};

	private readonly ValueDataSeries _ibhx1 = new("Ibhx1", "IBHX1")
	{
		Color = DefaultColors.Fuchsia.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1
	};

	private readonly ValueDataSeries _ibhx2 = new("Ibhx2", "IBHX2")
	{
		Color = DefaultColors.Fuchsia.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1
	};

	private readonly ValueDataSeries _ibhx3 = new("Ibhx3", "IBHX3")
	{
		Color = DefaultColors.Fuchsia.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1
	};

	private readonly ValueDataSeries _ibl = new("Ibl", "IBL")
	{
		Color = DefaultColors.Red.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1,
        DescriptionKey = nameof(Strings.BottomBandDscription)
    };

	private readonly ValueDataSeries _iblx1 = new("Iblx1", "IBLX1")
	{
		Color = DefaultColors.Purple.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1
	};

	private readonly ValueDataSeries _iblx2 = new("Iblx2", "IBLX2")
	{
		Color = DefaultColors.Purple.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1
	};

	private readonly ValueDataSeries _iblx3 = new("Iblx3", "IBLX3")
	{
		Color = DefaultColors.Purple.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1
	};

	private readonly ValueDataSeries _ibm = new("Ibm", "IBM")
	{
		Color = DefaultColors.Green.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		VisualType = VisualMode.Square,
		Width = 1,
        DescriptionKey = nameof(Strings.MidBandDescription)
    };

	private readonly ValueDataSeries _mid = new("MidId", "Mid")
	{
		Color = CrossColor.FromArgb(0, 0, 255, 0),
		LineDashStyle = LineDashStyle.Solid,
		VisualType = VisualMode.Square,
		Width = 1,
        DescriptionKey = nameof(Strings.SessionAveragePriceDescription)
    };

	private RangeDataSeries _ibhx32 = new("Ibhx32", "ibhx32")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
		DrawAbovePrice = false,
		IsHidden = true
	};
	private RangeDataSeries _ibhx21 = new("Ibhx21", "ibhx21")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};
	private RangeDataSeries _ibhx1h = new("Ibhx1h", "ibhx1h")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};
	private RangeDataSeries _ibHm = new("IbHm", "ibHm")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};
	private RangeDataSeries _ibMl = new("IbM1", "ibM1")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};
	private RangeDataSeries _ibl1 = new("Ibl1", "ibl1")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};
	private RangeDataSeries _iblx12 = new("Ibl12", "ibl12")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};
	private RangeDataSeries _iblx23 = new("Ibl23", "ibl23")
	{
		RangeColor = System.Drawing.Color.Transparent.Convert(),
        DrawAbovePrice = false,
        IsHidden = true
	};

    private CrossColor _borderColor = DefaultColors.Red.Convert();
	private int _borderWidth = 1;
	private bool _calculate;
	private bool _customSessionStart;
	private int _days = 20;
    private bool _drawText = true;
	private TimeSpan _endDate;
	private DateTime _endTime = DateTime.MaxValue;
	private CrossColor _fillColor = DefaultColors.Yellow.Convert();
	private bool _highLowIsSet;
	private decimal _ibMax = decimal.MinValue;
	private decimal _ibMin = decimal.MaxValue;
	private decimal _ibmValue = decimal.Zero;

	private bool _initialized;
	private int _lastStartBar = -1;
	private decimal _maxValue = decimal.MinValue;
	private decimal _minValue = decimal.MaxValue;
	private int _period = 60;
	private PeriodType _periodMode = PeriodType.Minutes;
	private DrawingRectangle _rectangle = new(0, 0, 0, 0, Pens.Gray, new SolidBrush(DefaultColors.Yellow));
	private bool _showOpenRange = true;
	private TimeSpan _startDate = new(9, 0, 0);
	private int _targetBar;
	private decimal _x1 = 1m;
	private decimal _x2 = 2m;
	private decimal _x3 = 3m;
	private decimal ibhx1 = decimal.Zero;
	private decimal ibhx2 = decimal.Zero;
	private decimal ibhx3 = decimal.Zero;
	private decimal iblx1 = decimal.Zero;
	private decimal iblx2 = decimal.Zero;
	private decimal iblx3 = decimal.Zero;
	private decimal mid = decimal.Zero;

	private bool _isStarted;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), 
		Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
    [Range(0, 1000)]
    public int Days
	{
		get => _days;
		set
		{
			_days = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show),
		GroupName = nameof(Strings.OpenRange), Description = nameof(Strings.ShowOpenRangeDescription), Order = 10)]
	public bool ShowOpenRange
	{
		get => _showOpenRange;
		set
		{
			_showOpenRange = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BorderWidth),
		GroupName = nameof(Strings.OpenRange), Description = nameof(Strings.BorderWidthPixelDescription), Order = 20)]
	[Range(1, 100)]
	public int BorderWidth
	{
		get => _borderWidth;
		set
		{
			_borderWidth = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BorderColor),
		GroupName = nameof(Strings.OpenRange), Description = nameof(Strings.BorderColorDescription),Order = 30)]
	public CrossColor BorderColor
	{
		get => _borderColor;
		set
		{
			_borderColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FillColor),
		GroupName = nameof(Strings.OpenRange), Description = nameof(Strings.FillColorDescription),Order = 40)]
	public CrossColor FillColor
	{
		get => _fillColor;
		set
		{
			_fillColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomSession),
		GroupName = nameof(Strings.SessionTime), Description = nameof(Strings.IsCustomSessionDescription),Order = 10)]
	public bool CustomSessionStart
	{
		get => _customSessionStart;
		set
		{
			_customSessionStart = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.StartTime),
		GroupName = nameof(Strings.SessionTime), Description = nameof(Strings.StartTimeDescription), Order = 20)]
	public TimeSpan StartDate
	{
		get => _startDate;
		set
		{
			_startDate = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.EndTime),
		GroupName = nameof(Strings.SessionTime), Description = nameof(Strings.EndTimeDescription), Order = 20)]
	public TimeSpan EndDate
	{
		get => _endDate;
		set
		{
			_endDate = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period),
		GroupName = nameof(Strings.SessionTime), Description = nameof(Strings.PeriodDescription), Order = 30)]
	[Range(1, 10000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodType),
		GroupName = nameof(Strings.SessionTime), Description = nameof(Strings.PeriodTypeDescription), Order = 40)]
	public PeriodType PeriodMode
	{
		get => _periodMode;
		set
		{
			_periodMode = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier1),
		GroupName = nameof(Strings.Multiplier), Description = nameof(Strings.MultiplierDescription), Order = 100)]
	public decimal X1
	{
		get => _x1;
		set
		{
			_x1 = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier2),
		GroupName = nameof(Strings.Multiplier), Description = nameof(Strings.MultiplierDescription),Order = 110)]
	public decimal X2
	{
		get => _x2;
		set
		{
			_x2 = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier3),
		GroupName = nameof(Strings.Multiplier), Description = nameof(Strings.MultiplierDescription), Order = 120)]
	public decimal X3
	{
		get => _x3;
		set
		{
			_x3 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text),
		GroupName = nameof(Strings.Show), Description = nameof(Strings.IsNeedShowLabelDescription), Order = 130)]
	public bool DrawText
	{
		get => _drawText;
		set
		{
			_drawText = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBHX32), 
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 200)]
	public CrossColor Ibhx32
	{
		get=>_ibhx32.RangeColor; 
		set=>_ibhx32.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBHX21),
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription),Order = 210)]
	public CrossColor Ibhx21 
	{
		get => _ibhx21.RangeColor;
		set => _ibhx21.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBHX1H),
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 220)]
	public CrossColor Ibhx1h 
	{
		get => _ibhx1h.RangeColor;
		set => _ibhx1h.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBHM), 
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 230)]
	public CrossColor IbHm
	{
		get => _ibHm.RangeColor;
		set => _ibHm.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBML), 
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 240)]
	public CrossColor IbMl
	{
		get => _ibMl.RangeColor;
		set => _ibMl.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBL1), 
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 250)]
	public CrossColor Ibl1
	{
		get => _ibl1.RangeColor;
		set => _ibl1.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBLX12),
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 260)]
	public CrossColor Iblx12
	{
		get => _iblx12.RangeColor;
		set => _iblx12.RangeColor = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IBLX23),
		GroupName = nameof(Strings.BackGround), Description = nameof(Strings.AreaColorDescription), Order = 270)]
	public CrossColor Iblx23
	{
		get => _iblx23.RangeColor;
		set => _iblx23.RangeColor = value;
	}

    #endregion
	
    #region ctor

    public InitialBalance()
		: base(true)
	{
		DenyToChangePanel = true;

        DataSeries[0] = _mid;
        DataSeries.Add(_ibh);
		DataSeries.Add(_ibl);
		DataSeries.Add(_ibm);
		DataSeries.Add(_ibhx1);
		DataSeries.Add(_ibhx2);
		DataSeries.Add(_ibhx3);
		DataSeries.Add(_iblx1);
		DataSeries.Add(_iblx2);
		DataSeries.Add(_iblx3);

		DataSeries.Add(_ibhx32);
		DataSeries.Add(_ibhx21);
		DataSeries.Add(_ibhx1h);
		DataSeries.Add(_ibHm);
		DataSeries.Add(_ibMl);
		DataSeries.Add(_ibl1);
		DataSeries.Add(_iblx12);
		DataSeries.Add(_iblx23);

		_ibh.PropertyChanged += DataSeriesPropertyChanged;
		_ibl.PropertyChanged += DataSeriesPropertyChanged;
		_ibm.PropertyChanged += DataSeriesPropertyChanged;
		_ibhx1.PropertyChanged += DataSeriesPropertyChanged;
		_ibhx2.PropertyChanged += DataSeriesPropertyChanged;
		_ibhx3.PropertyChanged += DataSeriesPropertyChanged;
		_iblx1.PropertyChanged += DataSeriesPropertyChanged;
		_iblx2.PropertyChanged += DataSeriesPropertyChanged;
		_iblx3.PropertyChanged += DataSeriesPropertyChanged;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			DataSeries.ForEach(x => x.Clear());
			ibhx1 = decimal.Zero;
			ibhx2 = decimal.Zero;
			ibhx3 = decimal.Zero;
			iblx1 = decimal.Zero;
			iblx2 = decimal.Zero;
			iblx3 = decimal.Zero;
			mid = decimal.Zero;
			_maxValue = decimal.MinValue;
			_minValue = decimal.MaxValue;
			_ibMax = decimal.MinValue;
			_ibMin = decimal.MaxValue;
			_ibmValue = decimal.Zero;
			_highLowIsSet = false;
			_lastStartBar = -1;
			_endTime = DateTime.MaxValue;
			_calculate = false;
			_initialized = false;
			_targetBar = 0;
			_isStarted = false;

            if (_days <= 0)
				return;

			var days = 0;

			for (var i = CurrentBar - 1; i >= 0; i--)
			{
				_targetBar = i;

				if (!IsNewSession(i))
					continue;

				days++;

				if (days == _days)
					break;
			}
		}

		if (bar < _targetBar)
			return;

		_initialized = true;
		var candle = GetCandle(bar);

		var time = candle.Time.AddHours(InstrumentInfo.TimeZone).TimeOfDay;
		var lastTime = candle.LastTime.AddHours(InstrumentInfo.TimeZone).TimeOfDay;
		
        if (CustomSessionStart)
		{
			bool inSession;

            if (StartDate < EndDate)
				inSession = (time >= StartDate || lastTime >= StartDate) && time < EndDate;
			else if (StartDate > EndDate)
			{
				inSession = ((time >= StartDate || lastTime >= StartDate) && time > EndDate)
						 || ((time <= EndDate || lastTime <= EndDate) && time < EndDate);
            }
			else
				inSession = true;

            if (!inSession)
			{
				_isStarted = false;

                foreach (var dataSeries in DataSeries)
					if (dataSeries is ValueDataSeries series)
						series.SetPointOfEndLine(bar - 1);
                return;
			}
		}

        var candleFullDateTime = candle.Time.AddHours(InstrumentInfo.TimeZone);
		var isStart = false;
		var isEnd = false;

        if (!_isStarted)
		{
			isStart = _customSessionStart
				   ? bar != 0 && (time >= StartDate || lastTime >= StartDate) && (GetPrevDateTime(bar).TimeOfDay < StartDate || GetPrevDateTime(bar).Date < candleFullDateTime.Date)
				   : IsNewSession(bar);
        }

        if (_isStarted)
		{
			isEnd = (PeriodMode is PeriodType.Minutes && candleFullDateTime >= _endTime && GetPrevDateTime(bar) < _endTime)
				 || (PeriodMode is PeriodType.Bars && bar - _lastStartBar >= Period);
        }           

		if (isStart)
		{
			//Clear all values
			_maxValue = decimal.MinValue;
			_minValue = decimal.MaxValue;
			_ibMax = decimal.MinValue;
			_ibMin = decimal.MaxValue;
			_ibmValue = decimal.Zero;
			ibhx1 = decimal.Zero;
			ibhx2 = decimal.Zero;
			ibhx3 = decimal.Zero;
			iblx1 = decimal.Zero;
			iblx2 = decimal.Zero;
			iblx3 = decimal.Zero;
			_calculate = true;
			_highLowIsSet = false;
			_lastStartBar = bar;
			_endTime = candleFullDateTime.AddMinutes(_period);
            _isStarted = true;

            foreach (var dataSeries in DataSeries)
                if (dataSeries is ValueDataSeries series)
                    series.SetPointOfEndLine(bar - 1);

            if (ShowOpenRange)
			{
				var pen = new Pen(ConvertColor(_borderColor))
				{
					Width = _borderWidth
				};
				var brush = new SolidBrush(ConvertColor(_fillColor));

				_rectangle = new DrawingRectangle(bar, decimal.Zero, bar, decimal.Zero, pen, brush);

				if (Rectangles.LastOrDefault()?.FirstBar == bar)
					Rectangles.RemoveAt(Rectangles.Count - 1);

				Rectangles.Add(_rectangle);
			}
		}
		else if (isEnd)
		{
			_calculate = _isStarted = false;
        }

		if (_calculate)
		{
			if (candle.High > _maxValue)
			{
				_highLowIsSet = true;
				_ibMax = _maxValue = candle.High;
			}

			if (candle.Low < _minValue)
			{
				_highLowIsSet = true;
				_ibMin = _minValue = candle.Low;
			}

			if (ShowOpenRange)
			{
				_rectangle.SecondBar = bar;
				_rectangle.FirstPrice = _ibMax;
				_rectangle.SecondPrice = _ibMin;
			}
		}

		if (candle.High > _maxValue)
			_maxValue = candle.High;

		if (candle.Low < _minValue)
			_minValue = candle.Low;

		if (!_highLowIsSet)
			return;

		_mid[bar] = mid = (_minValue + _maxValue) / 2m;
		_ibh[bar] = _ibMax;
		_ibl[bar] = _ibMin;
		_ibmValue = _ibm[bar] = (_ibMin + _ibMax) / 2m;
		var diff = _ibMax - _ibMin;

		ibhx1 = _ibhx1[bar] = _ibMax + diff * _x1;
		ibhx2 = _ibhx2[bar] = _ibMax + diff * _x2;
		ibhx3 = _ibhx3[bar] = _ibMax + diff * _x3;
		iblx1 = _iblx1[bar] = _ibMin - diff * _x1;
		iblx2 = _iblx2[bar] = _ibMin - diff * _x2;
		iblx3 = _iblx3[bar] = _ibMin - diff * _x3;

		_ibhx32[bar].Upper = ibhx3;
		_ibhx32[bar].Lower = _ibhx21[bar].Upper = ibhx2;
		_ibhx21[bar].Lower = _ibhx1h[bar].Upper = ibhx1;
		_ibhx1h[bar].Lower = _ibHm[bar].Upper = _ibh[bar];
		_ibHm[bar].Lower = _ibMl[bar].Upper = _ibm[bar];
		_ibMl[bar].Lower = _ibl1[bar].Upper = _ibl[bar];
		_ibl1[bar].Lower = _iblx12[bar].Upper = iblx1;
		_iblx12[bar].Lower = _iblx23[bar].Upper = iblx2;
		_iblx23[bar].Lower = iblx3;

        if (DrawText)
		{
			AddText(_lastStartBar + "Mid", "Mid", true, bar, mid, 0, 0, ConvertColor(_mid.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBH", "IBH", true, bar, _ibMax, 0, 0, ConvertColor(_ibh.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBL", "IBL", true, bar, _ibMin, 0, 0, ConvertColor(_ibl.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBM", "IBM", true, bar, _ibmValue, 0, 0, ConvertColor(_ibm.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBHX1", "IBHX1", true, bar, ibhx1, 0, 0, ConvertColor(_ibhx1.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBHX2", "IBHX2", true, bar, ibhx2, 0, 0, ConvertColor(_ibhx2.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBHX3", "IBHX3", true, bar, ibhx3, 0, 0, ConvertColor(_ibhx3.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBLX1", "IBLX1", true, bar, iblx1, 0, 0, ConvertColor(_iblx1.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBLX2", "IBLX2", true, bar, iblx2, 0, 0, ConvertColor(_iblx2.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);

			AddText(_lastStartBar + "IBLX3", "IBLX3", true, bar, iblx3, 0, 0, ConvertColor(_iblx3.Color), System.Drawing.Color.Transparent,
				System.Drawing.Color.Transparent, 12.0f, DrawingText.TextAlign.Right);
		}
	}

    private DateTime GetPrevDateTime(int bar)
    {
		return GetCandle(bar - 1).Time.AddHours(InstrumentInfo.TimeZone);
    }

    #endregion

    #region Private methods

    private void DataSeriesPropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		if (!_initialized)
			return;

		RecalculateValues();
	}

	private System.Drawing.Color ConvertColor(CrossColor color)
	{
		return System.Drawing.Color.FromArgb(color.A, color.R, color.G, color.B);
	}

	#endregion
}









Technical/InsideEqualsBar.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Concurrent;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;

    [DisplayName("Inside Bar")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.InsideEqualsBarDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602245")]
	public class InsideEqualsBar : Indicator
	{
		#region Nested types

		public enum ToleranceMode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Ticks,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AbsolutePrice))]
			Price,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent))]
			Percent
		}

		public enum CandleAreaMode
        {
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow))]
            HighLow,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CandleBodyHeight))]
            Body
		}

        #endregion

        #region Fields

        private Color _areaColor = Color.FromArgb(100, 200, 200, 0);
		private int _currentStart;
		private ConcurrentDictionary<int, int> _insideRanges;
		private int _lastBar;
		private decimal _tolerance;
		private ToleranceMode _toleranceType;
        private CandleAreaMode _candleArea;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Tolerance), Description = nameof(Strings.ToleranceTypeDescription), Order = 100)]
		public ToleranceMode ToleranceType
		{
			get => _toleranceType;
			set
			{
				_toleranceType = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Value), GroupName = nameof(Strings.Tolerance), Description = nameof(Strings.ToleranceDescription), Order = 110)]
		[Range(0, 1000000)]
		public decimal Tolerance
		{
			get => _tolerance;
			set
			{
				_tolerance = _toleranceType is ToleranceMode.Ticks
					? Math.Round(value)
					: value;

				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CandleArea), GroupName = nameof(Strings.Tolerance), Description = nameof(Strings.CandleAreaModeDescription), Order = 120)]
        public CandleAreaMode CandleArea 
		{
			get => _candleArea;
			set
			{
                _candleArea = value;
				RecalculateValues();
            } 
		}

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AreaColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.AreaColorDescription), Order = 200)]
		public CrossColor AreaColor
		{
			get => _areaColor.Convert();
			set => _areaColor = value.Convert();
		}

		#endregion

		#region ctor

		public InsideEqualsBar()
			: base(true)
		{
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Final);

			DenyToChangePanel = true;

			DataSeries[0].IsHidden = true;
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
		}

		#endregion

		#region Protected methods

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			if (ChartInfo is null)
				return;

            var clusterMode = ChartInfo.ChartVisualMode == ChartVisualModes.Clusters;
			var rowHeight = ChartInfo.ChartVisualMode == ChartVisualModes.Clusters 
						  ? (int)ChartInfo.PriceChartContainer.PriceRowHeight 
					   	  : 0;

            foreach (var range in _insideRanges)
			{
				if (range.Value < FirstVisibleBarNumber || range.Key > LastVisibleBarNumber)
					continue;

				var candle = GetCandle(range.Key);
				var y1 = ChartInfo.GetYByPrice(candle.High, clusterMode);
				var y2 = ChartInfo.GetYByPrice(candle.Low, clusterMode);
				var x1 = ChartInfo.GetXByBar(range.Key, false);
				var x2 = ChartInfo.GetXByBar(range.Value, false);

				var rect = new Rectangle(x1, y1, x2 - x1, y2 - y1 + rowHeight);
				context.FillRectangle(_areaColor, rect);
			}
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_insideRanges = new ConcurrentDictionary<int, int>();
				_currentStart = -1;
				return;
			}

			if (_lastBar == bar || bar < 2)
				return;

			var candle = GetCandle(bar - 1);
			var startCandle = GetCandle(_currentStart == -1 ? bar - 2 : _currentStart);

			decimal upper, lower;

            switch (_candleArea)
            {
                case CandleAreaMode.Body:
					upper = Math.Max(candle.Open, candle.Close);
					lower = Math.Min(candle.Open, candle.Close);
                    break;
				default:
					upper = candle.High;
					lower = candle.Low;
					break;
            }

            var tolerant = ToleranceType switch
			{
				ToleranceMode.Ticks =>
					(upper - startCandle.High) / InstrumentInfo.TickSize <= Tolerance
					&& (startCandle.Low - lower) / InstrumentInfo.TickSize <= Tolerance,
				ToleranceMode.Price => upper - startCandle.High <= Tolerance
					&& startCandle.Low - lower <= Tolerance,
				ToleranceMode.Percent => 100 * (upper - startCandle.High) / startCandle.High <= Tolerance
					&& 100 * (startCandle.Low - lower) / startCandle.Low <= Tolerance,
				_ => throw new ArgumentOutOfRangeException()
			};

			if (tolerant)
			{
				if (_currentStart == -1)
					_currentStart = bar - 2;

				if (_insideRanges.ContainsKey(_currentStart))
					_insideRanges[_currentStart] = bar - 1;
				else
					_insideRanges.TryAdd(_currentStart, bar - 1);
			}
			else
				_currentStart = -1;

			_lastBar = bar;
        }

        #endregion
    }
}










Technical/KAMA.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Kaufman Adaptive Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.KAMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602525")]
	public class KAMA : Indicator
	{
		#region Fields

		private readonly List<decimal> _closeList = new();

		private int _efficiencyRatioPeriod = 10;
        private int _lastBar = -1;
        private int _longPeriod = 30;
        private int _shortPeriod = 2;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EfficiencyRatioPeriod), GroupName = nameof(Strings.Common), Description = nameof(Strings.PeriodDescription))]
		[Range(1, 10000)]
		public int EfficiencyRatioPeriod
		{
			get => _efficiencyRatioPeriod;
			set
			{
				_efficiencyRatioPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Common), Description = nameof(Strings.ShortPeriodDescription))]
		[Range(1, 10000)]
        public int ShortPeriod
		{
			get => _shortPeriod;
			set
			{
				if (value > LongPeriod)
					return;

				_shortPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Common), Description = nameof(Strings.LongPeriodDescription))]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _longPeriod;
			set
			{
				if (value < ShortPeriod)
					return;

				_longPeriod = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public KAMA()
			: base(true)
		{
			DenyToChangePanel = true;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var currentCandle = GetCandle(bar);
			var pastCandle = GetCandle(Math.Max(bar - EfficiencyRatioPeriod, 0));

			if (bar == 0)
			{
				_closeList.Clear();
				_closeList.Add(currentCandle.Close);
				this[bar] = currentCandle.Close;
				return;
			}

			if (_closeList.Count > EfficiencyRatioPeriod)
				_closeList.RemoveAt(0);

			var change = currentCandle.Close - pastCandle.Close;
			var volatilitySum = Math.Abs(currentCandle.Close - _closeList.LastOrDefault());

			for (var i = _closeList.Count - 1; i > 0; i--)
				volatilitySum += Math.Abs(_closeList[i] - _closeList[i - 1]);

			decimal er;

			if (volatilitySum == 0.0m)
				er = 1;
			else
				er = change / volatilitySum;

			var fastestConst = 2.0m / (ShortPeriod + 1.0m);
			var slowestConst = 2.0m / (LongPeriod + 1.0m);

			var sc = er * (fastestConst - slowestConst) + slowestConst;
			sc *= sc;

			this[bar] = this[bar - 1] + sc * (currentCandle.Close - this[bar - 1]);

			if (bar != _lastBar)
				_lastBar = bar;
			else
				_closeList.RemoveAt(_closeList.Count - 1);

			_closeList.Add(currentCandle.Close);
		}

		#endregion
	}
}







namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Kaufman Adaptive Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.KAMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602525")]
	public class KAMA : Indicator
	{
		#region Fields

		private readonly List<decimal> _closeList = new();

		private int _efficiencyRatioPeriod = 10;
        private int _lastBar = -1;
        private int _longPeriod = 30;
        private int _shortPeriod = 2;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EfficiencyRatioPeriod), GroupName = nameof(Strings.Common), Description = nameof(Strings.PeriodDescription))]
		[Range(1, 10000)]
		public int EfficiencyRatioPeriod
		{
			get => _efficiencyRatioPeriod;
			set
			{
				_efficiencyRatioPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Common), Description = nameof(Strings.ShortPeriodDescription))]
		[Range(1, 10000)]
        public int ShortPeriod
		{
			get => _shortPeriod;
			set
			{
				if (value > LongPeriod)
					return;

				_shortPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Common), Description = nameof(Strings.LongPeriodDescription))]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _longPeriod;
			set
			{
				if (value < ShortPeriod)
					return;

				_longPeriod = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public KAMA()
			: base(true)
		{
			DenyToChangePanel = true;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var currentCandle = GetCandle(bar);
			var pastCandle = GetCandle(Math.Max(bar - EfficiencyRatioPeriod, 0));

			if (bar == 0)
			{
				_closeList.Clear();
				_closeList.Add(currentCandle.Close);
				this[bar] = currentCandle.Close;
				return;
			}

			if (_closeList.Count > EfficiencyRatioPeriod)
				_closeList.RemoveAt(0);

			var change = currentCandle.Close - pastCandle.Close;
			var volatilitySum = Math.Abs(currentCandle.Close - _closeList.LastOrDefault());

			for (var i = _closeList.Count - 1; i > 0; i--)
				volatilitySum += Math.Abs(_closeList[i] - _closeList[i - 1]);

			decimal er;

			if (volatilitySum == 0.0m)
				er = 1;
			else
				er = change / volatilitySum;

			var fastestConst = 2.0m / (ShortPeriod + 1.0m);
			var slowestConst = 2.0m / (LongPeriod + 1.0m);

			var sc = er * (fastestConst - slowestConst) + slowestConst;
			sc *= sc;

			this[bar] = this[bar - 1] + sc * (currentCandle.Close - this[bar - 1]);

			if (bar != _lastBar)
				_lastBar = bar;
			else
				_closeList.RemoveAt(_closeList.Count - 1);

			_closeList.Add(currentCandle.Close);
		}

		#endregion
	}
}









Technical/KdFast.cs










namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("KD - Fast")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.KdFastDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602411")]
	public class KdFast : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _dSeries = new("DSeries", Strings.SMA)
		{
			Color = DefaultColors.Green.Convert(),
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.SmaSetingsDescription)
		};
		
		private readonly ValueDataSeries _kSeries = new("KSeries", Strings.Line) 
		{
			Color = DefaultColors.Red.Convert(),
            DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
        };

		private readonly Lowest _lowest = new() { Period = 10 };
        private readonly Highest _highest = new() { Period = 10 };
        private readonly SMA _sma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodK), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodKDescription), Order = 100)]
		[Range(1, 10000)]
        public int PeriodK
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodD), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDDescription), Order = 110)]
		[Range(1, 10000)]
		public int PeriodD
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public KdFast()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _kSeries;
			DataSeries.Add(_dSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			var high = _highest.Calculate(bar, candle.High);
			var low = _lowest.Calculate(bar, candle.Low);

			_kSeries[bar] = high != low
				? 100m * (candle.Close - low) / (high - low)
				: 100m;

			_dSeries[bar] = _sma.Calculate(bar, _kSeries[bar]);
		}

		#endregion
	}
}









Technical/KdSlow.cs









namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("KD - Slow")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.KdSlowDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602412")]
	public class KdSlow : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _dSeries = new("DSeries", Strings.SMA)
		{
			Color = DefaultColors.Green.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.SmaSetingsDescription)
        };

		private readonly ValueDataSeries _kSeries = new("KSeries", Strings.Line) 
		{ 
			Color = DefaultColors.Red.Convert(),
            DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
        };
        
		private readonly KdFast _kdFast = new()
		{
			PeriodD = 10,
			PeriodK = 10
		};

		private readonly SMA _dSma = new() { Period = 10 };
        private readonly SMA _kSma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodK), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.ShortPeriodKDescription), Order = 100)]
		[Range(1, 10000)]
		public int PeriodK
		{
			get => _kdFast.PeriodK;
			set
			{
				_kdFast.PeriodK = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodD), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.ShortPeriodDDescription), Order = 110)]
		[Range(1, 10000)]
        public int PeriodD
		{
			get => _kdFast.PeriodD;
			set
			{
				_kdFast.PeriodD = _kSma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodD), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.LongPeriodDDescription), Order = 120)]
		[Range(1, 10000)]
        public int SlowPeriodD
		{
			get => _dSma.Period;
			set
			{
				_dSma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public KdSlow()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			Add(_kdFast);
			DataSeries[0] = _kSeries;
			DataSeries.Add(_dSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_kSeries[bar] = _kSma.Calculate(bar, ((ValueDataSeries)_kdFast.DataSeries[0])[bar]);
			_dSeries[bar] = _dSma.Calculate(bar, ((ValueDataSeries)_kdFast.DataSeries[1])[bar]);
		}

		#endregion
	}
}









Technical/KeltnerChannel.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Keltner Channel")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.KeltnerChannelDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602574")]
	public class KeltnerChannel : Indicator
	{
		#region Fields

		private readonly ATR _atr = new() { Period = 34 };
		private readonly RangeDataSeries _keltner = new("Keltner", "BackGround")
		{
			DrawAbovePrice = false ,
            DescriptionKey = nameof(Strings.RangeAreaDescription)
        };

		private readonly SMA _sma = new() { Period = 34 };

        private int _days = 20;
        private decimal _koef = 4;
		private int _targetBar;
		private int _lastAlertTop;
		private bool _onLineTop;
		private int _lastAlertMid;
		private bool _onLineMid;
		private bool _onLineBot;
		private int _lastAlertBot;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        [Range(0, 1000)]
		public int Days
		{
			get => _days;
			set
			{
				_days = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Calculation),
            Description = nameof(Strings.SMAPeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
        public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = _atr.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.OffsetMultiplier),
			GroupName = nameof(Strings.Calculation),
            Description = nameof(Strings.ATRMultiplierDescription),
            Order = 20)]
		[Parameter]
		[Range(0.00000001, 10000000)]
        public decimal Koef
		{
			get => _koef;
			set
			{
				_koef = value;
				RecalculateValues();
			}
		}

        #region TopAlert
        
        [Display(ResourceType = typeof(Strings),
	        Name = nameof(Strings.UseAlerts),
	        GroupName = nameof(Strings.TopBand),
	        Description = nameof(Strings.UseAlertDescription),
	        Order = 100)]
        public bool UseAlertsTop { get; set; }

        [Display(ResourceType = typeof(Strings),
	        Name = nameof(Strings.RepeatAlert),
	        GroupName = nameof(Strings.TopBand),
	        Description = nameof(Strings.RepeatAlertDescription),
	        Order = 110)]
        public bool RepeatAlertTop { get; set; }

        [Display(ResourceType = typeof(Strings),
	        Name = nameof(Strings.ApproximationFilter),
	        GroupName = nameof(Strings.TopBand),
	        Description = nameof(Strings.ApproximationFilterDescription),
	        Order = 120)]
        [Range(0, 100000)]
        public int AlertSensitivityTop { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
	        Name = nameof(Strings.AlertFile),
	        GroupName = nameof(Strings.TopBand),
	        Description = nameof(Strings.AlertFileDescription),
	        Order = 130)]
        public string AlertFileTop { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
	        Name = nameof(Strings.FontColor),
	        GroupName = nameof(Strings.TopBand),
	        Description = nameof(Strings.AlertTextColorDescription),
	        Order = 140)]
        public CrossColor FontColorTop { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
	        Name = nameof(Strings.BackGround),
	        GroupName = nameof(Strings.TopBand),
	        Description = nameof(Strings.AlertFillColorDescription),
	        Order = 150)]
        public CrossColor BackgroundColorTop { get; set; } = DefaultColors.Gray.Convert();

		#endregion

		#region MidAlert

		[Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.UseAlerts),
            GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 200)]
        public bool UseAlertsMid { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.RepeatAlert),
            GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 210)]
        public bool RepeatAlertMid { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.ApproximationFilter),
            GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 220)]
        [Range(0, 100000)]
        public int AlertSensitivityMid { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.AlertFile),
            GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 230)]
        public string AlertFileMid { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.FontColor),
            GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 240)]
        public CrossColor FontColorMid { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.BackGround),
            GroupName = nameof(Strings.MiddleBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 250)]
        public CrossColor BackgroundColorMid { get; set; } = DefaultColors.Gray.Convert();

        #endregion

        #region BotAlert

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.UseAlerts),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 300)]
        public bool UseAlertsBot { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.RepeatAlert),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 310)]
        public bool RepeatAlertBot { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.ApproximationFilter),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 320)]
        [Range(0, 100000)]
        public int AlertSensitivityBot { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.AlertFile),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 330)]
        public string AlertFileBot { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.FontColor),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 340)]
        public CrossColor FontColorBot { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.BackGround),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 350)]
        public CrossColor BackgroundColorBot { get; set; } = DefaultColors.Gray.Convert();
		
        #endregion

		#endregion

		#region ctor

		public KeltnerChannel()
			: base(true)
		{
			DenyToChangePanel = true;

			DataSeries.Add(new ValueDataSeries("UpperId", "Upper")
			{
				VisualType = VisualMode.Line,
				DescriptionKey = nameof(Strings.TopBandDscription)
			});

			DataSeries.Add(new ValueDataSeries("LowerId", "Lower")
			{
				VisualType = VisualMode.Line,
                DescriptionKey = nameof(Strings.BottomBandDscription)
            });

			DataSeries.Add(_keltner);
			Add(_atr);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				_targetBar = 0;

				if (_days > 0)
				{
					var days = 0;

					for (var i = CurrentBar - 1; i >= 0; i--)
					{
						_targetBar = i;

						if (!IsNewSession(i))
							continue;

						days++;

						if (days == _days)
							break;
					}

					if (_targetBar > 0)
					{
						((ValueDataSeries)DataSeries[0]).SetPointOfEndLine(_targetBar - 1);
						((ValueDataSeries)DataSeries[1]).SetPointOfEndLine(_targetBar - 1);
						((ValueDataSeries)DataSeries[2]).SetPointOfEndLine(_targetBar - 1);
					}
				}
			}

			var currentCandle = GetCandle(bar);
			var ema = _sma.Calculate(bar, currentCandle.Close);

			if (bar < _targetBar)
				return;

			var atr = _atr[bar] * Koef;
			var upAtr = ema + atr;
			var downAtr = ema - atr;

            this[bar] = ema;
			DataSeries[1][bar] = upAtr;
			DataSeries[2][bar] = downAtr;
			_keltner[bar].Upper = upAtr;
			_keltner[bar].Lower = downAtr;

			if (bar != CurrentBar - 1)
				return;

			if (UseAlertsTop && (RepeatAlertTop || _lastAlertTop != bar && !RepeatAlertTop))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(upAtr - close) / InstrumentInfo.TickSize <= AlertSensitivityTop;

				if (onLine && !_onLineTop)
				{
					AddAlert(AlertFileTop, InstrumentInfo.Instrument, "Keltner top approximation alert", BackgroundColorTop, FontColorTop);
					_lastAlertTop = bar;
				}

				_onLineTop = onLine;
			}

			if (UseAlertsMid && (RepeatAlertMid || _lastAlertMid != bar && !RepeatAlertMid))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(this[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityMid;

				if (onLine && !_onLineMid)
				{
					AddAlert(AlertFileMid, InstrumentInfo.Instrument, "Keltner middle approximation alert", BackgroundColorMid, FontColorMid);
					_lastAlertMid = bar;
				}

				_onLineMid = onLine;
			}

			if (UseAlertsBot && (RepeatAlertBot || _lastAlertBot != bar && !RepeatAlertBot))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(downAtr - close) / InstrumentInfo.TickSize <= AlertSensitivityBot;

				if (onLine && !_onLineBot)
				{
					AddAlert(AlertFileTop, InstrumentInfo.Instrument, "Keltner bottom approximation alert", BackgroundColorBot, FontColorBot);
					_lastAlertBot = bar;
				}

				_onLineBot = onLine;
			}
		}

		#endregion
	}
}








Technical/Kurtosis.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Kurtosis")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.KurtosisDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602556")]
	public class Kurtosis : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _populationSeries = new("PopulationSeries", Strings.Line)
		{
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
		};

		private readonly ValueDataSeries _sampleSeries = new("SampleSeries", Strings.Estimator) 
		{ 
			Color = DefaultColors.Blue.Convert(),
            DescriptionKey = nameof(Strings.EstimatorLineSettingsDescription)
        };

        private readonly ValueDataSeries _quadSeries = new("Quad");
        private readonly ValueDataSeries _squareSeries = new("Square");
        private readonly SMA _sma = new();

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(4, 10000)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Kurtosis()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _populationSeries;
			DataSeries.Add(_sampleSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var diff = (double)(value - _sma.Calculate(bar, value));

			_squareSeries[bar] = (decimal)(diff * diff);
			_quadSeries[bar] = (decimal)(diff * diff * diff * diff);

			if (bar < Period)
				return;

			var squareSum = _squareSeries.CalcSum(Period, bar) / Period;
			var quadSum = _quadSeries.CalcSum(Period, bar) / Period;

			_populationSeries[bar] = quadSum / (squareSum * squareSum) - 3;

			_sampleSeries[bar] = (Period - 1m) * (Period + 1m) / ((Period - 2m) * (Period - 3m)) *
				quadSum / (squareSum * squareSum) -
				3m * (Period - 1) * (Period - 1) / ((Period - 2) * (Period - 3));
		}

		#endregion
	}
}









Technical/LinRegChannel.cs








namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using Color = System.Drawing.Color;
using Pen = System.Drawing.Pen;

[DisplayName("Linear Regression Channel")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.LinRegChannelDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618910")]
public class LinRegChannel : Indicator
{
    #region Nested Types

    public enum InputType
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Open))]
        Open,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.High))]
        High,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low))]
        Low,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Close))]
        Close,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow2))]
        HighLow2,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLowClose3))]
        HighLowClose3,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OpenHighLowClose4))]
        OpenHighLowClose4,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow2Close4))]
        HighLow2Close4
    }

    internal enum DirectionTypes
    {
        Up,
        UpRight,
        Down,
        DownRight,
        Right
    }

    #endregion

    #region Fields

    private readonly decimal[] _fiboRatios = new decimal[] { 0.236m, 0.382m, 0.618m, 0.764m };
    private readonly ValueDataSeries _data = new("data");
    private readonly ValueDataSeries _slope = new("slope");
    private readonly ValueDataSeries _currDev = new("currDev");
    private readonly ValueDataSeries _y1 = new("y1");
    private readonly ValueDataSeries _y2 = new("y2");
    private readonly ValueDataSeries _outOfChannel = new("outOfChannel");

    private Pen _bullishPen = new(DefaultColors.Green) { Width = 2 };
    private Pen _bearishPen = new(DefaultColors.Red) { Width = 2 };
    private Pen _bullishDashPen = new(DefaultColors.Green) { Width = 2, DashStyle = DashStyle.Dash };
    private Pen _bearishDashPen = new(DefaultColors.Red) { Width = 2, DashStyle = DashStyle.Dash };
    private Pen _bullishFiboPen = new(DefaultColors.Green) { Width = 2, DashStyle = DashStyle.Dot };
    private Pen _bearishFiboPen = new(DefaultColors.Red) { Width = 2, DashStyle = DashStyle.Dot };
    private Pen _brokenPen = new(DefaultColors.Blue) { Width = 2, DashStyle = DashStyle.Dot };
    private PenSettings _arrowPen = new() { Color = DefaultColors.Black.Convert() };

    private Color _bullishColorTransparent;
    private Color _bearishColorTransparent;

    private TrendLine _main;
    private TrendLine _lower;
    private TrendLine _upper;
    private TrendLine _fibo1;
    private TrendLine _fibo2;
    private TrendLine _fibo3;
    private TrendLine _fibo4;
    private TrendLine _broken;

    private LinRegSlope _linRegSlope;
    private int _lastBar = -1;
    private int _realPeriod;

    private InputType _type = InputType.Close;
    private int _period = 100;
    private decimal _deviation = 2m;
    private bool _showFibonacci = true;
    private bool _showBrokenChannel = true;
    private bool _extendLines;
    private int _arrowSize = 2;
    private int _labelTransparency = 8;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Type), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.CalculationModeDescription))]
    public InputType Type 
    { 
        get => _type;
        set
        {
            _type = value;
            RecalculateValues();
        }
    }

    [Parameter]
    [Range(10, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.PeriodDescription))]
    public int Period 
    {
        get => _period;
        set
        {
            _period = value;
            RecalculateValues();
        }
    }

    [Parameter]
    [Range(0.1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Deviation), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.DeviationRangeDescription))]
    public decimal Deviation 
    {
        get => _deviation;
        set
        {
            _deviation = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ExtendLines), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ExtendLinesDescription))]
    public bool ExtendLines 
    { 
        get => _extendLines; 
        set
        {
            _extendLines = value;

            SetExtendLine(_main, _extendLines);
            SetExtendLine(_lower, _extendLines);
            SetExtendLine(_upper, _extendLines);
            SetExtendLine(_fibo1, _extendLines);
            SetExtendLine(_fibo2, _extendLines);
            SetExtendLine(_fibo3, _extendLines);
            SetExtendLine(_fibo4, _extendLines);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowFibonacci), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowFibonacciDescription))]
    public bool ShowFibonacci
    { 
        get => _showFibonacci;
        set
        {
            _showFibonacci = value;
            RecalculateValues();
        } 
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowBrokenChannel), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowBrokenChannelDescription))]
    public bool ShowBrokenChannel 
    { 
        get => _showBrokenChannel;
        set
        {
            _showBrokenChannel = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription))]
    public Color BullishColor 
    {
        get => _bullishPen.Color;
        set
        {
            _bullishPen.Color = value;
            _bullishDashPen.Color = value;
            _bullishFiboPen.Color = value;
            _bullishColorTransparent = GetColorTransparency(_bullishPen.Color, _labelTransparency);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription))]
    public Color BearishColor 
    {
        get => _bearishPen.Color; 
        set
        {
            _bearishPen.Color = value;
            _bearishDashPen.Color = value;
            _bearishFiboPen.Color = value;
            _bearishColorTransparent = GetColorTransparency(_bearishPen.Color, _labelTransparency);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BrokenChannelColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColorDescription))]
    public Color BrokenChannelColor 
    {
        get => _brokenPen.Color;
        set => _brokenPen.Color = value;
    }

    [Range(1, 20)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LineWidthDescription))]
    public float LineWidth 
    {
        get => _bullishPen.Width;
        set
        {
            _bullishPen.Width = value;
            _bullishFiboPen.Width = value;
            _bullishDashPen.Width = value;
            _bearishPen.Width = value;
            _bearishFiboPen.Width = value;
            _bearishDashPen.Width = value;
            _brokenPen.Width = value;
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LabelTextColorDescription))]
    public Color ArrowColor 
    {
        get => _arrowPen.Color.Convert();
        set => _arrowPen.Color = value.Convert();
    }

    [Range(1, 20)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.TextSizeDescription))]
    public int ArrowSize
    {
        get => _arrowSize;
        set
        {
            _arrowPen.Width = Math.Min(value, 2);
            _arrowSize = value;
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int LabelTransparency 
    { 
        get => _labelTransparency;
        set
        {
            _labelTransparency = value;
            _bullishColorTransparent = GetColorTransparency(_bullishPen.Color, _labelTransparency);
            _bearishColorTransparent = GetColorTransparency(_bearishPen.Color, _labelTransparency);
        }
    }

    #endregion

    #region ctor

    public LinRegChannel() : base(true)
    {
        DenyToChangePanel = true;
        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
        DrawAbovePrice = true;
        EnableCustomDrawing = true;
        SubscribeToDrawingEvents(DrawingLayouts.Final);

        _bullishColorTransparent = GetColorTransparency(_bullishPen.Color, _labelTransparency);
        _bearishColorTransparent = GetColorTransparency(_bearishPen.Color, _labelTransparency);
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        _realPeriod = _period > CurrentBar ? CurrentBar : _period;
        _linRegSlope = new LinRegSlope() { Period = _realPeriod };
        TrendLines.Clear();
        _main = _upper = _lower = _fibo1 = _fibo2 = _fibo3 = _fibo4 = null;
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        SetChannel(bar);
        var dev = RoundToFraction(_currDev[bar] * _deviation, InstrumentInfo.TickSize);

        if (ShowBrokenChannel)
            BreakdownTest(bar, dev);

        if ( bar == CurrentBar - 1) 
        {
            SetLinRegLine(bar, ref _lower, -dev, _bullishDashPen, _bearishDashPen);
            SetLinRegLine(bar, ref _main, 0, _bullishPen, _bearishPen);
            SetLinRegLine(bar, ref _upper, dev, _bullishDashPen, _bearishDashPen);

            if (ShowFibonacci)
            {
                SetFiboLine(bar, ref _fibo1, _fiboRatios[0], _bullishFiboPen, _bearishFiboPen);
                SetFiboLine(bar, ref _fibo2, _fiboRatios[1], _bullishFiboPen, _bearishFiboPen);
                SetFiboLine(bar, ref _fibo3, _fiboRatios[2], _bullishFiboPen, _bearishFiboPen);
                SetFiboLine(bar, ref _fibo4, _fiboRatios[3], _bullishFiboPen, _bearishFiboPen);
            }
        }

        _lastBar = bar;
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
        if (ChartInfo is null) return;

        DrawLabel(context);
    }

    #endregion

    #region Private Methods

    #region Drawing

    private void DrawLabel(RenderContext context)
    {
        if (CurrentBar < 2) return;

        var slope = _slope[CurrentBar - 1];
        var slopePrev = _slope[CurrentBar - 2];
        var direction = GetSlopeDirection(slope, slopePrev);
        var startPoint = GetStartPoint(direction);

        var shift = 10;
        var arrowSize = new Size(shift * _arrowSize, shift * _arrowSize);
        var w = arrowSize.Width * 3;
        var h = arrowSize.Height * 3;
        var labelExtendPoints = GetLabelExtendPoints(startPoint, shift, direction);
        var labelStart = GetLabelStart(startPoint, w, h, direction, shift);
        var rec = new Rectangle(labelStart.X, labelStart.Y, w, h);
        var arrowPoints = GetArrowPoints(direction, arrowSize, rec, shift);
        var color = direction == DirectionTypes.Up || direction == DirectionTypes.UpRight
                  ? _bullishColorTransparent
                  : _bearishColorTransparent;

        context.FillPolygon(color, new Point[] { startPoint, labelExtendPoints[0], labelExtendPoints[1] });
        context.FillRectangle(color, rec);
        context.DrawLines(_arrowPen.RenderObject, arrowPoints);
    }

    private Point GetLabelStart(Point startPoint, int w, int h, DirectionTypes direction, int shift)
    {
        int x;
        int y;
        switch (direction)
        {
            case DirectionTypes.Up:
                x = startPoint.X - w / 2;
                y = startPoint.Y + shift;
                break;
            case DirectionTypes.UpRight:
                x = startPoint.X - shift - w;
                y = startPoint.Y + shift;
                break;
            case DirectionTypes.Down:
                x = startPoint.X - w / 2;
                y = startPoint.Y - shift - h;
                break;
            case DirectionTypes.DownRight:
                x = startPoint.X - shift - w;
                y = startPoint.Y - shift - h;
                break;
            default:
                x = startPoint.X - shift - w;
                y = startPoint.Y - h / 2;
                break;
        }

        return new Point(x, y);
    }

    private Point[] GetLabelExtendPoints(Point startPoint, int shift, DirectionTypes direction)
    {
        int x1;
        int y1;
        int x2;
        int y2;
        switch (direction)
        {
            case DirectionTypes.Up:
                x1 = startPoint.X - shift;
                y1 = y2 = startPoint.Y + shift;
                x2 = startPoint.X + shift;
                break;
            case DirectionTypes.UpRight:
                x1 = x2 = startPoint.X - shift;
                y1 = startPoint.Y + shift;
                y2 = y1 + shift;
                break;
            case DirectionTypes.Down:
                x1 = startPoint.X - shift;
                y1 = y2 = startPoint.Y - shift;
                x2 = startPoint.X + shift;
                break;
            case DirectionTypes.DownRight:
                x1 = x2 = startPoint.X - shift;
                y1 = startPoint.Y - shift;
                y2 = y1 - shift;
                break;
            default:
                x1 = x2 = startPoint.X - shift;
                y1 = startPoint.Y - shift;
                y2 = startPoint.Y + shift;
                break;
        }

        return new Point[] { new Point(x1, y1), new Point(x2, y2) };
    }

    private Point[] GetArrowPoints(DirectionTypes direction, Size arrowSize, Rectangle rec, int shift)
    {
        return direction switch
        {
            DirectionTypes.UpRight => GetArrowPointsRotated(arrowSize, rec, 45, -shift / 2 * _arrowSize, shift / 2),
            DirectionTypes.Right => GetArrowPointsRotated(arrowSize, rec, 90, -shift * _arrowSize, 0),
            DirectionTypes.DownRight => GetArrowPointsRotated(arrowSize, rec, 135, -shift * _arrowSize, -shift / 2 * _arrowSize),
            DirectionTypes.Down => GetArrowPointsRotated(arrowSize, rec, 180, -shift * _arrowSize, -shift * _arrowSize),
            _ => GetArrowPointsBase(arrowSize, rec),
        };
    }

    private Point[] GetArrowPointsRotated(Size arrowSize, Rectangle rec, double angle, int shiftX, int shiftY)
    {
        var points = GetArrowPointsBase(arrowSize, rec);
        var x0 = points.Select(p => p.X).Max();
        var y0 = points.Select(p => p.Y).Max();
        var poiint0 = new Point(x0, y0);
        var newPoints = new Point[points.Length];
        double angleRadian = angle * Math.PI / 180;

        for (int i = 0; i < newPoints.Length; i++)
        {
            var x = (points[i].X - x0) * Math.Cos(angleRadian) - (points[i].Y - y0) * Math.Sin(angleRadian) + x0 + shiftX;
            var y = (points[i].X - x0) * Math.Sin(angleRadian) + (points[i].Y - y0) * Math.Cos(angleRadian) + y0 + shiftY;
            newPoints[i] = new Point((int)x, (int)y);
        }

        return newPoints;
    }

    private Point[] GetArrowPointsBase(Size arrowSize, Rectangle labelRec)
    {
        var shift = arrowSize.Width / 2;
        var shift1 = shift / 5 * 3;
        var point1 = new Point(labelRec.X + arrowSize.Width + shift1, labelRec.Y + arrowSize.Height * 2);
        var point2 = new Point(point1.X, point1.Y - arrowSize.Height + shift);
        var point3 = new Point(point2.X - shift1, point2.Y);
        var point4 = new Point(point3.X + shift, point2.Y - shift - shift1);
        var point5 = new Point(point4.X + shift, point2.Y);
        var point6 = new Point(point5.X - shift1, point5.Y);
        var point7 = new Point(point6.X, point1.Y);

        return new Point[] {point1, point2, point3, point4, point5, point6, point7};    
    }

    private Point GetStartPoint(DirectionTypes direction)
    {
        var bar = CurrentBar - 1;
        var dev = RoundToFraction(_currDev[bar] * _deviation, InstrumentInfo.TickSize);
        decimal price;
        switch (direction)
        {
            case DirectionTypes.Up:
            case DirectionTypes.UpRight:
                price = _y1[bar] - dev;
                break;
            case DirectionTypes.Down:
            case DirectionTypes.DownRight:
                price = _y1[bar] + dev;
                break;
            default:
                price = _y1[bar];
                break;
        }

        return new Point(ChartInfo.GetXByBar(bar - _realPeriod + 1, false), ChartInfo.GetYByPrice(price, false));
    }

    private DirectionTypes GetSlopeDirection(decimal slope, decimal slopePrev)
    {
        switch (slope)
        {
            case > 0:
                if (slope > slopePrev)
                    return DirectionTypes.Up;
                else
                    return DirectionTypes.UpRight;
            case < 0:
                if (slope < slopePrev)
                    return DirectionTypes.Down;
                else
                    return DirectionTypes.DownRight;
            default:
                return DirectionTypes.Right;
        }
    }

    private Color GetColorTransparency(Color color, int tr = 5) => Color.FromArgb((byte)(tr* 25), color.R, color.G, color.B);

    #endregion

    private void BreakdownTest(int bar, decimal dev)
    {
        if (bar < 0) return;

        if (bar != _lastBar)
        {
            _broken = null;
        }

        var candle = GetCandle(bar);

        if (_slope[bar] > 0 && candle.Close < (_y2[bar] - _currDev[bar] * _deviation)) 
        {
            if (_outOfChannel[bar - 1] == 0)
                SetLinRegLine(bar - 1, ref _broken, -dev, _brokenPen, _brokenPen, true);

            _outOfChannel[bar] = 1;

            return;
        }
        else if(_slope[bar] < 0 && candle.Close > (_y2[bar] + _currDev[bar] * _deviation))
        {
            if (_outOfChannel[bar - 1] == 0)
                SetLinRegLine(bar - 1, ref _broken, dev, _brokenPen, _brokenPen, true);

            _outOfChannel[bar] = 1;

            return;
        }

        if (_broken is not null)
        {
            TrendLines.Remove(_broken);
            _broken = null;
        }

        _outOfChannel[bar] = 0;
    }

    private void SetExtendLine(TrendLine line, bool extendLines)
    {
        if (line is null) return;

        line.IsRay = extendLines;
    }

    private decimal GetSource(IndicatorCandle candle)
    {
        return _type switch
        {
            InputType.Close => candle.Close,
            InputType.Open => candle.Open,
            InputType.High => candle.High,
            InputType.Low => candle.Low,
            InputType.HighLow2 => (candle.High + candle.Low) / 2,
            InputType.HighLowClose3 => (candle.High + candle.Low + candle.Close) / 3,
            InputType.OpenHighLowClose4 => (candle.Open + candle.High + candle.Low + candle.Close) / 4,
            InputType.HighLow2Close4 => (candle.High + candle.Low + 2 * candle.Close) / 4,
            _ => 0
        };
    }

    private void SetChannel(int bar)
    {
        var candle = GetCandle(bar);
        var sourceVal = GetSource(candle);
        _data[bar] = sourceVal;
        _slope[bar] = _linRegSlope.Calculate(bar, sourceVal);
        var mid = _data.CalcAverage(_realPeriod, bar);
        _y1[bar] = mid - _slope[bar] * (_realPeriod / 2) + (1 - _realPeriod % 2) / 2 * _slope[bar];
        _y2[bar] = _y1[bar] + _slope[bar] * (_realPeriod - 1);

        _y1[bar] = RoundToFraction(_y1[bar], InstrumentInfo.TickSize);
        _y2[bar] = RoundToFraction(_y2[bar], InstrumentInfo.TickSize);

        var dev = 0m;

        for (int i = bar - _realPeriod + 1; i <= bar; i++) 
        {
            var res = _data[i] - (_slope[bar] * (_realPeriod - (bar - i)) + _y1[bar]);
            dev += res * res;
        }

        _currDev[bar] = (decimal)Math.Sqrt((double)(dev / _realPeriod));
    }

    private void SetLinRegLine(int bar, ref TrendLine line, decimal dev, Pen bullishPen, Pen bearishPen, bool isBrokenLine = false)
    {
        var x1 = bar - _realPeriod + 1;
        var y1 = _y1[bar] + dev;
        var x2 = bar;
        var y2 = _y2[bar] + dev;
        var pen = _slope[bar] > 0 ? bullishPen : bearishPen;
        SetTrendLine(ref line, x1, y1, x2, y2, pen, isBrokenLine);
    }

    private decimal RoundToFraction(decimal value, decimal fraction) => Math.Round(value / fraction) * fraction;

    private void SetFiboLine(int bar, ref TrendLine line, decimal fiboRatio, Pen bullishFiboPen, Pen bearishFiboPen)
    {
        var dev = _currDev[bar] * _deviation - _currDev[bar] * _deviation * 2 * fiboRatio;
        dev = RoundToFraction(dev, InstrumentInfo.TickSize);
        var x1 = bar - _realPeriod + 1;
        var y1 = _y1[bar] - dev;
        var x2 = bar;
        var y2 = _y2[bar] - dev;
        var pen = _slope[bar] > 0 ? bullishFiboPen : bearishFiboPen;
        SetTrendLine(ref line, x1, y1, x2, y2, pen);
    }

    private void SetTrendLine(ref TrendLine line, int x1, decimal y1, int x2, decimal y2, Pen pen, bool isBrokenLine = false)
    {
        if (line is null)
        {
            line = new TrendLine(x1, y1, x2, y2, pen) { IsRay = !isBrokenLine && _extendLines };
            TrendLines.Add(line);
        }
        else
        {
            line.FirstBar = x1;
            line.FirstPrice = y1;
            line.SecondBar = x2;
            line.SecondPrice = y2;
            line.Pen = pen;
        }
    }

    #endregion
}









Technical/LinRegSlope.cs







namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Linear Regression Slope")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.LinRegSlopeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602416")]
	public class LinRegSlope : Indicator
	{
		#region Fields

		private int _period;

		#endregion

		#region Properties

		[Parameter]
		[Range(1, 10000)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
		public int Period
		{
			get => _period;
			set
			{
				if (_period == value)
					return;

				_period = value;

				RaisePropertyChanged(nameof(Period));
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public LinRegSlope()
		{
			Panel = IndicatorDataProvider.NewPanel;
			Period = 14;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar < Period + 1)
				return;

			var sumX = Period * (Period - 1) * 0.5m;
			var divisor = sumX * sumX - Period * Period * (Period - 1m) * (2 * Period - 1) / 6;
			decimal sumXY = 0;

			for (var count = 0; count < Period && bar - count >= 0; count++)
			{
				if (bar - count < 0)
					continue;

				sumXY += count * (decimal)SourceDataSeries[bar - count];
			}

			var val = (Period * sumXY - sumX * SourceDataSeries.CalcSum(Period, bar)) / divisor;
			this[bar] = val;
		}

		#endregion
	}
}









Indicators/Technical
/LinearReg.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Linear Regression")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.LinearRegIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602415")]
	public class LinearReg : Indicator
	{
		#region Fields

		private int _period = 10;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			var start = Math.Max(0, bar - Period + 1);
			var count = Math.Min(bar + 1, Period);

			var x = 0m;
			var y = 0m;
			var xy = 0m;
			var x2 = 0m;

			for (var i = start; i < start + count; i++)
			{
				var val = (decimal)SourceDataSeries[i];

				x += i;
				x2 += i * i;

				y += val;
				xy += i * val;
			}

			var k = count * x2 - x * x;

			k = k == 0
				? 0
				: (count * xy - x * y) / k;

			this[bar] = k * bar + (y - k * x) / count;
		}

		#endregion
	}
}









Technical/Logo.cs









namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.IO;

	using OFT.Attributes;
	using OFT.Attributes.Editors;
    using OFT.Localization;
    using OFT.Rendering.Context;

	[DisplayName("Background Picture")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.LogoIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602528")]
	public class Logo : Indicator
	{
		#region Nested types

		public enum Location
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Center))]
			Center,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopLeft))]
			TopLeft,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopRight))]
			TopRight,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomLeft))]
			BottomLeft,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomRight))]
			BottomRight
		}

		#endregion

		#region Fields

		private string _filePath;
		private Image _image;
		private DateTime _lastRender = DateTime.Now;
		private object _locker = new();
		private Image _source;
		private int _transparency;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LogoLocation), GroupName = nameof(Strings.Common), Description = nameof(Strings.ImageLocationDescription), Order = 20)]
		public Location LogoLocation { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Scale), GroupName = nameof(Strings.Common), Description = nameof(Strings.ElementScaleValueDescription), Order = 22)]
		[NumericEditor(NumericEditorTypes.TrackBar, 0, 100)]
		public int Scale { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.Common), Description = nameof(Strings.ImageTransparencyDescription), Order = 24)]
		[NumericEditor(NumericEditorTypes.TrackBar, 0, 100)]
		public int Transparency
		{
			get => _transparency;
			set
			{
				if (_source != null && (DateTime.Now - _lastRender).TotalMilliseconds >= 200)
				{
					lock (_locker)
					{
						_image = SetOpacity(_source, (float)(value * 0.01));
						_lastRender = DateTime.Now;
						RedrawChart();
					}
				}

				_transparency = value;
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HorizontalOffset), GroupName = nameof(Strings.Common), Description = nameof(Strings.ImageOffsetXDescription), Order = 30)]
		public int HorizontalOffset { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VerticalOffset), GroupName = nameof(Strings.Common), Description = nameof(Strings.ImageOffsetYDescription), Order = 40)]
		public int VerticalOffset { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowAboveChart), GroupName = nameof(Strings.Common), Description = nameof(Strings.DrawAbovePriceDescription), Order = 50)]
		public bool AbovePrice
		{
			get => DrawAbovePrice;
			set => DrawAbovePrice = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ImageLocation), GroupName = nameof(Strings.Location), Description = nameof(Strings.LogoFilePathDescription), Order = 70)]
		[SelectFileEditor(Environment.SpecialFolder.MyPictures, Filter = "Image files (*.bmp, *.gif, *.jpeg, *.jpg, *.png, *.tiff)|*.bmp;*.gif;*.jpeg;*.jpg;*.png;*.tiff", IsTextEditable = false)]
		public string FilePath
		{
			get => _filePath;
			set
			{
				_filePath = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Logo()
			: base(true)
		{
			_transparency = 100;
			Scale = 100;
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Historical);
			DrawAbovePrice = false;
		}

		#endregion

		#region Private methods

		private Image SetOpacity(Image image, float opacity)
		{
			var bmp = new Bitmap(image.Width, image.Height);

			using var g = Graphics.FromImage(bmp);

			var matrix = new ColorMatrix
			{
				Matrix33 = opacity
			};
			var attributes = new ImageAttributes();

			attributes.SetColorMatrix(matrix, ColorMatrixFlag.Default,
				ColorAdjustType.Bitmap);

			g.DrawImage(image, new Rectangle(0, 0, bmp.Width, bmp.Height),
				0, 0, image.Width, image.Height,
				GraphicsUnit.Pixel, attributes);

			return bmp;
		}

		#endregion

		#region Overrides of BaseIndicator

		protected override void OnRecalculate()
		{
			lock (_locker)
			{
				if (File.Exists(_filePath))
				{
					if (new FileInfo(_filePath).Length <= Math.Pow(2, 20))
						_source = Image.FromFile(_filePath);
					else
						AddAlert("alert1", "File is too big to load!");
				}
				else
					_source = null;

				if (_source != null)
					_image = SetOpacity(_source, (float)(Transparency * 0.01));
			}
		}

		protected override void OnCalculate(int bar, decimal value)
		{
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			lock (_locker)
			{
				if (_source == null)
					return;
			}

			var x = 0;
			var y = 0;

			lock (_locker)
			{
				var imageWidth = (int)Math.Round(Scale * 0.01m * _image.Width);
				var imageHeight = (int)Math.Round(Scale * 0.01m * _image.Height);

				switch (LogoLocation)
				{
					case Location.Center:
					{
						x = ChartInfo.PriceChartContainer.Region.Width / 2 - imageWidth / 2 + HorizontalOffset;

						y = ChartInfo.PriceChartContainer.Region.Height / 2 - imageHeight / 2 + VerticalOffset;

						break;
					}
					case Location.TopLeft:
					{
						x = HorizontalOffset;
						y = VerticalOffset;
						break;
					}
					case Location.TopRight:
					{
						x = ChartInfo.PriceChartContainer.Region.Width - imageWidth + HorizontalOffset;
						y = VerticalOffset;
						break;
					}
					case Location.BottomLeft:
					{
						x = HorizontalOffset;
						y = ChartInfo.PriceChartContainer.Region.Height - imageHeight + VerticalOffset;

						break;
					}
					case Location.BottomRight:
					{
						x = ChartInfo.PriceChartContainer.Region.Width - imageWidth + HorizontalOffset;
						y = ChartInfo.PriceChartContainer.Region.Height - imageHeight + VerticalOffset;

						break;
					}
					default:
						throw new ArgumentOutOfRangeException();
				}

				var rect = new Rectangle(x, y, imageWidth, imageHeight);
				context.DrawStaticImage(_image, rect);
			}
		}

		#endregion
	}
}









Technical/Lowest.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Lowest")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.LowestIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602417")]
	public class Lowest : Indicator
	{
		#region Fields

		private int _period = 10;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			var start = Math.Max(0, bar - Period + 1);
			var count = Math.Min(bar + 1, Period);

			var min = (decimal)SourceDataSeries[start];

			for (var i = start + 1; i < start + count; i++)
				min = Math.Min(min, (decimal)SourceDataSeries[i]);

			this[bar] = min;
		}

		#endregion
	}
}










Technical/MACD.cs








namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("MACD")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MACDDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602418")]
	public class MACD : Indicator 
	{
		#region Fields

		private readonly EMA _long = new() { Period = 26 };
		private readonly EMA _short = new() { Period = 12 };
		private readonly EMA _signal = new() { Period = 9 };

        #endregion

        #region Properties

        [Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.LongPeriod),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.LongPeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int LongPeriod
		{
			get => _long.Period;
			set
			{
				_long.Period = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ShortPeriod),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.ShortPeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
        public int ShortPeriod
		{
			get => _short.Period;
			set
			{
				_short.Period = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.SignalPeriod),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.SignalPeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
        public int SignalPeriod
		{
			get => _signal.Period;
			set
			{
				_signal.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MACD()
		{
			Panel = IndicatorDataProvider.NewPanel;

			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Blue.Convert();
			DataSeries[0].DescriptionKey = nameof(Strings.BaseLineSettingsDescription);


            DataSeries.Add(new ValueDataSeries("SignalId", "Signal")
			{
				VisualType = VisualMode.Line,
				IgnoredByAlerts = true,
				DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
			});

			DataSeries.Add(new ValueDataSeries("DifferenceId", "Difference")
			{
				VisualType = VisualMode.Histogram,
				Color = DefaultColors.Teal.Convert(),
				IgnoredByAlerts = true,
                DescriptionKey = nameof(Strings.MACDVsSignalDiffSettingsDescription) 
            });
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var macd = _short.Calculate(bar, value) - _long.Calculate(bar, value);
			var signal = _signal.Calculate(bar, macd);

			this[bar] = macd;
			DataSeries[1][bar] = signal;
			DataSeries[2][bar] = macd - signal;
		}

		#endregion
	}
}








Technical/MFI.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Money Flow Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MFIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602430")]
	public class MFI : Indicator
	{
		#region Fields

		private LineSeries _overbought = new("Overbought", Strings.Overbought)
		{
			Color = DefaultColors.Green.Convert(),
			Value = 80,
			IsHidden = true
        };
		private LineSeries _oversold = new("Oversold", Strings.Oversold)
		{
			Color = DefaultColors.Green.Convert(),
			Value = 20,
			IsHidden = true
        };
		private ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
            ShowZeroValue = false
		};
		
        private ValueDataSeries _negativeFlow = new("NegFlow");
        private ValueDataSeries _positiveFlow = new("PosFlow");

        private int _lastBar = -1;
        private int _period = 14;
        private decimal _previousTypical;
        private bool _drawLines = true;
        private System.Drawing.Color _greenColor = DefaultColors.Green;
        private System.Drawing.Color _sitColor = DefaultColors.DarkRed;
        private System.Drawing.Color _fakeColor = System.Drawing.Color.DodgerBlue;
        private System.Drawing.Color _weakColor = System.Drawing.Color.Gray;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				_previousTypical = -1;
				RecalculateValues();
			}
		}
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.GreenSeriesColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.StrongPositiveFlowColorDescription), Order = 200)]
		public CrossColor GreenColor
		{
			get => _greenColor.Convert();
			set
			{
				_greenColor = value.Convert(); 
				RecalculateValues();
			}
		}
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.WeakSeriesColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.WeakNegativeFlowColorDescription), Order = 210)]
		public CrossColor WeakColor
		{
			get => _weakColor.Convert();
			set
			{
                _weakColor = value.Convert();
				RecalculateValues();
			}
        }
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FakeSeriesColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.WeakPositiveFlowColorDescription), Order = 220)]
		public CrossColor FakeColor
		{
			get => _fakeColor.Convert();
			set
			{
				_fakeColor = value.Convert();
				RecalculateValues();
			}
        }
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SitSeriesColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.StrongNegativeFlowColorDescription), Order = 230)]
		public CrossColor SitColor
		{
			get => _sitColor.Convert();
			set
			{
				_sitColor = value.Convert();
				RecalculateValues();
			}
        }
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Line), Description = nameof(Strings.DrawLinesDescription), Order = 300)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if (LineSeries.Contains(_overbought))
						return;

					LineSeries.Add(_overbought);
					LineSeries.Add(_oversold);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Overbought), GroupName = nameof(Strings.Line), Description = nameof(Strings.OverboughtLimitDescription), Order = 310)]
		public LineSeries OverboughtLine 
		{ 
			get => _overbought;
			set => _overbought = value;
		} 

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Oversold), GroupName = nameof(Strings.Line), Description = nameof(Strings.OversoldLimitDescription), Order = 320)]
		public LineSeries OversoldLine
        { 
			get => _oversold;
			set => _oversold = value;
		} 
        #endregion

        #region ctor

        public MFI()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DenyToChangePanel = true;
			
			DataSeries[0] = _renderSeries;

			LineSeries.Add(_overbought);
			LineSeries.Add(_oversold);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			var typical = (candle.High + candle.Low + candle.Close) / 3.0m;

			if (bar == 0)
				_previousTypical = typical;

			var moneyFlow = typical * candle.Volume;

			if (typical > _previousTypical)
				_positiveFlow[bar] = moneyFlow;
			else
				_negativeFlow[bar] = moneyFlow;

			DataSeries.ForEach(x => ((ValueDataSeries)x)[bar] = 0);

			if (bar < Period)
				return;

			var positiveFlow = _positiveFlow.CalcSum(Period, Math.Max(bar - Period, 0));
			var negativeFlow = _negativeFlow.CalcSum(Period, Math.Max(bar - Period, 0));

			var renderValue = 100m;

			if (negativeFlow != 0.0m)
			{
				var moneyRatio = positiveFlow / negativeFlow;
				renderValue = 100.0m - 100.0m / (1.0m + moneyRatio);
			}

			if (bar != _lastBar)
				_previousTypical = typical;

			_lastBar = bar;

			_renderSeries[bar] = renderValue;

            if (bar == 0)
	            return;

            var prevCandle = GetCandle(bar - 1);

            _renderSeries.Colors[bar] = renderValue >= _renderSeries[bar - 1]
	            ? candle.Ticks >= prevCandle.Ticks
		            ? _greenColor
		            : _fakeColor
	            : candle.Ticks >= prevCandle.Ticks
		            ? _sitColor
		            : _weakColor;
		}

		#endregion
	}
}








Technical/MMed.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Moving Median")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MMedDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602433")]
	public class MMed : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MMed()
		{
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var startBar = Math.Max(0, bar - Period);
			var orderedValues = new List<decimal>();

			for (var i = startBar; i <= bar; i++)
				orderedValues.Add((decimal)SourceDataSeries[i]);

			orderedValues = orderedValues
				.OrderBy(x => x)
				.ToList();

			if (bar < Period)
			{
				var targetBar = bar - (bar + 1) / 2;

				if ((bar + 1) % 2 == 1)
					_renderSeries[bar] = orderedValues[bar - targetBar];
				else
					_renderSeries[bar] = (orderedValues[bar - targetBar] + orderedValues[bar - (targetBar + 1)]) / 2;
			}
			else
			{
				var targetBar = bar - Period / 2;

				if (Period % 2 == 1)
					_renderSeries[bar] = orderedValues[bar - targetBar];
				else
					_renderSeries[bar] = (orderedValues[bar - targetBar] + orderedValues[bar - (targetBar + 1)]) / 2;
			}
		}

		#endregion
	}
}









Technical/MSI.cs









namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("McClellan Summation Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MSIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602427")]
	public class MSI : Indicator
	{
		#region Static and constants

		private const int _shortPeriod = 19;
		private const int _longPeriod = 39;

		#endregion

		#region Fields

		private readonly ValueDataSeries _longEma = new("EmaLong");
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization) { UseMinimizedModeIfEnabled = true };
		private readonly ValueDataSeries _shortEma = new("EmaShort");

		#endregion

		#region ctor

		public MSI()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();
				_shortEma[bar] = value;
				_longEma[bar] = value;
				return;
			}

			_shortEma[bar] = 0;

			if (value != 0)
				_shortEma[bar] = 2 * value / (_shortPeriod + 1) + (1 - 2m / (_shortPeriod + 1)) * _shortEma[bar - 1];

			_longEma[bar] = 0;

			if (value != 0)
				_longEma[bar] = 2 * value / (_longPeriod + 1) + (1 - 2m / (_longPeriod + 1)) * _longEma[bar - 1];

			if (value != 0)
				_renderSeries[bar] = _renderSeries[bar - 1] + (_shortEma[bar] - _longEma[bar]);
			else
				_renderSeries[bar] = _renderSeries[bar - 1];
		}

		#endregion
	}
}









Technical/MaDifference.cs







namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.Drawing;
    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Moving Average Difference")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MaDifferenceDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602289")]
	public class MaDifference : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
			ShowZeroValue = false,
			UseMinimizedModeIfEnabled = true
		};

		private readonly SMA _sma1 = new() { Period = 10 };
		private readonly SMA _sma2 = new() { Period = 20 };

		private Color _negColor = DefaultColors.Red;
		private Color _posColor = DefaultColors.Green;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 610)]
        public Color PosColor
        {
	        get => _posColor;
	        set
	        {
		        _posColor = value;
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Down), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 620)]
        public Color NegColor
        {
	        get => _negColor;
	        set
	        {
		        _negColor = value;
		        RecalculateValues();
	        }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA1), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period1
		{
			get => _sma1.Period;
			set
			{
				_sma1.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA2), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int Period2
		{
			get => _sma2.Period;
			set
			{
				_sma2.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MaDifference()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_sma1.Calculate(bar, value);
			_sma2.Calculate(bar, value);

			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				return;
			}

			var diff = _sma1[bar] - _sma2[bar];
			_renderSeries[bar] = diff;
			_renderSeries.Colors[bar] = diff > _renderSeries[bar - 1] ? _posColor : _negColor;
		}

		#endregion
	}
}








Technical/MaEnvelope.cs








namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Moving Average Envelope")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MaEnvelopeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602431")]
	public class MaEnvelope : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FixedValue))]
			FixedValue,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent))]
			Percentage
		}

        #endregion

        #region Fields

        private readonly SMA _sma = new() { Period = 10 };

        private readonly ValueDataSeries _botSeries = new("BotSeries", Strings.BottomBand)
        {
	        Color = DefaultColors.Blue.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BottomChannelSettingsDescription)
        };
		private readonly ValueDataSeries _smaSeries = new("SmaSeries", Strings.MiddleBand)
		{
            DescriptionKey = nameof(Strings.MidChannelSettingsDescription)
        };

        private readonly ValueDataSeries _topSeries = new("TopSeries", Strings.TopBand)
        {
	        Color = DefaultColors.Blue.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.TopChannelSettingsDescription)
        };

        private Mode _calcMode = Mode.Percentage;
        private decimal _value = 1;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 110)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Value), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DeviationRangeDescription), Order = 120)]
		[Range(0.00001, 10000)]
        public decimal Value
		{
			get => _value;
			set
			{
				_value = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MaEnvelope()
		{
			DataSeries[0] = _botSeries;
			DataSeries.Add(_topSeries);
			DataSeries.Add(_smaSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_sma.Calculate(bar, value);
			_smaSeries[bar] = _sma[bar];

			if (_calcMode == Mode.FixedValue)
			{
				_topSeries[bar] = _sma[bar] + _value;
				_botSeries[bar] = _sma[bar] - _value;
			}
			else
			{
				_topSeries[bar] = _sma[bar] * (1 + 0.01m * _value);
				_botSeries[bar] = _sma[bar] * (1 - 0.01m * _value);
			}
		}

		#endregion
	}
}









Technical/MacdBbImproved.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("MACD Bollinger Bands - Improved")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MacdBbImprovedDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602628")]
	public class MacdBbImproved : Indicator
	{
        #region Fields

        private readonly ValueDataSeries _topBand = new("TopBand", Strings.TopBand)
        {
            Color = System.Drawing.Color.Purple.Convert(),
            IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.TopBandDscription)
        };

        private readonly ValueDataSeries _bottomBand = new("BottomBand", Strings.BottomBand)
		{
			Color = System.Drawing.Color.Purple.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BottomBandDscription)
        };

        private readonly MACD _macd = new()
        {
			LongPeriod = 26,
			ShortPeriod = 12,
			SignalPeriod = 9
        };

        private readonly SMA _sma = new() { Period = 9 };
		private readonly StdDev _stdDev = new() { Period = 9 };		
		private int _stdDevCount = 2;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int MacdPeriod
		{
			get => _macd.SignalPeriod;
			set
			{
				_macd.SignalPeriod = _stdDev.Period = _sma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int MacdShortPeriod
		{
			get => _macd.ShortPeriod;
			set
			{
				_macd.ShortPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int MacdLongPeriod
		{
			get => _macd.LongPeriod;
			set
			{
				_macd.LongPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.StdDev), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StdDevPeriodDescription), Order = 130)]
		[Range(1, 10000)]
        public int StdDev
		{
			get => _stdDevCount;
			set
			{
				_stdDevCount = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MacdBbImproved()
		{
			Panel = IndicatorDataProvider.NewPanel;
			((ValueDataSeries)_macd.DataSeries[1]).LineDashStyle = LineDashStyle.Solid;
			
			DataSeries[0] = _topBand;
			DataSeries.Add(_bottomBand);
			DataSeries.AddRange(_macd.DataSeries);
		}

		#endregion

		#region Protected methods
		
		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}
		
		protected override void OnCalculate(int bar, decimal value)
		{
			_macd.Calculate(bar, value);

			var deltaMacd = ((ValueDataSeries)_macd.DataSeries[0])[bar] - ((ValueDataSeries)_macd.DataSeries[1])[bar];
			_sma.Calculate(bar, Math.Abs(deltaMacd));

			var macdMa = ((ValueDataSeries)_macd.DataSeries[1])[bar];

			var stdDev = _stdDev.Calculate(bar, macdMa);

			_topBand[bar] = macdMa + _sma[bar] + _stdDevCount * stdDev;
			_bottomBand[bar] = macdMa - _sma[bar] - _stdDevCount * stdDev;
		}

		#endregion
	}
}








Technical/MacdBbStandart.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("MACD Bollinger Bands - Standard")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MacdBbStandartDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602295")]
	public class MacdBbStandart : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _bottomBand = new("BottomBand", Strings.BottomBand)
		{
			Color = System.Drawing.Color.Purple.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BottomBandDscription)
        };
		private readonly ValueDataSeries _topBand = new("TopBand", Strings.TopBand)
		{
			Color = System.Drawing.Color.Purple.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.TopBandDscription)
        };

        private readonly MACD _macd = new()
		{
			LongPeriod = 26,
			ShortPeriod = 12,
			SignalPeriod = 9
		};

		private readonly StdDev _stdDev = new() { Period = 9 };
		private int _stdDevCount = 2;

        #endregion

        #region Properties

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int MacdPeriod
		{
			get => _macd.SignalPeriod;
			set
			{
				_macd.SignalPeriod = _stdDev.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 110)]
		public int MacdShortPeriod
		{
			get => _macd.ShortPeriod;
			set
			{
				_macd.ShortPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 120)]
		public int MacdLongPeriod
		{
			get => _macd.LongPeriod;
			set
			{
				_macd.LongPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.StdDev), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StdDevPeriodDescription), Order = 130)]
		public int StdDev
		{
			get => _stdDevCount;
			set
			{
				_stdDevCount = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MacdBbStandart()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			((ValueDataSeries)_macd.DataSeries[1]).LineDashStyle = LineDashStyle.Solid;
			DataSeries[0] = _topBand;
			DataSeries.Add(_bottomBand);
			DataSeries.AddRange(_macd.DataSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}
		
		protected override void OnCalculate(int bar, decimal value)
		{
			_macd.Calculate(bar, value);
			var macdMa = ((ValueDataSeries)_macd.DataSeries[1])[bar];

			var stdDev = _stdDev.Calculate(bar, macdMa);

			_topBand[bar] = macdMa + _stdDevCount * stdDev;
			_bottomBand[bar] = macdMa - _stdDevCount * stdDev;
		}

		#endregion
	}
}







Technical/MacdLeader.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("MACD Leader")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MacdLeaderDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602419")]
	public class MacdLeader : Indicator
	{
		#region Fields

		private readonly EMA _longEma = new() { Period = 26 };
        private readonly EMA _longEmaSmooth = new() { Period = 26 };
        private readonly MACD _macd = new()
		{
			LongPeriod = 26,
			ShortPeriod = 12,
			SignalPeriod = 9
		};

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Indicator) 
		{
			Color = System.Drawing.Color.Purple.Convert(),
            DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
        };

		private readonly EMA _shortEma = new() { Period = 12 };
		private readonly EMA _shortEmaSmooth = new() { Period = 12 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int MacdPeriod
		{
			get => _macd.SignalPeriod;
			set
			{
				_macd.SignalPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int MacdShortPeriod
		{
			get => _macd.ShortPeriod;
			set
			{
				_macd.ShortPeriod = _shortEma.Period = _shortEmaSmooth.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int MacdLongPeriod
		{
			get => _macd.LongPeriod;
			set
			{
				_macd.LongPeriod = _longEma.Period = _longEmaSmooth.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MacdLeader()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _renderSeries;
			DataSeries.Add(_macd.DataSeries[2]);
		}

		#endregion

		#region Protected methods
		
		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}
		
		protected override void OnCalculate(int bar, decimal value)
		{
			var macd = _macd.Calculate(bar, value);

			_shortEma.Calculate(bar, value);
			_shortEmaSmooth.Calculate(bar, value - _shortEma[bar]);
			_longEma.Calculate(bar, value);
			_longEmaSmooth.Calculate(bar, value - _longEma[bar]);

			_renderSeries[bar] = _macd[bar] + _shortEmaSmooth[bar] - _longEmaSmooth[bar];
		}

		#endregion
		
	}
}









Technical/MacdVW.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("MACD - Volume Weighted")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MacdVWDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602231")]
	public class MacdVW : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 9 };

		private readonly ValueDataSeries _macdSeries = new("MacdSeries", Strings.MACD)
		{
			Color = System.Drawing.Color.CadetBlue.Convert(),
			VisualType = VisualMode.Histogram,
			UseMinimizedModeIfEnabled = true,
            DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
        };

		private readonly ValueDataSeries _signalSeries = new("SignalSeries", Strings.Signal) 
		{ 
			UseMinimizedModeIfEnabled = true ,
            DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
        };

		private readonly ValueDataSeries _valVol = new("ValVol");
		private readonly ValueDataSeries _vol = new("Volume");
		private int _longPeriod = 26;
        private int _shortPeriod = 12;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int ShortPeriod
		{
			get => _shortPeriod;
			set
			{
				_shortPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _longPeriod;
			set
			{
				_longPeriod = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MacdVW()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _macdSeries;
			DataSeries.Add(_signalSeries);
		}

		#endregion

		#region Protected methods
		
		protected override void OnRecalculate()
		{
			_vol.Clear();
			_valVol.Clear();

			DataSeries.ForEach(x => x.Clear());
		}
		
		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			_vol[bar] = candle.Volume;
			_valVol[bar] = value * candle.Volume;

			var volSumShort = _vol.CalcSum(ShortPeriod, bar);
			var volSumLong = _vol.CalcSum(LongPeriod, bar);

			if (volSumShort == 0 || volSumLong == 0)
			{
				_ema.Calculate(bar, 0);
				return;
			}

			var vwShort = _valVol.CalcSum(ShortPeriod, bar) / volSumShort;
			var vwLong = _valVol.CalcSum(LongPeriod, bar) / volSumLong;

			var vwMacd = vwShort - vwLong;
			_signalSeries[bar] = _ema.Calculate(bar, vwMacd);
			_macdSeries[bar] = vwMacd;
		}

		#endregion
	}
}









Technical/MarginZones.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

using Brushes = System.Drawing.Brushes;
using Color = System.Drawing.Color;
using FilterColor2 = Indicators.FilterColor;

[DisplayName("Margin zones")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.MarginZonesDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602421")]
public class MarginZones : Indicator
{
	#region Nested types

	public enum ZoneDirection
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up))]
		Up = 0,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Down))]
		Down = 1
	}

	#endregion

	#region Fields

	private readonly ValueDataSeries _100Line = new("100Line", "100% line")
		{ Color = DefaultColors.Maroon.Convert(), Width = 2, ScaleIt = false, VisualType = VisualMode.OnlyValueOnAxis, IsHidden = true };

	private readonly DrawingRectangle _100Rectangle = new(0, 0, 0, 0, Pens.Transparent, Brushes.Gray);

	private readonly ValueDataSeries _150Line = new("150Line", "150% line")
		{ Color = Color.SkyBlue.Convert(), Width = 1, ScaleIt = false, VisualType = VisualMode.Hide, IsHidden = true };

	private readonly DrawingRectangle _150Rectangle = new(0, 0, 0, 0, Pens.Transparent, Brushes.Gray);

	private readonly ValueDataSeries _200Line = new("200Line", "200% line")
		{ Color = Color.CadetBlue.Convert(), Width = 1, ScaleIt = false, VisualType = VisualMode.Hide, IsHidden = true };

	private readonly DrawingRectangle _200Rectangle = new(0, 0, 0, 0, Pens.Transparent, Brushes.Gray);

	private readonly ValueDataSeries _25Line = new("25Line", "25% line")
		{ Color = Color.LightSkyBlue.Convert(), Width = 1, ScaleIt = false, VisualType = VisualMode.OnlyValueOnAxis, IsHidden = true };

	private readonly DrawingRectangle _25Rectangle = new(0, 0, 0, 0, Pens.Transparent, Brushes.Gray);

	private readonly ValueDataSeries _50Line = new("50Line", "50% line")
		{ Color = Color.SkyBlue.Convert(), Width = 1, ScaleIt = false, VisualType = VisualMode.OnlyValueOnAxis, IsHidden = true };

	private readonly DrawingRectangle _50Rectangle = new(0, 0, 0, 0, Pens.Transparent, Brushes.Gray);

	private readonly ValueDataSeries _75Line = new("75Line", "75% line")
		{ Color = Color.LightSkyBlue.Convert(), Width = 1, ScaleIt = false, VisualType = VisualMode.Hide, IsHidden = true };

	private readonly DrawingRectangle _75Rectangle = new(0, 0, 0, 0, Pens.Transparent, Brushes.Gray);

	private readonly ValueDataSeries _baseLineLabel = new("BaseLineLabel", "Base line")
		{ Color = Color.Gray.Convert(), Width = 2, ScaleIt = false, VisualType = VisualMode.OnlyValueOnAxis, IsHidden = true };

	private readonly List<int> _newDays = new();

    private TrendLine _baseLine = new(0, 0, 0, 0, Pens.Gray);
	private RenderPen _baseLineRenderPen = new(Color.Gray);
	private bool _calculated;
	private ZoneDirection _direction;
	private int _lastCalculated;
	private int _margin = 3200;
	private decimal _secondPrice;
	private decimal _tickCost = 6.25m;
	private decimal _zonePrice;
	private decimal _zoneWidth;

	private int _zoneWidthDays = 3;

    private FilterColor2 _zone200Filter;
    private FilterColor2 _zone150Filter;
    private FilterColor2 _zone100Filter;
    private FilterColor2 _zone75Filter;
    private FilterColor2 _zone50Filter;
    private FilterColor2 _zone25Filter;
    private FilterColor2 _baseLineFilter;
    private Filter _customPriceFilter;

    #endregion

    #region Properties

    #region Settings

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Margin),
       GroupName = nameof(Strings.Settings), Description = nameof(Strings.MarginValueDescription), Order = 10)]

    public int Margin
    {
        get => _margin;
        set
        {
            _margin = value;
            RecalculateValues();
        }
    }

    [Parameter]
    [Range(0.000001, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TickCost),
        GroupName = nameof(Strings.Settings), Description = nameof(Strings.TickCostValueDescription), Order = 20)]
    public decimal TickCost
    {
        get => _tickCost;
        set
        {
            _tickCost = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ZoneWidth),
        GroupName = nameof(Strings.Settings), Description = nameof(Strings.DaysLookBackDescription), Order = 30)]
    public int ZoneWidth
    {
        get => _zoneWidthDays;
        set
        {
            _zoneWidthDays = Math.Max(1, value);
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomPrice),
      GroupName = nameof(Strings.Settings), Description = nameof(Strings.CustomPriceFilterDescription), Order = 40)]
    public Filter CustomPriceFilter 
    { 
        get => _customPriceFilter;
        set => SetTrackedProperty(ref _customPriceFilter, value, _ =>
        {
            RecalculateValues();
            RedrawChart();
        });
    }

    #endregion

    #region Visualization

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DirectionOfZone),
        GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ZoneDirectionDescription), Order = 10)]
    public ZoneDirection Direction
    {
        get => _direction;
        set
        {
            _direction = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone200),
       GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 15)]
    public FilterColor2 Zone200Filter 
	{ 
		get => _zone200Filter;
		set => SetTrackedProperty(ref _zone200Filter, value, propName =>
		{
            switch (propName)
            {
                case nameof(value.Value):
                    _200Line.Color = value.Value;
                    _200Rectangle.Brush = new SolidBrush(value.Value.Convert());
                    break;
                case nameof(value.Enabled):
                    _200Line.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

			RedrawChart();
        });
	}

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone150),
      GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 20)]
    public FilterColor2 Zone150Filter
    {
        get => _zone150Filter;
        set => SetTrackedProperty(ref _zone150Filter, value, propName =>
        {
            switch (propName)
            {
                case nameof(value.Value):
                    _150Line.Color = value.Value;
                    _150Rectangle.Brush = new SolidBrush(value.Value.Convert());
                    break;
                case nameof(value.Enabled):
                    _150Line.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

            RedrawChart();
        });
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone100),
    GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 30)]
    public FilterColor2 Zone100Filter
    {
        get => _zone100Filter; 
        set => SetTrackedProperty(ref _zone100Filter, value, propName =>
        {
            switch (propName)
            {
                case nameof(value.Value):
                    _100Line.Color = value.Value;
                    _100Rectangle.Brush = new SolidBrush(value.Value.Convert());
                    break;
                case nameof(value.Enabled):
                    _100Line.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

            RedrawChart();
        });
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone75),
    GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 40)]
    public FilterColor2 Zone75Filter
    {
        get => _zone75Filter;
        set => SetTrackedProperty(ref _zone75Filter, value, propName =>
        {
            switch (propName)
            {
                case nameof(value.Value):
                    _75Line.Color = value.Value;
                    _75Rectangle.Brush = new SolidBrush(value.Value.Convert());
                    break;
                case nameof(value.Enabled):
                    _75Line.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

            RedrawChart();
        });
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone50),
    GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 50)]
    public FilterColor2 Zone50Filter
    {
        get => _zone50Filter;
        set => SetTrackedProperty(ref _zone50Filter, value, propName =>
        {
            switch (propName)
            {
                case nameof(value.Value):
                    _50Line.Color = value.Value;
                    _50Rectangle.Brush = new SolidBrush(value.Value.Convert());
                    break;
                case nameof(value.Enabled):
                    _50Line.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

            RedrawChart();
        });
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone25),
    GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 60)]
    public FilterColor2 Zone25Filter
    {
        get => _zone25Filter;
        set => SetTrackedProperty(ref _zone25Filter, value, propName =>
        {
            switch (propName)
            {
                case nameof(value.Value):
                    _25Line.Color = value.Value;
                    _25Rectangle.Brush = new SolidBrush(value.Value.Convert());
                    break;
                case nameof(value.Enabled):
                    _25Line.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

            RedrawChart();
        });
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BaseLine),
    GroupName = nameof(Strings.Visualization), Description = nameof(Strings.EnabledColorElementDescription), Order = 60)]
    public FilterColor2 BaseLineFilter
    {
        get => _baseLineFilter;
        set => SetTrackedProperty(ref _baseLineFilter, value, propName =>
        {
			switch (propName)
			{
				case "Value":
                    _baseLineRenderPen = new(value.Value.Convert());
                    break;
                case "Enabled":
                    _baseLineLabel.VisualType = value.Enabled ? VisualMode.OnlyValueOnAxis : VisualMode.Hide;
                    break;
            }

            RedrawChart();
        });
    }

    #endregion

    #region Hidden 

    [Browsable(false)]
    [Obsolete]
    public Color Zone200LineColor
	{
		get => Zone200Filter.Value.Convert();
		set => Zone200Filter.Value = value.Convert();
	}

    [Browsable(false)]
	[Obsolete]
	public bool ShowZone200
	{
		get => Zone200Filter.Enabled;
		set => Zone200Filter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public Color Zone150LineColor
	{
        get => Zone150Filter.Value.Convert();
        set => Zone150Filter.Value = value.Convert();
    }

    [Browsable(false)]
    [Obsolete]
    public bool ShowZone150
	{
        get => Zone150Filter.Enabled;
        set => Zone150Filter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public Color Zone75LineColor
	{
        get => Zone75Filter.Value.Convert();
        set => Zone75Filter.Value = value.Convert();
    }

    [Browsable(false)]
    [Obsolete]
    public bool ShowZone75
	{
        get => Zone75Filter.Enabled;
        set => Zone75Filter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public Color Zone50LineColor
	{
        get => Zone50Filter.Value.Convert();
        set => Zone50Filter.Value = value.Convert();
    }

    [Browsable(false)]
    [Obsolete]
    public bool ShowZon50
	{
        get => Zone50Filter.Enabled;
        set => Zone50Filter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public Color Zone25LineColor
	{
        get => Zone25Filter.Value.Convert();
        set => Zone25Filter.Value = value.Convert();
    }

    [Browsable(false)]
    [Obsolete]
    public bool ShowZone25
	{
        get => Zone25Filter.Enabled;
        set => Zone25Filter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public Color Zone100LineColor
	{
        get => Zone100Filter.Value.Convert();
        set => Zone100Filter.Value = value.Convert();
    }

    [Browsable(false)]
    [Obsolete]
    public bool ShowZone100
	{
        get => Zone100Filter.Enabled;
        set => Zone100Filter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public Color BaseLineColor
	{
        get => BaseLineFilter.Value.Convert();
        set => BaseLineFilter.Value = value.Convert();
    }

    [Browsable(false)]
    [Obsolete]
    public bool ShowBaseLine
	{
        get => BaseLineFilter.Enabled;
        set => BaseLineFilter.Enabled = value;
    }

    [Browsable(false)]
    [Obsolete]
    public bool AutoPrice
	{
		get => !CustomPriceFilter.Enabled;
        set => CustomPriceFilter.Enabled = !value;

    }

    [Browsable(false)]
    [Obsolete]
    public decimal CustomPrice
	{
        get => CustomPriceFilter.Value;
        set => CustomPriceFilter.Value = value;
    }

    #endregion

    #endregion

    #region ctor

    public MarginZones()
		: base(true)
	{
		DenyToChangePanel = true;
		EnableCustomDrawing = true;
		DrawAbovePrice = false;
		SubscribeToDrawingEvents(DrawingLayouts.Historical);

        DataSeries[0] = _baseLineLabel;
        DataSeries.Add(_100Line);
		DataSeries.Add(_25Line);
		DataSeries.Add(_50Line);
		DataSeries.Add(_75Line);
		DataSeries.Add(_150Line);
		DataSeries.Add(_200Line);

        Zone200Filter = new(true) { Value = _200Line.Color, Enabled = _200Line.VisualType != VisualMode.Hide };
        Zone150Filter = new(true) { Value = _150Line.Color, Enabled = _150Line.VisualType != VisualMode.Hide };
        Zone100Filter = new(true) { Value = _100Line.Color, Enabled = _100Line.VisualType != VisualMode.Hide };
        Zone75Filter = new(true) { Value = _75Line.Color, Enabled = _75Line.VisualType != VisualMode.Hide };
        Zone50Filter = new(true) { Value = _50Line.Color, Enabled = _50Line.VisualType != VisualMode.Hide };
        Zone25Filter = new(true) { Value = _25Line.Color, Enabled = _25Line.VisualType != VisualMode.Hide };
        BaseLineFilter = new(true) { Value = _baseLineLabel.Color, Enabled = true };
        CustomPriceFilter = new(true);
    }

	#endregion

	#region Protected methods

	protected override void OnInitialize()
	{
		_baseLineLabel.ShowZeroValue = false;
		_100Line.ShowZeroValue = false;
		_25Line.ShowZeroValue = false;
		_50Line.ShowZeroValue = false;
		_75Line.ShowZeroValue = false;
		_150Line.ShowZeroValue = false;
		_200Line.ShowZeroValue = false;
    }

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (ChartInfo is null)
			return;

		if (BaseLineFilter.Enabled)
		{
			var x1 = ChartInfo.GetXByBar(_baseLine.FirstBar);
			var x2 = ChartInfo.GetXByBar(LastVisibleBarNumber);
			var y = ChartInfo.GetYByPrice(_baseLine.FirstPrice);

			if (x2 >= 0 && x1 <= Container.Region.Width && y >= 0 && y <= Container.Region.Height)
				context.DrawLine(_baseLineRenderPen, x1, y, x2, y);
		}

        if (Zone25Filter.Enabled)
            DrawZone(context, _25Rectangle, Zone25Filter.Value.Convert());

        if (Zone50Filter.Enabled)
            DrawZone(context, _50Rectangle, Zone50Filter.Value.Convert());

        if (Zone75Filter.Enabled)
            DrawZone(context, _75Rectangle, Zone75Filter.Value.Convert());

        if (Zone100Filter.Enabled)
            DrawZone(context, _100Rectangle, Zone100Filter.Value.Convert());

        if (Zone150Filter.Enabled)
            DrawZone(context, _150Rectangle, Zone150Filter.Value.Convert());

		if (Zone200Filter.Enabled)
			DrawZone(context, _200Rectangle, Zone200Filter.Value.Convert());
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_calculated = false;
			_newDays.Clear();
			_newDays.Add(0);
			_lastCalculated = 0;
			return;
		}

		if (IsNewSession(bar) && !_newDays.Contains(bar))
			_newDays.Add(bar);

		if (bar != CurrentBar - 1)
			return;

		if (_calculated)
		{
			if (IsNewWeek(bar))
				_calculated = false;

			var candle = GetCandle(bar);

			if (_direction == ZoneDirection.Up)
			{
				//ищем low
				if (candle.Low < _zonePrice)
					_calculated = false;
			}
			else if (_direction == ZoneDirection.Down)
			{
				//ищем high
				if (candle.High > _zonePrice)
					_calculated = false;
			}
		}
		else
		{
			_calculated = true;
			_baseLine.FirstBar = 0;
			_baseLine.SecondBar = 0;
			_baseLine.FirstPrice = 0;
			_baseLine.SecondPrice = 0;

            if (CustomPriceFilter.Enabled)
                _zonePrice = CustomPriceFilter.Value;
            else
            {
                var currentWeek = true;

                for (var i = bar; i >= _lastCalculated; i--)
                {
                    if (IsNewWeek(i))
                    {
                        if (!currentWeek)
                            break;

                        currentWeek = false;
                    }

                    if (currentWeek)
                        continue;

                    _zonePrice = 0;

                    var candle = GetCandle(i);

                    if (_direction == ZoneDirection.Up)
                    {
                        //ищем low
                        if (_zonePrice == 0 || candle.Low < _zonePrice)
                            _zonePrice = candle.Low;
                    }
                    else if (_direction == ZoneDirection.Down)
                    {
                        //ищем high
                        if (_zonePrice == 0 || candle.High > _zonePrice)
                            _zonePrice = candle.High;
                    }
                }
            }

			var firstBarNumber = Math.Max(_newDays.Count - _zoneWidthDays, 0);
			var firstBar = _newDays.Any() ? _newDays[firstBarNumber] : 0;
			var zoneSize = Margin / _tickCost * (_direction == ZoneDirection.Up ? 1 : -1);
			_zoneWidth = zoneSize * 0.1m * InstrumentInfo.TickSize;
			_secondPrice = _zonePrice + zoneSize * InstrumentInfo.TickSize;
			
			_baseLine.FirstBar = firstBar;
			_baseLine.SecondBar = bar;
			_baseLine.FirstPrice = _zonePrice;
			_baseLine.SecondPrice = _zonePrice;

			//Last value is hidden with single value in series
			_baseLineLabel[bar] = _baseLineLabel[bar - 1] = _zonePrice;
			_100Line[bar] = _100Line[bar - 1] = _secondPrice;
			_25Line[bar] = _25Line[bar - 1] = _zonePrice + zoneSize * 0.25m * InstrumentInfo.TickSize;
			_50Line[bar] = _50Line[bar - 1] = _zonePrice + zoneSize * 0.5m * InstrumentInfo.TickSize;
			_75Line[bar] = _75Line[bar - 1] = _zonePrice + zoneSize * 0.75m * InstrumentInfo.TickSize;
			_150Line[bar] = _150Line[bar - 1] = _zonePrice + zoneSize * 1.5m * InstrumentInfo.TickSize;
			_200Line[bar] = _200Line[bar - 1] = _zonePrice + zoneSize * 2m * InstrumentInfo.TickSize;

            SetRectanglesValues(_100Rectangle,firstBar, bar, _secondPrice, _zoneWidth);
            SetRectanglesValues(_25Rectangle, firstBar, bar, _25Line[bar], _zoneWidth / 4);
            SetRectanglesValues(_50Rectangle, firstBar, bar, _50Line[bar], _zoneWidth / 2);
            SetRectanglesValues(_75Rectangle, firstBar, bar, _75Line[bar], _zoneWidth / 4);
            SetRectanglesValues(_150Rectangle, firstBar, bar, _150Line[bar], _zoneWidth);
            SetRectanglesValues(_200Rectangle, firstBar, bar, _200Line[bar], _zoneWidth);

            _lastCalculated = bar;
		}

		foreach (var dataSeries in DataSeries)
		{
			var series = (ValueDataSeries)dataSeries;
			series[bar] = series[bar - 1];
        }
	}

    private void SetRectanglesValues(DrawingRectangle rectangle, int firstBar, int secondBar, decimal firstPrice, decimal width)
    {
        rectangle.FirstBar = firstBar;
        rectangle.SecondBar = secondBar;
        rectangle.FirstPrice = firstPrice;
        rectangle.SecondPrice = firstPrice + width;
    }

    #endregion

    #region Private methods

    private void DrawZone(RenderContext context, DrawingRectangle drawRect, Color color)
	{
		var x1 = ChartInfo.GetXByBar(drawRect.FirstBar);
		var x2 = ChartInfo.GetXByBar(LastVisibleBarNumber);
		var y1 = ChartInfo.GetYByPrice(drawRect.SecondPrice);
		var y2 = ChartInfo.GetYByPrice(drawRect.FirstPrice);

		if (x2 < 0 || x1 > Container.Region.Width || y2 < 0 || y2 > Container.Region.Height)
			return;

		var rect = new Rectangle(x1, y1, x2 - x1, y2 - y1);
		context.FillRectangle(color, rect);
	}

	#endregion
}









Technical/MarketFacilitation.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Market Facilitation Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MarketFacilitationDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602423")]
	public class MarketFacilitation : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private decimal _multiplier = 1;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription), Order = 100)]
		[Range(0.000000001, 1000000000)]
		public decimal Multiplier
		{
			get => _multiplier;
			set
			{
				_multiplier = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MarketFacilitation()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			_renderSeries[bar] = candle.Volume != 0
				? (candle.High - candle.Low) * _multiplier / candle.Volume
				: 0;
		}

		#endregion
	}
}








Indicators/Technical
/MarketPower.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Concurrent;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;
	using System.Threading;

	using OFT.Attributes;
	using OFT.Attributes.Editors;
    using OFT.Localization;
	
    [Category(IndicatorCategories.VolumeOrderFlow)]
	[DisplayName("CVD pro / Market Power")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MarketPowerDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602424")]
	public class MarketPower : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _barDelta = new("BarDeltaId", "BarDelta")
		{
			Color = CrossColor.FromArgb(255, 100, 149, 237),
			VisualType = VisualMode.Hide,
			IsHidden = true,
            UseMinimizedModeIfEnabled = true
		};
		private readonly ValueDataSeries _cumulativeDelta = new("CumulativeDelta", "HiLo")
		{
			Color = CrossColor.FromArgb(255, 100, 149, 237),
			Width = 2,
			IsHidden = true,
			ShowZeroValue = false,
            UseMinimizedModeIfEnabled = true
		};
        private readonly ValueDataSeries _higher = new("HigherId", "Higher")
        {
	        Color = CrossColor.FromArgb(255, 135, 206, 235),
			VisualType = VisualMode.Hide,
			IsHidden = true,
            UseMinimizedModeIfEnabled = true
        };
        private readonly ValueDataSeries _lower = new("LowerId", "Lower")
        {
			Color = CrossColor.FromArgb(255, 135, 206, 235),
			VisualType = VisualMode.Line,
			IsHidden = true,
			UseMinimizedModeIfEnabled = true
        };

        private readonly SMA _sma = new() { Period = 14 };

        private readonly ValueDataSeries _smaSeries = new("SmaSeries", "SMA")
        {
	        Color = CrossColor.FromArgb(255, 128, 128, 128),
	        IsHidden = true,
			ShowZeroValue = false,
            UseMinimizedModeIfEnabled = true
        };

		private bool _bigTradesIsReceived;
		private bool _cumulativeTrades = true;
		private decimal _delta;
		private int _lastBar = -1;
        private decimal _lastDelta;
		private decimal _lastMaxValue;
		private decimal _lastMinValue;

		private CumulativeTrade _lastTrade;
		private object _locker = new();
		private decimal _maxValue;
		private decimal _maxVolume;
		private decimal _minValue;
		private decimal _minVolume;
		private int _sessionBegin;
		private bool _showCumulative = true;
		private bool _showHiLo = true;
		private bool _showSma = true;
		private decimal _sum;

		private ConcurrentQueue<CumulativeTrade> _gapTrades = new();
		private ConcurrentQueue<MarketDataArg> _gapTicks = new();

		private bool _calculating;

        #endregion

        #region Properties

        #region Settings

        [Parameter]
        [Range(0, 1000000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 10)]
        public int SmaPeriod
        {
            get => _sma.Period;
            set
            {
                if (_sma.Period == value)
                    return;

                _sma.Period = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CumulativeTrades), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CumulativeTradesModeDescription), Order = 20)]
        [PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
        public bool CumulativeTrades
        {
            get => _cumulativeTrades;
            set
            {
                _cumulativeTrades = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 30)]
        [Range(0, 1000000)]
        [PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
        public decimal MinimumVolume
        {
            get => _minVolume;
            set
            {
                _minVolume = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 40)]
        [Range(0, 1000000)]
        [PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
        public decimal MaximumVolume
        {
            get => _maxVolume;
            set
            {
                _maxVolume = value;
                RecalculateValues();
            }
        }

        #endregion

        #region Visualization

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSMA), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.DisplaySMADescription), Order = 100)]
		public bool ShowSma
		{
			get => _showSma;
			set
			{
				_showSma = value;

				if (ShowCumulative)
					_smaSeries.VisualType = value ? VisualMode.Line : VisualMode.Hide;
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowHighLow), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.DisplayHighLowLineDescription), Order = 110)]
		public bool ShowHighLow
		{
			get => _showHiLo;
			set
			{
				_showHiLo = value;
				_higher.VisualType = value && !_showCumulative ? VisualMode.Histogram : VisualMode.Hide;

				_lower.VisualType = value
					? _showCumulative
						? VisualMode.Line
						: VisualMode.Histogram
					: VisualMode.Hide;
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowCumulative), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualModeHistogramDescription), Order = 120)]
		public bool ShowCumulative
		{
			get => _showCumulative;
			set
			{
				_showCumulative = value;

				if (value)
				{
					_lower.VisualType = VisualMode.Line;
					_cumulativeDelta.VisualType = VisualMode.Line;
					_higher.VisualType = VisualMode.Hide;
					_barDelta.VisualType = VisualMode.Hide;
					_smaSeries.VisualType = _showSma ? VisualMode.Line : VisualMode.Hide;
				}
				else
				{
					_lower.VisualType = VisualMode.Histogram;
					_higher.VisualType = VisualMode.Histogram;
					_barDelta.VisualType = VisualMode.Histogram;
					_cumulativeDelta.VisualType = VisualMode.Hide;
					_smaSeries.VisualType = VisualMode.Hide;
				}

				RecalculateValues();
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLowColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.HighLowLineColorDescription), Order = 300)]
		public CrossColor HighLowColor
		{
			get => _lower.Color;
			set => _lower.Color = _higher.Color = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.CumDeltaLineColorDescription), Order = 310)]
		public CrossColor LineColor
		{
			get => _cumulativeDelta.Color;
			set => _cumulativeDelta.Color = _barDelta.Color = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.SMALineColorDescription), Order = 320)]
		public CrossColor SmaColor
		{
			get => _smaSeries.Color;
			set => _smaSeries.Color = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.CumDeltaLineWidthDescription), Order = 330)]
		[Range(1, 100)]
		public int Width
		{
			get => _cumulativeDelta.Width;
			set => _cumulativeDelta.Width = value;
        }

        #endregion

        #endregion

        #region ctor

        public MarketPower()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _lower;
			DataSeries.Add(_smaSeries);
			DataSeries.Add(_cumulativeDelta);
			DataSeries.Add(_higher);
			DataSeries.Add(_barDelta);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			_bigTradesIsReceived = false;
            _gapTrades.Clear();
			_gapTicks.Clear();
			_calculating = true;
			_sma.SourceDataSeries = new ValueDataSeries("SMA");

			_maxValue = _minValue = _lastMaxValue = _lastMinValue = 0;
			DataSeries.ForEach(x => x.Clear());
			_delta = _lastDelta = 0;
			_barDelta.Clear();
        }

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == CurrentBar - 1 && _bigTradesIsReceived)
			{
				if (ShowCumulative)
				{
					if (_cumulativeDelta[bar] is 0)
						_cumulativeDelta[bar] = _cumulativeDelta[bar - 1];

					if (_lower[bar] is 0)
						_lower[bar] = _lower[bar - 1];

					if (_smaSeries[bar] is 0)
						_smaSeries[bar] = _smaSeries[bar - 1];
				}

				//_smaSeries[bar] = _sma.Calculate(bar, _cumulativeDelta[bar]);
			}
		}

		protected override void OnFinishRecalculate()
		{
			_sessionBegin = CurrentBar - 1;
			_lastBar = CurrentBar - 1;

			for (var i = CurrentBar - 1; i >= 0; i--)
			{
				if (!IsNewSession(i))
					continue;

				_sessionBegin = i;
				break;
			}

			for (var i = 0; i < _sessionBegin; i++)
				_sma.Calculate(i, 0);

			try
			{
				RequestForCumulativeTrades(new CumulativeTradesRequest(GetCandle(_sessionBegin).Time));
			}
			catch (ArgumentException)
			{
				var startTime = DateTime.Now;

				while ((DateTime.Now - startTime).TotalSeconds < 1 && !_bigTradesIsReceived)
					Thread.Sleep(10);

				RecalculateValues();
			}
		}

		protected override void OnCumulativeTradesResponse(CumulativeTradesRequest request, IEnumerable<CumulativeTrade> cumulativeTrades)
		{
			lock (_locker)
			{
				var trades = cumulativeTrades.Where(t=>t.Direction is not TradeDirection.Between).ToList();

				CalculateHistory(trades);

				if (CumulativeTrades)
					CalcCumulativeGap();
				else
					CalcSeparateGap();
			}

			_bigTradesIsReceived = true;
			_calculating = false;
        }
		
		protected override void OnNewTrade(MarketDataArg trade)
		{
			if (CumulativeTrades)
				return;

			if (!_bigTradesIsReceived)
			{
				if (_calculating)
					_gapTicks.Enqueue(trade);

				return;
			}

			var newBar = _lastBar < CurrentBar - 1;

			if (newBar)
				_lastBar = CurrentBar - 1;

			CalculateTick(trade, newBar, CurrentBar - 1);
        }
		
		protected override void OnCumulativeTrade(CumulativeTrade trade)
		{
			if(!CumulativeTrades)
				return;

			if (!_bigTradesIsReceived)
			{
				if(_calculating)
					_gapTrades.Enqueue(trade);

				return;
			}

			var newBar = _lastBar < CurrentBar - 1;

			if (newBar)
				_lastBar = CurrentBar - 1;
			
            CalculateTrade(trade, false, newBar, CurrentBar - 1);
        }

		protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
		{
			if (!CumulativeTrades)
				return;

            if (!_bigTradesIsReceived)
			{
				if (_calculating)
					_gapTrades.Enqueue(trade);

                return;
			}

            CalculateTrade(trade, true, false, CurrentBar - 1);
		}

		protected override void OnDispose()
		{
			_sma.Dispose();
			_gapTrades.Clear();
			_gapTicks.Clear();
		}

		#endregion

        #region Private methods

        private void CalcSeparateGap()
        {
            if (_gapTicks.TryPeek(out var firstTrade))
            {
                var histBar = CurrentBar - 1;
                var lastHistBar = 0;
                var candle = GetCandle(CurrentBar - 1);

                for (var i = CurrentBar - 1; i >= _sessionBegin; i--)
                {
                    candle = GetCandle(i);

                    if (firstTrade.Time >= candle.Time && firstTrade.Time <= candle.LastTime)
                    {
                        histBar = i;
                        break;
                    }
                }

                while (_gapTicks.TryDequeue(out var trade))
                {
                    if (trade.Time < _lastTrade.Time)
                        continue;

                    if (!(trade.Time >= candle.Time && trade.Time <= candle.LastTime))
                    {
                        for (var i = histBar + 1; i < CurrentBar; i++)
                        {
                            candle = GetCandle(i);

                            if (trade.Time < candle.Time || trade.Time > candle.LastTime)
                                continue;

                            histBar = i;
                            break;
                        }
                    }

                    CalculateTick(trade, lastHistBar != histBar, histBar);
                    lastHistBar = histBar;
                }
            }
        }

        private void CalcCumulativeGap()
        {
            if (_gapTrades.TryPeek(out var firstTrade))
            {
                var histBar = CurrentBar - 1;
                var lastHistBar = 0;
                var candle = GetCandle(CurrentBar - 1);

                for (var i = CurrentBar - 1; i >= _sessionBegin; i--)
                {
                    candle = GetCandle(i);

                    if (firstTrade.Time >= candle.Time && firstTrade.Time <= candle.LastTime)
                    {
                        histBar = i;
                        break;
                    }
                }

                while (_gapTrades.TryDequeue(out var trade))
                {
                    if (trade.Time < _lastTrade.Time)
                        continue;

                    if (!(trade.Time >= candle.Time && trade.Time <= candle.LastTime))
                    {
                        for (var i = histBar + 1; i < CurrentBar; i++)
                        {
                            candle = GetCandle(i);

                            if (trade.Time < candle.Time || trade.Time > candle.LastTime)
                                continue;

                            histBar = i;
                            break;
                        }
                    }

                    var isUpdate = _lastTrade.IsEqual(trade);
                    CalculateTrade(trade, isUpdate, lastHistBar != histBar, histBar);
                    lastHistBar = histBar;
                }
            }
        }

        private void CalculateHistory(List<CumulativeTrade> trades)
		{
			for (var i = 0; i < _sessionBegin; i++)
				_sma.Calculate(i, 0); //SMA must be calculated from first bar

			var lastTradeIdx = 0;

			if (trades.Count is 0)
				return;

            trades = trades.OrderBy(x => x.Time).ToList();
			
			for (var i = _sessionBegin; i <= CurrentBar - 1; i++)
			{
				CalculateBarTrades(trades, i, ref lastTradeIdx);

				if (_cumulativeDelta[i] == 0)
					_cumulativeDelta[i] = _cumulativeDelta[i - 1];

				_smaSeries[i] = _sma.Calculate(i, _cumulativeDelta[i]);

				RaiseBarValueChanged(i);
			}
			
			_lastTrade = trades[^1];

			_lastDelta = (_lastTrade.Direction is TradeDirection.Buy ? 1 : -1) *
				(CumulativeTrades 
					? _lastTrade.Volume 
					: _lastTrade.Ticks.Last().Volume);

			if (!ShowCumulative)
			{
				_lastMinValue = _lastMaxValue = 0;
				_sum = ShowCumulative ? _delta : 0;
				_lastDelta = 0;
            }

			RedrawChart();
		}

		//History
		private void CalculateBarTrades(List<CumulativeTrade> trades, int bar, ref int startIdx)
		{
			var candle = GetCandle(bar);
			
			var candleTrades = new List<CumulativeTrade>();
			
            for (var i = startIdx; i < trades.Count; i++)
            {
	            var trade = trades[i];

				if(trade.Direction is TradeDirection.Between)
					continue;

				if (trade.Time > candle.LastTime)
				{
					startIdx = i;
					break;
				}

				if (trade.Time < candle.Time)
					continue;

				candleTrades.Add(trade);
            }
			
			var sum = ShowCumulative ? _delta : 0;

			_lastMinValue = _lastMaxValue = 0;

			if (CumulativeTrades)
			{
				var filterTrades = candleTrades
					.Where(x => x.Volume >= _minVolume && (x.Volume <= _maxVolume || _maxVolume == 0))
					.ToList();

				foreach (var trade in filterTrades)
				{
					sum += trade.Volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);

					if (sum > _lastMaxValue || _lastMaxValue == 0)
						_lastMaxValue = sum;

					if (sum < _lastMinValue || _lastMinValue == 0)
						_lastMinValue = sum;
				}

				_lastDelta =
					filterTrades
						.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1)
						);
			}
			else
			{
				var filterTrades = candleTrades
					.SelectMany(x => x.Ticks)
					.Where(x => x.Volume >= _minVolume && (x.Volume <= _maxVolume || _maxVolume == 0))
					.ToList();

				foreach (var trade in filterTrades)
				{
					sum += trade.Volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);

					if (sum > _lastMaxValue || _lastMaxValue == 0)
						_lastMaxValue = sum;

					if (sum < _lastMinValue || _lastMinValue == 0)
						_lastMinValue = sum;
				}

				_lastDelta =
					filterTrades
						.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1)
						);
			}

			_sum = sum;
			_maxValue = _lastMaxValue;
			_minValue = _lastMinValue;

			_delta += _lastDelta;

			_cumulativeDelta[bar] = _delta == 0 ? _cumulativeDelta[bar - 1] : _delta;

			_barDelta[bar] = _lastDelta;

			if (ShowCumulative)
			{
				_higher[bar] = _maxValue == 0 ? _higher[bar - 1] : _maxValue;
				_lower[bar] = _minValue == 0 ? _lower[bar - 1] : _minValue;
            }
			else
			{
				if (_barDelta[bar] > _lastMaxValue || _lastMaxValue == 0)
					_lastMaxValue = _barDelta[bar];

				if (_barDelta[bar] < _lastMinValue || _lastMinValue == 0)
					_lastMinValue = _barDelta[bar];

				_higher[bar] = _lastMaxValue == 0 ? _higher[bar - 1] : _lastMaxValue;
				_lower[bar] = _lastMinValue == 0 ? _lower[bar - 1] : _lastMinValue;
			}

			if (bar == CurrentBar - 1)
				_smaSeries[bar] = _sma.Calculate(bar, _cumulativeDelta[bar]);

			RaiseBarValueChanged(bar);
		}

		private void CalculateTick(MarketDataArg trade, bool newBar, int bar)
		{
			if (newBar)
			{
				_lastMinValue = _lastMaxValue = 0;
				_sum = ShowCumulative ? _delta : 0;
				_lastDelta = 0;
			}

			if(trade.Volume < _minVolume || trade.Volume > _maxVolume && _maxVolume is not 0)
				return;

			_sum += trade.Volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);

			if (_sum > _lastMaxValue || _lastMaxValue == 0)
				_lastMaxValue = _sum;

			if (_sum < _lastMinValue || _lastMinValue == 0)
				_lastMinValue = _sum;

			_maxValue = _lastMaxValue;
			_minValue = _lastMinValue;

			_lastDelta = trade.Volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);

			_delta += _lastDelta;
			_barDelta[bar] += _lastDelta; _cumulativeDelta[bar] = _delta == 0 ? _cumulativeDelta[bar] : _delta;

			if (ShowCumulative)
			{
				_higher[bar] = _maxValue == 0 ? _higher[bar - 1] : _maxValue;
				_lower[bar] = _minValue == 0 ? _lower[bar - 1] : _minValue;
			}
			else
			{
				if (_barDelta[bar] > _lastMaxValue || _lastMaxValue == 0)
					_lastMaxValue = _barDelta[bar];

				if (_barDelta[bar] < _lastMinValue || _lastMinValue == 0)
					_lastMinValue = _barDelta[bar];

				_higher[bar] = _lastMaxValue;
				_lower[bar] = _lastMinValue;
			}

			_smaSeries[bar] = _sma.Calculate(bar, _cumulativeDelta[bar]);
			
			RaiseBarValueChanged(bar);
        }

        private void CalculateTrade(CumulativeTrade trade, bool isUpdate, bool newBar, int bar)
		{
			if (newBar)
			{
				_lastMinValue = _lastMaxValue = 0;
				_sum = ShowCumulative ? _delta : 0;
				_lastDelta = 0;
			}

			if (isUpdate && _lastTrade != null && IsTradeValid(_lastTrade))
			{
				var oldSum = _sum;
				_sum -= _lastTrade.Volume * (_lastTrade.Direction == TradeDirection.Buy ? 1 : -1);

				if (oldSum == _lastMaxValue)
					_lastMaxValue = _sum;

				if (oldSum == _lastMinValue)
					_lastMinValue = _sum; 
				
				_delta -= _lastDelta;
				_barDelta[bar] -= _lastDelta;
            }
			
			if (IsTradeValid(trade))
			{
				_sum += trade.Volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);

				if (_sum > _lastMaxValue || _lastMaxValue == 0)
					_lastMaxValue = _sum;

				if (_sum < _lastMinValue || _lastMinValue == 0)
					_lastMinValue = _sum;

				_maxValue = _lastMaxValue;
				_minValue = _lastMinValue;

				_lastDelta = trade.Volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);
				_delta += _lastDelta;
				_barDelta[bar] += _lastDelta;
            }

			_cumulativeDelta[bar] = _delta == 0 ? _cumulativeDelta[bar] : _delta;
            
            if (ShowCumulative)
			{
				_higher[bar] = _maxValue == 0 ? _higher[bar - 1] : _maxValue;
				_lower[bar] = _minValue == 0 ? _lower[bar - 1] : _minValue;
            }
			else
			{
				if (_barDelta[bar] > _lastMaxValue || _lastMaxValue == 0)
					_lastMaxValue = _barDelta[bar];

				if (_barDelta[bar] < _lastMinValue || _lastMinValue == 0)
					_lastMinValue = _barDelta[bar];

				_higher[bar] = _lastMaxValue;
				_lower[bar] = _lastMinValue;
			}

			_smaSeries[bar] = _sma.Calculate(bar, _cumulativeDelta[bar]);

			_lastTrade = trade;

			RaiseBarValueChanged(bar);
		}

		private bool IsTradeValid(CumulativeTrade trade)
		{
			return trade.Volume >= _minVolume && (trade.Volume <= _maxVolume || _maxVolume is 0);
		}

        #endregion
	}
}








Technical/MaxLevels.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Linq;
	using System.Reflection;

	using OFT.Attributes;
    using OFT.Attributes.Editors;
    using OFT.Localization;
    using OFT.Rendering.Context;
    using OFT.Rendering.Tools;
    [DisplayName("Maximum Levels")]
	[Category(IndicatorCategories.VolumeOrderFlow)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MaxLevelsIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602426")]
    public class MaxLevels : Indicator
	{
		#region Nested types

		[Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
		public enum MaxLevelType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
			Bid,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
			Ask,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PositiveDelta))]
			PositiveDelta,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.NegativeDelta))]
			NegativeDelta,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
			Volume,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Tick,

			[Obsolete]
			[Browsable(false)]
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Time))]
			Time
		}

		private sealed class TradingSessionsSource(MaxLevels indicator)
			: Collection<TradingSessionDescription>(indicator.DataProvider?.ChartInfo?.TradingSessionDescriptions?.ToList() ?? [])
		{
		}

        #endregion

        #region Fields

        private RenderFont _axisFont = new("Arial", 11F, FontStyle.Regular, GraphicsUnit.Point, 204);
		private Color _axisTextColor = System.Drawing.Color.White;
		private IndicatorCandle _candle;
		private bool _candleRequested;
		private string _description = "Current Day";
		private RenderFont _font = new("Arial", 10);
		private int _lastAlert;
		private int _lastSession;
		private Color _lineColor = System.Drawing.Color.CornflowerBlue;
		private FixedProfilePeriods _period = FixedProfilePeriods.CurrentDay;
		private long? _tradingSession;
		private decimal _prevClose;
		private RenderPen _renderPen = new(System.Drawing.Color.CornflowerBlue, 2);

		private RenderStringFormat _stringRightFormat = new()
		{
			Alignment = StringAlignment.Far,
			LineAlignment = StringAlignment.Center,
			Trimming = StringTrimming.EllipsisCharacter,
			FormatFlags = StringFormatFlags.NoWrap
		};

		private Color _textColor = System.Drawing.Color.Black;
		private int _width = 2;

        #endregion

        #region Properties

        #region Calculation

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.Period), Description = nameof(Strings.ProfilePeriodDescription), Order = 10)]
		public FixedProfilePeriods Period
		{
			get => _period;
			set
			{
				_period = value;
				_description = GetPeriodDescription(_period);
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			GroupName = nameof(Strings.Calculation),
			Name = nameof(Strings.TradingSession),
			Description = nameof(Strings.TradingSessionDescription),
            Order = 15)]
		[ComboBoxEditor(typeof(TradingSessionsSource), 
			DisplayMember = nameof(TradingSessionDescription.Name), 
			ValueMember = nameof(TradingSessionDescription.Id),
			SelectItemWithNullValue = true)]
        public long? TradingSession
        {
			get => _tradingSession;
			set
			{
				if (_tradingSession == value)
					return;

				_tradingSession = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.Type), Description = nameof(Strings.SourceTypeDescription), Order = 20)]
		public MaxLevelType Type { get; set; } = MaxLevelType.Volume;

        #endregion

        #region Visualization

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Color), Description = nameof(Strings.LineColorDescription), Order = 30)]
		public CrossColor Color
		{
			get => _lineColor.Convert();
			set
			{
				_lineColor = value.Convert();
				_renderPen = new RenderPen(_lineColor, _width);
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Width), Description = nameof(Strings.LineWidthDescription), Order = 40)]
		[Range(1, 100)]
		public int Width
		{
			get => _width;
			set
			{
				_width = value;
				_renderPen = new RenderPen(_lineColor, _width);
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.Length), Description = nameof(Strings.LineLengthDescription), Order = 45)]
		[Range(1, 10000)]
		public int Length { get; set; } = 300;

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Visualization), Name = nameof(Strings.AxisTextColor), Description = nameof(Strings.AxisTextColorDescription), Order = 50)]
		public CrossColor AxisTextColor
		{
			get => _axisTextColor.Convert();
			set => _axisTextColor = value.Convert();
		}

        #endregion

        #region Label

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.LabelOffset), Description = nameof(Strings.LabelOffsetXDescription), Order = 51)]
		[Range(0, 10000)]
        public int LabelOffset { get; set; }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Text), Description = nameof(Strings.IsNeedShowLabelDescription), Order = 52)]
		public bool ShowText { get; set; } = true;

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.CustomLabel), Description = nameof(Strings.LabelTextDescription), Order = 54)]
		public String CustomLabel { get; set; }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Value), Description = nameof(Strings.ShowValueOnLabelDescription), Order = 55)]
		public bool ShowValue { get; set; }

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Color), Description = nameof(Strings.LabelTextColorDescription), Order = 60)]
		public CrossColor TextColor
		{
			get => _textColor.Convert();
			set => _textColor = value.Convert();
		}

        [Range(7, 100)]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Label), Name = nameof(Strings.Size), Description = nameof(Strings.FontSizeDescription), Order = 70)]
		public int FontSize
		{
			get => (int)_font.Size;
			set => _font = new RenderFont("Arial", value);
		}

        #endregion

        #region Alerts

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertDescription), Order = 100)]
		public bool UseAlert { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 110)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription), Order = 120)]
		public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 130)]
		public CrossColor AlertBgColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

        #endregion

        #endregion

        #region ctor

        public MaxLevels()
			: base(true)
		{
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.LatestBar | DrawingLayouts.Historical);
			DrawAbovePrice = true;
		}

		#endregion

		#region Protected methods
		
		protected override void OnApplyDefaultColors()
		{
			if (ChartInfo is null)
				return;

			AxisTextColor = ChartInfo.ColorsStore.AxisTextColor.Convert();
			TextColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor.Convert();
        }
		
		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_lastAlert = 0;
				_prevClose = GetCandle(CurrentBar - 1).Close;
			}

			if (bar == 0 || IsNewSession(bar) && _lastSession != bar)
				_candleRequested = false;

			if (bar != CurrentBar - 1)
				return;

			if (!_candleRequested)
			{
				_candleRequested = true;
				GetFixedProfile(new FixedProfileRequest(Period, TradingSession));
				_lastSession = bar;
			}

			var candle = GetCandle(bar);

			if (UseAlert && _lastAlert != bar && _candle is not null)
			{
				var priceInfo = GetPriceVolumeInfo(_candle, Type);

				if (candle.Close >= priceInfo.Price && _prevClose < priceInfo.Price
				    ||
				    candle.Close <= priceInfo.Price && _prevClose > priceInfo.Price)
				{
					AddAlert(AlertFile, InstrumentInfo.Instrument, $"Price reached maximum level: {priceInfo.Price}", AlertBgColor, AlertForeColor);
					_lastAlert = bar;
				}
			}

			_prevClose = candle.Close;
		}

		protected override void OnFixedProfilesResponse(IndicatorCandle fixedProfileScaled, IndicatorCandle fixedProfileOriginScale, FixedProfilePeriods period)
		{
			_candle = fixedProfileOriginScale;
			RedrawChart();
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			if(ChartInfo is null || InstrumentInfo is null)
				return;

			if (_candle == null)
				return;

			var priceInfo = GetPriceVolumeInfo(_candle, Type);

			if (priceInfo == null)
				return;

			var y = ChartInfo.GetYByPrice(priceInfo.Price, false);
			var firstX = ChartInfo.PriceChartContainer.Region.Width - Length;
			var secondX = ChartInfo.PriceChartContainer.Region.Width;

			context.DrawLine(_renderPen, firstX, y, secondX, y);

			this.DrawLabelOnPriceAxis(context, string.Format(ChartInfo.StringFormat, priceInfo.Price), y, _axisFont, _lineColor, _axisTextColor);

			if (!ShowText && !ShowValue)
				return;

			var renderText = "";

			if (ShowText)
				renderText += string.IsNullOrWhiteSpace(CustomLabel) ? _description : CustomLabel;

            if (ShowValue)
			{
				var value = Type switch
				{
					MaxLevelType.Bid => priceInfo.Bid,
					MaxLevelType.Ask => priceInfo.Ask,
					MaxLevelType.PositiveDelta => priceInfo.Ask - priceInfo.Bid,
					MaxLevelType.NegativeDelta => priceInfo.Ask - priceInfo.Bid,
					MaxLevelType.Tick => priceInfo.Ticks,
					MaxLevelType.Time => priceInfo.Time,
					_ => priceInfo.Volume
				};

				var stringValue = CutValue(value);

				if (ShowText)
					renderText += " " + stringValue;
			}

			var size = context.MeasureString(renderText, _font);

			var textRect = new Rectangle(new Point(ChartInfo.PriceChartContainer.Region.Width - size.Width - 20 - LabelOffset, y - size.Height - Width / 2),
				new Size(size.Width + 20, size.Height));

			context.SetTextRenderingHint(RenderTextRenderingHint.Aliased);
			context.DrawString(renderText, _font, _textColor, textRect, _stringRightFormat);
			context.SetTextRenderingHint(RenderTextRenderingHint.AntiAlias);
		}

		#endregion

		#region Private methods

		private string CutValue(decimal value)
		{
			var kValue = value / 1000;
			var mValue = value / 1000000;

			if (kValue < 1)
				return $"{value:0.##}";

			return mValue < 1
				? $"{kValue:0.##}K"
				: $"{mValue:0.##}M";
		}

		private string GetPeriodDescription(FixedProfilePeriods period)
		{
			return period switch
			{
				FixedProfilePeriods.CurrentDay => "Current day",
				FixedProfilePeriods.LastDay => "Last day",
				FixedProfilePeriods.CurrentWeek => "Current week",
				FixedProfilePeriods.LastWeek => "Last week",
				FixedProfilePeriods.CurrentMonth => "Current month",
				FixedProfilePeriods.LastMonth => "Last month",
				FixedProfilePeriods.Contract => "Contract",
				_ => throw new ArgumentOutOfRangeException(nameof(period), period, null)
			};
		}

		private PriceVolumeInfo GetPriceVolumeInfo(IndicatorCandle candle, MaxLevelType levelType)
		{
			return Type switch
			{
				MaxLevelType.Bid => _candle.MaxBidPriceInfo,
				MaxLevelType.Ask => _candle.MaxAskPriceInfo,
				MaxLevelType.PositiveDelta => _candle.MaxPositiveDeltaPriceInfo,
				MaxLevelType.NegativeDelta => _candle.MaxNegativeDeltaPriceInfo,
				MaxLevelType.Volume => _candle.MaxVolumePriceInfo,
				MaxLevelType.Tick => _candle.MaxTickPriceInfo,
				MaxLevelType.Time => _candle.MaxTimePriceInfo,
				_ => throw new ArgumentOutOfRangeException()
			};
		}

		#endregion
	}
}










Technical/McClellanOscillator.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("McClellan Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.McClellanOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602558")]
	public class McClellanOscillator : Indicator
	{
		#region Fields

		private readonly EMA _mEmaLong = new() { Period = 39 };
		private readonly EMA _mEmaShort = new() { Period = 19 };
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", "McClellan Oscillator")
		{
			Color = System.Drawing.Color.LimeGreen.Convert(),
			Width = 2,
			UseMinimizedModeIfEnabled = true
		};

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int ShortPeriod
		{
			get => _mEmaShort.Period;
			set
			{
				_mEmaShort.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _mEmaLong.Period;
			set
			{
				_mEmaLong.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public McClellanOscillator()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_renderSeries[bar] = _mEmaShort.Calculate(bar, value) - _mEmaLong.Calculate(bar, value);
		}

		#endregion
	}
}






Technical/MeanDeviation.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Mean Deviation")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MeanDevDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602428")]
	public class MeanDev : Indicator
	{
		#region Fields

		private readonly SMA _sma = new() { Period = 10 };

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
        public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MeanDev()
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var sma = _sma.Calculate(bar, value);

			var start = Math.Max(0, bar - Period + 1);
			var count = Math.Min(bar + 1, Period);

			var sum = 0m;

			for (var i = start; i < start + count; i++)
				sum += Math.Abs((decimal)SourceDataSeries[i] - sma);

			this[bar] = sum / count;
		}

		#endregion
	}
}








Technical/Momentum.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Momentum")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MomentumDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602429")]
	public class Momentum : Indicator
	{
		#region Fields

		private readonly SMA _sma = new();
		private readonly ValueDataSeries _smaSeries = new("SmaSeries", Strings.SMA)
		{
			Color = DefaultColors.Blue.Convert(),
			UseMinimizedModeIfEnabled = true,
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.SmaSetingsDescription)
		};

		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Common), Description = nameof(Strings.PeriodDescription), Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSMA), GroupName = nameof(Strings.SMA), Description = nameof(Strings.DisplaySMADescription), Order = 200)]
		public bool ShowSma
		{
			get => _smaSeries.VisualType == VisualMode.Line;
			set => _smaSeries.VisualType = value ? VisualMode.Line : VisualMode.Hide;
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.SMAPeriodDescription), Order = 210)]
		[Range(1, 10000)]
        public int SmaPeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Momentum()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
			DataSeries[0].DescriptionKey = nameof(Strings.BaseLineSettingsDescription);
            DataSeries.Add(_smaSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var start = Math.Max(0, bar - Period + 1);
			this[bar] = value - (decimal)SourceDataSeries[start];
			_smaSeries[bar] = _sma.Calculate(bar, this[bar]);
		}

		#endregion
	}
}







Technical/MomentumOscillator.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Price Momentum Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MomentumOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602449")]
	public class MomentumOscillator : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 10 };
		private readonly ValueDataSeries _rateSeries = new("Rate");

		private readonly ValueDataSeries _signalSeries = new("SignalSeries", Strings.Line)
		{
			Color = DefaultColors.Red.Convert(),
			UseMinimizedModeIfEnabled = true,
			DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
		};

		private readonly ValueDataSeries _smoothSeries = new("SmoothSeries", Strings.EMA)
		{
			Color = DefaultColors.Blue.Convert(),
			UseMinimizedModeIfEnabled = true,
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.EMALineSettingsDescription)
        };

		private int _period1 = 10;
		private int _period2 = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SignalPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
		public int SignalPeriod
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period1), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int Period1
		{
			get => _period1;
			set
			{
				_period1 = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period2), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 120)]
		[Range(1, 10000)]
		public int Period2
		{
			get => _period2;
			set
			{
				_period2 = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MomentumOscillator()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _signalSeries;
			DataSeries.Add(_smoothSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var rate = 100m * (value - (decimal)SourceDataSeries[bar - 1]) / (decimal)SourceDataSeries[bar - 1];
			_rateSeries[bar] = 2m / _period1 * (rate - _rateSeries[bar - 1]) + _rateSeries[bar - 1];
			_signalSeries[bar] = 2m / _period2 * (_rateSeries[bar] - _signalSeries[bar - 1]) + _signalSeries[bar - 1];

			_smoothSeries[bar] = _ema.Calculate(bar, 10 * _signalSeries[bar]);
		}

		#endregion
	}
}








Technical/MomentumTrend.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Momentum Trend")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MomentumTrendDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602636")]
	public class MomentumTrend : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _downSeries = new("DownSeries", Strings.Down)
		{
			Color = DefaultColors.Red.Convert(),
			VisualType = VisualMode.Dots,
			Width = 3,
            DescriptionKey = nameof(Strings.IncreasedMomentumSettingsDescription)
        };
		private readonly ValueDataSeries _upSeries = new("UpSeries", Strings.Up)
		{
			Color = DefaultColors.Green.Convert(),
			VisualType = VisualMode.Dots,
			Width = 3,
            DescriptionKey = nameof(Strings.DecreasedMomentumSettingsDescription)
        };

		private readonly Momentum _momentum = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _momentum.Period;
			set
			{
				_momentum.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MomentumTrend()
		{
			DenyToChangePanel = true;
			
			DataSeries[0] = _upSeries;
			DataSeries.Add(_downSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_momentum.Calculate(bar, value);

			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				return;
			}

			var candle = GetCandle(bar);

			if (_momentum[bar] > _momentum[bar - 1])
				_upSeries[bar] = candle.High;
			else
				_downSeries[bar] = candle.Low;
		}

		#endregion
	}
}








Technical/MovingAverage.cs







namespace ATAS.Indicators.Technical;

using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

[DisplayName("Moving Average")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.MovingAverageIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000618959")]
public class MovingAverage : Indicator
{
    #region Nested Types

    public enum MovingType
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BWMA))]
        Bwma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DEMA))]
        Dema,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA))]
        Ema,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA))]
        Sma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMMA))]
        Smma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SZMA))]
        Szma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TEMA))]
        Tema,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TMA))]
        Tma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA))]
        Wma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WWMA))]
        Wwma,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ZLEMA))]
        Zlema,
    }

    #endregion

    #region Fields

    private readonly ValueDataSeries _data = new("Data", "MA");

    private BWMA _bwma;
    private DEMA _dema;
    private EMA _ema;
    private SMA _sma;
    private SMMA _smma;
    private SZMA _szma;
    private TEMA _tema;
    private TMA _tma;
    private WMA _wma;
    private WWMA _wwma;
    private ZLEMA _zlema;

    private bool _onLine;
    private int _lastAlert;

    private int _period = 10;
    private MovingType _movType = MovingType.Sma;
    private bool _coloredDirection;
    private Color _bullishColor = DefaultColors.Green;
    private Color _bearishColor = DefaultColors.Red;

    #endregion

    #region Properties

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
    public int Period 
    { 
        get => _period;
        set
        {
            _period = value;
            SetPeriod(value);
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MovingType), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription))]
    public MovingType MovType 
    { 
        get => _movType; 
        set
        {
            _movType = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColoredDirection), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColoredDirectionDescription))]
    public bool ColoredDirection 
    {
        get => _coloredDirection; 
        set
        {
            _coloredDirection = value;
            RecalculateValues();
        } 
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription))]
    public Color BullishColor 
    {
        get => _bullishColor;
        set
        {
            _bullishColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription))]
    public Color BearishColor 
    { 
        get => _bearishColor;
        set
        {
            _bearishColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.ApproximationAlert), Description = nameof(Strings.UseAlertsDescription))]
    public bool UseAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RepeatAlert), GroupName = nameof(Strings.ApproximationAlert), Description = nameof(Strings.RepeatAlertDescription))]
    public bool RepeatAlert { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ApproximationFilter), GroupName = nameof(Strings.ApproximationAlert), Description = nameof(Strings.ApproximationFilterDescription))]
    [Range(0, 100000)]
    public int AlertSensitivity { get; set; } = 1;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.ApproximationAlert), Description = nameof(Strings.AlertFileDescription))]
    public string AlertFile { get; set; } = "alert1";

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.ApproximationAlert), Description = nameof(Strings.AlertTextColorDescription))]
    public Color FontColor { get; set; } = DefaultColors.White;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.ApproximationAlert), Description = nameof(Strings.AlertFillColorDescription))]
    public Color BackgroundColor { get; set; } = DefaultColors.Gray;

    #endregion

    #region ctor

    public MovingAverage() 
    {
        DataSeries[0] = _data;
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        switch (_movType)
        {
            case MovingType.Bwma:
                _bwma = new() { Period = _period };
                break;
            case MovingType.Dema:
                _dema = new() { Period = _period };
                break;
            case MovingType.Ema:
                _ema = new() { Period = _period };
                break;
            case MovingType.Szma:
                _szma = new() { Period = _period };
                break;
            case MovingType.Smma:
                _smma = new() { Period = _period };
                break;
            case MovingType.Sma:
                _sma = new() { Period = _period };
                break;
            case MovingType.Tema:
                _tema = new() { Period = _period };
                break;
            case MovingType.Tma:
                _tma = new() { Period = _period };
                break;
            case MovingType.Zlema:
                _zlema = new() { Period = _period };
                break;
            case MovingType.Wma:
                _wma = new() { Period = _period };
                break;
            case MovingType.Wwma:
                _wwma = new() { Period = _period };
                break;
        }
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        _data[bar] = GetMA(bar, value);

        if (bar == 0)
            return;

        if (ColoredDirection)
        {
            _data.Colors[bar] = _data[bar] > _data[bar - 1]
           ? _bullishColor
           : _bearishColor;
        }

        if (bar != CurrentBar - 1 || !UseAlerts)
            return;

        if (_lastAlert == bar && !RepeatAlert)
            return;

        var close = GetCandle(bar).Close;
        var onLine = Math.Abs(_data[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivity;

        if (onLine && !_onLine)
        {
            AddAlert(AlertFile, InstrumentInfo.Instrument, $"MA approximation alert: {_data[bar]:0.#####}", BackgroundColor.Convert(), FontColor.Convert());
            _lastAlert = bar;
        }

        _onLine = onLine;
    }

    #endregion

    #region Private Methods

    private decimal GetMA(int bar, decimal value)
    {
        return _movType switch
        {
            MovingType.Bwma => _bwma.Calculate(bar, value),
            MovingType.Dema => _dema.Calculate(bar, value),
            MovingType.Ema => _ema.Calculate(bar, value),
            MovingType.Szma => _szma.Calculate(bar, value),
            MovingType.Smma => _smma.Calculate(bar, value),
            MovingType.Sma => _sma.Calculate(bar, value),
            MovingType.Tema => _tema.Calculate(bar, value),
            MovingType.Tma => _tma.Calculate(bar, value),
            MovingType.Zlema => _zlema.Calculate(bar, value),
            MovingType.Wma => _wma.Calculate(bar, value),
            MovingType.Wwma => _wwma.Calculate(bar, value),
            _ => 0m
        };
    }

    private void SetPeriod(int period)
    {
        switch (_movType)
        {
            case MovingType.Bwma:
                if (_bwma != null)
                    _bwma.Period = period;
                break;
            case MovingType.Dema:
                if (_dema != null)
                    _dema.Period = period;
                break;
            case MovingType.Ema:
                if (_ema != null)
                    _ema.Period = period;
                break;
            case MovingType.Szma:
                if (_szma != null)
                    _szma.Period = period;
                break;
            case MovingType.Smma:
                if (_smma != null)
                    _smma.Period = period;
                break;
            case MovingType.Sma:
                if (_sma != null)
                    _sma.Period = period;
                break;
            case MovingType.Tema:
                if (_tema != null)
                    _tema.Period = period;
                break;
            case MovingType.Tma:
                if (_tma != null)
                    _tma.Period = period;
                break;
            case MovingType.Zlema:
                if (_zlema != null)
                    _zlema.Period = period;
                break;
            case MovingType.Wma:
                if (_wma != null)
                    _wma.Period = period;
                break;
            case MovingType.Wwma:
                if (_wwma != null)
                    _wwma.Period = period;
                break;
        }
    }


    #endregion
}








Technical/MultiMarketPower.cs






namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Attributes.Editors;
using OFT.Localization;
using Utils.Common;

[Category(IndicatorCategories.VolumeOrderFlow)]
[DisplayName("CVD pro(multi) / Multi Market Powers")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.MultiMarketPowerDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602434")]
public class MultiMarketPower : Indicator
{
	#region Fields

	private readonly ValueDataSeries _filter1Series = new("Filter1Series", "Filter1")
	{
		Color = CrossColor.FromArgb(255, 135, 206, 235),
		IsHidden = true,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true
	};

	private readonly ValueDataSeries _filter2Series = new("Filter2Series", "Filter2")
	{
		Color = DefaultColors.Red.Convert(),
		IsHidden = true,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true
	};

	private readonly ValueDataSeries _filter3Series = new("Filter3Series", "Filter3")
	{
		Color = DefaultColors.Green.Convert(),
		IsHidden = true,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true
	};

	private readonly ValueDataSeries _filter4Series = new("Filter4Series", "Filter4")
	{
		Color = CrossColor.FromArgb(255, 128, 128, 128),
		Width = 2,
		IsHidden = true,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true
	};

	private readonly ValueDataSeries _filter5Series = new("Filter5Series", "Filter5")
	{
		Color = CrossColor.FromArgb(255, 205, 92, 92),
		Width = 2,
		IsHidden = true,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true
	};

	private bool _bigTradesIsReceived;
	private bool _cumulativeTrades = true;
	private decimal _delta1;
	private decimal _delta2;
	private decimal _delta3;
	private decimal _delta4;
	private decimal _delta5;
	private int _lastBar = -1;
	private decimal _lastDelta1;
	private decimal _lastDelta2;
	private decimal _lastDelta3;
	private decimal _lastDelta4;
	private decimal _lastDelta5;
	private CumulativeTrade _lastTrade;
	private object _locker = new();
	private decimal _maxVolume1 = 5;
	private decimal _maxVolume2 = 10;
	private decimal _maxVolume3 = 20;
	private decimal _maxVolume4 = 40;
	private decimal _maxVolume5;
	private decimal _minVolume1;
	private decimal _minVolume2 = 6;
	private decimal _minVolume3 = 11;
	private decimal _minVolume4 = 21;
	private decimal _minVolume5 = 41;

	private int _requestId;
	private int _sessionBegin;

	private List<MarketDataArg> _ticks = new();
	private List<CumulativeTrade> _trades = new();

	private bool _useFilter1 = true;
	private bool _useFilter2 = true;
	private bool _useFilter3 = true;
	private bool _useFilter4 = true;
	private bool _useFilter5 = true;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CumulativeTrades), GroupName = nameof(Strings.Filters), Description = nameof(Strings.CumulativeTradesModeDescription), Order = 90)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	public bool CumulativeTrades
	{
		get => _cumulativeTrades;
		set
		{
			_cumulativeTrades = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.Filter1), Description = nameof(Strings.UseFilterDescription), Order = 100)]
	public bool UseFilter1
	{
		get => _useFilter1;
		set
		{
			_useFilter1 = value;
			_filter1Series.VisualType = value ? VisualMode.Line : VisualMode.Hide;
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Filter1), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 130)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MinVolume1
	{
		get => _minVolume1;
		set
		{
			_minVolume1 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Filter1), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 140)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0.0000001, 100000000)]
	public decimal MaxVolume1
	{
		get => _maxVolume1;
		set
		{
			_maxVolume1 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Filter1), Description = nameof(Strings.LineColorDescription), Order = 150)]
	public CrossColor Color1
	{
		get => _filter1Series.Color;
		set => _filter1Series.Color = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Filter1), Description = nameof(Strings.LineWidthDescription), Order = 160)]
    [Range(1, 100)]
    public int LineWidth1
    {
        get => _filter1Series.Width;
        set => _filter1Series.Width = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.Filter2), Description = nameof(Strings.UseFilterDescription), Order = 200)]
	public bool UseFilter2
	{
		get => _useFilter2;
		set
		{
			_useFilter2 = value;
			_filter2Series.VisualType = value ? VisualMode.Line : VisualMode.Hide;
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Filter2), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 230)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MinVolume2
	{
		get => _minVolume2;
		set
		{
			_minVolume2 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Filter2), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 240)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MaxVolume2
	{
		get => _maxVolume2;
		set
		{
			_maxVolume2 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Filter2), Description = nameof(Strings.LineColorDescription), Order = 250)]
	public CrossColor Color2
	{
		get => _filter2Series.Color;
		set => _filter2Series.Color = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Filter2), Description = nameof(Strings.LineWidthDescription), Order = 260)]
    [Range(1, 100)]
    public int LineWidth2
    {
        get => _filter2Series.Width;
        set => _filter2Series.Width = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.Filter3), Description = nameof(Strings.UseFilterDescription), Order = 300)]
	public bool UseFilter3
	{
		get => _useFilter3;
		set
		{
			_useFilter3 = value;
			_filter3Series.VisualType = value ? VisualMode.Line : VisualMode.Hide;
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Filter3), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 330)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MinVolume3
	{
		get => _minVolume3;
		set
		{
			_minVolume3 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Filter3), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 340)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MaxVolume3
	{
		get => _maxVolume3;
		set
		{
			_maxVolume3 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Filter3), Description = nameof(Strings.LineColorDescription), Order = 350)]
	public CrossColor Color3
	{
		get => _filter3Series.Color;
		set => _filter3Series.Color = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Filter3), Description = nameof(Strings.LineWidthDescription), Order = 360)]
    [Range(1, 100)]
    public int LineWidth3
    {
        get => _filter3Series.Width;
        set => _filter3Series.Width = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.Filter4), Description = nameof(Strings.UseFilterDescription), Order = 400)]
	public bool UseFilter4
	{
		get => _useFilter4;
		set
		{
			_useFilter4 = value;
			_filter4Series.VisualType = value ? VisualMode.Line : VisualMode.Hide;
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Filter4), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 430)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MinVolume4
	{
		get => _minVolume4;
		set
		{
			_minVolume4 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Filter4), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 440)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MaxVolume4
	{
		get => _maxVolume4;
		set
		{
			_maxVolume4 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Filter4), Description = nameof(Strings.LineColorDescription), Order = 450)]
	public CrossColor Color4
	{
		get => _filter4Series.Color;
		set => _filter4Series.Color = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Filter4), Description = nameof(Strings.LineWidthDescription), Order = 460)]
    [Range(1, 100)]
    public int LineWidth4
    {
        get => _filter4Series.Width;
        set => _filter4Series.Width = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.Filter5), Description = nameof(Strings.UseFilterDescription), Order = 500)]
	public bool UseFilter5
	{
		get => _useFilter5;
		set
		{
			_useFilter5 = value;
			_filter5Series.VisualType = value ? VisualMode.Line : VisualMode.Hide;
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumVolume), GroupName = nameof(Strings.Filter5), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 530)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MinVolume5
	{
		get => _minVolume5;
		set
		{
			_minVolume5 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumVolume), GroupName = nameof(Strings.Filter5), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 540)]
	[PostValueMode(PostValueModes.Delayed, DelayMilliseconds = 500)]
	[Range(0, 100000000)]
	public decimal MaxVolume5
	{
		get => _maxVolume5;
		set
		{
			_maxVolume5 = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Filter5), Description = nameof(Strings.LineColorDescription), Order = 550)]
	public CrossColor Color5
	{
		get => _filter5Series.Color;
		set => _filter5Series.Color = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Filter5), Description = nameof(Strings.LineWidthDescription), Order = 560)]
    [Range(1, 100)]
    public int LineWidth5
    {
        get => _filter5Series.Width;
        set => _filter5Series.Width = value;
    }

    #endregion

    #region ctor

    public MultiMarketPower()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DenyToChangePanel = true;

		DataSeries[0] = _filter1Series;
		DataSeries.Add(_filter2Series);
		DataSeries.Add(_filter3Series);
		DataSeries.Add(_filter4Series);
		DataSeries.Add(_filter5Series);
	}

	#endregion

	#region Protected methods
	
	protected override void OnCalculate(int bar, decimal value)
	{
		if (!_bigTradesIsReceived || bar != CurrentBar - 1)
			return;

		DataSeries.ForEach(ds =>
		{
			if (ds is ValueDataSeries vds && vds[bar] is 0)
				vds[bar] = vds[bar - 1];
		});
	}
	
	protected override void OnFinishRecalculate()
	{
		_bigTradesIsReceived = false;

        _ticks.Clear();
		_trades.Clear();
		var totalBars = CurrentBar - 1;
		_sessionBegin = totalBars;
		_lastBar = totalBars;

		for (var i = totalBars; i >= 0; i--)
		{
			if (!IsNewSession(i))
				continue;

			_sessionBegin = i;
			break;
		}

		var request = new CumulativeTradesRequest(GetCandle(_sessionBegin).Time);
		_requestId = request.RequestId;
		RequestForCumulativeTrades(request);
    }
	
	protected override void OnCumulativeTradesResponse(CumulativeTradesRequest request, IEnumerable<CumulativeTrade> cumulativeTrades)
	{
		if (request.RequestId != _requestId)
			return;

		ClearValues();
		var trades = cumulativeTrades.ToList();
		
		CalculateHistory(trades);

		_bigTradesIsReceived = true;
	}

	protected override void OnNewTrade(MarketDataArg trade)
	{
		if (CumulativeTrades || ChartInfo is null)
			return;

		if (!_bigTradesIsReceived)
		{
			_ticks.Add(trade);
			return;
		}

		var newBar = _lastBar < CurrentBar - 1;

		if (newBar)
			_lastBar = CurrentBar - 1;

		CalculateTick(trade);
	}

	protected override void OnCumulativeTrade(CumulativeTrade trade)
	{
		if (!CumulativeTrades)
			return;

		if (!_bigTradesIsReceived)
		{
			_trades.Add(trade);
			return;
		}

		var newBar = _lastBar < CurrentBar - 1;

		if (newBar)
			_lastBar = CurrentBar - 1;

		CalculateTrade(trade, false, newBar);
	}

	protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
	{
		if (!CumulativeTrades)
			return;

		if (!_bigTradesIsReceived)
		{
			if (_trades.Count != 0)
				_trades[^1] = trade;
			return;
		}

		var newBar = _lastBar < CurrentBar - 1;

		if (newBar)
			_lastBar = CurrentBar - 1;

		CalculateTrade(trade, true, newBar);
	}

	#endregion

	#region Private methods

	private void ClearValues()
	{
		_bigTradesIsReceived = false;
		DataSeries.ForEach(x => x.Clear());
		_delta1 = _delta2 = _delta3 = _delta4 = _delta5 = 0;
	}

	private void CalculateTrade(CumulativeTrade trade, bool isUpdate, bool newBar)
	{
		if (isUpdate && _lastTrade != null)
		{
			if (_lastTrade.IsEqual(trade))
			{
				var prevBarReset = _lastTrade.Time < GetCandle(CurrentBar - 1).Time;

				var lastVolume = _lastTrade.Volume * (_lastTrade.Direction == TradeDirection.Buy ? 1 : -1);

				if (_lastTrade.Volume >= _minVolume1 && (_lastTrade.Volume <= _maxVolume1 || _maxVolume1 == 0))
				{
					_delta1 -= lastVolume;

					if (prevBarReset)
						_filter1Series[CurrentBar - 2] -= lastVolume;
				}

				if (_lastTrade.Volume >= _minVolume2 && (_lastTrade.Volume <= _maxVolume2 || _maxVolume2 == 0))
				{
					if (prevBarReset)
						_filter2Series[CurrentBar - 2] -= lastVolume;

					_delta2 -= lastVolume;
				}

				if (_lastTrade.Volume >= _minVolume3 && (_lastTrade.Volume <= _maxVolume3 || _maxVolume3 == 0))
				{
					if (prevBarReset)
						_filter3Series[CurrentBar - 2] -= lastVolume;

					_delta3 -= lastVolume;
				}

				if (_lastTrade.Volume >= _minVolume4 && (_lastTrade.Volume <= _maxVolume4 || _maxVolume4 == 0))
				{
					if (prevBarReset)
						_filter4Series[CurrentBar - 2] -= lastVolume;

					_delta4 -= lastVolume;
				}

				if (_lastTrade.Volume >= _minVolume5 && (_lastTrade.Volume <= _maxVolume5 || _maxVolume5 == 0))
				{
					if (prevBarReset)
						_filter5Series[CurrentBar - 2] -= lastVolume;

					_delta5 -= lastVolume;
				}
			}
		}

		var volume = trade.Volume;
		var deltaVolume = volume * (trade.Direction == TradeDirection.Buy ? 1 : -1);

		if (volume >= _minVolume1 && (volume <= _maxVolume1 || _maxVolume1 == 0))
			_delta1 += deltaVolume;

		if (volume >= _minVolume2 && (volume <= _maxVolume2 || _maxVolume2 == 0))
			_delta2 += deltaVolume;

		if (volume >= _minVolume3 && (volume <= _maxVolume3 || _maxVolume3 == 0))
			_delta3 += deltaVolume;

		if (volume >= _minVolume4 && (volume <= _maxVolume4 || _maxVolume4 == 0))
			_delta4 += deltaVolume;

		if (volume >= _minVolume5 && (volume <= _maxVolume5 || _maxVolume5 == 0))
			_delta5 += deltaVolume;

		_filter1Series[CurrentBar - 1] = _delta1;
		_filter2Series[CurrentBar - 1] = _delta2;
		_filter3Series[CurrentBar - 1] = _delta3;
		_filter4Series[CurrentBar - 1] = _delta4;
		_filter5Series[CurrentBar - 1] = _delta5;

		RaiseBarValueChanged(CurrentBar - 1);
		_lastTrade = trade.MemberwiseClone();
	}

	private void CalculateHistory(List<CumulativeTrade> trades)
	{
		try
		{
			if(trades.Count is 0)
				return;
			
			var searchIdx = 0;

            if (CumulativeTrades)
			{
				trades = trades.OrderBy(t => t.Time).ToList();
                
				for (var i = _sessionBegin; i <= CurrentBar - 1; i++)
					CalculateBarTrades(trades, i, ref searchIdx);

				foreach (var trade in _trades)
					CalculateTrade(trade, false, false);
			}
			else
			{
				var ticks = trades
					.SelectMany(x => x.Ticks)
					.OrderBy(t=>t.Time)
					.ToList();

				for (var i = _sessionBegin; i <= CurrentBar - 1; i++)
					CalculateBarTicks(ticks, i, ref searchIdx);

				foreach (var tick in _ticks)
					CalculateTick(tick);
			}

			RedrawChart();
		}
		catch (NullReferenceException)
		{
			//on reset exception ignored
		}
	}

	private void CalculateBarTicks(List<MarketDataArg> trades, int i, ref int searchIdx)
	{
		var candle = GetCandle(i);

		var candleTrades = new List<MarketDataArg>();

		for (var bar = searchIdx; bar < trades.Count; bar++)
		{
			var trade = trades[bar];
			searchIdx = bar;
            
			if (trade.Direction is TradeDirection.Between)
				continue;

			if (trade.Time > candle.LastTime)
				break;

			if (trade.Time < candle.Time)
				continue;

			candleTrades.Add(trade);
		}

        foreach (var tick in candleTrades)
		{
			var deltaVolume = tick.Volume * (tick.Direction is TradeDirection.Buy ? 1 : -1);

			if (IsFiltered(MinVolume1, MaxVolume1, tick.Volume))
				_delta1 += deltaVolume;

			if (IsFiltered(MinVolume2, MaxVolume2, tick.Volume))
				_delta2 += deltaVolume;

			if (IsFiltered(MinVolume3, MaxVolume3, tick.Volume))
				_delta3 += deltaVolume;

			if (IsFiltered(MinVolume4, MaxVolume4, tick.Volume))
				_delta4 += deltaVolume;

			if (IsFiltered(MinVolume5, MaxVolume5, tick.Volume))
				_delta5 += deltaVolume;
		}

		_filter1Series[i] = _delta1;
		_filter2Series[i] = _delta2;
		_filter3Series[i] = _delta3;
		_filter4Series[i] = _delta4;
		_filter5Series[i] = _delta5;

		RaiseBarValueChanged(i);
	}

	private void CalculateTick(MarketDataArg tick)
	{
		var deltaVolume = tick.Volume * (tick.Direction is TradeDirection.Buy ? 1 : -1);

		if (IsFiltered(MinVolume1, MaxVolume1, tick.Volume))
			_delta1 += deltaVolume;

		if (IsFiltered(MinVolume2, MaxVolume2, tick.Volume))
			_delta2 += deltaVolume;

		if (IsFiltered(MinVolume3, MaxVolume3, tick.Volume))
			_delta3 += deltaVolume;

		if (IsFiltered(MinVolume4, MaxVolume4, tick.Volume))
			_delta4 += deltaVolume;

		if (IsFiltered(MinVolume5, MaxVolume5, tick.Volume))
			_delta5 += deltaVolume;

		_filter1Series[^1] = _delta1;
		_filter2Series[^1] = _delta2;
		_filter3Series[^1] = _delta3;
		_filter4Series[^1] = _delta4;
		_filter5Series[^1] = _delta5;
	}

	private bool IsFiltered(decimal minFilter, decimal maxFilter, decimal volume)
	{
		return volume >= minFilter && (volume <= maxFilter || maxFilter == 0);
	}

	private void CalculateBarTrades(List<CumulativeTrade> trades, int bar, ref int searchIdx, bool realTime = false, bool newBar = false)
	{
		if (CumulativeTrades && realTime && !newBar)
		{
			_delta1 -= _lastDelta1;
			_delta2 -= _lastDelta2;
			_delta3 -= _lastDelta3;
			_delta4 -= _lastDelta4;
			_delta5 -= _lastDelta5;
		}

		var candle = GetCandle(bar);

		var candleTrades = new List<CumulativeTrade>();

		for (var i = searchIdx; i < trades.Count; i++)
		{
			var trade = trades[i];

			if (trade.Direction is TradeDirection.Between)
				continue;

			if (trade.Time > candle.LastTime)
			{
				searchIdx = i;
				break;
			}

			if (trade.Time < candle.Time)
				continue;

			candleTrades.Add(trade);
		}

        _lastDelta1 = candleTrades
			.Where(x => x.Volume >= _minVolume1 && (x.Volume <= _maxVolume1 || _maxVolume1 == 0))
			.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1));

		_delta1 += _lastDelta1;

		_filter1Series[bar] = _delta1;

		_lastDelta2 = candleTrades
			.Where(x => x.Volume >= _minVolume2 && (x.Volume <= _maxVolume2 || _maxVolume2 == 0))
			.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1));

		_delta2 += _lastDelta2;

		_filter2Series[bar] = _delta2;

		_lastDelta3 = candleTrades
			.Where(x => x.Volume >= _minVolume3 && (x.Volume <= _maxVolume3 || _maxVolume3 == 0))
			.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1));

		_delta3 += _lastDelta3;

		_filter3Series[bar] = _delta3;

		_lastDelta4 = candleTrades
			.Where(x => x.Volume >= _minVolume4 && (x.Volume <= _maxVolume4 || _maxVolume4 == 0))
			.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1));

		_delta4 += _lastDelta4;

		_filter4Series[bar] = _delta4;

		_lastDelta5 = candleTrades
			.Where(x => x.Volume >= _minVolume5 && (x.Volume <= _maxVolume5 || _maxVolume5 == 0))
			.Sum(x => x.Volume * (x.Direction == TradeDirection.Buy ? 1 : -1));

		_delta5 += _lastDelta5;

		_filter5Series[bar] = _delta5;

		RaiseBarValueChanged(bar);
		_lastBar = bar;
	}

	#endregion
}








Technical/MurrayMath.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("Murrey Math")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.MurreyMathDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602435")]
	public class MurrayMath : Indicator
	{
		#region Nested types

		public enum FrameMultiplierEnum
		{
			[Display(Name = "1.0")]
			Min = 10,

			[Display(Name = "1.5")]
			Mid = 15,

			[Display(Name = "2.0")]
			Max = 20
		}

		public enum FrameSizeEnum
		{
			[Display(Name = "4")]
			Pow2 = 4,

			[Display(Name = "8")]
			Pow3 = 8,

			[Display(Name = "16")]
			Pow4 = 16,

			[Display(Name = "32")]
			Pow5 = 32,

			[Display(Name = "64")]
			Pow6 = 64,

			[Display(Name = "128")]
			Pow7 = 128,

			[Display(Name = "256")]
			Pow8 = 256,

			[Display(Name = "512")]
			Pow9 = 512
		}

		#endregion

		#region Fields

		private readonly Highest _high = new();

		private readonly double _log10 = Math.Log(10);
		private readonly double _log2 = Math.Log(2);
		private readonly double _log8 = Math.Log(8);
		private readonly Lowest _low = new();
		private int _days = 20;

        private decimal _frameMultiplier = 1.5m;
        private int _frameSize = 64;
        private bool _ignoreWicks = true;
        private int _lookBack;
		private int _targetBar;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        [Range(0, 1000)]
		public int Days
		{
			get => _days;
			set
			{
				_days = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Common), Name = nameof(Strings.IgnoreWicks), Description = nameof(Strings.IgnoreWicksDescription), Order = 100)]
		public bool IgnoreWicks
		{
			get => _ignoreWicks;
			set
			{
				_ignoreWicks = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Common), Name = nameof(Strings.FrameSize), Description = nameof(Strings.PeriodValueDefinerDescription), Order = 110)]
		public FrameSizeEnum FrameSize
		{
			get => (FrameSizeEnum)_frameSize;
			set
			{
				_frameSize = (int)value;
				_lookBack = (int)(_frameSize * _frameMultiplier);
				_high.Period = _lookBack;
				_low.Period = _lookBack;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Common), Name = nameof(Strings.FrameMultiplier), Description = nameof(Strings.MultiplierDescription), Order = 200)]
		public FrameMultiplierEnum FrameMultiplier
		{
			get => (FrameMultiplierEnum)(int)(_frameMultiplier * 10);
			set
			{
				_frameMultiplier = Convert.ToDecimal((int)value / 10.0);
				_lookBack = (int)(_frameSize * _frameMultiplier);
				_high.Period = _lookBack;
				_low.Period = _lookBack;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public MurrayMath()
			: base(true)
		{
			DenyToChangePanel = true;
			
			DataSeries.Clear();

			for (var i = -3; i <= 8 + 3; i++)
			{
				var name = i <= 8
					? $"Level {i}/8"
					: $"Level +{i % 4}/8";

				DataSeries.Add(new ValueDataSeries($"{name.Replace(" ", "")}Id", name)
				{
					ShowZeroValue = false,
					LineDashStyle = LineDashStyle.Solid,
					VisualType = VisualMode.Line,
					Width = i % 4 == 0 ? 2 : 1,

					Color = i % 4 == 0 ? DefaultColors.Blue.Convert() :
						i % 4 == 1 || i % 4 == 3 ? DefaultColors.Green.Convert() :
						i % 4 == 2 ? DefaultColors.Red.Convert() :
						DefaultColors.Gray.Convert()
				});
			}
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				_targetBar = 0;

				if (_days > 0)
				{
					var days = 0;

					for (var i = CurrentBar - 1; i >= 0; i--)
					{
						_targetBar = i;

						if (!IsNewSession(i))
							continue;

						days++;

						if (days == _days)
							break;
					}

					if (_targetBar > 0)
						DataSeries.ForEach(x => ((ValueDataSeries)x).SetPointOfEndLine(_targetBar - 1));
				}
			}

			if (bar < _targetBar - _lookBack)
				return;

			var currentCandle = GetCandle(bar);

			var hValue = IgnoreWicks
				? Math.Max(currentCandle.Open, currentCandle.Close)
				: currentCandle.High;

			var lValue = IgnoreWicks
				? Math.Min(currentCandle.Open, currentCandle.Close)
				: currentCandle.Low;

			var lowPeriod = _low.Calculate(bar, lValue);
			var highPeriod = _high.Calculate(bar, hValue);

			if (bar < _targetBar)
				return;

			var difference = highPeriod - lowPeriod;

			var tmpHigh = Convert.ToDouble(lowPeriod < 0 ? 0 - lowPeriod : highPeriod);
			var tmpLow = Convert.ToDouble(lowPeriod < 0 ? 0 - lowPeriod - difference : lowPeriod);

			var shift = lowPeriod < 0;

			var sfVar = Math.Log(0.4 * tmpHigh) / _log10
				- Math.Floor(Math.Log(0.4 * tmpHigh) / _log10);

			double SR;

			if (tmpHigh > 25)
			{
				SR = sfVar > 0
					? Math.Exp(_log10 * Math.Floor(Math.Log(0.4 * tmpHigh) / _log10) + 1.0)
					: Math.Exp(_log10 * Math.Floor(Math.Log(0.4 * tmpHigh) / _log10));
			}
			else
				SR = 100.0 * Math.Exp(_log8 * Math.Floor(Math.Log(0.005 * tmpHigh) / _log8));

			var highDiff = tmpHigh - tmpLow;
			var nVar1 = Math.Log(SR / (highDiff == 0 ? 1 : highDiff)) / _log8;
			var nVar2 = nVar1 - Math.Floor(nVar1);

			var N = nVar1 <= 0 ? 0 :
				nVar2 == 0 ? Math.Floor(nVar1) : Math.Floor(nVar1) + 1;

			var SI = SR * Math.Exp(-N * _log8);
			var M = Math.Floor(1.0 / _log2 * Math.Log((tmpHigh - tmpLow) / SI + 0.0000001));

			var I = Math.Round((tmpHigh + tmpLow) * 0.5 / (SI * Math.Exp((M - 1.0) * _log2)));
			var bot = (I - 1.0) * SI * Math.Exp((M - 1.0) * _log2);
			var top = (I + 1.0) * SI * Math.Exp((M - 1.0) * _log2);

			var doShift =
				tmpHigh - top > 0.25 * (top - bot)
				||
				bot - tmpLow > 0.25 * (top - bot);

			var ER = doShift ? 1 : 0;

			var MM = ER == 0 ? M : ER == 1 && M < 2 ? M + 1.0 : 0;
			var NN = ER == 0 ? N : ER == 1 && M < 2 ? N : N - 1.0;

			var finalSI = ER == 1 ? SR * Math.Exp(-NN * _log8) : SI;
			var finalI = ER == 1 ? Math.Round((tmpHigh + tmpLow) * 0.5 / (finalSI * Math.Exp((MM - 1.0) * _log2))) : I;
			var finalBot = ER == 1 ? (finalI - 1.0) * finalSI * Math.Exp((MM - 1.0) * _log2) : bot;
			var finalTop = ER == 1 ? (finalI + 1.0) * finalSI * Math.Exp((MM - 1.0) * _log2) : top;

			var increment = (finalTop - finalBot) / 8.0;

			var absTop = shift
				? -(finalBot - 3.0 * increment)
				: finalTop + 3.0 * increment;

			var lineCount = 0;

			for (var i = DataSeries.Count - 1; i >= 0; i--)
			{
				DataSeries[i][bar] = Convert.ToDecimal(absTop - lineCount * increment);
				lineCount++;
			}
		}

		#endregion
	}
}







Technical/MutualFundBars.cs






namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Mutual Fund Bars")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.MutualFundBarsDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619006")]
public class MutualFundBars : Indicator
{
    #region Fields

    private readonly CrossColor _transparent = System.Drawing.Color.Transparent.Convert();
    private readonly PaintbarsDataSeries _bars = new("BarsId", "Bars") { IsHidden = true };
	private CandleDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

	#endregion

	#region ctor

	public MutualFundBars()
		: base(true)
	{
		DenyToChangePanel = true;

		DataSeries[0] = _bars;
		DataSeries.Add(_renderSeries);
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    _renderSeries.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    _renderSeries.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
	    _renderSeries.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
    }

    protected override void OnCalculate(int bar, decimal value)
	{
		_bars[bar] = _transparent;

		if (bar == 0)
		{
			_renderSeries.Clear();
			return;
		}

		var candle = GetCandle(bar);
		var prevCandle = GetCandle(bar - 1);

		_renderSeries[bar].Open = prevCandle.Close;
		_renderSeries[bar].High = Math.Max(candle.Close, prevCandle.Close);
		_renderSeries[bar].Low = Math.Min(candle.Close, prevCandle.Close);
		_renderSeries[bar].Close = candle.Close;
	}

	#endregion
}







Technical/OBV.cs






namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("OBV")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OBVDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602436")]
	public class OBV : Indicator
	{
		private readonly ValueDataSeries _volSignedSeries = new("Signed");

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.ShortValues), Description = nameof(Strings.UsePeriodDescription), Order = 100)]
        [Range(1, 10000)]
        public FilterInt MinimizedMode { get; set; } = new(true) { Value = 10, Enabled = false };

        #region ctor

        public OBV() : base(true)
        {
            Panel = IndicatorDataProvider.NewPanel;

            DataSeries[0].UseMinimizedModeIfEnabled = true;

            MinimizedMode.PropertyChanged += FilterChanged;
        }

        private void FilterChanged(object sender, PropertyChangedEventArgs e)
        {
            RecalculateValues();
        }

        #endregion

        #region Protected methods

        protected override void OnInitialize()
        {
			MinimizedMode.PropertyChanged += (_, _) =>
			{
				RecalculateValues();
				RedrawChart();
			};
        }

        protected override void OnRecalculate()
        {
	        Clear();
        }
		
        protected override void OnCalculate(int bar, decimal value)
        {
	        if (bar is 0)
		        return;

			var currentClose = GetCandle(bar).Close;
			var previousClose = GetCandle(bar - 1).Close;
			var currentVolume = GetCandle(bar).Volume;

            if (MinimizedMode.Enabled)
			{
				_volSignedSeries[bar] = currentClose > previousClose
					? currentVolume
					: currentClose < previousClose
						? -currentVolume
						: 0;
			}

			if (bar == 0)
			{
				this[bar] = 0;
				return;
			}

			if (MinimizedMode.Enabled)
			{
				this[bar] = bar < MinimizedMode.Value
					? this[bar - 1] + _volSignedSeries[bar]
					: this[bar - 1] + _volSignedSeries[bar] - _volSignedSeries[bar - MinimizedMode.Value];
			}
			else
			{
				if (currentClose > previousClose) // UP
					this[bar] = this[bar - 1] + currentVolume;
				else if (currentClose < previousClose) // DOWN
					this[bar] = this[bar - 1] - currentVolume;
				else
					this[bar] = this[bar - 1];
			}
		}

        #endregion
	}
}








Technical/OIAnalyzer.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Linq;

	using ATAS.Indicators.Technical.Editors;

	using OFT.Attributes;
	using OFT.Attributes.Editors;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Settings;
	using OFT.Rendering.Tools;

	using Utils.Common;

	using Color = System.Drawing.Color;

    [Category(IndicatorCategories.VolumeOrderFlow)]
	[DisplayName("OI Analyzer")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OIAnalyzerDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602437")]
	public class OIAnalyzer : Indicator
	{
        #region Nested types

        [Editor(typeof(RangeEditor), typeof(RangeEditor))]
        public class Range : NotifyPropertyChangedBase
		{
			#region Properties

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Minimum), Order = 20)]
			public int From
			{
				get => _from;
				set => SetProperty(ref _from, value);
			}

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Maximum), Order = 10)]
			public int To
			{
				get => _to;
				set => SetProperty(ref _to, value);
			}

			#endregion

			#region Private fields

			private int _from;
			private int _to;

			#endregion
		}

		public enum CalcMode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CumulativeTrades), Description = nameof(Strings.OIAnalyzerCumulativeTradesModeDescription))]
			CumulativeTrades,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SeparatedTrades), Description = nameof(Strings.OIAnalyzerSeparatedTradesModeDescription))]
			SeparatedTrades
		}

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Buys))]
			Buys,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Sells))]
			Sells
		}

		#endregion

		#region Static and constants

		private const int _height = 15;

		#endregion

		#region Fields

		private readonly RenderFont _font = new("Arial", 9);

		private readonly RenderStringFormat _stringAxisFormat = new()
		{
			Alignment = StringAlignment.Center,
			LineAlignment = StringAlignment.Center,
			Trimming = StringTrimming.EllipsisCharacter
		};

		private CalcMode _calcMode = CalcMode.CumulativeTrades;
        private Color _candlesColor;
		private bool _cumulativeMode = true;
		private bool _customDiapason;

		private LineSeries _dn = new("Dn", "Down")
		{
			Color = Color.Transparent.Convert(),
			LineDashStyle = LineDashStyle.Dot,
			Value = -300,
			Width = 1,
			UseScale = false,
			IsHidden = true
		};

		private int _gridStep = 1000;

        private int _lastBar;
		private int _lastCalculatedBar;
		private decimal _lastOi;
		private Mode _mode = Mode.Buys;
        private Candle _prevCandle;
		private decimal _prevLastOi;
		private CumulativeTrade _prevTrade;

		private CandleDataSeries _renderValues = new("RenderValues", "Values")
		{
			IsHidden = true,
			ShowCurrentValue = false,
			ScaleIt = true,
			DownCandleColor = Color.Green.Convert(),
			BorderColor = Color.Green.Convert(),
			UpCandleColor = Color.White.Convert(),
			ValuesColor = Color.LightBlue,
			UseMinimizedModeIfEnabled = true
		};

		private bool _requestFailed;
		private bool _requestWaiting;

		private bool _requireNewRequest;
		private int _sessionBegin;
		private List<CumulativeTrade> _tradeBuffer = new();

		private LineSeries _up = new("UpId", "Up")
		{
			Color = Color.Transparent.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 300,
			Width = 1,
			UseScale = false,
			IsHidden = true
		};
		
		#endregion

		#region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.CustomDiapason), Description = nameof(Strings.UseCustomDiapasonDescription), Order = 100)]
		public bool CustomDiapason
		{
			get => _customDiapason;
			set
			{
				_customDiapason = value;
				FilterRange_PropertyChanged(null, null);
			}
		}

		[IsExpanded]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Range), GroupName = nameof(Strings.CustomDiapason), Description = nameof(Strings.ValuesRangeDescription), Order = 105)]
		public Range FilterRange { get; set; } = new(){ From = 0, To = 0 };

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), Order = 130, GroupName = nameof(Strings.Calculation), Description = nameof(Strings.BuySellModeDescription))]
		public Mode OiMode
		{
			get => _mode;
			set
			{
				_mode = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), Order = 140, GroupName = nameof(Strings.Calculation), Description = nameof(Strings.CalculationModeDescription))]
		public CalcMode CalculationMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CumulativeMode), Order = 150, GroupName = nameof(Strings.Calculation), Description = nameof(Strings.CumulativeTradesModeDescription))]
		public bool CumulativeMode
		{
			get => _cumulativeMode;
			set
			{
				_cumulativeMode = value;
				_renderValues.ResetAlertsOnNewBar = !value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ClustersMode), Order = 150, GroupName = nameof(Strings.Calculation), Description = nameof(Strings.ClustersModeDescription))]
		public bool ClustersMode
		{
			get => !_renderValues.Visible;
			set
			{
				_renderValues.Visible = !value;
				FilterRange_PropertyChanged(null, null);
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.GridStep), Order = 160, GroupName = nameof(Strings.Grid), Description = nameof(Strings.GridRowHeihgtDescription))]
		[Range(1, 1000000)]
		public int GridStep
		{
			get => _gridStep;
			set
			{
				_gridStep = value;
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.Grid), Order = 170, Description = nameof(Strings.GridLineSettingsDescription))]
		public PenSettings Pen { get; set; } = new()
			{ Color = CrossColor.FromArgb(100, 128, 128, 128), Width = 1 };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowCurrentValue), Order = 170, GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowCurrentValueDescription))]
		public bool ShowCurrentValue
		{
			get => _renderValues.ShowCurrentValue;
			set => _renderValues.ShowCurrentValue = value;
		}
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), Order = 170, GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription))]
		public CrossColor DownColor
		{
			get => _renderValues.DownCandleColor;
			set
			{
				_candlesColor = value.Convert();
				_renderValues.DownCandleColor = _renderValues.BorderColor = value;
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), Order = 180, GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription))]
		public CrossColor UpColor
		{
			get => _renderValues.UpCandleColor;
			set => _renderValues.UpCandleColor = value;
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), Order = 190, GroupName = nameof(Strings.AxisTextColor),
			Description = nameof(Strings.AxisTextColorDescription))]
		public Color FontColor { get; set; } = Color.Black;

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearishColor), Order = 200, GroupName = nameof(Strings.AxisTextColor),
			Description = nameof(Strings.AxisTextColorDescription))]
		public Color BearishFontColor { get; set; } = Color.White;

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Author), GroupName = nameof(Strings.Copyright), Order = 200, Description = nameof(Strings.IndicatorAuthorDescription))]
		public string Author => "Sotnikov Denis (sotnik)";

		#endregion

		#region ctor

		public OIAnalyzer()
			: base(true)
		{
			DrawAbovePrice = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.LatestBar | DrawingLayouts.Historical);
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderValues;
			LineSeries.Add(_up);
			LineSeries.Add(_dn);

			FilterRange.PropertyChanged += FilterRange_PropertyChanged;
		}

		#endregion

		#region Protected methods

		protected override void OnInitialize()
		{
			_renderValues.ShowCurrentValue = false;
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_requireNewRequest = true;

				UpdateCustomDiapasonRange();
			}

			if (_requireNewRequest && bar == CurrentBar - 1)
			{
				_requireNewRequest = false;
				_renderValues.Clear();
				var totalBars = CurrentBar - 1;
				_sessionBegin = totalBars;

				for (var i = totalBars; i >= 0; i--)
				{
					if (!IsNewSession(i))
						continue;

					_sessionBegin = i;
					break;
				}

				if (!_requestWaiting)
				{
					_requestWaiting = true;

					RequestForCumulativeTrades(new CumulativeTradesRequest(GetCandle(_sessionBegin).Time, GetCandle(CurrentBar - 1).LastTime.AddMinutes(1), 0,
						0));
				}
				else
					_requestFailed = true;
			}

			if (!_requestWaiting && CurrentBar - 1 - _lastBar > 1)
			{
				CalculateHistory(_tradeBuffer
					.Where(x => x.Time >= GetCandle(_lastBar + 1).Time && x.Time <= GetCandle(CurrentBar - 1).LastTime)
					.ToList());
			}
		}

		protected override void OnCumulativeTradesResponse(CumulativeTradesRequest request, IEnumerable<CumulativeTrade> cumulativeTrades)
		{
			if (!_requestFailed)
			{
				var trade = cumulativeTrades
					.OrderBy(x => x.Time)
					.ToList();

				var filterTime = request.EndTime;

				if (cumulativeTrades.Any())
					filterTime = cumulativeTrades.Last().Time;

				trade.AddRange(_tradeBuffer
					.Where(x => x.Time > filterTime)
					.ToList());

				CalculateHistory(trade);
				_requestWaiting = false;
				_tradeBuffer.Clear();
			}
			else
			{
				_requestWaiting = false;
				_requestFailed = false;
				Calculate(0, 0);
				RedrawChart();
			}
		}

		protected override void OnCumulativeTrade(CumulativeTrade trade)
		{
			if (_requestWaiting)
			{
				_tradeBuffer.Add(trade);
				return;
			}

			CalculateTrade(trade, CurrentBar - 1);
		}

		protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
		{
			if (_requestWaiting)
			{
				_tradeBuffer.RemoveAll(trade.IsEqual);
				_tradeBuffer.Add(trade);
				return;
			}

			CalculateTrade(trade, CurrentBar - 1, true);
		}

		protected override void OnRender(RenderContext g, DrawingLayouts layout)
		{
			if (ClustersMode)
			{
				var lastBar = ChartInfo.PriceChartContainer.LastVisibleBarNumber;
                var firstBar = Math.Max(ChartInfo.PriceChartContainer.FirstVisibleBarNumber, _sessionBegin);
				
				for (var i = firstBar; i <= lastBar; i++)
				{
					var x = ChartInfo.GetXByBar(i);
					var rect = new Rectangle(x, Container.Region.Y, (int)ChartInfo.PriceChartContainer.BarsWidth, Container.Region.Height);
					var diff = _renderValues[i].Close - _renderValues[i].Open;
					g.DrawString(diff.ToString("+#;-#;0"), _font, _candlesColor, rect, _stringAxisFormat);
				}
			}
			else
			{
				if (layout is DrawingLayouts.Historical)
                    DrawGrid(g);

				DrawAxisValue(g);
            }
		}

		private void DrawAxisValue(RenderContext g)
		{
			var bounds = g.ClipBounds;

			try
			{
				g.ResetClip();

				var lastBar = ChartInfo.PriceChartContainer.LastVisibleBarNumber;

				var candle = _renderValues[lastBar];
				var closeValue = candle.Close;

				var x = ChartInfo.PriceChartContainer.Region.Right;
				var y = Container.GetYByValue(closeValue);

				var font = ChartInfo.PriceAxisFont;
				var priceString = ChartInfo.TryGetMinimizedVolumeString(closeValue);
				var size = g.MeasureString(priceString, font);

				var priceHeight = size.Height / 2;

				var leftX = x + priceHeight;
				var rightX = ChartInfo.ChartContainer.Region.Right;
				var upperY = y - priceHeight;
				var lowerY = y + priceHeight;

				var points = new Point[]
				{
					new(x, y),
					new(leftX, upperY),
					new(rightX, upperY),
					new(rightX, lowerY),
					new(leftX, lowerY)
				};

				var isBullish = candle.Close > candle.Open;

				var bgColor = isBullish
					? _renderValues.UpCandleColor
					: _renderValues.DownCandleColor;

				g.FillPolygon(bgColor.Convert(), points);

				var textRect = new Rectangle(leftX, upperY, rightX - leftX, lowerY - upperY);

				var textColor = isBullish
					? FontColor
					: BearishFontColor;

				g.DrawString(priceString, font, textColor, textRect);
			}
			catch
			{
				g.SetClip(bounds);
				throw;
			}
        }

        #endregion

        #region Private methods

        private void FilterRange_PropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			UpdateCustomDiapasonRange();

			try
			{
				if (ChartInfo != null)
				{
					for (var i = 0; i <= CurrentBar - 1; i++)
						RaiseBarValueChanged(i);
				}
			}
			catch (Exception)
			{
			}
		}

		private void UpdateCustomDiapasonRange()
		{
			if (CustomDiapason)
			{
				//enabled
				_up.UseScale = _dn.UseScale = true;
				_renderValues.ScaleIt = false;

				_up.Value = FilterRange.To;
				_dn.Value = FilterRange.From;
			}
			else
			{
				//disabled
				_up.UseScale = _dn.UseScale = false;
				_renderValues.ScaleIt = true;
			}
		}

		private void CalculateHistory(List<CumulativeTrade> trades)
		{
			IndicatorCandle lastCandle = null;
			var lastCandleNumber = _sessionBegin - 1;

			foreach (var trade in trades.OrderBy(x => x.Time))
			{
				if (lastCandle == null || lastCandle.LastTime < trade.Time)
				{
					for (var i = lastCandleNumber + 1; i <= CurrentBar - 1; i++)
					{
						lastCandle = GetCandle(i);
						lastCandleNumber = i;

						if (lastCandle.LastTime >= trade.Time)
							break;
					}
				}

				CalculateTrade(trade, lastCandleNumber);
			}

			for (var i = 0; i <= CurrentBar - 1; i++)
				RaiseBarValueChanged(i);

			RedrawChart();
		}

		private void CalculateTrade(CumulativeTrade trade, int bar, bool isUpdated = false)
		{
			var newBar = false;

			if (_lastCalculatedBar != bar)
			{
				_lastBar = _lastCalculatedBar;
				_lastCalculatedBar = bar;
				newBar = true;
			}

			if (isUpdated && _prevTrade != null)
			{
				if (trade.IsEqual(_prevTrade))
					_lastOi = _prevLastOi;
			}
			else
			{
				_prevLastOi = _lastOi;
				_prevTrade = trade;
			}

			var open = 0m;

			if (_cumulativeMode && _lastBar > 0)
			{
				var prevValue = _renderValues[_lastBar];

				if (prevValue.Close != 0)
					open = prevValue.Close;
			}

			var currentValue = _renderValues[bar];

			if (IsEmpty(currentValue))
			{
				_renderValues[bar] = new Candle
				{
					High = open,
					Low = open,
					Open = open,
					Close = open
				};
			}
			else
			{
				if (currentValue.Open == currentValue.Close && currentValue.Open == 0)
				{
					_renderValues[bar] = new Candle
					{
						High = open,
						Low = open,
						Open = open,
						Close = open
					};
				}
			}

			if (isUpdated && trade.IsEqual(_prevTrade) && !newBar)
				_renderValues[bar] = _prevCandle.MemberwiseClone();
			else
				_prevCandle = _renderValues[bar].MemberwiseClone();

			if (_calcMode == CalcMode.CumulativeTrades)
			{
				if (_lastOi != 0)
				{
					var dOi = trade.Ticks.Last().OpenInterest - _lastOi;

					if (dOi != 0)
					{
						if (_mode == Mode.Buys && trade.Direction == TradeDirection.Buy
							||
							_mode == Mode.Sells && trade.Direction == TradeDirection.Sell)
						{
							var value = dOi > 0 ? trade.Volume : -trade.Volume;
							_renderValues[bar].Close += value;

							if (_renderValues[bar].Close > _renderValues[bar].High)
								_renderValues[bar].High = _renderValues[bar].Close;

							if (_renderValues[bar].Close < _renderValues[bar].Low)
								_renderValues[bar].Low = _renderValues[bar].Close;
						}
					}
				}

				if(trade.Ticks.Count != 0)
					_lastOi = trade.Ticks.Last().OpenInterest;
			}
			else
			{
				foreach (var tick in trade.Ticks)
				{
					if (_lastOi != 0)
					{
						var dOi = tick.OpenInterest - _lastOi;

						if (dOi != 0)
						{
							if (_mode == Mode.Buys && tick.Direction == TradeDirection.Buy
								||
								_mode == Mode.Sells && tick.Direction == TradeDirection.Sell)
							{
								var value = dOi > 0 ? tick.Volume : -tick.Volume;
								_renderValues[bar].Close += value;

								if (_renderValues[bar].Close > _renderValues[bar].High)
									_renderValues[bar].High = _renderValues[bar].Close;

								if (_renderValues[bar].Close < _renderValues[bar].Low)
									_renderValues[bar].Low = _renderValues[bar].Close;
							}
						}
					}

					if (trade.Ticks.Count != 0)
                        _lastOi = tick.OpenInterest;
				}
			}

			RaiseBarValueChanged(bar);
		}

		private bool IsEmpty(Candle candle)
		{
			return candle.High == 0 && candle.Low == 0 && candle.Open == 0 && candle.Close == 0;
		}

		private void DrawGrid(RenderContext context)
		{
			if (GridStep is 0)
				return;

			var linePen = Pen.RenderObject;

			var max = Container.Maximum - Container.Maximum % GridStep;

			var levelsCnt = (int)(Container.Maximum - Container.Minimum) / GridStep;

			if (Container.Region.Height < levelsCnt * 5)
				return;

			while (max > Container.Minimum)
			{
				var y = Container.GetYByValue(max);

				if (y > Container.RelativeRegion.Y)
					context.DrawLine(linePen, 0, y, Container.Region.Width, y);

				max -= GridStep;
			}
		}

		#endregion
	}
}








Technical/OSMA.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Localization;

	using Utils.Common.Attributes;

    [DisplayName("Moving Average of Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OSMADescription))]
    [OFT.Attributes.HelpLink("https://help.atas.net/en/support/solutions/articles/72000602432")]	
	public class OSMA : Indicator
	{
		#region Fields

		private EMA _shortEma = new() { Period = 9 };
		private SMA _signalSma = new() { Period = 26 };
		private EMA _longEma = new() { Period = 12 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Period), Description = nameof(Strings.ShortPeriodDescription), Order = 100)]
		[Range(2, 10000)]
		[LessThan<int>(nameof(LongPeriod), ErrorMessageResourceType = typeof(Strings), ErrorMessageResourceName = nameof(Strings.ValueMustBeLessThan))]
		public int ShortPeriod
		{
			get => _shortEma.Period;
			set
			{
				if (value >= LongPeriod)
					return;

				_shortEma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Period), Description = nameof(Strings.LongPeriodDescription), Order = 110)]
		[Range(2, 10000)]
		[GreaterThan<int>(nameof(ShortPeriod), ErrorMessageResourceType = typeof(Strings), ErrorMessageResourceName = nameof(Strings.ValueMustBeGreaterThan))]
		public int LongPeriod
		{
			get => _longEma.Period;
			set
			{
				if (value <= ShortPeriod)
					return;

				_longEma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SignalPeriod), GroupName = nameof(Strings.Period), Description = nameof(Strings.SignalPeriodDescription), Order = 120)]
		[Range(2, 10000)]
		public int SignalPeriod
		{
			get => _signalSma.Period;
			set
			{
				_signalSma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public OSMA()
		{
			Panel = IndicatorDataProvider.NewPanel;
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Histogram;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_shortEma.Calculate(bar, value);
			_longEma.Calculate(bar, value);

			var macd = _shortEma[bar] - _longEma[bar];

			_signalSma.Calculate(bar, macd);

			this[bar] = macd - _signalSma[bar];
		}

		#endregion
	}
}







Technical/OpenInterest.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using Utils.Common;
    
    [DisplayName("Open Interest")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OpenInterestDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602439")]
	public class OpenInterest : Indicator
	{
        #region Nested types

        public enum OpenInterestMode
        {
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ByBar))]
            ByBar,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Session))]
            Session,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Cumulative))]
            Cumulative
        }

        #endregion

        #region Fields

        private readonly CandleDataSeries _filterSeries = new("FilterSeries", "Open interest filtered")
        {
            UpCandleColor = System.Drawing.Color.LightBlue.Convert(),
            DownCandleColor = System.Drawing.Color.LightBlue.Convert(),
            IsHidden = true,
            ScaleIt = false,
            ShowCurrentValue = false,
            ShowTooltip = false,
            UseMinimizedModeIfEnabled = true,
            ResetAlertsOnNewBar = true
        };

        private readonly CandleDataSeries _oi = new("Oi", "OI")
        {
            UseMinimizedModeIfEnabled = true,
            ResetAlertsOnNewBar = true,
            DescriptionKey=nameof(Strings.OISettingsDescription)
        };

        private int _lastBar = -1;
        private bool _isAlerted;
        private decimal _filter;
        private bool _minimizedMode;

        private OpenInterestMode _mode = OpenInterestMode.ByBar;
        private decimal _changeSize;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription))]
        public OpenInterestMode Mode
        {
            get => _mode;
            set
            {
                _mode = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimizedMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.HistogramMinimizedModeDescription))]
        public bool MinimizedMode
        {
            get => _minimizedMode;
            set
            {
                _minimizedMode = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MaximumFilterDescription))]
        [Range(0, 100000000)]
        public decimal Filter
        {
            get => _filter;
            set
            {
                _filter = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FilterColor), GroupName = nameof(Strings.Filters), Description = nameof(Strings.FilterCandleColorDescription))]
        public CrossColor FilterColor
        {
            get => _filterSeries.UpCandleColor;
            set => _filterSeries.UpCandleColor = _filterSeries.DownCandleColor = value;
        }

        #region Alerts

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription))]
        public bool UseAlerts { get; set; }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription))]
        public string AlertFile { get; set; } = "alert1";

        [Range(0, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RequiredChange), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFilterDescription))]
        public decimal ChangeSize
        {
            get => _changeSize;
            set 
            {
                _changeSize = value;
                RecalculateValues(); 
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription))]
        public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription))]
        public CrossColor AlertBGColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

        #endregion

        #endregion

        #region ctor

        public OpenInterest()
            : base(true)
        {
            DataSeries[0].IsHidden = true;
            ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

            DataSeries.Add(_oi);
            DataSeries.Add(_filterSeries);
            Panel = IndicatorDataProvider.NewPanel;
        }

        #endregion

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
            if (ChartInfo is null)
                return;

            _oi.UpCandleColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
            _oi.DownCandleColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
            _oi.BorderColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
        }

        protected override void OnCalculate(int bar, decimal value)
        {
            var currentCandle = GetCandle(bar);

            if (currentCandle.OI == 0)
            {
                if(bar == 0 || _mode is OpenInterestMode.ByBar)
                    return;

                var close = _oi[bar - 1].Close;

                _oi[bar] = new Candle()
                {
	                Open = close,
	                Low = close,
	                Close = close,
	                High = close
                };
                return;
            }

            var currentOpen = bar == 0 
	            ? currentCandle.OI
	            : GetCandle(bar - 1).OI;

            if (currentOpen is 0)
	            currentOpen = currentCandle.OI;

            var candle = _oi[bar];

            switch (_mode)
            {
                case OpenInterestMode.ByBar:
                    if (_minimizedMode)
                    {
                        if (currentCandle.OI > currentOpen)
                        {
                            candle.Open = 0;
                            candle.Close = currentCandle.OI - currentOpen;
                            candle.High = currentCandle.MaxOI - currentOpen;
                        }
                        else
                        {
                            candle.Open = currentOpen - currentCandle.OI;
                            candle.Close = 0;
                            candle.High = currentOpen - currentCandle.MinOI;
                        }
                    }
                    else
                    {
                        candle.Open = 0;
                        candle.Close = currentCandle.OI - currentOpen;
                        candle.High = currentCandle.MaxOI - currentOpen;
                        candle.Low = currentCandle.MinOI - currentOpen;
                    }

                    break;

                case OpenInterestMode.Cumulative:
                    candle.Open = currentOpen;
                    candle.Close = currentCandle.OI;
                    candle.High = currentCandle.MaxOI;
                    candle.Low = currentCandle.MinOI;
                    break;

                default:
                    var prevValue = _oi[bar - 1].Close;
                    var dOi = currentOpen - prevValue;

                    if (IsNewSession(bar))
                        dOi = currentOpen;

                    candle.Open = currentOpen - dOi;
                    candle.Close = currentCandle.OI - dOi;
                    candle.High = currentCandle.MaxOI - dOi;
                    candle.Low = currentCandle.MinOI - dOi;
                    break;
            }

            this[bar] = candle.Close;

            var oiValue = Math.Abs(candle.Close);

            if (oiValue < Filter || Filter == 0)
                _filterSeries[bar].Open = _filterSeries[bar].Close = _filterSeries[bar].High = _filterSeries[bar].Low = candle.Open;
            else
                _filterSeries[bar] = candle.MemberwiseClone();
            
            if (bar != _lastBar)
            {
                _isAlerted = false;
            }

            if (bar == CurrentBar - 1)
            {
                if (UseAlerts && Math.Abs(this[bar]) >= _changeSize && !_isAlerted)
                {
                    AddAlert(AlertFile, InstrumentInfo.Instrument, "OI changed!", AlertBGColor, AlertForeColor);
                    _isAlerted = true;
                }
            }

            _lastBar = bar;
        }

        #endregion
    }
}








Technical/OpenLine.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
    using OFT.Rendering.Settings;
    using OFT.Rendering.Tools;

    [DisplayName("Open Line")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OpenLineDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602440")]
	public class OpenLine : Indicator
	{
		#region Nested types

		public class Session
		{
			#region Properties

			public int StartBar { get; set; }

			public int EndBar { get; set; }

			public decimal OpenPrice { get; set; }

			public bool Touched { get; set; }

			#endregion
		}

		#endregion

		#region Fields

		private int _days = 5;

        private RenderFont _font = new("Arial", 8);
		private int _fontSize = 8;
		private int _lastBar;

		private List<Session> _sessions = new();

		private int _targetBar;
		private bool _tillTouch;
		private string _openCandleText = "Open Line";
        private FilterTimeSpan _customSessionStartFilter;
        private Session _lastSession;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Days),
			GroupName = nameof(Strings.Settings), Description = nameof(Strings.DaysLookBackDescription),
            Order = 5)]
        [Range(0, 10000)]
		public int Days
		{
			get => _days;
			set
			{
				_days = value;
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomSessionStart),
           GroupName = nameof(Strings.Settings), Description = nameof(Strings.CustomSessionStartFilterDescription),
           Order = 10)]
        public FilterTimeSpan CustomSessionStartFilter
		{
			get => _customSessionStartFilter;
			set => SetTrackedProperty(ref _customSessionStartFilter, value, _ =>
			{
				RecalculateValues();
				RedrawChart();
			});
		}

        #region Hidden

        [Obsolete]
		[Browsable(false)]
		public bool CustomSessionStart
		{
			get => _customSessionStartFilter.Enabled;
			set => _customSessionStartFilter.Enabled = value;

        }

        [Obsolete]
        [Browsable(false)]
		public TimeSpan StartDate
		{
            get => _customSessionStartFilter.Value;
            set => _customSessionStartFilter.Value = value;
        }

        #endregion

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text),
			GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LabelTextDescription),
            Order = 30)]
		public string OpenCandleText
		{
			get => _openCandleText;
			set
			{
				if(value.Length > 1000)
					return;

				_openCandleText = value;
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize),
			GroupName = nameof(Strings.Drawing), Description = nameof(Strings.FontSizeDescription),
            Order = 40)]
		[Range(1, 200)]
		public int FontSize
		{
			get => _fontSize;
			set
			{
				_fontSize = value;
				_font = new RenderFont("Arial", value);
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OffsetY),
			GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LabelOffsetYDescription),
            Order = 50)]
		public int Offset { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.OpenLine),
			GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PenSettingsDescription),
            Order = 60)]
		public PenSettings LinePen { get; set; } = new() { Color = System.Drawing.Color.SkyBlue.Convert(), Width = 2 };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineTillTouch),
			GroupName = nameof(Strings.Drawing), Description = nameof(Strings.IsLineTillTouchDescription),
            Order = 62)]
		public bool TillTouch
		{
			get => _tillTouch;
			set
			{
				_tillTouch = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public OpenLine()
			: base(true)
		{
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Final);

			DataSeries[0].IsHidden = true;
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

			DenyToChangePanel = true;
			CustomSessionStartFilter = new(true) { Value = new(9, 0, 0) };
        }

		#endregion

		#region Protected methods

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
            foreach (var session in _sessions)
            {
                if (session.StartBar > LastVisibleBarNumber)
                    continue;

                var x1 = ChartInfo.GetXByBar(session.StartBar, false);

                var x2 = ChartInfo.GetXByBar(session.EndBar, false);

                if (x2 < 0)
                    continue;

                var y = ChartInfo.GetYByPrice(session.OpenPrice, false);

                context.DrawLine(LinePen.RenderObject, x1, y, x2, y);

                var stringSize = context.MeasureString(OpenCandleText, _font);
                context.DrawString(OpenCandleText, _font, LinePen.RenderObject.Color, x2 - stringSize.Width, y - stringSize.Height - Offset - 3);
            }
        }

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_sessions.Clear();
				_lastSession = null;

                _targetBar = 0;

				if (_days > 0)
				{
					var days = 0;

					for (var i = CurrentBar - 1; i >= 0; i--)
					{
						_targetBar = i;

						if (!IsNewSession(i))
							continue;

						days++;

						if (days == _days)
							break;
					}
				}
			}

			if (bar < _targetBar)
				return;

            var candle = GetCandle(bar);

            if (_lastBar != bar)
            {
                _lastBar = bar;

                if (_lastSession is not null && !_lastSession.Touched)
                    _lastSession.EndBar = bar;

                if (_customSessionStartFilter.Enabled)
				{
                    var filter = _customSessionStartFilter.Value;
                    var time = candle
                        .Time.AddHours(InstrumentInfo.TimeZone)
                        .TimeOfDay;

					if (time == filter)
					{
						AddNewSession(bar, candle);
					}
					else if (bar > 0) 
                    {
                        var prevCandle = GetCandle(bar - 1);
                        var prevTime = prevCandle
                            .Time.AddHours(InstrumentInfo.TimeZone)
                            .TimeOfDay;

                        if (prevTime < time )
						{
                            if (time > filter && prevTime < filter)
							{
                                if (_lastSession != null)
                                    _lastSession.EndBar -= 1;

                                AddNewSession(bar - 1, prevCandle);								
                            }
                        }
                        else if (prevTime > time)
						{
							if((time < filter && prevTime < filter) || (time > filter && prevTime > filter))
							{
                                if (_lastSession != null)
                                    _lastSession.EndBar -= 1;

                                AddNewSession(bar - 1, prevCandle);
                            }
						}
                    }					                 
                }
				else if (IsNewSession(bar))
                {
                    AddNewSession(bar, candle);
                }
            }

			if (_lastSession is null || _lastSession.StartBar == bar)
				return;

            if (TillTouch && !_lastSession.Touched)
            {
                var open = _lastSession.OpenPrice;

                if (candle.High >= open && candle.Low <= open)
                {
                    _lastSession.Touched = true;
                    _lastSession.EndBar = bar;
                }
            }
        }

        #endregion

        #region Private methods

        private void AddNewSession(int bar, IndicatorCandle candle)
        {
            _lastSession = new Session
            {
                StartBar = bar,
                EndBar = bar,
                OpenPrice = candle.Open
            };

            _sessions.Add(_lastSession);
        }

        #endregion
    }
}











Technical/OrderBlock.cs






namespace ATAS.Indicators.Technical;

using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;

[DisplayName("Order Block")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.OrderBlockIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000641186-order-block")]

public class OrderBlock : Indicator
{
    #region Nested types

    class Swing(int bar, decimal prise)
    {
        public int Bar { get; set; } = bar;
        public decimal Prise { get; set; } = prise;
        public bool IsCrossed { get; set; } = false;
        public bool IsBullish { get; set; }
    }

    class Block
    {
        public int Bar { get; set; }
        public decimal Top { get; set; }
        public decimal Btm { get; set; }
        public int BreakerBar { get; set; }
        public bool IsVisible { get; set; }
        public decimal PocPrice { get; set; }
    }

    #endregion

    #region Fields

    #region Readonly fields

    private readonly List<Block> _bullishBlocks = [];
    private readonly List<Block> _bearishBlocks = [];
    private readonly List<Block> _blocksForDelete = [];

    private readonly PenSettings _bullishPen = new() { Color = DefaultColors.Green.Convert(), Width = 1 };
    private readonly PenSettings _bearishPen = new() { Color = DefaultColors.Red.Convert(), Width = 1 };
    private readonly PenSettings _brokenBullishPen = new()
    {
        Color = DefaultColors.DarkRed.Convert(),
        Width = 1,
        LineDashStyle = LineDashStyle.DashDotDot
    };

    private readonly PenSettings _brokenBearishPen = new()
    {
        Color = DefaultColors.Lime.Convert(),
        Width = 1,
        LineDashStyle = LineDashStyle.DashDotDot
    };

    private readonly PenSettings _pocPen = new() { Color = DefaultColors.Blue.Convert(), Width = 1 };

    #endregion

    private int _lasBar = -1;
    private Swing? _topSwing;
    private Swing? _bottomSwing;
    private Swing? _lastSwing;

    private Block? _curBullishBlock;
    private Block? _curBearishBlock;
    private int? _os;

    private int _period = 10;
    private bool _usBody;

    #endregion

    #region Properties

    [Parameter]
    [Range(3, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings),
        Description = nameof(Strings.PeriodDescription))]
    public int Period 
    { 
        get => _period; 
        set
        {
            _period = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.IgnoreWicks), GroupName = nameof(Strings.Settings),
        Description = nameof(Strings.IgnoreWicksDescription))]
    public bool UsBody 
    {
        get => _usBody;
        set
        {
            _usBody = value;
            RecalculateValues();
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.Settings),
       Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int Transparency { get; set; } = 5;

    #region Bullish

    [Range(0, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LastBullishElementsNumber), GroupName = nameof(Strings.Bullish))]
    public int BullishNumber { get; set; } = 3;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Bullish),
        Description = nameof(Strings.BullishColorDescription))]
    public Color BullishColor
    {
        get => _bullishPen.Color.Convert();
        set => _bullishPen.Color = value.Convert();
    } 

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishBreakColor), GroupName = nameof(Strings.Bullish),
        Description = nameof(Strings.BrokenBullishDescription))]
    public Color BullishBreakColor 
    {
        get=>_brokenBullishPen.Color.Convert();
        set=> _brokenBullishPen.Color = value.Convert();
    }

    #endregion

    #region Bearish

    [Range(0, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LastBearishElementsNumber), GroupName = nameof(Strings.Bearish))]
    public int BearishNumber { get; set; } = 3;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearishColor), GroupName = nameof(Strings.Bearish),
        Description = nameof(Strings.BearishColorDescription))]
    public Color BearishColor 
    {
        get => _bearishPen.Color.Convert();
        set => _bearishPen.Color = value.Convert();
    } 

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearishBreakColor), GroupName = nameof(Strings.Bearish),
       Description = nameof(Strings.BrokenBearishDescription))]
    public Color BearishBreakColor 
    {
        get => _brokenBearishPen.Color.Convert();
        set => _brokenBearishPen.Color = value.Convert();
    }

    #endregion

    #region POC Level

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowPocLevel), GroupName = nameof(Strings.PocLevel),
      Description = nameof(Strings.ShowPocLevelDescription))]
    public bool ShowPocLevel { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.PocLevel),
       Description = nameof(Strings.ColorDescription))]
    public Color PocColor 
    {
        get => _pocPen.Color.Convert();
        set => _pocPen.Color = value.Convert();
    }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.PocLevel),
        Description = nameof(Strings.LineWidthDescription))]
    public int PocWidth 
    {
        get => _pocPen.Width;
        set => _pocPen.Width = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineDashStyle), GroupName = nameof(Strings.PocLevel),
       Description = nameof(Strings.LineDashStyleDescription))]
    public LineDashStyle PocStyle
    {
        get => _pocPen.LineDashStyle;
        set => _pocPen.LineDashStyle = value;
    }

    #endregion

    #endregion

    #region ctor

    public OrderBlock() : base(true)
    {
        DenyToChangePanel = true;
        SubscribeToDrawingEvents(DrawingLayouts.Final);
        EnableCustomDrawing = true;

        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).ShowZeroValue = false;
    }

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
        if (ChartInfo is null)
            return;

        _bullishPen.Color = DefaultColors.Green.Convert();
        _bearishPen.Color = DefaultColors.Red.Convert();
        _brokenBullishPen.Color = DefaultColors.DarkRed.Convert();
        _brokenBearishPen.Color = DefaultColors.Lime.Convert();
        _pocPen.Color = DefaultColors.Blue.Convert();
    }

    protected override void OnRecalculate()
    {
        _bullishBlocks.Clear();
        _bearishBlocks.Clear();
        _blocksForDelete.Clear();

        _lastSwing = _topSwing = _bottomSwing = null;
        _os = 0;
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (_lasBar != bar)
        {
            TrySetSwings(bar - 1);
            TrySetBullishBlock(bar - 1);
            TrySetBearishBlock(bar - 1);
            TryBreakBlocks(bar - 1);
        }

        _lasBar = bar;
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
        if (ChartInfo is null)
            return;

        DrawBlocks(context, _bullishBlocks, BullishNumber, _bullishPen, _brokenBullishPen, Transparency);
        DrawBlocks(context, _bearishBlocks, BearishNumber, _bearishPen, _brokenBearishPen, Transparency);
    }

    #endregion

    #region Private methods

    private void TryBreakBlocks(int bar)
    {
        if (bar < 0)
            return;

        var candle = GetCandle(bar);

        foreach (var block in _bullishBlocks)
        {
            if (block.BreakerBar == 0)
                block.BreakerBar = candle.Close < block.Btm ? bar : 0;
            else if (candle.Close > block.Top)
                _blocksForDelete.Add(block);
        }

        foreach (var block in _blocksForDelete)
            _bullishBlocks.Remove(block);

        _blocksForDelete.Clear();

        foreach (var block in _bearishBlocks)
        {
            if (block.BreakerBar == 0)
                block.BreakerBar = candle.Close > block.Top ? bar : 0;
            else if (candle.Close < block.Btm)
                _blocksForDelete.Add(block);
        }

        foreach (var block in _blocksForDelete)
            _bearishBlocks.Remove(block);

        _blocksForDelete.Clear();
    }

    private void TrySetBearishBlock(int bar)
    {
        if (bar < 0)
            return;

        var candle = GetCandle(bar);

        if (_curBearishBlock is { } && !_curBearishBlock.IsVisible && candle.High < _curBearishBlock.Btm)
            _curBearishBlock.IsVisible = true;

        if (_bottomSwing is null || _bottomSwing.IsCrossed || candle.Close >= _bottomSwing.Prise)
            return;

        _bottomSwing.IsCrossed = true;
        var swingBar = bar;
        var maxMin = GetCandleMaxMin(swingBar);
        var max = maxMin.Item1;
        var min = maxMin.Item2;

        for (int i = swingBar - 1; i > _bottomSwing.Bar; i--)
        {
            var maxMinLocal = GetCandleMaxMin(i);

            max = Math.Max(max, maxMinLocal.Item1);
            min = max == maxMinLocal.Item1 ? maxMinLocal.Item2 : min;
            swingBar = max == maxMinLocal.Item1 ? i : swingBar;
        }

        if (GetCandleForm(swingBar) != 1)
        {
            swingBar--;

            if (GetCandleForm(swingBar) != 1)
                return;

            maxMin = GetCandleMaxMin(swingBar);
            max = maxMin.Item1;
            min = maxMin.Item2;
        }

        if (_curBearishBlock is { } && !_curBearishBlock.IsVisible)
            _bearishBlocks.Remove(_curBearishBlock);

        _curBearishBlock = new Block
        {
            Bar = swingBar,
            Top = max,
            Btm = min,
            PocPrice = GetCandle(swingBar).MaxVolumePriceInfo.Price
        };

        _bearishBlocks.Add(_curBearishBlock);
    }

    private void TrySetBullishBlock(int bar)
    {
        if (bar < 0)
            return;

        var candle = GetCandle(bar);

        if (_curBullishBlock is { } && !_curBullishBlock.IsVisible && candle.Low > _curBullishBlock.Top)
            _curBullishBlock.IsVisible = true;

        if (_topSwing is null || _topSwing.IsCrossed || candle.Close <= _topSwing.Prise)
            return;

        _topSwing.IsCrossed = true;
        var swingBar = bar;
        var maxMin = GetCandleMaxMin(swingBar);
        var max = maxMin.Item1;
        var min = maxMin.Item2;       

        for (int i = swingBar - 1; i > _topSwing.Bar; i--) 
        {
            var maxMinLocal = GetCandleMaxMin(i);
                       
            min = Math.Min(min, maxMinLocal.Item2);
            max = min == maxMinLocal.Item2 ? maxMinLocal.Item1 : max;
            swingBar = min == maxMinLocal.Item2 ? i : swingBar; 
        }

        if (GetCandleForm(swingBar) != -1) 
        {
            swingBar--;

            if (GetCandleForm(swingBar) != -1)
                return;

            maxMin = GetCandleMaxMin(swingBar);
            max = maxMin.Item1;
            min = maxMin.Item2;
        }

        if (_curBullishBlock is { } && !_curBullishBlock.IsVisible)
            _bullishBlocks.Remove(_curBullishBlock);

        _curBullishBlock = new Block
        {
            Bar = swingBar,
            Top = max,
            Btm = min,
            PocPrice = GetCandle(swingBar).MaxVolumePriceInfo.Price
        };

        _bullishBlocks.Add(_curBullishBlock);
    }

    /// <summary>
    /// Determines whether the candle is rising or falling. 
    /// If the returned value is positive, it means the candle is growing, 
    /// if negative, it means the candle is falling.
    /// </summary>
    /// <param name="bar"></param>
    /// <returns></returns>
    private int GetCandleForm(int bar)
    {
        var candle = GetCandle(bar);

        return (candle.High - candle.Close) < (candle.Close - candle.Low)
            ? 1
            : (candle.High - candle.Close) > (candle.Close - candle.Low)
             ? -1
             : 0;
    }

    private (decimal, decimal) GetCandleMaxMin(int bar)
    {
        var candle = GetCandle(bar);

        return UsBody
            ? (Math.Max(candle.Open, candle.Close), Math.Min(candle.Open, candle.Close))
            : (candle.High, candle.Low);
    }

    private void TrySetSwings(int bar)
    {
        if (bar < _period)
            return;

        var b = bar - _period;
        var upper = GetLastHighest(bar);
        var lower = GetLastLowest(bar);
        var candle = GetCandle(b);
        int? os;

        if (_lastSwing is null || _lastSwing.IsBullish && b != _lastSwing.Bar) 
        {
            os = candle.High > upper ? 0 : _os;

            if (os == 0 && _os != 0)
            {
                _lastSwing = _topSwing = new(b, candle.High);
                _os = os;
            }
        }
        
        if(_lastSwing is null || !_lastSwing.IsBullish && b != _lastSwing.Bar)
        {
            os = candle.Low < lower ? 1 : _os;

            if (os == 1 && _os != 1)
            {
                _lastSwing = _bottomSwing = new(b, candle.Low) { IsBullish = true };
                _os = os;
            }
        }   
    }

    private decimal GetLastLowest(int bar)
    {
        var start = Math.Max(0, bar - _period + 1);
        var res = decimal.MaxValue;

        for (int i = start; i < bar; i++)
        {
            var candle = GetCandle(i);

            if (candle.Low < res)
                res = candle.Low;
        }

        return res;
    }

    private decimal GetLastHighest(int bar)
    {
        var start = Math.Max(0, bar - _period +1 );
        var res = 0m;

        for (int i = start; i < bar; i++)
        {
            var candle = GetCandle(i);

            if (candle.High > res)
                res = candle.High;
        }

        return res;
    }

    #region Drawing

    private void DrawBlocks(RenderContext context, List<Block> blocksList, int number, PenSettings pen, PenSettings breakPen, int transparency)
    {
        var blocks = blocksList.Where(b => b.IsVisible).TakeLast(number).ToList(); 

        foreach (var block in blocks)
        {
            if (block.Bar > LastVisibleBarNumber)
                continue;

            var isBroken = block.BreakerBar > 0;
            var x = ChartInfo.GetXByBar(block.Bar);
            var y = ChartInfo.GetYByPrice(block.Top);
            var w = (isBroken ? ChartInfo.GetXByBar(block.BreakerBar) : ChartArea.Right) - x;
            var h = ChartInfo.GetYByPrice(block.Btm) - y + ChartInfo.PriceChartContainer.PriceRowHeight;
            var rec = new Rectangle(x, y, w, (int)h);

            context.DrawFillRectangle(pen.RenderObject, GetColorTransparency(pen.RenderObject.Color, transparency), rec);

            if (ShowPocLevel)
            {
                var pocY = ChartInfo.GetYByPrice(block.PocPrice, false);
                context.DrawLine(_pocPen.RenderObject, x, pocY, ChartArea.Right, pocY);
            }

            if (!isBroken)
                continue;

            x = ChartInfo.GetXByBar(block.BreakerBar);
            w = ChartArea.Right - x;
            rec = new Rectangle(x, y, w, (int)h);

            context.DrawFillRectangle(breakPen.RenderObject, GetColorTransparency(breakPen.RenderObject.Color, transparency), rec);
        }
    }

    private Color GetColorTransparency(Color color, int tr = 5)
    {
        var colorA = Math.Max(color.A - (tr * 25), 0);

        return Color.FromArgb((byte)colorA, color.R, color.G, color.B);
    }

    #endregion

    #endregion
}







Technical/OrderBookAlerts.cs








namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using Color = System.Drawing.Color;

[DisplayName("Order Book Alerts")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.OrderBookAlertsIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619055")]
public class OrderBookAlerts : Indicator
{
    #region Nested Types

    public enum PriceOffsetMode
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent))]
        Percent,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
        Ticks
    }

    internal class PriceInfo
    {
        internal decimal Price { get; set; }
        internal decimal Volume { get; set; }
        internal DateTime AppearanceTime { get; set; }
        internal DateTime LastAlertTime { get; set; }
        internal bool IsAlerted { get; set; }
        internal bool IsActive { get; set; } = true;
    }

    #endregion

    #region Fields

    private readonly List<PriceInfo> _priceInfos = new();
    private decimal _lastPrice;
    private decimal _filter = 100;
    private PriceOffsetMode _pOMode;
    private int _priceOffset = 1;

    #endregion

    #region Properties

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MinVolumeFilterCommonDescription))]
    public decimal Filter 
    { 
        get => _filter;
        set
        {
            _filter = value;
            RecalculateValues();
        }
    }

    [Range(0, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFilterSec), GroupName = nameof(Strings.Filters), Description = nameof(Strings.LevelValidTimeFilterDescription))]
    public Filter TimeFilter { get; set; } = new Filter() { Enabled = false, Value = 1 };

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.PriceOffset), Description = nameof(Strings.CalculationModeDescription))]
    public PriceOffsetMode POMode 
    { 
        get => _pOMode;
        set
        {
            _pOMode = value;
            RecalculateValues();
        }
    }

    [Parameter]
    [Range(0, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Offset), GroupName = nameof(Strings.PriceOffset), Description = nameof(Strings.PriceLevelsCountDescription))]
    public int PriceOffset 
    { 
        get => _priceOffset; 
        set
        {
            _priceOffset = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription))]
    public bool UseAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription))]
    public string AlertFile { get; set; } = "alert1";

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription))]
    public Color AlertForeColor { get; set; } = Color.FromArgb(255, 247, 249, 249);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription))]
    public Color AlertBGColor { get; set; } = Color.FromArgb(255, 75, 72, 72);

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowOnChart), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.ShowLevelsOnChartDescription))]
    public bool ShowOnChart { get; set; }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CoolDownPeriod), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.CoolDownAlertPeriodDescription))]
    public float CoolDownPeriod { get; set; } = 1f;

    #endregion

    #region ctor

    public OrderBookAlerts() : base(true)
    {
        DenyToChangePanel = true;
        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).ShowZeroValue = false;

        EnableCustomDrawing = true;
        SubscribeToDrawingEvents(DrawingLayouts.Final);
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        _lastPrice = 0;
        _priceInfos.Clear();
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (bar != CurrentBar - 1) return;

        var candle = GetCandle(bar);
        _lastPrice = candle.Close;
    }

    protected override void MarketDepthChanged(MarketDataArg depth)
    {
        if (_lastPrice == 0) return;

        var depths = MarketDepthInfo.GetMarketDepthSnapshot();
        var lowerPrice = 0m;
        var upperPrice = 0m;

        switch (POMode)
        {
            case PriceOffsetMode.Percent:
                lowerPrice = _lastPrice - _lastPrice / 100 * _priceOffset;
                upperPrice = _lastPrice + _lastPrice / 100 * _priceOffset;
                break;
            case PriceOffsetMode.Ticks:
                lowerPrice = _lastPrice - _priceOffset * InstrumentInfo.TickSize;
                upperPrice = _lastPrice + _priceOffset * InstrumentInfo.TickSize;
                break;
        }

        foreach (var mdArg in depths)
        {
            if (mdArg.Price >= lowerPrice && mdArg.Price <= upperPrice && mdArg.Volume > _filter)
            {
	            var priceInfo = _priceInfos.FirstOrDefault(p => p.Price == mdArg.Price)
		            ?? new PriceInfo { AppearanceTime = MarketTime };

                priceInfo.Price = mdArg.Price;
                priceInfo.Volume = mdArg.Volume;
                priceInfo.IsActive = true;

                if (!_priceInfos.Contains(priceInfo))
                    _priceInfos.Add(priceInfo);

                if (!priceInfo.IsAlerted && (MarketTime - priceInfo.LastAlertTime).TotalSeconds >= CoolDownPeriod) 
                {
                    var trueConditions = true;

                    if (TimeFilter.Enabled)
                        trueConditions = (decimal)(MarketTime - priceInfo.AppearanceTime).TotalSeconds >= TimeFilter.Value;

                    if (trueConditions)
                    {
                        priceInfo.LastAlertTime = MarketTime;

                        if (UseAlerts)
                        {
                            AddAlert(AlertFile, InstrumentInfo.Instrument, $"New Level: {priceInfo.Price}, Volume: {priceInfo.Volume}",
                                AlertBGColor.Convert(), AlertForeColor.Convert());
                            priceInfo.IsAlerted = true;
                        }   
                    }
                }
            }
            else
            {
                var priceInfo = _priceInfos.FirstOrDefault(p => p.Price == mdArg.Price);

                if (priceInfo is null) continue;

                priceInfo.IsAlerted = false;
                priceInfo.IsActive = false;
            }
        }
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
        if (ChartInfo is null) return;

        if (ShowOnChart)
            DrawPriceLevel(context);
    }

    #endregion

    #region Private Methods

    private void DrawPriceLevel(RenderContext context)
    {
        foreach (var pInfo in _priceInfos)
        {
            if (!pInfo.IsActive) continue;

            var x = ChartInfo.GetXByBar(FirstVisibleBarNumber);
            var y = ChartInfo.GetYByPrice(pInfo.Price);
            var w = ChartInfo.Region.Width;
            var h = Math.Max(1, ChartInfo.PriceChartContainer.PriceRowHeight);
            var rec = new Rectangle(x, y, w, (int)h);
            var color = Color.FromArgb((int)(AlertBGColor.A * 0.7), AlertBGColor.R, AlertBGColor.G, AlertBGColor.B);

            context.FillRectangle(color, rec);
        }
    }

    #endregion
}







Technical/OrderFlow.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Linq;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Settings;
	using OFT.Rendering.Tools;

	using Utils.Common.Logging;

	using Color = System.Drawing.Color;
	
    [DisplayName("Order Flow Indicator")]
	[Category(IndicatorCategories.VolumeOrderFlow)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OrderFlowDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602441")]
	public class OrderFlow : Indicator
	{
		#region Nested types

		private class Ellipse
		{
			#region Properties

			public int Y { get; set; }

			public int X { get; set; }

			public Color FillBrush { get; set; }

			public decimal Volume { get; set; }

			#endregion
		}

		public enum TradesType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CumulativeTrades))]
			Cumulative,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SeparatedTrades))]
			Separated
		}

		public enum VisualType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Circles))]
			Circles,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Rectangles))]
			Rectangles
		}

		#endregion

		#region Static and constants

		private const int _radius = 2;

		#endregion

		#region Fields

		private readonly RenderStringFormat _format = new()
		{
			Alignment = StringAlignment.Center,
			LineAlignment = StringAlignment.Center
		};

		private readonly List<MarketDataArg> _singleTrades = new();

		private readonly List<CumulativeTrade> _trades = new();
		private bool _alertRaised;
		private bool _combineSmallTrades;
		private decimal _filter = 10;
		private object _locker = new();
		private int _offset = 100;
        private string _priceFormat = "{0:0.##}";
        private bool _showSmallTrades = true;
        private int _size = 10;
        private int _spacing = 8;
        private int _speedInterval = 300;

        #endregion

        #region Properties

        #region Settings

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.VisualModeDescription), Order = 100)]
		public VisualType VisMode { get; set; } = VisualType.Circles;

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Trades), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 105)]
		public TradesType TradesMode { get; set; }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinimumFilterDescription), Order = 400)]
        [Range(0, 10000000)]
        public decimal Filter
        {
            get => _filter;
            set
            {
                _filter = value;
                RedrawChart();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSmallTrades), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowSmallTradesDescription), Order = 410)]
        public bool ShowSmallTrades
        {
            get => _showSmallTrades;
            set
            {
                _showSmallTrades = value;
                RedrawChart();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CombineSmallTrades), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CombineSmallTradesDescription), Order = 420)]
        public bool CombineSmallTrades
        {
            get => _combineSmallTrades;
            set
            {
                _combineSmallTrades = value;
                RedrawChart();
            }
        }

        #endregion

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Buys), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BuySignalColorDescription), Order = 110)]
		public CrossColor Buys { get; set; } = CrossColor.FromArgb(255, 106, 214, 106);

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Sells), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.SellSignalColorDescription), Order = 120)]
		public CrossColor Sells { get; set; } = CrossColor.FromArgb(255, 240, 122, 125);

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.FontSettingDescription), Order = 130)]
		public FontSetting Font { get; set; } = new("Arial", 10);

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LabelTextColorDescription), Order = 135)]
		public CrossColor TextColor { get; set; } = System.Drawing.Color.Black.Convert();

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PenSettingsDescription), Order = 140)]
		public PenSettings LineColor { get; set; } = new()
		{
			Color = Color.Black.Convert(),
			LineDashStyle = LineDashStyle.Solid,
			Width = 1
		};

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Border), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PenSettingsDescription), Order = 141)]
		public PenSettings BorderColor { get; set; } = new();

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Spacing), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.SpaceBetweenObjectsDescription), Order = 150)]
		[Range(1, 300)]
		public int Spacing
		{
			get => _spacing;
			set
			{
				_spacing = value;
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Size), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ObjectSizeDescription), Order = 160)]
		[Range(1, 200)]
		public int Size
		{
			get => _size;
			set
			{
				_size = value;
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.DoNotShowAboveChart), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.DoNotShowAboveChartDescription), Order = 161)]
		public bool DoNotShowAboveChart { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SpeedInterval), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.OrderSpeedIntervalDescription), Order = 170)]
		[Range(100, 10000)]
		public int SpeedInterval
		{
			get => _speedInterval;
			set
			{
				if (_speedInterval == value)
					return;

				if (DataProvider is not null)
				{
					UnsubscribeFromTimer(TimeSpan.FromMilliseconds(_speedInterval), OnTimerCall);
                    SubscribeToTimer(TimeSpan.FromMilliseconds(value), OnTimerCall);
				}

				_speedInterval = value;
			}
		}
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LinkingToBar), GroupName = nameof(Strings.Location), Description = nameof(Strings.OrderFlowLinkingToBarDescription), Order = 300)]
		public bool LinkingToBar { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Offset), GroupName = nameof(Strings.Location), Description = nameof(Strings.LabelOffsetXDescription), Order = 310)]
		[Range(0, 1000)]
		public int Offset
		{
			get => _offset;
			set
			{
				_offset = value;
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription), Order = 500)]
		public bool UseAlerts { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFilter), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFilterDescription), Order = 510)]
		public decimal AlertFilter { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 520)]
		public string AlertFile { get; set; } = "alert2";

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription), Order = 530)]
		public CrossColor AlertColor { get; set; } = Color.Black.Convert();

		#endregion

		#region ctor

		public OrderFlow()
			: base(true)
		{
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			DrawAbovePrice = true;
            SubscribeToDrawingEvents(DrawingLayouts.Final);
			
			DataSeries[0].IsHidden = true;
		}

		#endregion

		#region Protected methods
		
		protected override void OnApplyDefaultColors()
		{
			if (ChartInfo is null)
				return;

			Buys = ChartInfo.ColorsStore.FootprintAskColor.Convert();
			Sells = ChartInfo.ColorsStore.FootprintBidColor.Convert();
			LineColor.Color = BorderColor.Color = ChartInfo.ColorsStore.FootprintTextColor.Convert();
		}
		
		protected override void OnCalculate(int bar, decimal value)
		{
		}

		protected override void OnNewTrade(MarketDataArg trade)
		{
			if (TradesMode is TradesType.Cumulative)
				return;

			_alertRaised = false;

			lock (_locker)
			{
				_singleTrades.Add(trade);

				if (UseAlerts && trade.Volume > AlertFilter)
				{
					_alertRaised = true;
					AddTradeAlert(trade.Direction, trade.Price);
				}

				CleanUpTrades();
			}
		}

		protected override void OnCumulativeTrade(CumulativeTrade trade)
		{
			if (TradesMode is TradesType.Separated)
				return;

			_alertRaised = false;

			lock (_locker)
			{
				_trades.Add(trade);

				if (UseAlerts && trade.Volume > AlertFilter)
				{
					_alertRaised = true;
					AddTradeAlert(trade.Direction, trade.FirstPrice);
				}

				CleanUpTrades();
			}
		}

		protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
		{
			if (TradesMode is TradesType.Separated)
				return;

			lock (_locker)
			{
				if (_trades.Any(x => x != null))
				{
					for (var i = _trades.Count - 1; i >= 0; i--)
					{
						if (_trades[i] == null)
							continue;

						if (!trade.IsEqual(_trades[i]))
							continue;

						_trades.RemoveAt(i);
						_trades.Insert(i, null);
						break;
					}

					_trades.Add(trade);
				}
				else
					_trades.Add(trade);
			}

			if (!_alertRaised && UseAlerts && trade.Volume > AlertFilter)
			{
				_alertRaised = true;
				AddTradeAlert(trade.Direction, trade.FirstPrice);
			}
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			lock (_locker)
			{
				if (_trades.Count(x => x != null) == 0 && TradesMode is TradesType.Cumulative 
				    ||
				    _singleTrades.Count(x => x != null) == 0 && TradesMode is TradesType.Separated)
					return;
			}

			var textColor = TextColor.Convert();
			var barsWidth = ChartInfo.GetXByBar(1) - ChartInfo.GetXByBar(0);
			var minX = DoNotShowAboveChart ? ChartInfo.GetXByBar(LastVisibleBarNumber) + barsWidth : 0;

			var x1 = Container.Region.Width;

			if (LinkingToBar)
				x1 = ChartInfo.GetXByBar(LastVisibleBarNumber);

			var points = new List<Point>();
			var ellipses = new List<Ellipse>();
			CumulativeTrade lastTrade = null;
			MarketDataArg lastSingleTrade = null;
			var currentX = x1 - _offset;
			var j = -1;
			var firstY = 0;
			var sells = Sells.Convert();
			var buys = Buys.Convert();
			var border = BorderColor.RenderObject;

			lock (_locker)
			{
				var start = TradesMode is TradesType.Cumulative ? _trades.Count - 1 : _singleTrades.Count - 1;

				for (var i = start; i >= 0; i--)
				{
					if (TradesMode is TradesType.Cumulative && _trades[i] == null || TradesMode is TradesType.Separated && _singleTrades[i] == null)
					{
						currentX -= 2;
						continue;
					}

					var volume = TradesMode is TradesType.Cumulative
						? _trades[i].Volume
						: _singleTrades[i].Volume;

					var price = TradesMode is TradesType.Cumulative
						? _trades[i].FirstPrice
						: _singleTrades[i].Price;

					if (!ShowSmallTrades && volume < Filter)
						continue;

					if (CombineSmallTrades && volume < Filter &&
					    (lastTrade != null && TradesMode is TradesType.Cumulative || lastSingleTrade != null && TradesMode is TradesType.Separated))
					{
						var lastPrice = TradesMode is TradesType.Cumulative
							? lastTrade.FirstPrice
							: lastSingleTrade.Price;

						if (lastPrice == price)
						{
							switch (VisMode)
							{
								case VisualType.Circles when lastPrice == price:
									if (TradesMode is TradesType.Cumulative)
										lastTrade = _trades[i];
									else
										lastSingleTrade = _singleTrades[i];
									continue;
								case VisualType.Rectangles when lastPrice == price:
									if (TradesMode is TradesType.Cumulative)
									{
										if (lastTrade.Lastprice == _trades[i].Lastprice)
											lastTrade = _trades[i];
									}
									else
										lastSingleTrade = _singleTrades[i];

									continue;
							}
						}
					}

					if (TradesMode is TradesType.Cumulative)
						lastTrade = _trades[i];
					else
						lastSingleTrade = _singleTrades[i];

					j++;
					var lastX = 0;

					var direction = TradesMode is TradesType.Cumulative
						? _trades[i].Direction
						: _singleTrades[i].Direction;

					var fillColor = direction is TradeDirection.Sell ? sells : buys;

					lastX = currentX - j * Spacing;

					if (lastX < minX)
						break;

					var lastY = ChartInfo.GetYByPrice(price, false);

					if (firstY == 0)
						firstY = lastY;

					if (firstY + 1 > Container.Region.Height)
						firstY = Container.Region.Height;

					var y = lastY;

					if (y + 1 > Container.Region.Height)
						y = Container.Region.Height;

					points.Add(new Point(lastX, y));

					ellipses.Add(new Ellipse
					{
						FillBrush = fillColor,
						X = lastX,
						Y = lastY,
						Volume = volume >= Filter ? volume : 0
					});

					if (volume >= Filter)
						j++;

					if (lastX < 0)
						break;
				}
			}

			if (points.Count > 2)
			{
				points.Insert(0, new Point(x1 - Offset, firstY));
				context.DrawLines(LineColor.RenderObject, points.ToArray());
			}

			foreach (var ellipse in ellipses)
			{
				if (ellipse == null)
					continue;

				if (ellipse.Y + 1 > Container.Region.Height)
					continue;

				var ellipseRect = new Rectangle(ellipse.X - _radius, ellipse.Y - _radius, 2 * _radius, 2 * _radius);

				if (VisMode == VisualType.Circles)
				{
					context.FillEllipse(ellipse.FillBrush, ellipseRect);
					context.DrawEllipse(border, ellipseRect);
				}
				else
				{
					context.FillRectangle(ellipse.FillBrush, ellipseRect);
					context.DrawRectangle(border, ellipseRect);
				}
			}

			ellipses.RemoveAll(x => x == null || x.Volume == 0);

			for (var i = ellipses.Count - 1; i >= 0; i--)
			{
				if (ellipses[i].Y + 1 > Container.Region.Height)
					continue;

				var str = ChartInfo.TryGetMinimizedVolumeString(ellipses[i].Volume);

				var width = context.MeasureString(str, Font.RenderObject).Width;
				var height = context.MeasureString(str, Font.RenderObject).Height;
				var objSize = Math.Max(width, height) + _size;
				var radius = objSize / 2;
				var rect = new Rectangle(ellipses[i].X - radius, ellipses[i].Y - radius, objSize, objSize);

				if (VisMode == VisualType.Circles)
				{
					context.FillEllipse(ellipses[i].FillBrush, rect);
					context.DrawEllipse(border, rect);
				}
				else
				{
					context.FillRectangle(ellipses[i].FillBrush, rect);
					context.DrawRectangle(border, rect);
				}

				context.DrawString(str, Font.RenderObject, textColor, rect, _format);
			}
		}

		protected override void OnInitialize()
		{
			SubscribeToTimer(TimeSpan.FromMilliseconds(_speedInterval), OnTimerCall);
		}

		protected override void OnDispose()
		{
			UnsubscribeFromTimer(TimeSpan.FromMilliseconds(_speedInterval), OnTimerCall);
        }

		private void OnTimerCall()
		{
			try
			{
				lock (_locker)
				{
					if (TradesMode is TradesType.Cumulative)
					{
						_trades.Add(null);
						CleanUpTrades();
					}
					else
					{
						_singleTrades.Add(null);
						CleanUpTrades();
					}
				}

				if (Container != null)
					RedrawChart(new RedrawArg(Container.Region));
			}
			catch (Exception ex)
			{
				this.LogError("Refresh error: ", ex);
			}
        }

        #endregion

        #region Private methods

        private void AddTradeAlert(TradeDirection dir, decimal price)
		{
			var message = $"Trade volume is greater than {AlertFilter}. {dir} at {price}";
			AddAlert(AlertFile, InstrumentInfo.Instrument, message, AlertColor, Color.White.Convert());
		}

		private void CleanUpTrades()
		{
			if (TradesMode is TradesType.Cumulative && _trades.Count > 2000)
			{
				_trades.RemoveRange(0, 1000);
				return;
			}

			if (TradesMode is TradesType.Separated && _singleTrades.Count > 2000)
				_singleTrades.RemoveRange(0, 1000);
		}

		#endregion
	}
}







Technical/OutsideBar.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Outside Bar")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.OutsideBarDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602280")]
	public class OutsideBar : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			Color = DefaultColors.Blue.Convert(),
			VisualType = VisualMode.Dots,
			Width = 3
		};

		private bool _includeEqual;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IncludeEqualHighLow), GroupName = nameof(Strings.Settings), Description = nameof(Strings.IncludeEqualsValuesDescription), Order = 100)]
		public bool IncludeEqual
		{
			get => _includeEqual;
			set
			{
				_includeEqual = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public OutsideBar()
			: base(true)
		{
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();
				return;
			}

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			switch (_includeEqual)
			{
				case false when candle.High > prevCandle.High && candle.Low < prevCandle.Low:
					_renderSeries[bar] = candle.High;
					return;
				case true when candle.High >= prevCandle.High && candle.Low <= prevCandle.Low:
					_renderSeries[bar] = candle.High;
					break;
			}
		}

		#endregion
	}
}








Technical/ParabolicSAR.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Parabolic SAR")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ParabolicSARDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602442")]
	public class ParabolicSAR : Indicator
	{
		#region Fields

        private decimal _start = 0.02m;
        private decimal _increment = 0.02m;
        private decimal _max = 0.2m;

        private decimal _sar;
        private decimal _acceleration;
        private decimal _extreme;
        private bool _isUptrend;
        private int _lastBar;

        #endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AccelStart),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.AccelStartDescription),
            Order = 20)]
		[Range(0.000000001, 100000000)]
		public decimal AccelStart
		{
			get => _start;
			set
			{
				_start = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AccelStep),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.AccelStepDescription),
            Order = 21)]
		[Range(0.000000001, 100000000)]
        public decimal AccelStep
		{
			get => _increment;
			set
			{
				_increment = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AccelMax),
			GroupName = nameof(Strings.Common),
            Description = nameof(Strings.AccelMaxDescription),
            Order = 22)]
		[Range(0.000000001, 100000000)]
        public decimal AccelMax
		{
			get => _max;
			set
			{
				_max = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ParabolicSAR()
			: base(true)
		{
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Dots;
			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Blue.Convert();
			((ValueDataSeries)DataSeries[0]).Width = 2;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar < 2)
				return;

			if (_lastBar == bar)
				return;

			_lastBar = bar;

            bar--;

			var high = GetCandle(bar).High;
			var low = GetCandle(bar).Low;
			var prevHigh = GetCandle(bar - 1).High;
			var prevLow = GetCandle(bar - 1).Low;

			if (bar == 1)
			{
				_sar = _isUptrend ? prevLow : prevHigh;
				_extreme = _isUptrend ? high : low;
				return;
			}

			_sar += _acceleration * (_extreme - _sar);

			if (_isUptrend)
			{
				if (_sar > low)
				{
					_isUptrend = false;
					_sar = Math.Max(prevHigh, _extreme);
					_extreme = low;
					_acceleration = _start;
				}
				else
				{
					if (high > _extreme)
					{
						_extreme = high;
						_acceleration = Math.Min(_acceleration + _increment, _max);
					}
				}
			}
			else
			{
				if (_sar < high)
				{
					_isUptrend = true;
					_sar = Math.Min(prevLow, _extreme);
					_extreme = high;
					_acceleration = _start;
				}
				else
				{
					if (low < _extreme)
					{
						_extreme = low;
						_acceleration = Math.Min(_acceleration + _increment, _max);
					}
				}
			}

			_sar = _isUptrend 
				? Math.Min(_sar, Math.Min(prevLow, GetCandle(bar - 2).Low))
				: Math.Max(_sar, Math.Max(prevHigh, GetCandle(bar - 2).High));

			this[bar] = _sar;
		}

		#endregion
	}
}








Technical/PercentagePrice.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Percentage Price Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.PercentagePriceDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602445")]
	public class PercentagePrice : Indicator
	{
		#region Fields

		private readonly EMA _emaLong = new() { Period = 20 };
		private readonly EMA _emaShort = new() { Period = 5 };

        private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int ShortPeriod
		{
			get => _emaShort.Period;
			set
			{
				_emaShort.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _emaLong.Period;
			set
			{
				_emaLong.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public PercentagePrice()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_emaLong.Calculate(bar, value);
			_emaShort.Calculate(bar, value);

			if (bar == 0)
				return;

			_renderSeries[bar] = _emaLong[bar] != 0
				? 100 * (_emaShort[bar] - _emaLong[bar]) / _emaLong[bar]
				: _renderSeries[bar - 1];
		}

		#endregion
	}
}








Technical/Pivots.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
	using OFT.Attributes.Editors;
    using OFT.Localization;
    using Utils.Common.Logging;

	using Color = System.Drawing.Color;
    
    [DisplayName("Pivots")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.PivotsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602446")]
    public class Pivots : Indicator
    {
        #region Nested types

        public enum Period
        { 
	        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M1))]
            M1 = 1,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M5))]
            M5 = 3,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M10))]
            M10 = 4,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M15))]
            M15 = 5,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.M30))]
            M30 = 6,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Hourly))]
            Hourly = -1,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H4))]
            H4 = 7,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Daily))]
            Daily = 0,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Weekly))]
            Weekly = 10,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Monthly))]
            Monthly = 20
        }

        public enum TextLocation
        {
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Left))]
            Left = 0,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Right))]
            Right = 1
        }

        public enum Formula
        {
            [Display(Name = "PP +/- 2(High � Low)")]
            HighLow,
            [Display(Name = "High/Low + 2(PP - Low/High)")]
            PpHighLow
        }

        #endregion

        #region Fields

        private readonly ValueDataSeries _m1Series = new("M1Series", "M1")
        {
            Color = DefaultColors.Blue.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.MidLineSettingsDescription)
        };
        private readonly ValueDataSeries _m2Series = new("M2Series", "M2")
        {
            Color = DefaultColors.Blue.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.MidLineSettingsDescription)
        };
        private readonly ValueDataSeries _m3Series = new("M3Series", "M3")
        {
            Color = DefaultColors.Blue.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.MidLineSettingsDescription)
        };
        private readonly ValueDataSeries _m4Series = new("M4Series", "M4")
        {
            Color = DefaultColors.Blue.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.MidLineSettingsDescription)
        };

        private readonly ValueDataSeries _ppSeries = new("PpSeries", "PP")
        {
            ScaleIt = false,
            Color = Color.Goldenrod.Convert(),
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
        };
        private readonly ValueDataSeries _r1Series = new("R1Series", "R1")
        {
            Color = DefaultColors.Aqua.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.ResistanceLineSettingsDescription)
        };
        private readonly ValueDataSeries _r2Series = new("R2Series", "R2")
        {
            Color = DefaultColors.Aqua.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.ResistanceLineSettingsDescription)
        };
        private readonly ValueDataSeries _r3Series = new("R3Series", "R3")
        {
            Color = DefaultColors.Aqua.Convert(),
            ScaleIt = false,
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.ResistanceLineSettingsDescription)
        };
        private readonly ValueDataSeries _s1Series = new("S1Series", "S1")
        {
            ScaleIt = false,
            Color = Color.Crimson.Convert(),
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.SupportLineSettingsDescription)
        };
        private readonly ValueDataSeries _s2Series = new("S2Series", "S2")
        {
            ScaleIt = false,
            Color = Color.Crimson.Convert(),
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.SupportLineSettingsDescription)
        };
        private readonly ValueDataSeries _s3Series = new("S3Series", "S3")
        {
            ScaleIt = false,
            Color = Color.Crimson.Convert(),
            VisualType = VisualMode.Hash,
            DescriptionKey = nameof(Strings.SupportLineSettingsDescription)
        };

        private readonly Queue<int> _sessionStarts;

        private decimal _prevDayClose;
        private decimal _prevDayHigh;
        private decimal _prevDayLow;

        private int _fontSize = 12;
        private int _id;
        private int _lastBar;

        private int _lastNewSessionBar = -1;

        private decimal _m1;
        private decimal _m2;
        private decimal _m3;
        private decimal _m4;
        private bool _newSessionWasStarted;
        private Period _pivotRange;

        private decimal _pp;
        private decimal _r1;
        private decimal _r2;
        private decimal _r3;

        private decimal _s1;
        private decimal _s2;
        private decimal _s3;
        private TimeSpan _sessionBegin = new(0, 0, 0);
        private TimeSpan _sessionEnd = new(23, 59, 59);

        private bool _showText = true;

        private TextLocation _textLocation;
        private bool _useCustomSession;
        private Formula _formula = Formula.HighLow;

        #endregion

        #region Properties

        #region Settings

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ThirdFormula), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 5)]
        public Formula ThirdFormula
        {
            get => _formula;
            set
            {
                _formula = value;
                RecalculateValues();
            }
        }

        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RenderPeriods), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodsCountFilterDescription), Order = 10)]
        public FilterInt RenderPeriodsFilter { get; set; } = new(true)
        { Value = 3, Enabled = false };

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PivotRange), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodTypeDescription), Order = 15)]
        public Period PivotRange
        {
            get => _pivotRange;
            set
            {
                _pivotRange = value;
                RecalculateValues();
            }
        }

        #endregion

        #region CustomSession

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.CustomSession), Description = nameof(Strings.IsCustomSessionDescription), Order = 20)]
        public bool UseCustomSession
        {
            get => _useCustomSession;
            set
            {
                _useCustomSession = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionBegin), GroupName = nameof(Strings.CustomSession), Description = nameof(Strings.SessionBeginDescription), Order = 30)]
        [Mask(MaskTypes.DateTimeAdvancingCaret, "HH:mm:ss")]
        public TimeSpan SessionBegin
        {
            get => _sessionBegin;
            set
            {
                _sessionBegin = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionEnd), GroupName = nameof(Strings.CustomSession), Description = nameof(Strings.SessionEndDescription), Order = 40)]
        [Mask(MaskTypes.DateTimeAdvancingCaret, "HH:mm:ss")]
        public TimeSpan SessionEnd
        {
            get => _sessionEnd;
            set
            {
                _sessionEnd = value;
                RecalculateValues();
            }
        }

        #endregion

        #region Text

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Text), Description = nameof(Strings.IsNeedShowLabelDescription), Order = 50)]
        public bool ShowText
        {
            get => _showText;
            set
            {
                _showText = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize), GroupName = nameof(Strings.Text), Description = nameof(Strings.FontSizeDescription), Order = 60)]
        [Range(1, 1000)]
        public int FontSize
        {
            get => _fontSize;
            set
            {
                _fontSize = Math.Max(9, value);
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextLocation), GroupName = nameof(Strings.Text), Description = nameof(Strings.LabelLocationDescription), Order = 70)]
        public TextLocation Location
        {
            get => _textLocation;
            set
            {
                _textLocation = value;
                RecalculateValues();
            }
        }

        #endregion

        #endregion

        #region ctor

        public Pivots()
            : base(true)
        {
            _sessionStarts = new Queue<int>();
            DenyToChangePanel = true;

            DataSeries[0] = _ppSeries;

            DataSeries.Add(_s1Series);
            DataSeries.Add(_s2Series);
            DataSeries.Add(_s3Series);

            DataSeries.Add(_r1Series);
            DataSeries.Add(_r2Series);
            DataSeries.Add(_r3Series);

            DataSeries.Add(_m1Series);
            DataSeries.Add(_m2Series);
            DataSeries.Add(_m3Series);
            DataSeries.Add(_m4Series);

            _ppSeries.PropertyChanged += SeriesPropertyChanged;
            _s1Series.PropertyChanged += SeriesPropertyChanged;
            _s2Series.PropertyChanged += SeriesPropertyChanged;
            _s3Series.PropertyChanged += SeriesPropertyChanged;

            _r1Series.PropertyChanged += SeriesPropertyChanged;
            _r2Series.PropertyChanged += SeriesPropertyChanged;
            _r3Series.PropertyChanged += SeriesPropertyChanged;

            _m1Series.PropertyChanged += SeriesPropertyChanged;
            _m2Series.PropertyChanged += SeriesPropertyChanged;
            _m3Series.PropertyChanged += SeriesPropertyChanged;
            _m4Series.PropertyChanged += SeriesPropertyChanged;
        }

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
        {
            if (bar == 0)
            {
                _lastNewSessionBar = -1;
                _lastBar = 0;
                _sessionStarts.Clear();
                _newSessionWasStarted = false;
                DataSeries.ForEach(x => x.Clear());
                Labels.Clear();
                _prevDayHigh = _prevDayLow = _prevDayClose = 0;
            }

            if (RenderPeriodsFilter.Enabled && RenderPeriodsFilter.Value <= 0)
                return;

            _ppSeries[bar] = 0;
            _s1Series[bar] = 0;
            _s2Series[bar] = 0;
            _s3Series[bar] = 0;
            _r1Series[bar] = 0;
            _r2Series[bar] = 0;
            _r3Series[bar] = 0;

            var candle = GetCandle(bar);
            var inSession = InsideSession(bar) || !UseCustomSession;
            var isNewSession = IsNeSession(bar);

            if (isNewSession && inSession && _lastNewSessionBar != bar)
            {
                _sessionStarts.Enqueue(bar);

                if (RenderPeriodsFilter.Enabled)
                {
                    while (_sessionStarts.Count > RenderPeriodsFilter.Value)
                    {
                        RemoveLabels(_sessionStarts.Peek());

                        for (var i = _sessionStarts.Dequeue(); i < _sessionStarts.Peek(); i++)
                        {
                            _ppSeries[i] = 0;
                            _s1Series[i] = 0;
                            _s2Series[i] = 0;
                            _s3Series[i] = 0;

                            _r1Series[i] = 0;
                            _r2Series[i] = 0;
                            _r3Series[i] = 0;

                            _m1Series[i] = 0;
                            _m2Series[i] = 0;
                            _m3Series[i] = 0;
                            _m4Series[i] = 0;
                        }
                    }
                }

                _lastNewSessionBar = bar;
                _id = bar;
                _newSessionWasStarted = true;

                var close = _prevDayClose == 0 ? candle.Close : _prevDayClose;

                _pp = (_prevDayHigh + _prevDayLow + close) / 3;
                _s1 = 2 * _pp - _prevDayHigh;
                _r1 = 2 * _pp - _prevDayLow;
                _s2 = _pp - (_prevDayHigh - _prevDayLow);
                _r2 = _pp + (_prevDayHigh - _prevDayLow);

                _s3 = ThirdFormula is Formula.HighLow
                    ? _pp - 2 * (_prevDayHigh - _prevDayLow)
                    : _prevDayLow - 2 * (_prevDayHigh - _pp);

                _r3 = ThirdFormula is Formula.HighLow
                    ? _pp + 2 * (_prevDayHigh - _prevDayLow)
                    : _prevDayHigh + 2 * (_pp - _prevDayLow);

                _m1 = (_s1 + _s2) / 2;
                _m2 = (_s1 + _pp) / 2;
                _m3 = (_r1 + _pp) / 2;
                _m4 = (_r1 + _r2) / 2;

                _prevDayHigh = candle.High;
                _prevDayLow = candle.Low;
                _prevDayClose = candle.Close;
            }
            else if (inSession)
            {
                if (candle.High > _prevDayHigh)
                    _prevDayHigh = candle.High;

                if (candle.Low < _prevDayLow || _prevDayLow == 0)
                    _prevDayLow = candle.Low;

                _prevDayClose = candle.Close;
            }

            if (_newSessionWasStarted && inSession)
            {
                _ppSeries[bar] = _pp;
                _s1Series[bar] = _s1;
                _s2Series[bar] = _s2;
                _s3Series[bar] = _s3;

                _r1Series[bar] = _r1;
                _r2Series[bar] = _r2;
                _r3Series[bar] = _r3;

                _m1Series[bar] = _m1;
                _m2Series[bar] = _m2;
                _m3Series[bar] = _m3;
                _m4Series[bar] = _m4;

                if (_showText && Location == TextLocation.Right)
                    SetLabels(bar, DrawingText.TextAlign.Left);
            }

            if (_showText
                && Labels
                    .Select(x => x.Value.Bar)
                    .DefaultIfEmpty(0)
                    .Max() < _lastNewSessionBar)
                SetLabels(bar, DrawingText.TextAlign.Right);

            if (inSession)
                _lastBar = bar;
        }

        protected override void OnInitialize()
        {
            RenderPeriodsFilter.PropertyChanged += (_, _) =>
            {
                RecalculateValues();
                RedrawChart();
            };
        }

        #endregion

        #region Private methods

        private bool InsideSession(int bar)
        {
            var diff = InstrumentInfo.TimeZone;
            var candle = GetCandle(bar);
            var time = candle.Time.AddHours(diff);

            if (_sessionBegin < _sessionEnd)
                return time.TimeOfDay <= _sessionEnd && time.TimeOfDay >= _sessionBegin;

            return time.TimeOfDay >= _sessionEnd && time.TimeOfDay >= _sessionBegin
                || time.TimeOfDay <= _sessionBegin && time.TimeOfDay <= _sessionEnd;
        }

        private void SeriesPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            try
            {
                foreach (var drawingText in Labels)
                {
                    if (drawingText.Value.Text == "PP")
                        drawingText.Value.Textcolor = ConvertColor(_ppSeries.Color);
                    else if (drawingText.Value.Text == "S1")
                        drawingText.Value.Textcolor = ConvertColor(_s1Series.Color);
                    else if (drawingText.Value.Text == "S2")
                        drawingText.Value.Textcolor = ConvertColor(_s2Series.Color);
                    else if (drawingText.Value.Text == "S3")
                        drawingText.Value.Textcolor = ConvertColor(_s3Series.Color);
                    else if (drawingText.Value.Text == "R1")
                        drawingText.Value.Textcolor = ConvertColor(_r1Series.Color);
                    else if (drawingText.Value.Text == "R2")
                        drawingText.Value.Textcolor = ConvertColor(_r2Series.Color);
                    else if (drawingText.Value.Text == "R3")
                        drawingText.Value.Textcolor = ConvertColor(_r3Series.Color);
                    else if (drawingText.Value.Text == "M1")
                        drawingText.Value.Textcolor = ConvertColor(_m1Series.Color);
                    else if (drawingText.Value.Text == "M2")
                        drawingText.Value.Textcolor = ConvertColor(_m2Series.Color);
                    else if (drawingText.Value.Text == "M3")
                        drawingText.Value.Textcolor = ConvertColor(_m3Series.Color);
                    else if (drawingText.Value.Text == "M4")
                        drawingText.Value.Textcolor = ConvertColor(_m4Series.Color);
                }
            }
            catch (Exception exception)
            {
                this.LogError("Pivots update colors error", exception);
            }
        }

        private void SetLabels(int bar, DrawingText.TextAlign align)
        {
            if (Labels is null)
                return;

            AddText("pp" + _id, "PP", true, bar, _pp, -3, 0, ConvertColor(_ppSeries.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("s1" + _id, "S1", true, bar, _s1, -3, 0, ConvertColor(_s1Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("s2" + _id, "S2", true, bar, _s2, -3, 0, ConvertColor(_s2Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("s3" + _id, "S3", true, bar, _s3, -3, 0, ConvertColor(_s3Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("r1" + _id, "R1", true, bar, _r1, -3, 0, ConvertColor(_r1Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("r2" + _id, "R2", true, bar, _r2, -3, 0, ConvertColor(_r2Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("r3" + _id, "R3", true, bar, _r3, -3, 0, ConvertColor(_r3Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);

            AddText("m1" + _id, "M1", true, bar, _m1, -3, 0, ConvertColor(_m1Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("m2" + _id, "M2", true, bar, _m2, -3, 0, ConvertColor(_m2Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("m3" + _id, "M3", true, bar, _m3, -3, 0, ConvertColor(_m3Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
            AddText("m4" + _id, "M4", true, bar, _m4, -3, 0, ConvertColor(_m4Series.Color), Color.Transparent, Color.Transparent, _fontSize, align);
        }

        private void RemoveLabels(int id)
        {
            Labels.Remove("pp" + id);
            Labels.Remove("s1" + id);
            Labels.Remove("s2" + id);
            Labels.Remove("s3" + id);
            Labels.Remove("r1" + id);
            Labels.Remove("r2" + id);
            Labels.Remove("r3" + id);
            Labels.Remove("m1" + id);
            Labels.Remove("m2" + id);
            Labels.Remove("m3" + id);
            Labels.Remove("m4" + id);
        }

        private Color ConvertColor(CrossColor cl)
        {
            return Color.FromArgb(cl.A, cl.R, cl.G, cl.B);
        }

        private bool IsNeSession(int bar)
        {
            if (bar == 0)
                return true;

            switch (PivotRange)
            {
                case Period.M1:
                    return isnewsession(1, bar);
                case Period.M5:
                    return isnewsession(5, bar);
                case Period.M10:
                    return isnewsession(10, bar);
                case Period.M15:
                    return isnewsession(15, bar);
                case Period.M30:
                    return isnewsession(30, bar);
                case Period.Hourly:
                    return GetCandle(bar).Time.Hour != GetCandle(bar - 1).Time.Hour;
                case Period.H4:
                    return isnewsession(240, bar);
                case Period.Daily:
                    return UseCustomSession ? IsNewCustomSession(bar) : IsNewSession(bar);
                case Period.Weekly:
                    return UseCustomSession ? IsNewCusomWeek(bar) : IsNewWeek(bar);
                case Period.Monthly:
                    return UseCustomSession ? IsNewCusomMonth(bar) : IsNewMonth(bar);
            }

            return false;
        }

        private bool IsNewCusomMonth(int bar)
        {
            for (var i = _lastBar + 1; i <= bar; i++)
            {
                if (IsNewMonth(i))
                    return true;
            }

            return false;
        }

        private bool IsNewCusomWeek(int bar)
        {
            for (var i = _lastBar + 1; i <= bar; i++)
            {
                if (IsNewWeek(i))
                    return true;
            }

            return false;
        }

        private bool IsNewCustomSession(int bar)
        {
            var candle = GetCandle(bar);

            var candleStart = candle.Time
                .AddHours(InstrumentInfo.TimeZone)
                .TimeOfDay;

            var candleEnd = candle.LastTime
                .AddHours(InstrumentInfo.TimeZone)
                .TimeOfDay;

            if (bar == 0)
            {
                if (_sessionBegin < _sessionEnd)
                {
                    return candleStart <= _sessionBegin && candleEnd >= _sessionEnd
                        || candleStart >= _sessionBegin && candleEnd <= _sessionEnd
                        || candleStart < _sessionBegin && candleEnd > _sessionBegin && candleEnd <= _sessionEnd;
                }

                return candleStart >= _sessionBegin || candleStart <= _sessionEnd;
            }

            var diff = InstrumentInfo.TimeZone;

            var prevCandle = GetCandle(bar - 1);
            var prevTime = prevCandle.LastTime.AddHours(diff);

            var time = candle.LastTime.AddHours(diff);

            if (_sessionBegin < _sessionEnd)
            {
                return time.TimeOfDay >= _sessionBegin && time.TimeOfDay <= _sessionEnd &&
                    !(prevTime.TimeOfDay >= _sessionBegin && prevTime.TimeOfDay <= _sessionEnd);
            }

            return time.TimeOfDay >= _sessionBegin && time.TimeOfDay >= _sessionEnd
                && !(prevTime.TimeOfDay >= _sessionBegin && prevTime.TimeOfDay >= _sessionEnd
                    ||
                    time.TimeOfDay <= _sessionBegin && time.TimeOfDay <= _sessionEnd)
                && !(prevTime.TimeOfDay <= _sessionBegin && prevTime.TimeOfDay <= _sessionEnd);
        }

        private bool isnewsession(int tf, int bar)
        {
            return (GetBeginTime(GetCandle(bar).Time, tf) - GetBeginTime(GetCandle(bar - 1).Time, tf)).TotalMinutes >= tf;
        }

        private DateTime GetBeginTime(DateTime tim, int period)
        {
            var tim2 = tim;
            tim2 = tim2.AddMilliseconds(-tim2.Millisecond);
            tim2 = tim2.AddSeconds(-tim2.Second);
            var begin = Convert.ToInt32((tim2 - new DateTime()).TotalMinutes % period);
            var res = tim2.AddMinutes(-begin).AddMilliseconds(-tim2.Millisecond).AddSeconds(-tim2.Second);
            return res;
        }

        #endregion
    }
}







Technical/PolarizedFractal.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Polarized Fractal Efficiency")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.PolarizedFractalDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602281")]
	public class PolarizedFractal : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 10 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly ValueDataSeries _sqrtSeries = new("SqrtSum");
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(2, 10000000)]
		public int ShortPeriod
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Smooth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription), Order = 110)]
		[Range(1, 10000000)]
		public int Smooth
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public PolarizedFractal()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_renderSeries.Clear();
				_sqrtSeries.Clear();
				return;
			}

			var squareDiff = (value - (decimal)SourceDataSeries[bar - 1]) * (value - (decimal)SourceDataSeries[bar - 1]);

			_sqrtSeries[bar] = (decimal)Math.Sqrt((double)squareDiff + 1);

			if (bar < _period)
				return;

			var squarePeriod = (value - (decimal)SourceDataSeries[bar - _period]) * (value - (decimal)SourceDataSeries[bar - _period]) + _period * _period;
			var sqrtPeriod = (decimal)Math.Sqrt((double)squarePeriod);

			var pfe = sqrtPeriod / _sqrtSeries.CalcSum(_period - 1, bar);

			if (value < (decimal)SourceDataSeries[bar - 1])
				pfe = -pfe;

			_renderSeries[bar] = 100 * _ema.Calculate(bar, pfe);
		}

		#endregion
	}
}









Technical/QQE.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("Qualitative Quantitative Estimation")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.QQEDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602629")]
	public class QQE : Indicator
	{
		#region Static and constants

		private const decimal QQEmultiplier = 4.236m;

		#endregion

		#region Fields

		private readonly EMA _emaAtrRsi = new();
		private readonly EMA _emaWilders = new();
		private readonly RSI _rsi = new() { Period = 14 };
		private readonly EMA _rsiEma = new() { Period = 5 };

		private readonly ValueDataSeries _rsiMa = new("RsiMaId", "RsiMa")
		{
			Color = DefaultColors.Navy.Convert(), 
			Width = 2,
            DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
        };

		private readonly ValueDataSeries _trLevelSlow = new("TrLevelSlow", "LevelSlow")
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.EMALineSettingsDescription)
        };

        private int _lastBar = -1;
        private bool _lastBarCounted;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RSI), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
        [Range(1, 10000)]
        public int RsiPeriod
        {
            get => _rsi.Period;
            set
            {
                _rsi.Period = value;
                _emaWilders.Period = value * 2 - 1;
                _emaAtrRsi.Period = value * 2 - 1;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SlowFactor), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription))]
        [Range(1, 10000)]
        public int SlowFactor
        {
            get => _rsiEma.Period;
            set
            {
                _rsiEma.Period = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription), Order = 0)]
		public bool UseAlerts { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 1)]
		public string AlertFile { get; set; } = "alert1";

		#endregion

		#region ctor

		public QQE()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			_emaWilders.Period = _emaAtrRsi.Period = _rsi.Period * 2 - 1;
			
			DataSeries[0] = _trLevelSlow;
			DataSeries.Add(_rsiMa);

			LineSeries.Add(new LineSeries("TargetLevelId", "TargetLevel")
			{
				Value = 50,
				Color = System.Drawing.Color.Aqua.Convert()
			});
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_lastBarCounted = false;
				return;
			}

			var candle = GetCandle(bar);

			var rsi = _rsi.Calculate(bar, candle.Close);
			var rsiMa = _rsiEma.Calculate(bar, rsi);
			var atrRsi = Math.Abs(_rsiEma[bar - 1] - rsiMa);
			var maAtrRsi = _emaWilders.Calculate(bar, atrRsi);

			if (_emaWilders.Period < SlowFactor && bar < SlowFactor
				|| _emaWilders.Period >= SlowFactor && bar < _emaWilders.Period)
				return;

			_trLevelSlow[bar] = _trLevelSlow[bar - 1];
			_rsiMa[bar] = rsiMa;

			var dar = _emaAtrRsi.Calculate(bar, maAtrRsi) * QQEmultiplier;

			var dv = _trLevelSlow[bar];

			if (rsiMa < _trLevelSlow[bar])
			{
				_trLevelSlow[bar] = rsiMa + dar;

				if (_rsiEma[bar - 1] < dv && _trLevelSlow[bar] > dv)
					_trLevelSlow[bar] = dv;
			}
			else if (rsiMa > _trLevelSlow[bar])
			{
				_trLevelSlow[bar] = rsiMa - dar;

				if (_rsiEma[bar - 1] > dv && _trLevelSlow[bar] < dv)
					_trLevelSlow[bar] = dv;
			}

			if (_lastBar != bar)
			{
				if (_lastBarCounted && UseAlerts)
				{
					if (_rsiMa[bar - 1] < LineSeries[0].Value && _rsiMa[bar - 2] > LineSeries[0].Value
						||
						_rsiMa[bar - 1] > LineSeries[0].Value && _rsiMa[bar - 2] < LineSeries[0].Value
					)
						AddAlert(AlertFile, "Target level is achieved");
				}

				_lastBar = bar;
			}
			else
			{
				if (!_lastBarCounted)
					_lastBarCounted = true;
			}
		}

		#endregion
	}
}







Technical/QStick.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Q Stick")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.QStickDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602451")]
	public class QStick : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _openCloseSeries = new("OpenClose");

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization) { UseMinimizedModeIfEnabled = true };
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public QStick()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			LineSeries.Add(new LineSeries("ZeroVal", Strings.ZeroValue)
			{
				Color = System.Drawing.Color.Gray.Convert(), 
				Value = 0, 
				Width = 2,
                DescriptionKey = nameof(Strings.ZeroLineDescription)
            });
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_openCloseSeries[bar] = candle.Close - candle.Open;

			if (bar < _period)
				return;

			_renderSeries[bar] = _openCloseSeries.CalcSum(_period, bar) / _period;
		}

		#endregion
	}
}








Indicators/Technical
/RMI.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Relative Momentum Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RMIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602456")]
	public class RMI : Indicator
	{
		#region Fields

		private readonly SMMA _downSma = new() { Period = 14 };

		private readonly ValueDataSeries _rmiSeries = new("RmiSeries", "RMI")
		{
			Color = DefaultColors.Blue.Convert(),
			Width = 2,
			ShowZeroValue = true
		};

		private readonly SMMA _upSma = new() { Period = 14 };

        private int _period = 3;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int RmiLength
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.SMAPeriod), Description = nameof(Strings.SMMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int RmiMaLength
		{
			get => _upSma.Period;
			set
			{
				_upSma.Period = value;
				_downSma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public RMI()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _rmiSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				_rmiSeries.Clear();

			var periodBar = Math.Max(bar - RmiLength, 0);
			var upSma = _upSma.Calculate(bar, Math.Max(value - (decimal)SourceDataSeries[periodBar], 0));

			var downSma = _downSma.Calculate(bar,
				Math.Abs(Math.Min(value - (decimal)SourceDataSeries[periodBar], 0)));

			var rmi = downSma == 0
				? 100
				: upSma == 0
					? 0
					: 100 - 100 / (1 + upSma / downSma);

			_rmiSeries[bar] = rmi;
		}

		#endregion
	}
}








Technical/RMO.cs






namespace ATAS.Indicators.Technical
{
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("Rahul Mohindar Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RMODescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602452")]
	public class RMO : Indicator
	{
        #region Fields

        private readonly EMA _emaSignal = new() { Period = 15 };
        private readonly EMA _emaSt1 = new() { Period = 10 };
        private readonly EMA _emaSt2 = new() { Period = 10 };

        private readonly ValueDataSeries _buySignal = new("BuySignal", Strings.Buys)
		{
			Color = DefaultColors.Green.Convert(),
			VisualType = VisualMode.UpArrow,
			ShowTooltip = false,
			ShowZeroValue = false,
            UseMinimizedModeIfEnabled = true,
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BuySignalSettingsDescription)
        };
        private readonly ValueDataSeries _emaSt1Series = new("EmaSt1Series", Strings.EmaPeriod1)
		{
			Color = DefaultColors.DarkRed.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			UseMinimizedModeIfEnabled = true,
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.EMALineSettingsDescription)
        };
        private readonly ValueDataSeries _emaSt2Series = new("EmaSt2Series", Strings.EmaPeriod2)
		{
			Color = DefaultColors.Green.Convert(),
			LineDashStyle = LineDashStyle.Dash,
            UseMinimizedModeIfEnabled = true,
            IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.EMALineSettingsDescription)
        };
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			Width = 2,
			UseMinimizedModeIfEnabled = true,
			DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
		};
        private readonly ValueDataSeries _sellSignal = new("SellSignal", Strings.Sells)
        {
	        Color = DefaultColors.Red.Convert(),
	        VisualType = VisualMode.DownArrow,
	        ShowTooltip = false,
	        ShowZeroValue = false,
	        UseMinimizedModeIfEnabled = true,
	        IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.SellSignalSettingsDescription)
        };

        private readonly Highest _highest = new() { Period = 10 };
		private readonly Lowest _lowest = new() { Period = 10 };

		private readonly List<SMA> _smaTen = new();
        private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA), GroupName = nameof(Strings.Period), Description = nameof(Strings.SMAPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				_smaTen.ForEach(x => x.Period = value);
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLow), GroupName = nameof(Strings.Period), Description = nameof(Strings.HighestLowestPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int HighLow
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA), GroupName = nameof(Strings.Period), Description = nameof(Strings.EMAPeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int EmaPeriod1
		{
			get => _emaSt1.Period;
			set
			{
				_emaSt1.Period = _emaSt2.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SignalPeriod), GroupName = nameof(Strings.Period), Description = nameof(Strings.SignalPeriodDescription), Order = 130)]
		[Range(1, 10000)]
        public int SignalPeriod
		{
			get => _emaSignal.Period;
			set
			{
				_emaSignal.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public RMO()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			for (var i = 0; i < 10; i++)
			{
				_smaTen.Add(new SMA
					{ Period = _period });
			}
			
			DataSeries[0] = _renderSeries;
			DataSeries.Add(_buySignal);
			DataSeries.Add(_sellSignal);
			DataSeries.Add(_emaSt1Series);
			DataSeries.Add(_emaSt2Series);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				DataSeries.ForEach(x => x.Clear());

			_smaTen[0].Calculate(bar, value);

			for (var i = 1; i < _smaTen.Count; i++)
				_smaTen[i].Calculate(bar, _smaTen[i - 1][bar]);

			var swingTrade = 0m;

			if (_highest.Calculate(bar, value) != _lowest.Calculate(bar, value))
			{
				var smaSum = _smaTen.Sum(x => x[bar]);
				swingTrade = 100 * (value - smaSum / 10) / (_highest[bar] - _lowest[bar]);
			}

			_emaSt1Series[bar] = _emaSt1.Calculate(bar, swingTrade);
			_emaSt2Series[bar] = _emaSt2.Calculate(bar, _emaSt1[bar]);

			_renderSeries[bar] = _emaSignal.Calculate(bar, swingTrade);

			if (bar == 0)
				return;

			if (_emaSt2[bar - 1] < _emaSt1[bar - 1] && _emaSt2[bar] > _emaSt1[bar])
				_buySignal[bar] = _renderSeries[bar];

			if (_emaSt2[bar - 1] > _emaSt1[bar - 1] && _emaSt2[bar] < _emaSt1[bar])
				_sellSignal[bar] = _renderSeries[bar];
		}

		#endregion
	}
}







Technical/ROC.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Rate of Change")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ROCDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602454")]
	public class ROC : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Percent))]
			Percent,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Ticks
		}

		#endregion

		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
			UseMinimizedModeIfEnabled = true
		};
		private Mode _calcMode = Mode.Percent;
        private decimal _multiplier = 100;
        private int _period = 10;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 90)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription), Order = 110)]
		[Range(0.0000001, 10000000000)]
		public decimal Multiplier
		{
			get => _multiplier;
			set
			{
				_multiplier = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ROC()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var calcBar = Math.Max(0, bar - _period);
			var roc = 0m;

			switch (_calcMode)
			{
				case Mode.Percent:
					if ((decimal)SourceDataSeries[calcBar] != 0)
						roc = _multiplier * (value - (decimal)SourceDataSeries[calcBar]) / (decimal)SourceDataSeries[calcBar];
					break;
				case Mode.Ticks:
					roc = (value - (decimal)SourceDataSeries[calcBar]) / InstrumentInfo.TickSize;
					break;
			}

			_renderSeries[bar] = roc;
		}

		#endregion
	}
}








Indicators/Technical
/RSI.cs





namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;
	
    [DisplayName("RSI")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RSIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602531")]
	public class RSI : Indicator
	{
		#region Fields

		private readonly CrossColor _black = System.Drawing.Color.Black.Convert();
		private readonly SMMA _negative = new() { Period = 10 };
        private readonly SMMA _positive = new() { Period = 10 };

        private LineSeries _upLine = new("UpLine", "Up")
        {
            Color = System.Drawing.Color.Orange.Convert(),
            LineDashStyle = LineDashStyle.Dash,
            Value = 70,
            Width = 1,
            DescriptionKey = nameof(Strings.OverboughtLimitDescription)
        };

        private LineSeries _downLine = new("DownLine", "Down")
		{
			Color = System.Drawing.Color.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 30,
			Width = 1,
            DescriptionKey = nameof(Strings.OversoldLimitDescription)
        };

		private int _lastDownAlert;

		private int _lastUpAlert;
		private decimal _lastValue;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]	
		public int Period
		{
			get => _positive.Period;
			set
			{
				_positive.Period = _negative.Period = value;
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings),
           Name = nameof(Strings.UpAlert),
           GroupName = nameof(Strings.Alerts),
           Description = nameof(Strings.UpAlertFileFilterDescription),
           Order = 100)]
        public FilterString UpAlertFilter { get; set; }

        [Display(ResourceType = typeof(Strings),
          Name = nameof(Strings.DownAlert),
          GroupName = nameof(Strings.Alerts),
          Description = nameof(Strings.DownAlertFileFilterDescription),
          Order = 110)]
        public FilterString DownAlertFilter { get; set; }

        #region Hidden

        [Browsable(false)]
		[Obsolete]
		public bool UseUpAlert 
		{
			get => UpAlertFilter.Enabled;
			set => UpAlertFilter.Enabled = value;
        }

        [Browsable(false)]
        [Obsolete]
        public string UpAlertFile
		{
            get => UpAlertFilter.Value;
            set => UpAlertFilter.Value = value;
        }

        [Browsable(false)]
        [Obsolete]
        public bool UseDownAlert 
		{
            get => DownAlertFilter.Enabled;
            set => DownAlertFilter.Enabled = value;
        }

        [Browsable(false)]
        [Obsolete]
        public string DownAlertFile 
		{
            get => DownAlertFilter.Value;
            set => DownAlertFilter.Value = value;
        }

        #endregion

        #endregion

        #region ctor

        public RSI()
		{
			Panel = IndicatorDataProvider.NewPanel;

			LineSeries.Add(_downLine);
			LineSeries.Add(_upLine);

			UpAlertFilter = new(true) { Value = "alert1" };
            DownAlertFilter = new(true) { Value = "alert1" };
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				this[bar] = 0;
				_lastUpAlert = _lastDownAlert = 0;
				return;
			}

			var diff = (decimal)SourceDataSeries[bar] - (decimal)SourceDataSeries[bar - 1];
			var pos = _positive.Calculate(bar, diff > 0 ? diff : 0);
			var neg = _negative.Calculate(bar, diff < 0 ? -diff : 0);

			if (neg != 0)
			{
				var div = pos / neg;

				this[bar] = div == 1
					? 0m
					: 100m - 100m / (1m + div);
			}
			else
				this[bar] = 100m;

			if (bar == CurrentBar - 1 && _lastValue != 0)
			{
				if (UpAlertFilter.Enabled)
				{
					if ((_lastValue < _upLine.Value && this[bar] >= _upLine.Value || _lastValue > _upLine.Value && this[bar] <= _upLine.Value)
						&& _lastUpAlert != bar)
					{
						AddAlert(UpAlertFilter.Value, InstrumentInfo.Instrument, $"Up value alert {this[bar]:0.#####}", _black, _upLine.Color);
						_lastUpAlert = bar;
					}
				}

				if (DownAlertFilter.Enabled)
				{
					if ((_lastValue < _downLine.Value && this[bar] >= _downLine.Value || _lastValue > _downLine.Value && this[bar] <= _downLine.Value)
					    && _lastDownAlert != bar)
					{
						AddAlert(DownAlertFilter.Value, InstrumentInfo.Instrument, $"Down value alert {this[bar]:0.#####}", _black, _downLine.Color);
						_lastDownAlert = bar;
					}
				}
			}

			_lastValue = this[bar];
		}

		#endregion
	}
}







Technical/RVI.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("RVI V1")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RVI1Description))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602461")]
	public class RVI : Indicator
	{
		#region ctor

		public RVI()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Green.Convert();
			((ValueDataSeries)DataSeries[0]).DescriptionKey = nameof(Strings.BaseLineSettingsDescription);

            DataSeries.Add(new ValueDataSeries("SignalId", "Signal")
			{
				VisualType = VisualMode.Line,
				IgnoredByAlerts = true,
                DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
            });
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar > 3)
			{
				var c0 = GetCandle(bar - 3);
				var c1 = GetCandle(bar - 2);
				var c2 = GetCandle(bar - 1);
				var c3 = GetCandle(bar - 0);

				var valueNum = (c0.Close - c0.Open + 2 * (c1.Close - c1.Open) + 2 * (c2.Close - c2.Open) + (c3.Close - c3.Open)) / 6m;
				var valueDenum = (c0.High - c0.Low + 2 * (c1.High - c1.Low) + 2 * (c2.High - c2.Low) + (c3.High - c3.Low)) / 6m;

				DataSeries[0][bar] = valueDenum != 0 ? valueNum / valueDenum : valueNum;
				DataSeries[1][bar] = (this[bar - 3] + 2 * this[bar - 2] + 2 * this[bar - 1] + this[bar]) / 6m;
			}
			else
			{
				DataSeries[0][bar] = 0m;
				DataSeries[1][bar] = 0m;
			}
		}

		#endregion
	}
}









Technical/RVI2.cs








namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("RVI V2")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RVI2Description))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602642")]
	public class RVI2 : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _rviSignal = new("RviSignal", Strings.RVI) 
		{ 
			DescriptionKey = nameof(Strings.BaseLineSettingsDescription) 
		};

		private readonly ValueDataSeries _rviValues = new("RviValues", Strings.Signal) 
		{
			Color = DefaultColors.Green.Convert(), 
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
        };

		private readonly SMA _smaHighLow = new() { Period = 10 };
		private readonly SMA _smaOpenClose = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
		[Range(1,10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _smaOpenClose.Period;
			set
			{
				_smaOpenClose.Period = _smaHighLow.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public RVI2()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			DataSeries[0] = _rviSignal;
			DataSeries.Add(_rviValues);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			DataSeries.ForEach(x => x.Clear());
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar < 3)
			{
				_smaHighLow.Calculate(bar, 0);
				_smaOpenClose.Calculate(bar, 0);
				return;
			}

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);
			var prev2Candle = GetCandle(bar - 2);
			var prev3Candle = GetCandle(bar - 3);

			var closeOpen = (prev3Candle.Close - prev3Candle.Open +
				2 * (prev2Candle.Close - prev2Candle.Open) +
				2 * (prevCandle.Close - prevCandle.Open) +
				candle.Close - candle.Open) / 6m;

			var highLow = (prev3Candle.High - prev3Candle.Low +
				2 * (prev2Candle.High - prev2Candle.Low) +
				2 * (prevCandle.High - prevCandle.Low) +
				candle.High - candle.Low) / 6m;

			_rviValues[bar] = _smaOpenClose.Calculate(bar, closeOpen) / _smaHighLow.Calculate(bar, highLow);

			_rviSignal[bar] = (_rviValues[bar - 3] + 2 * _rviValues[bar - 2] + 2 * _rviValues[bar - 1] + _rviValues[bar]) / 6m;
		}

		#endregion
	}
}









Technical/RWI.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Random Walk Indicator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RWIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602453")]
	public class RWI : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _highSeries = new("HighSeries", Strings.Highest) 
		{ 
			Color = DefaultColors.Green.Convert(),
            DescriptionKey = nameof(Strings.UpTrendSettingsDescription)
        };

		private readonly ValueDataSeries _lowSeries = new("LowSeries", Strings.Lowest)
		{
			DescriptionKey = nameof(Strings.DownTrendSettingsDescription)
		};

		private readonly TrueRange _trueRange = new();
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public RWI()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			Add(_trueRange);

			DataSeries[0] = _lowSeries;
			DataSeries.Add(_highSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				return;
			}

			if (bar < _period)
				return;

			var maxHigh = 0m;
			var maxLow = 0m;
			var candle = GetCandle(bar);

			for (var i = 1; i <= _period; i++)
			{
				var stepCandle = GetCandle(bar - i);
				var atr = Atr(bar - 1, i);
				var high = atr == 0 ? 0 : (candle.High - stepCandle.Low) / (atr * (decimal)Math.Sqrt(i));
				var low = atr == 0 ? 0 : (stepCandle.High - candle.Low) / (atr * (decimal)Math.Sqrt(i));

				if (high > maxHigh)
					maxHigh = high;

				if (low > maxLow)
					maxLow = low;
			}

			_highSeries[bar] = maxHigh;
			_lowSeries[bar] = maxLow;
		}

		#endregion

		#region Private methods

		private decimal Atr(int bar, int period)
		{
			return ((ValueDataSeries)_trueRange.DataSeries[0]).CalcAverage(period, bar);
		}

		#endregion
	}
}







Technical/Ratio.cs







namespace ATAS.Indicators.Technical
{
	using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Ratio")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RatioDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602282")]
	public class Ratio : Indicator
	{
		#region Nested types

		private class RatioSign
		{
			#region Fields

			public readonly int Bar;
			public readonly int Direction;
			public readonly decimal Price;
			public readonly decimal Ratio;

			#endregion

			#region ctor

			public RatioSign(int bar, int direction, decimal ratio, decimal price)
			{
				Bar = bar;
				Direction = direction;
				Ratio = ratio;
				Price = price;
			}

			#endregion
		}

		#endregion

		#region Static and constants

		public const int Call = 1;
		public const int Put = -1;
		public const int Wait = 0;

		#endregion

		#region Fields
		
		private CrossColor _bgColor = DefaultColors.Yellow.Convert();
		private int _days = 20;
        private int _fontSize = 10;
        private CrossColor _highColor = DefaultColors.Blue.Convert();
		private CrossColor _lowColor = DefaultColors.Green.Convert();
		private decimal _lowRatio = 0.71m;
		private CrossColor _neutralColor = DefaultColors.Gray.Convert();
		private decimal _neutralRatio = 29m;
		private int _targetBar;
		public int CallPutCount;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.LowRatio), Description = nameof(Strings.LowRatioDescription), Order = 20)]
        public decimal LowRatio
        {
            get => _lowRatio;
            set
            {
                _lowRatio = value;
                ReDraw();
            }
        }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.NeutralRatio), Description = nameof(Strings.HighRatioDescription), Order = 21)]

        public decimal NeutralRatio
        {
            get => _neutralRatio;
            set
            {
                _neutralRatio = value;
                ReDraw();
            }
        }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        [Range(0, 1000)]
        public int Days
		{
			get => _days;
			set
			{
				if (value < 0)
					return;

				_days = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.LowColor), Description = nameof(Strings.LowRatioColorDescription), Order = 10)]
		public CrossColor LowColor
		{
			get => _lowColor;
			set
			{
				_lowColor = value;
				ReDraw();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.NeutralColor), Description = nameof(Strings.NeutralRatioColorDescription), Order = 11)]
		public CrossColor NeutralColor
		{
			get => _neutralColor;
			set
			{
				_neutralColor = value;
				ReDraw();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.HighColor), Description = nameof(Strings.HighRatioColorDescription), Order = 12)]
		public CrossColor HighColor
		{
			get => _highColor;
			set
			{
				_highColor = value;
				ReDraw();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.BackGround), Description = nameof(Strings.FillColorDescription), Order = 13)]
		public CrossColor BackgroundColor
		{
			get => _bgColor;
			set
			{
				_bgColor = value;
				ReDraw();
			}
		}

		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Colors), Name = nameof(Strings.FontSize), Description = nameof(Strings.FontSizeDescription), Order = 22)]
		[Range(1, 10000)]
        public int FontSize
		{
			get => _fontSize;
			set
			{
				_fontSize = value;
				ReDraw();
			}
		}

		#endregion

		#region ctor

		public Ratio()
			: base(true)
		{
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_targetBar = 0;

				if (_days <= 0)
					return;

				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}

				return;
			}

			if (bar < _targetBar)
				return;

			var rs = CaclulateRatio(bar);
			AddLabel(rs);
		}

		#endregion

		#region Private methods

		private void ReDraw()
		{
			try
			{
				foreach (var l in Labels)
				{
					decimal ratio = 0;

					if (l.Value.Text.Length > 0)
						ratio = Convert.ToDecimal(l.Value.Text);
					l.Value.AutoSize = _fontSize == 0;
					l.Value.FontSize = _fontSize;
					l.Value.XOffset = 0;
					l.Value.FontSize = FontSize;
					l.Value.FillColor = System.Drawing.Color.FromArgb(_bgColor.A, _bgColor.R, _bgColor.G, _bgColor.B);

					if (ratio <= _lowRatio)
						l.Value.Textcolor = System.Drawing.Color.FromArgb(_lowColor.A, _lowColor.R, _lowColor.G, _lowColor.B);
					else if (ratio <= _neutralRatio)
						l.Value.Textcolor = System.Drawing.Color.FromArgb(_neutralColor.A, _neutralColor.R, _neutralColor.G, _neutralColor.B);
					else
						l.Value.Textcolor = System.Drawing.Color.FromArgb(_highColor.A, _highColor.R, _highColor.G, _highColor.B);
				}
			}
			catch (Exception)
			{
			}
		}

		private RatioSign CaclulateRatio(int bar)
		{
			RatioSign rs;
			var candle = GetCandle(bar);

			if (candle.Open < candle.Close) // bullish
			{
				var lowBid = 0;
				var lowBid2 = 0;
				var volumeInfo = candle.GetPriceVolumeInfo(candle.Low);

				if (volumeInfo != null)
					lowBid = (int)volumeInfo.Bid;

				var volumeInfo2 = candle.GetPriceVolumeInfo(candle.Low + InstrumentInfo.TickSize);

				if (volumeInfo2 != null)
					lowBid2 = (int)volumeInfo2.Bid;
				decimal ratio = 0;

				if (lowBid > 0)
					ratio = (decimal)lowBid2 / lowBid;
				rs = new RatioSign(bar, Call, ratio, candle.Low - 4 * InstrumentInfo.TickSize);
			}
			else if (candle.Open > candle.Close) // bearish
			{
				var highAsk = 0;
				var highAsk2 = 0;

				var volumeInfo = candle.GetPriceVolumeInfo(candle.High);

				if (volumeInfo != null)
					highAsk = (int)volumeInfo.Ask;

				var volumeInfo2 = candle.GetPriceVolumeInfo(candle.High - InstrumentInfo.TickSize);

				if (volumeInfo2 != null)
					highAsk2 = (int)volumeInfo2.Ask;
				decimal ratio = 0;

				if (highAsk > 0)
					ratio = (decimal)highAsk2 / highAsk;
				rs = new RatioSign(bar, Put, ratio, candle.High + 2 * InstrumentInfo.TickSize);
			}
			else
				rs = new RatioSign(bar, 0, 0, 0);

			return rs;
		}

		private void AddLabel(RatioSign rs)
		{
			var bg = System.Drawing.Color.FromArgb(_bgColor.A, _bgColor.R, _bgColor.G, _bgColor.B);
			var price = rs.Price;
			var labelName = "BAR_" + rs.Bar;

			if (Labels.Count > 0)
			{
				var lastLabel = Labels.Last();

				if (lastLabel.Key.Equals(labelName))
					Labels.Remove(lastLabel.Key);
			}

			var sRatio = rs.Ratio.ToString("N2");
			sRatio = sRatio.Replace(",00", "");

			if (rs.Direction == Call)
			{
				if (rs.Ratio <= _lowRatio)
				{
					AddText(labelName, sRatio, true, rs.Bar, price, 0, 0,
						System.Drawing.Color.FromArgb(_lowColor.A, _lowColor.R, _lowColor.G, _lowColor.B), System.Drawing.Color.Transparent, bg, _fontSize,
						DrawingText.TextAlign.Center, _fontSize == 0);
				}
				else if (rs.Ratio <= _neutralRatio)
				{
					AddText(labelName, sRatio, true, rs.Bar, price, 0, 0,
						System.Drawing.Color.FromArgb(_neutralColor.A, _neutralColor.R, _neutralColor.G, _neutralColor.B)
						, System.Drawing.Color.Transparent, bg, _fontSize,
						DrawingText.TextAlign.Center, _fontSize == 0);
				}
				else
				{
					AddText(labelName, sRatio, true, rs.Bar, price, 0, 0,
						System.Drawing.Color.FromArgb(_highColor.A, _highColor.R, _highColor.G, _highColor.B)
						, System.Drawing.Color.Transparent, bg, _fontSize,
						DrawingText.TextAlign.Center, _fontSize == 0);
				}
			}
			else if (rs.Direction == Put)
			{
				if (rs.Ratio <= _lowRatio)
				{
					AddText(labelName, sRatio, true, rs.Bar, price, 0, 0,
						System.Drawing.Color.FromArgb(_lowColor.A, _lowColor.R, _lowColor.G, _lowColor.B)
						, System.Drawing.Color.Transparent, bg, _fontSize, DrawingText.TextAlign.Center, _fontSize == 0);
				}
				else if (rs.Ratio <= _neutralRatio)
				{
					AddText(labelName, sRatio, true, rs.Bar, price, 0, 0,
						System.Drawing.Color.FromArgb(_neutralColor.A, _neutralColor.R, _neutralColor.G, _neutralColor.B)
						, System.Drawing.Color.Transparent, bg, _fontSize,
						DrawingText.TextAlign.Center, _fontSize == 0);
				}
				else
				{
					AddText(labelName, sRatio, true, rs.Bar, price, 0, 0,
						System.Drawing.Color.FromArgb(_highColor.A, _highColor.R, _highColor.G, _highColor.B)
						, System.Drawing.Color.Transparent, bg, _fontSize,
						DrawingText.TextAlign.Center, _fontSize == 0);
				}
			}
			else
			{
				AddText(labelName, "", true, rs.Bar, price, 0, 0,
					System.Drawing.Color.FromArgb(_lowColor.A, _lowColor.R, _lowColor.G, _lowColor.B)
					, System.Drawing.Color.Transparent, bg, _fontSize,
					DrawingText.TextAlign.Center, _fontSize == 0);
			}
		}

		#endregion
	}
}





Indicators/Technical
/RelativeVigorIndex.cs








namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Relative Vigor Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RVIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000619101")]
    public class RelativeVigorIndex : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _rviSeries = new("RviSeries", "RVI")
		{
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
		};

		private readonly ValueDataSeries _signalSeries = new("SignalSeries", Strings.Signal) 
		{ 
			Color = DefaultColors.Blue.Convert(),
            DescriptionKey = nameof(Strings.SignalLineSettingsDescription)
        };

		private readonly SMA _smaRvi = new() { Period = 4 };
		private readonly SMA _smaSig = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SignalPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _smaSig.Period;
			set
			{
				_smaSig.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int SmaPeriod
		{
			get => _smaRvi.Period;
			set
			{
				_smaRvi.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public RelativeVigorIndex()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _signalSeries;
			DataSeries.Add(_rviSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var rvi = 0m;

			if (candle.High - candle.Low != 0)
				rvi = (candle.Close - candle.Open) / (candle.High - candle.Low);

			_rviSeries[bar] = _smaRvi.Calculate(bar, rvi);

			_signalSeries[bar] =_smaSig.Calculate(bar, rvi);
		}

		#endregion
	}
}








Indicators/Technical
/RelativeVolume.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

using Color = System.Drawing.Color;

[DisplayName("Relative Volume")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.RelativeVolumeDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602457")]
public class RelativeVolume : Indicator
{
	#region Nested types

	private class AvgBar
	{
		#region Fields

		private readonly int _lookBack;

		private readonly Queue<decimal> _volume = new();

		#endregion

		#region Properties

		public decimal AvgValue { get; private set; }

		#endregion

		#region ctor

		public AvgBar(int lookBack)
		{
			_lookBack = lookBack;
		}

		#endregion

		#region Public methods

		public void Add(decimal volume)
		{
			_volume.Enqueue(volume);

			if (_volume.Count > _lookBack)
				_volume.Dequeue();

			AvgValue = Avg();
		}

		#endregion

		#region Private methods

		private decimal Avg()
		{
			if (_volume.Count == 0)
				return 0;

			decimal sum = 0;

			foreach (var vol in _volume)
				sum += vol;

			return sum / _volume.Count;
		}

		#endregion
	}

	#endregion

	#region Fields

	private readonly ValueDataSeries _averagePoints = new("AveragePointsId", "AveragePoints")
	{
		VisualType = VisualMode.Dots,
		Color = DefaultColors.Blue.Convert(),
		Width = 2,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
		IgnoredByAlerts = true,
		DescriptionKey = nameof(Strings.AverageVolumeSettingsDescription)
	};

	private readonly Dictionary<TimeSpan, AvgBar> _avgVolumes = new();

	private readonly ValueDataSeries _volumeSeries = new("VolumeSeries", Strings.Volume)
	{
		VisualType = VisualMode.Histogram,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
		ResetAlertsOnNewBar = true,
        DescriptionKey = nameof(Strings.VolumeSettingsDescription)
    };

	private bool _deltaColored;
	private bool _isSupportedTimeFrame;
	private int _lastBar = -1;
	private int _lookBack = 20;

	private Color _negColor = DefaultColors.Red;
	private Color _neutralColor = DefaultColors.Gray;
	private Color _posColor = DefaultColors.Green;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.AnalysisPeriod), Description = nameof(Strings.PeriodDescription))]
    public int LookBack
    {
        get => _lookBack;
        set
        {
            if (value <= 0)
                return;

            _lookBack = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 610)]
	public CrossColor PosColor
	{
		get => _posColor.Convert();
		set
		{
			_posColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 620)]
	public CrossColor NegColor
	{
		get => _negColor.Convert();
		set
		{
			_negColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Neutral), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NeutralValueDescription), Order = 630)]
	public CrossColor NeutralColor
	{
		get => _neutralColor.Convert();
		set
		{
			_neutralColor = value.Convert();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.DeltaColored), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.DeltaColoredDescription), Order = 640)]
	public bool DeltaColored
	{
		get => _deltaColored;
		set
		{
			_deltaColored = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public RelativeVolume()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = _volumeSeries;
		DataSeries.Add(_averagePoints);
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_isSupportedTimeFrame = ChartInfo.ChartType == "TimeFrame" || ChartInfo.ChartType == "Seconds";
			_avgVolumes.Clear();
			_lastBar = 0;
		}

		var candle = GetCandle(bar);

		if (_isSupportedTimeFrame && bar > _lastBar)
		{
			_lastBar = bar;

			var time = candle.Time.TimeOfDay;

			if (!_avgVolumes.TryGetValue(time, out var avgVolumes))
			{
				avgVolumes = new AvgBar(LookBack);
				_avgVolumes.Add(time, avgVolumes);
			}

			_averagePoints[bar] = avgVolumes.AvgValue;
			var previousCandle = GetCandle(bar - 1);

			if (_avgVolumes.TryGetValue(previousCandle.Time.TimeOfDay, out var prevavgVolumes))
				prevavgVolumes.Add(previousCandle.Volume);
		}

		_volumeSeries[bar] = candle.Volume;

		if (DeltaColored)
		{
			_volumeSeries.Colors[bar] = candle.Delta switch
			{
				> 0 => _posColor,
				< 0 => _negColor,
				_ => _neutralColor
			};
		}
		else
		{
			if (candle.Open < candle.Close)
				_volumeSeries.Colors[bar] = _posColor;
			else if (candle.Open > candle.Close)
				_volumeSeries.Colors[bar] = _negColor;
			else
				_volumeSeries.Colors[bar] = _neutralColor;
		}
	}

	#endregion
}








Technical/Repulse.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Repulse")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RepulseDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602283")]
	public class Repulse : Indicator
	{
		#region Fields

		private readonly EMA _emaHigh = new();
		private readonly EMA _emaLow = new();
		private readonly ValueDataSeries _highSeries = new("High");
		private readonly ValueDataSeries _lowSeries = new("Low");

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				_emaLow.Period = _emaHigh.Period = value * 5;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Repulse()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_highSeries[bar] = candle.High;
			_lowSeries[bar] = candle.Low;

			if (bar < Period)
			{
				var firstCandle = GetCandle(0);
				var max = _highSeries.MAX(bar, bar);
				var min = _lowSeries.MIN(bar, bar);

				var bull = 100 * (3 * candle.Close - 2 * min - firstCandle.Open) / candle.Close;
				var bear = 100 * (firstCandle.Open + 2 * max - 3 * candle.Close) / candle.Close;
				_emaHigh.Calculate(bar, bull);
				_emaLow.Calculate(bar, bear);
			}
			else
			{
				var firstCandle = GetCandle(bar - Period);
				var max = _highSeries.MAX(Period, bar);
				var min = _lowSeries.MIN(Period, bar);

				var bull = 100 * (3 * candle.Close - 2 * min - firstCandle.Open) / candle.Close;
				var bear = 100 * (firstCandle.Open + 2 * max - 3 * candle.Close) / candle.Close;
				_emaHigh.Calculate(bar, bull);
				_emaLow.Calculate(bar, bear);
			}

			_renderSeries[bar] = _emaHigh[bar] - _emaLow[bar];
		}

		#endregion
	}
}








Technical/RoundNr.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Globalization;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Settings;
	using OFT.Rendering.Tools;

	[DisplayName("Round Numbers")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.RoundNrDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602459")]
	public class RoundNr : Indicator
	{
		#region Fields

		private readonly RenderFont _renderFont = new("Arial", 10);
		private int _step = 100;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Step), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StepSizeInTicksDescription), Order = 100)]
		[Range(1, 1000000)]
		public int Step
		{
			get => _step;
			set
			{
				_step = value;
				RedrawChart();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PenSettingsDescription), Order = 110)]
		public PenSettings Pen { get; set; } = new()
			{ Color = DefaultColors.Red.Convert(), Width = 1 };

		#endregion

		#region ctor

		public RoundNr()
			: base(true)
		{
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Final);
			DataSeries[0].IsHidden = true;
		}

		#endregion

		#region Protected methods

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			var low = GetFirstValue(ChartInfo.PriceChartContainer.Low);
			var high = ChartInfo.PriceChartContainer.High;
			var levelHeight = ChartInfo.GetYByPrice(0) - ChartInfo.GetYByPrice(InstrumentInfo.TickSize * Step);
			var renderText = "TextCheck";
			var textHeight = context.MeasureString(renderText, _renderFont).Height;
			var isFreeSpace = levelHeight > textHeight;

			for (var i = low; i <= high; i += InstrumentInfo.TickSize * _step)
			{
				var y = ChartInfo.GetYByPrice(i, false);

				if (y > ChartInfo.Region.Height)
					continue;

				if (y < 0)
					break;

				context.DrawLine(Pen.RenderObject, 0, y, ChartInfo.Region.Width, y);

				if (isFreeSpace)
				{
					var textWidth = context.MeasureString(i.ToString(CultureInfo.InvariantCulture), _renderFont).Width;
					var rect = new Rectangle(ChartInfo.Region.Width - textWidth, y - textHeight, textWidth, textHeight);
					context.DrawString(i.ToString(CultureInfo.InvariantCulture), _renderFont, Pen.RenderObject.Color, rect);
				}
			}
		}

		protected override void OnCalculate(int bar, decimal value)
		{
		}

		#endregion

		#region Private methods

		private decimal GetFirstValue(decimal low)
		{
			var lowLines = low / (_step * InstrumentInfo.TickSize);

			if (lowLines % 1 == 0)
				return low;

			return Math.Truncate(lowLines) * _step * InstrumentInfo.TickSize;
		}

		#endregion
	}
}






Technical/SMA.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("SMA")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602468")]
	public class SMA : Indicator
	{
		#region Fields

		private int _lastBar = -1;
		private int _period = 10;
		private decimal _sum;
		private bool _onLine;
		private int _lastAlert;

		private ValueDataSeries _renderSeries = new("RenderSeries", "SMA");
		private System.Drawing.Color _bullishColor = DefaultColors.Green;
		private System.Drawing.Color _bearishColor = DefaultColors.Red;
		private bool _coloredDirection = true;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColoredDirection), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColoredDirectionDescription), Order = 200)]
		[Range(1, 10000)]
		public bool ColoredDirection
		{
			get => _coloredDirection;
			set
			{
				_coloredDirection = value;

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription), Order = 210)]
		public CrossColor BullishColor
		{
			get => _bullishColor.Convert();
			set
			{
				_bullishColor = value.Convert();
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription), Order = 220)]
		public CrossColor BearishColor
		{
			get => _bearishColor.Convert();
			set
			{
				_bearishColor = value.Convert();
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.UseAlertsDescription),
            Order = 300)]
		public bool UseAlerts { get; set; }


		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 310)]
		[Range(0, 100000)]
		public bool RepeatAlert { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 320)]
		[Range(0, 100000)]
		public int AlertSensitivity { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.AlertFileDescription),
            Order = 330)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 340)]
		public CrossColor FontColor { get; set; } = System.Drawing.Color.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.ApproximationAlert),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 350)]
		public CrossColor BackgroundColor { get; set; } = System.Drawing.Color.DimGray.Convert();

        #endregion

        #region ctor

        public SMA()
        {
            DataSeries[0] = _renderSeries;
        }

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_onLine = false;
				_sum = 0;
				_renderSeries[bar] = value;
				return;
			}

			if (bar != _lastBar)
			{
				_lastBar = bar;
				_sum += (decimal)SourceDataSeries[bar - 1];

				if (bar >= Period)
					_sum -= (decimal)SourceDataSeries[bar - Period];
			}

			var sum = _sum + value;
			_renderSeries[bar] = sum / Math.Min(Period, bar + 1);

			if (ColoredDirection)
			{
				_renderSeries.Colors[bar] = _renderSeries[bar] > _renderSeries[bar - 1]
					? _bullishColor
					: _bearishColor;
			}

			if (bar != CurrentBar - 1 || !UseAlerts)
				return;

			if (_lastAlert == bar && !RepeatAlert)
				return;

            var close = GetCandle(bar).Close;
			var onLine = Math.Abs(_renderSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivity;

			if (onLine && !_onLine)
			{
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"SMA approximation alert: {_renderSeries[bar]:0.#####}", BackgroundColor, FontColor);
				_lastAlert = bar;
			}

			_onLine = onLine;
		}

		#endregion
	}
}







Indicators/Technical
/SMMA.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("SMMA")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SMMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602532")]
	public class SMMA : Indicator
	{
		#region Fields

		private int _period = 10;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			this[bar] = bar == 0 
				? value 
				: this[bar] = (this[bar - 1] * (Period - 1) + value) / Period;
		}

		#endregion
	}
}








Technical/SPVO.cs







namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Simple Percentage Volume Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SPVODescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602263")]
	public class SPVO : Indicator
	{
		#region Fields

		private readonly SMA _longSma = new() { Period = 60 };
        private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private readonly SMA _shortSma = new() { Period = 20 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 100)]
		[Range(2, 10000)]
		public int ShortPeriod
		{
			get => _shortSma.Period;
			set
			{
				_shortSma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 110)]
       	[Range(2, 10000)]
        public int LongPeriod
		{
			get => _longSma.Period;
			set
			{
				_longSma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public SPVO() 
			:base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			LineSeries.Add(new LineSeries("Base", Strings.BaseLine)
			{
				Color = DefaultColors.Gray.Convert(),
				Value = 0,
				DescriptionKey = nameof(Strings.ZeroLineDescription)
			});

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var volume = GetCandle(bar).Volume;
			_shortSma.Calculate(bar, volume);
			_longSma.Calculate(bar, volume);

			if (bar == 0)
			{
				_renderSeries.Clear();
				return;
			}
			
			_renderSeries[bar] = _longSma[bar] != 0
				? 100 * (_shortSma[bar] - _longSma[bar]) / _longSma[bar]
				: _renderSeries[bar - 1];
		}

		#endregion
	}
}








Technical/SWWMA.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Sine-Wave Weighted Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SWWMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602467")]
	public class SWWMA : Indicator
	{
		#region Static and constants

		private const decimal _sinSum = 3.73205080757m;

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar < 5)
			{
				this[bar] = value;
				return;
			}

			var valueSum = 0m;

			for (var i = 1; i <= 5; i++)
				valueSum += (decimal)Math.Sin(i * Math.PI / 6.0) * (decimal)SourceDataSeries[bar - i];

			this[bar] = valueSum / _sinSum;
		}

		#endregion
	}
}









Technical/SZMA.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Simple Moving Average - Skip Zeros")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SZMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602237")]
	public class SZMA : Indicator
	{
		#region Fields

		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			var sum = 0m;
			var nonZeroValues = 0;

			for (var i = Math.Max(0, bar - _period); i <= bar; i++)
			{
				if ((decimal)SourceDataSeries[i] == 0)
					continue;

				sum += (decimal)SourceDataSeries[i];
				nonZeroValues++;
			}

			this[bar] = nonZeroValues != 0 
				? sum / nonZeroValues
				: 0;
		}

		#endregion
	}
}








Technical/SampleCustomViewIndicator.cs








namespace ATAS.Indicators.Technical;

using System.ComponentModel;

using ATAS.Indicators.Technical.Editors;

[DisplayName("Custom View")]
[Category(IndicatorCategories.Samples)]
[Editor(typeof(CustomView), typeof(CustomView))]
public class SampleCustomViewIndicator : Indicator
{
	#region Custom properties

	public string? StringValue { get; set; }

	public int NumberValue { get; set; }
	
	#endregion

	#region Overrides of BaseIndicator

	protected override void OnCalculate(int bar, decimal value)
	{
		
	}

	#endregion
}









Technical/SampleProperties.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.ObjectModel;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Net;
	using System.Security;

	using ATAS.Indicators.Technical.Editors;

	using Newtonsoft.Json;

	using OFT.Attributes.Editors;
	using OFT.Rendering.Heatmap;
	using OFT.Rendering.Settings;

	using static System.Environment;

    [DisplayName("Properties")]
	[Category(IndicatorCategories.Samples)]
	public class SampleProperties : Indicator, IPropertiesEditorOwner
	{
		#region Private fields

		private const string _managedCategoryCategoryName = "ManagedCategory";

		private bool              _activateProperties;
		private bool              _categoryManager;
		private IPropertiesEditor _propertiesEditor;
		private bool              _propertyManager;

		#endregion

		#region Properties

		[Display(Name = "Font", GroupName = "Examples")]
		public FontSetting Font { get; set; } = new();

		[Display(Name = "Pen", GroupName = "Examples")]
		public PenSettings Pen { get; set; } = new()
			{ Color = System.Drawing.Color.Red.Convert(), Width = 1 };

		[Display(Name = "Brush", GroupName = "Examples")]
		public BrushSettings Brush { get; set; } = new()
			{ StartColor = System.Drawing.Color.Red.Convert(), EndColor = System.Drawing.Color.Yellow.Convert(), UseEndColor = true };

		[Display(Name = "Heatmap", GroupName = "Examples")]
		public HeatmapTypes HeatmapType { get; set; }

		[Display(Name = "Filter Enum", GroupName = "Examples")]
		public Filter<FilterTypes> FilterType { get; set; } = new()
			{ Enabled = true };

		[Display(Name = "Filter Decimal", GroupName = "Examples")]
		[Range(-100, 100)]
		[DisplayFormat(DataFormatString = "##0.0##")]
		public Filter FilterDecimal { get; set; } = new();

		[Display(Name = "Filter Integer", GroupName = "Examples")]
		public FilterInt FilterInt { get; set; } = new();

		[Display(Name = "Filter Text", GroupName = "Examples")]
		[Mask(MaskTypes.Regular, "..-..")]
		public FilterString FilterText { get; set; } = new();

		[Display(Name = "Track Bar", GroupName = "Examples")]
		[NumericEditor(NumericEditorTypes.TrackBar, -100, 100)]
		public int TrackBar { get; set; }

		[Display(Name = "Enum", GroupName = "Examples")]
		public FilterTypes Enum { get; set; }

		[Display(Name = "Selector", GroupName = "Examples")]
		[ComboBoxEditor(typeof(EntitiesSource), DisplayMember = nameof(Entity.Name), ValueMember = nameof(Entity.Value))]
		public int? Selector { get; set; }

		[IsExpanded]
		[Display(Name = "Numbers", GroupName = "Examples")]
		[Range(0, 100)]
		[DisplayFormat(DataFormatString = "P")]
		[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
		public ObservableCollection<decimal> Numbers { get; set; } = new()
			{ 1.0m, 2.0m, 3.0m };

		[Display(Name = "Filters", GroupName = "Examples")]
		[DisplayFormat(DataFormatString = "F2")]
		[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
		public ObservableCollection<Filter> Filters { get; set; } = new();

		[IsExpanded]
		[Display(Name = "Colors", GroupName = "Examples")]
		[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
		public ObservableCollection<CrossColor> ColorsSource { get; set; } = new()
            {  System.Drawing.Color.Red.Convert(), System.Drawing.Color.Green.Convert(), System.Drawing.Color.Blue.Convert() };

		[Display(Name = "Ranges", GroupName = "Examples")]
		[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
		public ObservableCollection<Range> Ranges { get; set; } = new();

		[IsExpanded]
		[Display(Name = "Range", GroupName = "Examples")]
		public Range FilterRange { get; set; } = new()
			{ From = 0, To = 10 };

		[Display(Name = "Hot Key", GroupName = "Examples")]
		public CrossKey[] HotKeys { get; set; } = { CrossKey.V };

		[Display(Name = "Decimal", GroupName = "Examples")]
		[NumericEditor(0.0, 100.0, Step = 0.5, DisplayFormat = "F2")]
		public decimal Decimal { get; set; }

		[Display(Name = "Integer", GroupName = "Examples")]
		[Range(0, 100)]
		public int Integer { get; set; }

		[Display(Name = "Boolean", GroupName = "Examples")]
		public bool Boolean { get; set; }

		[Display(Name = "Time Span", GroupName = "Examples")]
		[Mask(MaskTypes.DateTimeAdvancingCaret, "HH:mm:ss")]
		public TimeSpan TimeSpan { get; set; } = new(1, 0, 0);

		[Display(Name = "Date", GroupName = "Examples")]
		[Mask(MaskTypes.DateTime, "dd.MM.yyyy")]
		public DateTime DateTime { get; set; } = new(2020, 01, 01);

		[Display(Name = "Time Zone", GroupName = "Examples")]
		public TimeZoneInfo TimeZone { get; set; } = TimeZoneInfo.Local;

		[Display(Name = "Password", GroupName = "Examples")]
		public SecureString Password { get; set; }

		[Display(Name = "IP-address", GroupName = "Examples")]
		public EndPoint IpAddress { get; set; }

		[Display(Name = "E-mail", GroupName = "Examples")]
		[RegularExpression(@"^([\w\.\-]+)@([\w\-]+)((\.(\w){2,3})+)$")]
		public string Email { get; set; }

		[Display(Name = "File", GroupName = "Examples")]
		[SelectFileEditor(SpecialFolder.MyDocuments, Filter = "Text files (*.txt)|*.txt", IsTextEditable = false)]
		public string File { get; set; }

		[Display(Name = "Files", GroupName = "Examples")]
		[SelectFileEditor(SpecialFolder.MyDocuments, Filter = "Text files (*.txt)|*.txt", IsTextEditable = false, Multiselect = true)]
		public string Files { get; set; }

		[Display(Name = "Directory", GroupName = "Examples")]
		[SelectDirectoryEditor(IsTextEditable = false, ShowNewFolderButton = true)]
		public string Directory { get; set; }

		[Browsable(false)]
		public int NoBrowsable { get; set; }

		[Display(Name = "Enable Properties", GroupName = "Activate properties")]
		public bool ActivateProperties
		{
			get => _activateProperties;
			set
			{
				_activateProperties = value;
				ActiveFilter1.Enabled = ActiveFilter2.Enabled = ActiveFilter3.Enabled = value;
			}
		}

		[Display(Name = "Number property", GroupName = "Activate properties")]
		public Filter ActiveFilter1 { get; set; } = new(false) { Value = 123.456m };

		[Display(Name = "Bool property", GroupName = "Activate properties")]
		public FilterBool ActiveFilter2 { get; set; } = new(false);

		[Display(Name = "String property", GroupName = "Activate properties")]
		public FilterString ActiveFilter3 { get; set; } = new(false) { Value = "1234abcd" };

		[IsExpanded]
		[Display(Name = "Custom class", GroupName = "Custom class properties")]
		public CustomClass CustomProperty { get; set; } = new();

		[Display(Name = "Expandable property", GroupName = "Custom class properties")]
		public CustomClass ExpandableProperty { get; set; } = new();
		
		[Display(Name = "Category", GroupName = "Management")]
		public bool CategoryManager
		{
			get => _categoryManager;
			set => SetProperty(ref _categoryManager, value, () => _propertiesEditor?.SetIsExpandedCategory(_managedCategoryCategoryName, value));
		}

		[Display(Name = "Property", GroupName = "Management")]
		public bool PropertyManager
		{
			get => _propertyManager;
			set => SetProperty(ref _propertyManager, value, () => _propertiesEditor?.SetIsExpandedProperty(nameof(ExpandableProperty), value));
		}

		[Display(Name = "Managed Property 1", GroupName = _managedCategoryCategoryName)]
		public int ManagedProperty1 { get; set; }

		[Display(Name = "Managed Property 2", GroupName = _managedCategoryCategoryName)]
		public int ManagetProperty2 { get; set; }

		#endregion

        #region ctor

        public SampleProperties()
			: base(true)
		{
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			Panel = IndicatorDataProvider.NewPanel;
		}

		#endregion

		#region Protected methods

		#region Overrides of BaseIndicator

		protected override void OnCalculate(int bar, decimal value)
		{
		}

		#endregion

		#endregion

		#region Nested classes

		public enum FilterTypes
		{
			[Display(Name = "Type 1")]
			Type1,

			[Display(Name = "Type 2")]
			Type2,

			[Display(Name = "Type 3")]
			Type3
		}

		public class Entity
		{
			#region Properties

			public int Value { get; set; }

			public string Name { get; set; }

			#endregion
		}


        [Editor(typeof(RangeEditor), typeof(RangeEditor))]
        public class Range : NotifyPropertyChangedBase
		{
			#region Properties

			public int From
			{
				get => _from;
				set => SetProperty(ref _from, value);
			}

			public int To
			{
				get => _to;
				set => SetProperty(ref _to, value);
			}

			#endregion

			#region Private fields

			private int _from;
			private int _to;

			#endregion
		}

		private class EntitiesSource : Collection<Entity>
		{
			#region ctor

			public EntitiesSource()
				: base(new[]
				{
					new Entity { Value = 1, Name = "Entity 1" },
					new Entity { Value = 2, Name = "Entity 2" },
					new Entity { Value = 3, Name = "Entity 3" },
					new Entity { Value = 4, Name = "Entity 4" },
					new Entity { Value = 5, Name = "Entity 5" }
				})
			{
			}

			#endregion
		}

		#endregion

		#region Implementation of IPropertiesEditorOwner

		[Browsable(false)]
		IPropertiesEditor IPropertiesEditorOwner.PropertiesEditor
		{
			get => _propertiesEditor;
			set
			{
				if(_propertiesEditor == value) 
					return;

				var oldValue = _propertiesEditor;
				_propertiesEditor = value;

				PropertiesEditorOnChanged(oldValue, value);
			}
		}

		private void PropertiesEditorOnChanged(IPropertiesEditor oldValue, IPropertiesEditor newValue)
		{
			//TODO: Add code when show in editor. Parameters oldValue or newValue may be null.

			newValue?.BeginInit();

			newValue?.SetIsExpandedCategory(_managedCategoryCategoryName, CategoryManager);
			newValue?.SetIsExpandedProperty(nameof(ExpandableProperty), PropertyManager);

			newValue?.EndInit();
		}

		#endregion
	}
	
    [Editor(typeof(SampleEditor), typeof(SampleEditor))]
    public class CustomClass
    {
	    [Display(Name = "Enum property")]
	    public PictureChoiceSample EnumProperty { get; set; }

	    [Display(Name = "Number property")]
		public decimal Number { get; set; } = 123.456m;

        [Display(Name = "String property")]
		public string Str { get; set; } = "abcd";

        [Display(Name = "Hotkey property")]
		public CrossKey[] Keys { get; set; } = { CrossKey.F };
		
		[Display(Name = "Font property")]
		public FontSetting Font { get; set; } = new();

		[Display(Name = "Color property")]
		public CrossColor ColorProperty { get; set; } = System.Drawing.Color.Aqua.Convert();
    }

	public enum PictureChoiceSample
	{
		[Display(Name = "Picture 1")]
		Picture1,

		[Display(Name = "Picture 2")]
		Picture2
    }
}








Technical/SchaffTrendCycle.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("Schaff Trend Cycle")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SchaffTrendCycleDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602464")]
	public class SchaffTrendCycle : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _f1Series = new("f1");
		private readonly ValueDataSeries _f2Series = new("f2");

		private readonly Highest _highestMacd = new() { Period = 10 };
		private readonly Highest _highestPf = new() { Period = 10 };
        private readonly EMA _longMa = new() { Period = 50 };
		private readonly Lowest _lowestMacd = new() { Period = 10 };
        private readonly Lowest _lowestPf = new() { Period = 10 };
		private readonly MACD _macd = new()
		{
			LongPeriod = 50,
			ShortPeriod = 23
		};
        private readonly ValueDataSeries _pffSeries = new("pff");
		private readonly ValueDataSeries _pfSeries = new("pf");
		private readonly EMA _shortMa = new() { Period = 23 };

		private int _lastBar = -1;

        private decimal _lastF1;
		private decimal _lastF2;
		private decimal _lastPf;
		private decimal _lastPff;
		private bool _drawLines = true;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), 
			GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
		[Range(1, 10000)]
		public int Period
		{
			get => _highestMacd.Period;
			set
			{
				_highestMacd.Period = value;
				_lowestMacd.Period = value;
				_highestPf.Period = value;
				_lowestPf.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod),
			GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription))]
		[Range(1, 10000)]
        public int ShortPeriod
		{
			get => _shortMa.Period;
			set
			{
				_shortMa.Period = value;
				_macd.ShortPeriod = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), 
			GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription))]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _longMa.Period;
			set
			{
				_longMa.Period = value;
				_macd.LongPeriod = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Show),
			GroupName = nameof(Strings.Line), Description = nameof(Strings.DrawLinesDescription),
            Order = 30)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if (LineSeries.Contains(UpLine))
						return;

					LineSeries.Add(UpLine);
					LineSeries.Add(DownLine);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Up),
			GroupName = nameof(Strings.Line), Description = nameof(Strings.OverboughtLimitDescription),
            Order = 30)]
		public LineSeries UpLine { get; set; } = new("UpLine", "Up")
		{
			Color = System.Drawing.Color.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 75,
			Width = 1,
			IsHidden = true
		};

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Down),
			GroupName = nameof(Strings.Line), Description = nameof(Strings.OversoldLimitDescription),
            Order = 30)]

		public LineSeries DownLine { get; set; } = new("DownLine", "Down")
		{
			Color = System.Drawing.Color.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 25,
			Width = 1,
			IsHidden = true
		};

        #endregion

        #region ctor

        public SchaffTrendCycle()
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			LineSeries.Add(UpLine);
			LineSeries.Add(DownLine);
			((ValueDataSeries)DataSeries[0]).Width = 2;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar != _lastBar && bar > 0)
			{
				_lastBar = bar;

				_lastF1 = _f1Series[bar - 1];
				_lastF2 = _f2Series[bar - 1];
				_lastPf = _pfSeries[bar - 1];
				_lastPff = _pffSeries[bar - 1];
			}

			var candle = GetCandle(bar);

			var macd = _macd.Calculate(bar, candle.Close);

			var v1 = _lowestMacd.Calculate(bar, macd);
			var v2 = _highestMacd.Calculate(bar, macd) - v1;

			_f1Series[bar] = v2 > 0
				? (macd - v1) / v2 * 100.0m
				: _lastF1;

			_pfSeries[bar] = _lastPf == 0
				? _f1Series[bar]
				: _lastPf + 0.5m * (_f1Series[bar] - _lastPf);

			var v3 = _lowestPf.Calculate(bar, _pfSeries[bar]);
			var v4 = _highestPf.Calculate(bar, _pfSeries[bar]) - v3;

			_f2Series[bar] = v4 > 0
				? (_pfSeries[bar] - v3) / v4 * 100m
				: _lastF2;

			_pffSeries[bar] = _lastPff == 0
				? _f2Series[bar]
				: _lastPff + 0.5m * (_f2Series[bar] - _lastPff);

			this[bar] = _pffSeries[bar];
		}

		#endregion
	}
}









Technical/SessionColor.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Drawing;
	using System.Reflection;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
	using OFT.Rendering.Tools;
	
    [Obfuscation(Feature = "renaming", ApplyToMembers = true, Exclude = true)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SessionColorIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602465")]
	[DisplayName("Session Color")]
	public class SessionColor : Indicator
	{
		#region Nested types

		private class Session
		{
			#region Properties

			public int FirstBar { get; }

			public int LastBar { get; private set; }

			private DateTime End { get; }

			private DateTime Start { get; }

			#endregion

			#region ctor

			public Session(DateTime start, DateTime end, int bar)
			{
				Start = start;
				End = end;
				FirstBar = LastBar = bar;
			}

			#endregion

			#region Public methods

			public bool TryAddCandle(int i, DateTime time)
			{
				if (time >= End)
					return false;

				if (time < Start)
					return false;

				if (i > LastBar)
					LastBar = i;

				return true;
			}

			#endregion
		}

		#endregion

		#region Fields

		private readonly List<Session> _sessions = new();
		private readonly object _syncRoot = new();

		private Color _areaColor = Color.FromArgb(63, 65, 105, 225);
		private Session _currentSession;
		private TimeSpan _endTime = new(12, 0, 0);
		private Color _fillBrush;
		private int _lastEndAlert;
		private int _lastSessionBar;

		private int _lastStartAlert;
		private TimeSpan _startTime;

		#endregion

		#region Properties

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ShowAboveChart),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.DrawAbovePriceDescription),
            Order = 10)]
		public bool ShowAboveChart
		{
			get => DrawAbovePrice;
			set => DrawAbovePrice = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ShowArea),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.FillAreaDescription),
            Order = 20)]
		public bool ShowArea { get; set; } = true;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AreaColor),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.AreaColorDescription),
            Order = 30)]
		public CrossColor AreaColor
		{
			get => _areaColor.Convert();
			set
			{
				_areaColor = value.Convert();
				_fillBrush = _areaColor;
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.StartTime),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.StartTimeDescription),
            Order = 40)]
		public TimeSpan StartTime
		{
			get => _startTime;
			set
			{
				_startTime = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.EndTime),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.EndTimeDescription),
            Order = 50)]
		public TimeSpan EndTime
		{
			get => _endTime;
			set
			{
				_endTime = value;
				RecalculateValues();
			}
		}

        [Display(ResourceType = typeof(Strings),
           Name = nameof(Strings.OpenSession),
           GroupName = nameof(Strings.Alerts),
           Description = nameof(Strings.OpenSessionAlertFilterDescription),
           Order = 10)]
        public FilterString OpenAlertFilter { get; set; }

        [Display(ResourceType = typeof(Strings),
        Name = nameof(Strings.ClosingSession),
        GroupName = nameof(Strings.Alerts),
        Description = nameof(Strings.CloseSessionAlertFilterDescription),
        Order = 20)]
        public FilterString CloseAlertFilter { get; set; }

        #region Hidden

        [Browsable(false)]
		[Obsolete]
		public bool UseOpenAlert
		{
			get => OpenAlertFilter.Enabled;
			set => OpenAlertFilter.Enabled = value;
        }

        [Browsable(false)]
        [Obsolete]
        public string AlertOpenFile
        {
            get => OpenAlertFilter.Value;
            set => OpenAlertFilter.Value = value;
        }

        [Browsable(false)]
        [Obsolete] 
		public bool UseCloseAlert
        {
            get => CloseAlertFilter.Enabled;
            set => CloseAlertFilter.Enabled = value;
        }

        [Browsable(false)]
        [Obsolete]
        public string AlertCloseFile
        {
            get => CloseAlertFilter.Value;
            set => CloseAlertFilter.Value = value;
        }

        #endregion

        #endregion

        #region ctor

        public SessionColor()
			: base(true)
		{
			DataSeries[0].IsHidden = true;
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

			DenyToChangePanel = true;
			EnableCustomDrawing = true;
			SubscribeToDrawingEvents(DrawingLayouts.Historical);

			OpenAlertFilter = new(true) { Value = "alert1" };
            CloseAlertFilter = new(true) { Value = "alert1" };
        }

		#endregion

		#region Public methods

		public override string ToString()
		{
			return "Session Color";
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			lock (_syncRoot)
			{
				if (bar == 0)
				{
					_sessions.Clear();
					_currentSession = null;
					_lastSessionBar = -1;
					_lastEndAlert = _lastStartAlert = -1;
				}
				var candle = GetCandle(bar);

				var diff = InstrumentInfo.TimeZone;
				var time = candle.Time.AddHours(diff);
				var lastTime = candle.LastTime.AddHours(diff);

				DateTime start;
				DateTime end;

				if (EndTime >= StartTime)
				{
					start = time.Date + StartTime;
					end = time.Date + EndTime;
				}
				else
				{
					start = bar > 0
						? time.Date + StartTime
						: time.Date.AddDays(-1) + StartTime;

					end = bar > 0
						? time.Date.AddDays(1) + EndTime
						: time.Date + EndTime;
				}

				if (_currentSession == null)
				{
					var startBar = StartSession(start, end, bar);

					if (startBar == -1)
						return;

					_currentSession = new Session(start, end, startBar);
					_sessions.Add(_currentSession);
					StartAlert(bar);
				}
				else
				{
					StartAlert(bar);

					var candleAdded = _currentSession.TryAddCandle(bar, time);

					if (_lastSessionBar != _currentSession.LastBar && lastTime >= end && !candleAdded)
					{
						if (CloseAlertFilter.Enabled && _lastEndAlert != bar && bar == CurrentBar - 1)
						{
							AddAlert(CloseAlertFilter.Value, InstrumentInfo.Instrument, "Session end", Color.Black.Convert(), Color.White.Convert());
							_lastEndAlert = bar;
						}

						_lastSessionBar = _currentSession.LastBar;
					}

					if (!candleAdded)
					{
						if (time < start && lastTime < start || time >= end)
							return;

						var startBar = StartSession(start, end, bar);

						if (_currentSession.FirstBar != startBar)
						{
							_currentSession = new Session(start, end, startBar);
							_sessions.Insert(0, _currentSession);
						}
					}
				}
			}
		}

		protected override void OnRender(RenderContext context, DrawingLayouts layout)
		{
			lock (_syncRoot)
			{
				var lastVisibleBar = LastVisibleBarNumber + 1;
				var firstVisibleBar = lastVisibleBar - VisibleBarsCount - 1;

				foreach (var session in _sessions)
				{
					if (session.FirstBar > lastVisibleBar)
						continue;

					if (session.LastBar < firstVisibleBar)
						return;

					var x = ChartInfo.GetXByBar(session.FirstBar);
					var x2 = ChartInfo.GetXByBar(session.LastBar + 1);

					if (x2 > ChartArea.Width)
						x2 = ChartArea.Width;

					if (ShowArea)
					{
						var rectangle = new Rectangle(x, 0, x2 - x, ChartArea.Height);
						context.FillRectangle(_fillBrush, rectangle);
					}
					else
					{
						var pen = new RenderPen(_areaColor, 2);
						context.DrawLine(pen, x, 0, x, ChartArea.Height);
						context.DrawLine(pen, x2, 0, x2, ChartArea.Height);
					}
				}
			}
		}

		#endregion

		#region Private methods

		private void StartAlert(int bar)
		{
			if (OpenAlertFilter.Enabled && _lastStartAlert != bar && bar == CurrentBar - 1 && bar == _currentSession.FirstBar)
			{
				AddAlert(OpenAlertFilter.Value, InstrumentInfo.Instrument, "Session start", Color.Black.Convert(), Color.White.Convert());
				_lastStartAlert = bar;
			}
		}

		private int StartSession(DateTime startTime, DateTime endTime, int bar)
		{
			var candle = GetCandle(bar);
			var timeZone = InstrumentInfo.TimeZone;

			var time = candle.Time.AddHours(timeZone);
			var lastTime = candle.LastTime.AddHours(timeZone);

			if (time <= endTime && (time >= startTime || lastTime >= startTime))
				return bar;

			for (var i = bar; i < CurrentBar; i++)
			{
				var searchCandle = GetCandle(i);

				if (searchCandle.Time.AddHours(timeZone) <= endTime && searchCandle.Time.AddHours(timeZone) >= startTime)
					return i;
			}

			return -1;
		}

		#endregion
	}
}









Technical/SpeedOfTape.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Context;
    using OFT.Rendering.Settings;

    using Color = System.Drawing.Color;
	
    [DisplayName("Speed of Tape")]
	[Category(IndicatorCategories.VolumeOrderFlow)]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SpeedOfTapeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602472")]
	public class SpeedOfTape : Indicator
	{
		#region Nested types

		[Serializable]
		public enum SpeedOfTapeType
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
			Volume,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Ticks,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Buys))]
			Buys,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Sells))]
			Sells,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Delta))]
			Delta
		}

		internal class Signal
		{
			internal int Bar { get; set; }
            internal decimal Price { get; set; }
            internal bool IsBullish { get; set; }
        }

		#endregion

		#region Fields

		private readonly ConcurrentBag<Signal> _signals = [];
		private readonly PaintbarsDataSeries _paintBars = new("PaintBars", "Paint bars") { IsHidden = true };

		private readonly SMA _sma = new()
			{ Name = "Filter line" };

		private readonly ValueDataSeries _smaSeries;
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", "Speed of tape")
		{
			ResetAlertsOnNewBar = true,
			VisualType = VisualMode.Histogram,
			Color = CrossColor.FromArgb(255, 0, 255, 255)
		};

		private bool _autoFilter = true;
		private int _lastAlertBar = -1;
		private int _sec = 15;
		private int _trades = 100;

		private SpeedOfTapeType _type = SpeedOfTapeType.Ticks;
		private Color _maxSpeedColor = DefaultColors.Yellow;

        #endregion

        #region Properties

        #region Filters

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AutoFilter), GroupName = nameof(Strings.Filters), Description = nameof(Strings.SpeedOfTapeAutoFilterDescription))]
		public bool AutoFilter
		{
			get => _autoFilter;
			set
			{
				_autoFilter = value;
				RecalculateValues();
			}
		}

        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AutoFilterPeriod), GroupName = nameof(Strings.Filters), Description = nameof(Strings.SMAPeriodDescription))]
		public int AutoFilterPeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFilterSec), GroupName = nameof(Strings.Filters), Description = nameof(Strings.MaxTimeFilterDescription))]
		public int Sec
		{
			get => _sec;
			set
			{
				_sec = Math.Max(1, value);
				RecalculateValues();
			}
		}

        [Range(0, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TradesFilter), GroupName = nameof(Strings.Filters), Description = nameof(Strings.TradesCountDescription))]
		public int Trades
		{
			get => _trades;
			set
			{
				_trades = Math.Max(1, value);
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Filters), Description = nameof(Strings.CalculationModeDescription))]
		public SpeedOfTapeType Type
		{
			get => _type;
			set
			{
				_type = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Alerts

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription))]
		public bool UseAlerts { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription))]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FontColor), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription))]
		public CrossColor AlertForeColor { get; set; } = CrossColor.FromArgb(255, 247, 249, 249);

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription))]
		public CrossColor AlertBgColor { get; set; } = CrossColor.FromArgb(255, 75, 72, 72);

        #endregion

        #region Visualization

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowPriceSelection), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.DrawLinesDescription))]
		public bool DrawLines { get; set; } = true;

        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Length), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LineLengthDescription))]
		public int BarsLength { get; set; } = 10;

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PositiveDelta), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PenSettingsDescription))]
		public PenSettings PosPen { get; set; } = new PenSettings() { Color = DefaultColors.Green.Convert() };

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.NegativeDelta), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PenSettingsDescription))]
		public PenSettings NegPen { get; set; } = new PenSettings() { Color = DefaultColors.Red.Convert() };

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FilterColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.FilterCandleColorDescription))]
        public Color MaxSpeedColor
        {
            get => _maxSpeedColor;
            set
            {
                _maxSpeedColor = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PaintBars), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PaintBarsDescription))]
        public bool PaintBars
        {
            get => _paintBars.Visible;
            set
            {
                _paintBars.Visible = value;
                RecalculateValues();
            }
        }


        #endregion

        #endregion

        #region ctor

        public SpeedOfTape()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DenyToChangePanel = true;
			SubscribeToDrawingEvents(DrawingLayouts.Final);
			EnableCustomDrawing = true;

			DataSeries[0] = _renderSeries;

			_sma.ColoredDirection = false;
            _smaSeries = (ValueDataSeries)_sma.DataSeries[0];
            _smaSeries.Id = "FilterLineDataSeries";
			_smaSeries.Name = "Filter line";
            _smaSeries.Width = 2;
			_smaSeries.Color = Color.LightBlue.Convert();
			_smaSeries.UseMinimizedModeIfEnabled = true;
			_smaSeries.IgnoredByAlerts = true;
			
			DataSeries.Add(_smaSeries);
			DataSeries.Add(_paintBars);

            PosPen.PropertyChanged += Pen_PropertyChanged;
            NegPen.PropertyChanged += Pen_PropertyChanged;
        }

        #endregion

        #region Protected methods

        protected override void OnApplyDefaultColors()
        {
	        if (ChartInfo is null)
		        return;

			PosPen.Color = ChartInfo.ColorsStore.UpCandleColor.Convert();
			NegPen.Color = ChartInfo.ColorsStore.DownCandleColor.Convert();
		}

        protected override void OnRecalculate()
        {
			_signals.Clear();
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			var j = bar;
			var pace = 0m;
			var currentCandle = GetCandle(bar);

			while (j >= 0)
			{
				var candle = GetCandle(j);
				var ts = currentCandle.Time - candle.Time;

				if (ts.TotalSeconds < Sec)
				{
					if (_type == SpeedOfTapeType.Volume)
						pace += candle.Volume;

					if (_type == SpeedOfTapeType.Ticks)
						pace += candle.Ticks;
					else if (_type == SpeedOfTapeType.Buys)
						pace += candle.Ask;
					else if (_type == SpeedOfTapeType.Sells)
						pace += candle.Bid;
					else if (_type == SpeedOfTapeType.Delta)
						pace += candle.Delta;
				}
				else
				{
					pace = pace * Sec / (decimal)ts.TotalSeconds;
					break;
				}

				j--;
			}

			_sma.Calculate(bar, pace * 1.5m);

			if (!AutoFilter)
				_smaSeries[bar] = Trades;
			
			_renderSeries[bar] = pace;

            if (Math.Abs(pace) > _smaSeries[bar])
            {
	            _renderSeries.Colors[bar] = _maxSpeedColor;
				_paintBars[bar] = _maxSpeedColor.Convert();

                var signal = _signals.LastOrDefault(s => s.Bar == bar) ?? new Signal() { Bar = bar };
                signal.Price = (currentCandle.High + currentCandle.Low) / 2;
                signal.IsBullish = currentCandle.Delta >= 0;
                _signals.Add(signal);

                if (UseAlerts && bar == CurrentBar - 1 && bar != _lastAlertBar)
				{
					AddAlert(AlertFile, InstrumentInfo.Instrument, $"Speed of tape is increased to {pace:0.####} value", AlertBgColor, AlertForeColor);
					_lastAlertBar = bar;
				}
			}
			else
			{
				_paintBars[bar] = null;
			}
		}

        protected override void OnRender(RenderContext context, DrawingLayouts layout)
        {
			if (ChartInfo is null) return;

			if (DrawLines) DrawSignalLines(context);
        }

        #endregion

        #region Private methods

        private void DrawSignalLines(RenderContext context)
        {
            foreach (var signal in _signals)
            {
                if (signal.Bar > LastVisibleBarNumber || (signal.Bar + BarsLength) < FirstVisibleBarNumber)
                    continue;

                if (signal.Price <= ChartInfo.PriceChartContainer.Low) continue;

                var x1 = ChartInfo.GetXByBar(signal.Bar);
                var y = ChartInfo.GetYByPrice(signal.Price, false);
                var x2 = Math.Min(ChartInfo.GetXByBar(signal.Bar + BarsLength), ChartInfo.Region.Width);
                var pen = signal.IsBullish ? PosPen : NegPen;

                context.DrawLine(pen.RenderObject, x1, y, x2, y);
            }
        }

        private void Pen_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
			if ((PenSettings)sender == PosPen && e.PropertyName == nameof(PosPen.Color))
				_sma.BullishColor = PosPen.Color;

            if ((PenSettings)sender == NegPen && e.PropertyName == nameof(PosPen.Color))
                _sma.BearishColor = NegPen.Color;
        }

        #endregion
    }
}








Technical/SpreadVolume.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

[DisplayName("Spread Volumes Indicator")]
[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.SpreadVolumeDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602630")]
public class SpreadVolume : Indicator
{
	#region Nested types

	private class SpreadIndicatorItem
	{
		#region Properties

		public decimal BidPrice { get; }

		public decimal AskPrice { get; }

		public decimal BidVol { get; set; }

		public decimal AskVol { get; set; }

		#endregion

		#region ctor

		public SpreadIndicatorItem(decimal bidPrice, decimal askPrice)
		{
			BidPrice = bidPrice;
			AskPrice = askPrice;
		}

		#endregion
	}

	#endregion

	#region Fields

	private readonly RenderFont _font = new("Arial", 10);
	private readonly List<SpreadIndicatorItem> _prints = new();
	private readonly object _syncRoot = new();

	private readonly RenderStringFormat _textFormat = new()
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center
	};

	private decimal _askPrice;
	private decimal _bidPrice;

	private Color _buyColor = Color.Green;
	private SpreadIndicatorItem _currentTrade;
	private CumulativeTrade _lastTrade;

	private int _offset = 1;
	private Color _sellColor = Color.Red;
	private int _spacing;
	private Color _textColor = Color.Black;
	private int _width = 20;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.BuySignalColorDescription), Order = 1)]
	public CrossColor BuyColor
	{
		get => _buyColor.Convert();
		set => _buyColor = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.SellSignalColorDescription), Order = 3)]
	public CrossColor SellColor
	{
		get => _sellColor.Convert();
		set => _sellColor = value.Convert();
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.LabelTextColorDescription), Order = 4)]
	public CrossColor TextColor
	{
		get => _textColor.Convert();
		set => _textColor = value.Convert();
	}

	[Range(0, int.MaxValue)]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Spacing), GroupName = nameof(Strings.Common), Description = nameof(Strings.SpaceBetweenLabelsDescription))]
	public int Spacing
	{
		get => _spacing;
		set
		{
			_spacing = value;
			RedrawChart();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Offset), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelOffsetXDescription))]
	public int Offset
	{
		get => _offset;
		set
		{
			_offset = value;
			RedrawChart();
		}
	}

    [Range(10, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Width), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelWidthDescription))]
	public int Width
	{
		get => _width;
		set
		{
			_width = value;
			RedrawChart();
		}
	}

	#endregion

	#region ctor

	public SpreadVolume()
		: base(true)
	{
		DenyToChangePanel = true;
		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

		EnableCustomDrawing = true;
		DrawAbovePrice = true;
		SubscribeToDrawingEvents(DrawingLayouts.LatestBar);
	}

    #endregion

    #region Protected methods

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo is null)
		    return;

	    BuyColor = ChartInfo.ColorsStore.FootprintAskColor.Convert();
	    SellColor = ChartInfo.ColorsStore.FootprintBidColor.Convert();
		TextColor = ChartInfo.ColorsStore.FootprintMaximumVolumeTextColor.Convert();
    }

    protected override void OnCumulativeTrade(CumulativeTrade trade)
	{
		if (trade.Direction == TradeDirection.Between)
			return;

		_lastTrade = trade;

		if (trade.PreviousAsk.Price != _askPrice || trade.PreviousBid.Price != _bidPrice || _currentTrade == null)
		{
			_askPrice = trade.PreviousAsk.Price;
			_bidPrice = trade.PreviousBid.Price;
			_currentTrade = new SpreadIndicatorItem(_bidPrice, _askPrice);

			lock (_syncRoot)
			{
				_prints.Add(_currentTrade);

				if (_prints.Count > 200)
					_prints.RemoveRange(0, 100);
			}
		}

		if (trade.Direction == TradeDirection.Buy)
			_currentTrade.AskVol += trade.Volume;
		else if (trade.Direction == TradeDirection.Sell)
			_currentTrade.BidVol += trade.Volume;
	}

	protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
	{
		if (_currentTrade == null || _lastTrade == null)
			return;

		var diff = trade.Volume - _lastTrade.Volume;

		if (diff <= 0)
			return;

		if (trade.Direction == TradeDirection.Buy)
			_currentTrade.AskVol += diff;
		else if (trade.Direction == TradeDirection.Sell)
			_currentTrade.BidVol += diff;

		_lastTrade = trade;
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		var j = -1;
		var firstBarX = ChartInfo.PriceChartContainer.GetXByBar(CurrentBar - 1);

		lock (_syncRoot)
		{
			for (var i = _prints.Count - 1; i >= 0; i--)
			{
				j++;
				var trade = _prints[i];

				var x = firstBarX - j * (Spacing + Width) - Offset;

				if (x < 0)
					return;

				var y1 = ChartInfo.PriceChartContainer.GetYByPrice(trade.AskPrice, true);
				var h = y1 - ChartInfo.PriceChartContainer.GetYByPrice(trade.AskPrice + InstrumentInfo.TickSize, true);

				if (h == 0)
					continue;

				var y2 = ChartInfo.PriceChartContainer.GetYByPrice(trade.BidPrice, true);

				var rect1 = new Rectangle(x, y1, Width, h);
				var rect2 = new Rectangle(x, y2, Width, h);

				if (trade.AskVol != 0)
				{
					context.FillRectangle(_buyColor, rect1);
					context.DrawString(trade.AskVol.ToString(), _font, _textColor, rect1, _textFormat);
				}

				if (trade.BidVol != 0)
				{
					context.FillRectangle(_sellColor, rect2);
					context.DrawString(trade.BidVol.ToString(), _font, _textColor, rect2, _textFormat);
				}
			}
		}
	}

	protected override void OnCalculate(int bar, decimal value)
	{
	}

	#endregion
}







Technical/SqueezeMomentum.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using Color = System.Drawing.Color;

    [DisplayName("Squeeze Momentum")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SqueezeMomentumDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602637")]
	public class SqueezeMomentum : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _dotsSeries = new("DotsSeries", "Dots")
		{
			Color = Color.Gray.Convert(),
			VisualType = VisualMode.Dots,
			Width = 2,
			Digits = 6,
			ShowTooltip = false,
			ShowZeroValue = true,
			UseMinimizedModeIfEnabled = true,
			IsHidden = true,
			IgnoredByAlerts = true
		};
		
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Values)
		{
			VisualType = VisualMode.Histogram,
            Digits = 6,
            ShowZeroValue = false,
            UseMinimizedModeIfEnabled = true
		};

        private readonly Highest _highest = new() { Period = 20 };
        private readonly LinearReg _linRegr = new() { Period = 20 };
        private readonly Lowest _lowest = new() { Period = 20 };
		private readonly SMA _smaBb = new() { Period = 20 };
		private readonly SMA _smaKc = new() { Period = 20 };
		private readonly SMA _smaKcRange = new() { Period = 20 };
		private readonly StdDev _stdDev = new() { Period = 20 };
		
		private decimal _bbMultFactor = 2.0m;
        private decimal _kcMultFactor = 1.5m;
        private bool _useTrueRange;
        private Color _upperColor = DefaultColors.Lime;
        private Color _upColor = DefaultColors.Green;
        private Color _lowColor = DefaultColors.DarkRed;
        private Color _lowerColor = DefaultColors.Red;
        private Color _nullColor = DefaultColors.Blue;
        private Color _falseColor = DefaultColors.Gray;
        private Color _trueColor = Color.Black;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
        [Range(1, 10000)]
        public int BBPeriod
        {
            get => _smaBb.Period;
            set
            {
                _smaBb.Period = value;
                _stdDev.Period = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBMultFactor), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription))]
        [Range(1, 10000)]
        public decimal BBMultFactor
        {
            get => _bbMultFactor;
            set
            {
                _bbMultFactor = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.KCPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
        [Range(1, 10000)]
        public int KCPeriod
        {
            get => _smaKc.Period;
            set
            {
                _smaKc.Period = value;
                _smaKcRange.Period = value;
                _linRegr.Period = value;
                _highest.Period = value;
                _lowest.Period = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.KCMultFactor), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription))]
        [Range(0.00000001, 100000000)]
        public decimal KCMultFactor
        {
            get => _kcMultFactor;
            set
            {
                _kcMultFactor = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseTrueRangeKc), GroupName = nameof(Strings.Settings), Description = nameof(Strings.UseTrueRangeDescription))]
        public bool UseTrueRange
        {
            get => _useTrueRange;
            set
            {
                _useTrueRange = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Upper), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.UpperPositiveValueColorDescription), Order = 610)]
        public CrossColor UpperColor
        {
	        get => _upperColor.Convert();
	        set
	        {
		        _upperColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription), Order = 620)]
        public CrossColor UpColor
        {
	        get => _upColor.Convert();
	        set
	        {
		        _upColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription), Order = 630)]
        public CrossColor LowColor
        {
	        get => _lowColor.Convert();
	        set
	        {
		        _lowColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Lower), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LowerNegativeValueColorDescription), Order = 640)]
        public CrossColor LowerColor
        {
	        get => _lowerColor.Convert();
	        set
	        {
		        _lowerColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(Name = "Dots True", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 650)]
        public CrossColor TrueColor
        {
	        get => _trueColor.Convert();
	        set
	        {
                _trueColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(Name = "Dots False", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 660)]
        public CrossColor FalseColor
        {
	        get => _falseColor.Convert();
	        set
	        {
		        _falseColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(Name = "Dots Null", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 670)]
        public CrossColor NullColor
        {
	        get => _nullColor.Convert();
	        set
	        {
		        _nullColor = value.Convert();
		        RecalculateValues();
	        }
        }

		#endregion

		#region ctor

		public SqueezeMomentum()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			DataSeries[0] = _renderSeries;
			DataSeries.Add(_dotsSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			var basis = _smaBb.Calculate(bar, candle.Close);
			var dev = BBMultFactor * _stdDev.Calculate(bar, candle.Close);

			var upperBB = basis + dev;
			var lowerBB = basis - dev;

			var ma = _smaKc.Calculate(bar, candle.Close);
			var range = candle.High - candle.Low;

			if (UseTrueRange && bar > 0)
			{
				var trueRange = Math.Max(range, Math.Abs(candle.High - GetCandle(bar - 1).Close));

				range = Math.Max(trueRange, Math.Abs(candle.Low - GetCandle(bar - 1).Close));
			}

			var rangeSma = _smaKcRange.Calculate(bar, range);

			var upperKC = ma + rangeSma * KCMultFactor;
			var lowerKC = ma - rangeSma * KCMultFactor;

			var sqzOn = lowerBB > lowerKC && upperBB < upperKC;
			var sqzOff = lowerBB < lowerKC && upperBB > upperKC;
			var noSqz = !sqzOff && !sqzOn;

			var high = _highest.Calculate(bar, candle.High);
			var low = _lowest.Calculate(bar, candle.Low);

			var val = _linRegr.Calculate(bar, candle.Close - ((high + low) / 2.0m + ma) / 2.0m);

			if (bar == 0)
				return;

			var lastValue = _renderSeries[bar - 1];

			_renderSeries[bar] = val;
			_renderSeries.Colors[bar] = val > 0
				? val > lastValue
					? _upperColor
					: _upColor
				: val < lastValue
					? _lowerColor
					: _lowColor;

			_dotsSeries[bar] = 0.000000001m;
			_dotsSeries.Colors[bar] = noSqz
				? _nullColor
				: sqzOn
					? _trueColor
					: _falseColor;
		}

		#endregion
	}
}










Technical/StackedImbalance.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using Pen = System.Drawing.Pen;
	
    [DisplayName("Stacked Imbalance")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StackedImbalanceDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602474")]
	public class StackedImbalance : Indicator
	{
		#region Fields

		private readonly Pen _askBidPen;
		private readonly Pen _bidAskPen;

		private CrossColor _askBidImbalanceColor = DefaultColors.Green.Convert();
		private CrossColor _bidAskImbalanceColor = DefaultColors.DarkRed.Convert();
		private int _days = 20;
        private int _drawBarsLength = 10;
		private bool _ignoreZeroValues;
		private int _imbalanceRange = 3;

		private int _imbalanceRatio = 300;
		private int _imbalanceVolume = 30;
		private int _lastCalculatedBar = -1;
		private decimal _lastClose;
		private int _lineWidth = 10;
		private List<decimal> _priceAlerts = new();

		private bool _readyToAlert;
		private int _targetBar;
		private bool _tillTouch;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.IgnoreZeroValues), GroupName = nameof(Strings.Settings), Description = nameof(Strings.IgnoreZeroValuesDescription))]
        public bool IgnoreZeroValues
        {
            get => _ignoreZeroValues;
            set
            {
                _ignoreZeroValues = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ImbalanceRatio), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinRatioDescription))]
        [Range(0, 100000)]
        public int ImbalanceRatio
        {
            get => _imbalanceRatio;
            set
            {
                _imbalanceRatio = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ImbalanceRange), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinLevelsRangeSizeDescription))]
        [Range(0, 100000)]
        public int ImbalanceRange
        {
            get => _imbalanceRange;
            set
            {
                _imbalanceRange = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ImbalanceVolume), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MinVolumeFilterCommonDescription))]
        [Range(0, 10000000)]
        public int ImbalanceVolume
        {
            get => _imbalanceVolume;
            set
            {
                _imbalanceVolume = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        [Range(0, 1000)]
		public int Days
		{
			get => _days;
			set
			{
				_days = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineTillTouch), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.IsLineTillTouchDescription))]
		public bool TillTouch
		{
			get => _tillTouch;
			set
			{
				_tillTouch = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskBidImbalanceColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.BullishColorDescription))]
		public CrossColor AskBidImbalanceColor
		{
			get => _askBidImbalanceColor;
			set
			{
				_askBidImbalanceColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidAskImbalanceColor), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.BearishColorDescription))]
		public CrossColor BidAskImbalanceColor
		{
			get => _bidAskImbalanceColor;
			set
			{
				_bidAskImbalanceColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LineWidthDescription))]
		[Range(1, 100)]
		public int LineWidth
		{
			get => _lineWidth;
			set
			{
				_lineWidth = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.PrintLineForXBars), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.LineLengthDescription))]
		[Range(0, 10000)]
		public int DrawBarsLength
		{
			get => _drawBarsLength;
			set
			{
				_drawBarsLength = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SingalAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.IsSingalAlertDescription))]
		public bool UseAlerts { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ApproximationAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.IsApproximationAlertDescription))]
		public bool UseCrossAlerts { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription))]
		public string AlertFile { get; set; } = "alert1";

		#endregion

		#region ctor

		public StackedImbalance()
			: base(true)
		{
			_askBidPen = new Pen(GetDrawingColor(_askBidImbalanceColor));
			_bidAskPen = new Pen(GetDrawingColor(_bidAskImbalanceColor));

			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;
		}

		#endregion

		#region Protected methods

		protected override void OnInitialize()
		{
			((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
			DataSeries[0].IsHidden = true;
        }

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_priceAlerts.Clear();
				_askBidPen.Width = _lineWidth;
				_bidAskPen.Width = _lineWidth;
				_askBidPen.Color = GetDrawingColor(_askBidImbalanceColor);
				_bidAskPen.Color = GetDrawingColor(_bidAskImbalanceColor);
				_readyToAlert = false;

				_targetBar = 0;
				_lastClose = 0;

				if (_days <= 0)
					return;

				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}

				return;
			}

			if (bar < _targetBar)
				return;

			if (bar != _lastCalculatedBar)
			{
				_priceAlerts.Clear();
				_lastCalculatedBar = bar;

				var volumes = GetVolumes(bar - 1);
				CalculateAskBid(bar - 1, volumes);
				CalculateBidAsk(bar - 1, volumes);

				if (_readyToAlert && UseAlerts &&
					ContainsCurrentLines(bar - 1))
				{
					AddAlert(AlertFile, "StackedImbalance was triggered");
					_readyToAlert = false;
				}

				return;
			}

			_readyToAlert = true;

			var closePrice = GetCandle(bar).Close;

			if (UseCrossAlerts && _lastClose != 0)
			{
				foreach (var line in HorizontalLinesTillTouch.Where(x => x.SecondBar >= bar))
				{
					var price = line.FirstPrice;

					if (_priceAlerts.Contains(price))
						continue;

					if (_lastClose < price && closePrice >= price
					    ||
					    _lastClose > price && closePrice <= price)
					{
						AddAlert(AlertFile, $"Price reached {price} level");
						_priceAlerts.Add(price);
					}
				}
			}

			_lastClose = closePrice;
		}

		private bool ContainsCurrentLines(int bar)
		{
			for (var i = HorizontalLinesTillTouch.Count - 1; i >= 0; i--)
			{
				var item = HorizontalLinesTillTouch[i];

				if (item.FirstBar == bar)
					return true;

				if (item.FirstBar < bar)
					break;
			}

			return false;
		}
		
		#endregion

		#region Private methods

		private List<decimal[]> GetVolumes(int bar)
		{
			var candle = GetCandle(bar);
			var volumes = new List<decimal[]>();

			for (var price = candle.Low; price <= candle.High; price += InstrumentInfo.TickSize)
			{
				var volumeInfo = candle.GetPriceVolumeInfo(price);

				if (volumeInfo == null)
					continue;

				var volume = new decimal[3];
				volume[0] = price;
				volume[1] = volumeInfo.Bid;
				volume[2] = volumeInfo.Ask;
				volumes.Add(volume);
			}

			return volumes;
		}

		private void CalculateAskBid(int bar, List<decimal[]> volumes) // Ask/Bid
		{
			var imbalance = new bool[volumes.Count];

			for (var i = 0; i < volumes.Count - 1; i++)
			{
				var lowVolume = volumes[i];
				var highVolume = volumes[i + 1];
				var askFilterValue = lowVolume[1] * _imbalanceRatio / 100;

				if (_ignoreZeroValues && askFilterValue == 0)
					continue;

				if (highVolume[2] > askFilterValue && highVolume[2] > _imbalanceVolume) // Ask > volume
					imbalance[i] = true;
			}

			var count = 0;

			for (var i = 0; i < volumes.Count; i++)
			{
				if (imbalance[i])
					count++;
				else
				{
					if (count >= _imbalanceRange)
					{
						if (_drawBarsLength != 0)
						{
							for (var k = i - count + 1; k <= i; k++)
							{
								HorizontalLinesTillTouch.Add(_tillTouch
									? new LineTillTouch(bar, volumes[k][0], _askBidPen)
									: new LineTillTouch(bar, volumes[k][0], _askBidPen, _drawBarsLength));
							}
						}
						else
						{
							for (var k = i - count + 1; k <= i; k++)
								HorizontalLinesTillTouch.Add(new LineTillTouch(bar, volumes[k][0], _askBidPen));
						}
					}

					count = 0;
				}
			}
		}

		private void CalculateBidAsk(int bar, List<decimal[]> volumes) // Bid/Ask
		{
			var imbalance = new bool[volumes.Count];

			for (var i = 0; i < volumes.Count - 1; i++)
			{
				var lowVolume = volumes[i];
				var highVolume = volumes[i + 1];
				var bidFilterValue = highVolume[2] * _imbalanceRatio / 100;

				if (_ignoreZeroValues && bidFilterValue == 0)
					continue;

				if (lowVolume[1] > bidFilterValue && lowVolume[1] > _imbalanceVolume) // Bid
					imbalance[i] = true;
			}

			var count = 0;

			for (var i = 0; i < volumes.Count; i++)
			{
				if (imbalance[i])
					count++;
				else
				{
					if (count >= _imbalanceRange)
					{
						if (_drawBarsLength != 0)
						{
							for (var k = i - count + 1; k <= i; k++)
							{
								HorizontalLinesTillTouch.Add(_tillTouch
									? new LineTillTouch(bar, volumes[k - 1][0], _bidAskPen)
									: new LineTillTouch(bar, volumes[k - 1][0], _bidAskPen, _drawBarsLength));
							}
						}
						else
						{
							for (var k = i - count + 1; k <= i; k++)
								HorizontalLinesTillTouch.Add(new LineTillTouch(bar, volumes[k - 1][0], _bidAskPen));
						}
					}

					count = 0;
				}
			}
		}

		private System.Drawing.Color GetDrawingColor(CrossColor color)
		{
			var drawingColor = System.Drawing.Color.FromArgb(color.A, color.R, color.G, color.B);
			return drawingColor;
		}

		#endregion
	}
}







Technical/StarcBands.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Starc Bands")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StarcBandsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602475")]
	public class StarcBands : Indicator
	{
		#region Fields

		private readonly ATR _atr = new() { Period = 10 };
        private readonly SMA _sma = new() { Period = 10 };

        private readonly ValueDataSeries _botSeries = new("BotSeries", Strings.BottomBand)
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BottomBandDscription),
        };

		private readonly ValueDataSeries _smaSeries = new("SmaSeries", Strings.SMA)
		{
			DescriptionKey = nameof(Strings.SmaSetingsDescription),
		};

		private readonly ValueDataSeries _topSeries = new("TopSeries", Strings.TopBand)
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.TopBandDscription),
		};

		private decimal _botBand = 1;
        private decimal _topBand = 1;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 1000000)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ATR), GroupName = nameof(Strings.Settings), Description = nameof(Strings.AtrPeriodDescription), Order = 110)]
		[Range(1, 1000000)]
		public int SmaPeriod
		{
			get => _atr.Period;
			set
			{
				_atr.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ATRMultiplierDescription), Order = 120)]
		[Range(0.000001, 1000000)]
		public decimal TopBand
		{
			get => _topBand;
			set
			{
				_topBand = value;
				RecalculateValues();
			}
		}

        [Obsolete]
		[Browsable(false)]
		public decimal BotBand
		{
			get => _botBand;
			set
			{
				_botBand = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StarcBands()
		{
			Add(_atr);

			DataSeries[0] = _topSeries;
			DataSeries.Add(_botSeries);
			DataSeries.Add(_smaSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_sma.Calculate(bar, value);

			var bandValue = _topBand * _atr[bar];

			_topSeries[bar] = _sma[bar] + bandValue;
			_botSeries[bar] = _sma[bar] - bandValue;
			_smaSeries[bar] = _sma[bar];
		}

		#endregion
	}
}








Technical/StdDev.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Standard Deviation")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StdDevDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602477")]
	public class StdDev : Indicator
	{
		#region Fields

		private readonly SMA _sma = new() { Period = 10 };

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StdDev()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var sma = _sma.Calculate(bar, value);

			var start = Math.Max(0, bar - Period + 1);
			var count = Math.Min(bar + 1, Period);

			var sum = 0m;

			for (var i = start; i < start + count; i++)
			{
				var tmp = Math.Abs((decimal)SourceDataSeries[i] - sma);
				sum += tmp * tmp;
			}
			
			this[bar] = (decimal)Math.Sqrt((double)(sum / count));
		}

		#endregion
	}
}







Technical/StdDevBands.cs





namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Standard Deviation Bands")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StdDevBandsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602614")]
	public class StdDevBands : Indicator
	{
        #region Fields

        private readonly Highest _highest = new() { Period = 10 };
        private readonly Lowest _lowest = new() { Period = 10 };
        private readonly SMA _smaHigh = new() { Period = 10 };
        private readonly SMA _smaLow = new() { Period = 10 };
        private readonly StdDev _stdHigh = new() { Period = 10 };
        private readonly StdDev _stdLow = new() { Period = 10 };

		private readonly ValueDataSeries _smaBotSeries = new("SmaBotSeries", Strings.SMA1)
		{
            DescriptionKey = nameof(Strings.SmaSetingsDescription),
        };

		private readonly ValueDataSeries _smaTopSeries = new("SmaTopSeries", Strings.SMA2)
		{
			DescriptionKey = nameof(Strings.SmaSetingsDescription),
		};

        private readonly ValueDataSeries _botSeries = new("BotSeries", Strings.BottomBand)
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.BottomBandDscription),
        };
		
        private readonly ValueDataSeries _topSeries = new("TopSeries", Strings.TopBand)
        {
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			IgnoredByAlerts = true,
            DescriptionKey = nameof(Strings.TopBandDscription),
        };

		private int _width = 2;
		private int _lastAlertTop;
		private bool _onLineTop;
		private int _lastAlertUpperSma;
		private bool _onLineUpperSma;
		private int _lastAlertLowerSma;
		private bool _onLineLowerSma;
		private int _lastAlertBot;
		private bool _onLineBot;

		#endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StdPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _stdHigh.Period;
			set
			{
				_stdHigh.Period = _stdLow.Period = _highest.Period = _lowest.Period =
					_smaHigh.Period = _smaLow.Period = value;

				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBandsWidth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription), Order = 110)]
		[Range(1, 1000)]
        public int SmaPeriod
		{
			get => _width;
			set
			{
				_width = value;
				RecalculateValues();
			}
		}

        #region TopAlert

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.UseAlerts),
            GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 100)]
        public bool UseAlertsTop { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.RepeatAlert),
            GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 110)]
        public bool RepeatAlertTop { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.ApproximationFilter),
            GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 120)]
        [Range(0, 100000)]
        public int AlertSensitivityTop { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.AlertFile),
            GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 130)]
        public string AlertFileTop { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.FontColor),
            GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 140)]
        public CrossColor FontColorTop { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.BackGround),
            GroupName = nameof(Strings.TopBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 150)]
        public CrossColor BackgroundColorTop { get; set; } = DefaultColors.Gray.Convert();

        #endregion

        #region UpperSmaAlert

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.UseAlerts),
            GroupName = nameof(Strings.UpperSma),
            Description = nameof(Strings.UseAlertDescription),
            Order = 200)]
        public bool UseAlertsUpperSma { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.RepeatAlert),
            GroupName = nameof(Strings.UpperSma),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 210)]
        public bool RepeatAlertUpperSma { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.ApproximationFilter),
            GroupName = nameof(Strings.UpperSma),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 220)]
        [Range(0, 100000)]
        public int AlertSensitivityUpperSma { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.AlertFile),
            GroupName = nameof(Strings.UpperSma),
            Description = nameof(Strings.AlertFileDescription),
            Order = 230)]
        public string AlertFileUpperSma { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.FontColor),
            GroupName = nameof(Strings.UpperSma),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 240)]
        public CrossColor FontColorUpperSma { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.BackGround),
            GroupName = nameof(Strings.UpperSma),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 250)]
        public CrossColor BackgroundColorUpperSma { get; set; } = DefaultColors.Gray.Convert();

        #endregion

        #region LowerSmaAlert

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.UseAlerts),
            GroupName = nameof(Strings.LowerSma),
            Description = nameof(Strings.UseAlertDescription),
            Order = 200)]
        public bool UseAlertsLowerSma { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.RepeatAlert),
            GroupName = nameof(Strings.LowerSma),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 210)]
        public bool RepeatAlertLowerSma { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.ApproximationFilter),
            GroupName = nameof(Strings.LowerSma),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 220)]
        [Range(0, 100000)]
        public int AlertSensitivityLowerSma { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.AlertFile),
            GroupName = nameof(Strings.LowerSma),
            Description = nameof(Strings.AlertFileDescription),
            Order = 230)]
        public string AlertFileLowerSma { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.FontColor),
            GroupName = nameof(Strings.LowerSma),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 240)]
        public CrossColor FontColorLowerSma { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.BackGround),
            GroupName = nameof(Strings.LowerSma),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 250)]
        public CrossColor BackgroundColorLowerSma { get; set; } = DefaultColors.Gray.Convert();

        #endregion

        #region BotAlert

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.UseAlerts),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.UseAlertDescription),
            Order = 300)]
        public bool UseAlertsBot { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.RepeatAlert),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.RepeatAlertDescription),
            Order = 310)]
        public bool RepeatAlertBot { get; set; }

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.ApproximationFilter),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.ApproximationFilterDescription),
            Order = 320)]
        [Range(0, 100000)]
        public int AlertSensitivityBot { get; set; } = 1;

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.AlertFile),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertFileDescription),
            Order = 330)]
        public string AlertFileBot { get; set; } = "alert1";

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.FontColor),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertTextColorDescription),
            Order = 340)]
        public CrossColor FontColorBot { get; set; } = DefaultColors.White.Convert();

        [Display(ResourceType = typeof(Strings),
            Name = nameof(Strings.BackGround),
            GroupName = nameof(Strings.BottomBand),
            Description = nameof(Strings.AlertFillColorDescription),
            Order = 350)]
        public CrossColor BackgroundColorBot { get; set; } = DefaultColors.Gray.Convert();

        #endregion

        #endregion

        #region ctor

        public StdDevBands()
		{
			DataSeries[0] = _topSeries;
			DataSeries.Add(_botSeries);
			DataSeries.Add(_smaTopSeries);
			DataSeries.Add(_smaBotSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var high = _highest.Calculate(bar, value);
			var low = _lowest.Calculate(bar, value);

			_topSeries[bar] = _smaHigh.Calculate(bar, high) + _width * _stdHigh.Calculate(bar, high);
			_botSeries[bar] = _smaLow.Calculate(bar, low) - _width * _stdLow.Calculate(bar, low);
			_smaTopSeries[bar] = _smaHigh[bar];
			_smaBotSeries[bar] = _smaLow[bar];

			CheckAlerts(bar);
		}

		private void CheckAlerts(int bar)
		{
			if (bar != CurrentBar - 1)
				return;

			if (UseAlertsTop && (RepeatAlertTop || _lastAlertTop != bar && !RepeatAlertTop))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(_topSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityTop;

				if (onLine && !_onLineTop)
				{
					AddAlert(AlertFileTop, InstrumentInfo.Instrument, "StdDev Bands top approximation alert", BackgroundColorTop, FontColorTop);
					_lastAlertTop = bar;
				}

				_onLineTop = onLine;
			}

			if (UseAlertsUpperSma && (RepeatAlertUpperSma || _lastAlertUpperSma != bar && !RepeatAlertUpperSma))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(_smaTopSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityUpperSma;

				if (onLine && !_onLineUpperSma)
				{
					AddAlert(AlertFileUpperSma, InstrumentInfo.Instrument, "StdDev Bands Upper SMA approximation alert", BackgroundColorUpperSma,
						FontColorUpperSma);
					_lastAlertUpperSma = bar;
				}

				_onLineUpperSma = onLine;
			}

			if (UseAlertsLowerSma && (RepeatAlertLowerSma || _lastAlertLowerSma != bar && !RepeatAlertLowerSma))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(_smaBotSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityLowerSma;

				if (onLine && !_onLineLowerSma)
				{
					AddAlert(AlertFileLowerSma, InstrumentInfo.Instrument, "StdDev Bands Lower SMA approximation alert", BackgroundColorLowerSma,
						FontColorLowerSma);
					_lastAlertLowerSma = bar;
				}

				_onLineLowerSma = onLine;
			}

			if (UseAlertsBot && (RepeatAlertBot || _lastAlertBot != bar && !RepeatAlertBot))
			{
				var close = GetCandle(bar).Close;
				var onLine = Math.Abs(_botSeries[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivityBot;

				if (onLine && !_onLineBot)
				{
					AddAlert(AlertFileTop, InstrumentInfo.Instrument, "StdDev Bands bottom approximation alert", BackgroundColorBot, FontColorBot);
					_lastAlertBot = bar;
				}

				_onLineBot = onLine;
			}
		}

		#endregion
	}
}






Technical/StdErrBands.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Standard Error Bands")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StdErrBandsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602232")]
	public class StdErrBands : Indicator
	{
        #region Fields

        private readonly LinearReg _linReg = new() { Period = 10 };
        private readonly SMA _sma = new() { Period = 10 };

        private readonly ValueDataSeries _botSeries = new("BotSeries", Strings.BottomBand)
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
            DescriptionKey = nameof(Strings.BottomBandDscription),
        };

		private readonly ValueDataSeries _topSeries = new("TopSeries", Strings.TopBand)
		{ 
			Color = System.Drawing.Color.DodgerBlue.Convert(),
            DescriptionKey = nameof(Strings.TopBandDscription),
        };

		private int _stdDev = 1;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = _linReg.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.StdDev), GroupName = nameof(Strings.Settings), Description = nameof(Strings.DeviationRangeDescription), Order = 110)]
		[Range(1, 10000)]
        public int StdDev
		{
			get => _stdDev;
			set
			{
				_stdDev = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StdErrBands()
		{
			DataSeries[0] = _topSeries;
			DataSeries.Add(_botSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_sma.Calculate(bar, value);
			_linReg.Calculate(bar, value);

			if (bar == 0)
				DataSeries.ForEach(x => x.Clear());

			if (bar < Period)
				return;

			var diffSum = 0m;
			var kSum = 0m;
			var kDiffSum = 0m;

			for (var i = bar - Period; i < bar; i++)
			{
				var diff = (decimal)SourceDataSeries[i] - _sma[i];
				diffSum += diff * diff;

				var k = i - (Period - 1) / 2m;
				kSum += k * k;

				kDiffSum += k * diff;
			}

			var sum = (double)((diffSum - kDiffSum * kDiffSum) / ((Period - 2) * kSum));

			var sqrt = Math.Sqrt(Math.Abs(sum));

			var se = (decimal)sqrt;
			_topSeries[bar] = _linReg[bar] + _stdDev * se;
			_botSeries[bar] = _linReg[bar] - _stdDev * se;
		}

		#endregion
	}
}







Technical/Stochastic.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("Stochastic")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StochasticDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602478")]
	public class Stochastic : Indicator
	{
		#region Fields

		private readonly Highest _highest = new() { Period = 10 };
		private readonly ValueDataSeries _k = new("KId", "K");
		private readonly SMA _ksma = new() { Period = 3 };
		private readonly Lowest _lowest = new() { Period = 10 };
		private readonly SMA _sma = new() { Period = 3 };
		private bool _drawLines = true;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period), Description = nameof(Strings.PeriodDescription),
            GroupName = nameof(Strings.Settings))]
		[Range(1, 10000)]
		public int Period
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Smooth), Description = nameof(Strings.SMAPeriod1Description),
            GroupName = nameof(Strings.Settings))]
		[Range(1, 10000)]
        public int Smooth
		{
			get => _ksma.Period;
			set
			{
				_ksma.Period = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AveragePeriod), Description = nameof(Strings.SMAPeriod2Description),
            GroupName = nameof(Strings.Settings))]
		[Range(1, 10000)]
        public int AveragePeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Show), Description = nameof(Strings.DrawLinesDescription),
            GroupName = nameof(Strings.Line),
			Order = 30)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if (LineSeries.Contains(UpLine))
						return;

					LineSeries.Add(UpLine);
					LineSeries.Add(DownLine);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Up), Description = nameof(Strings.OverboughtLimitDescription),
            GroupName = nameof(Strings.Line),
			Order = 30)]
		public LineSeries UpLine { get; set; } = new("UpLine", "Up")
		{
			Color = System.Drawing.Color.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 80,
			Width = 1,
			IsHidden = true
		};

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Down), Description = nameof(Strings.OversoldLimitDescription),
            GroupName = nameof(Strings.Line),
			Order = 30)]
		public LineSeries DownLine { get; set; } = new("DownLine", "Down")
		{
			Color = System.Drawing.Color.Orange.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			Value = 20,
			Width = 1,
			IsHidden = true
		};

        #endregion

        #region ctor

        public Stochastic()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;

			((ValueDataSeries)DataSeries[0]).Color = DefaultColors.Blue.Convert();

            DataSeries.Add(new ValueDataSeries("DId", "%D")
			{
				VisualType = VisualMode.Line,
				LineDashStyle = LineDashStyle.Dash,
				Color = DefaultColors.Red.Convert(),
				IgnoredByAlerts = true,
                DescriptionKey = nameof(Strings.SmaSetingsDescription),
            });

			LineSeries.Add(UpLine);
			LineSeries.Add(DownLine);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var highest = _highest.Calculate(bar, candle.High);
			var lowest = _lowest.Calculate(bar, candle.Low);

			decimal k = 50;

			if (highest - lowest == 0)
			{
				if (bar > 0)
					k = _k[bar - 1];
			}
			else
				k = (candle.Close - lowest) / (highest - lowest) * 100;

			_k[bar] = k;
			var ksma = _ksma.Calculate(bar, k);
			var d = _sma.Calculate(bar, ksma);

			this[bar] = ksma;
			DataSeries[1][bar] = d;
		}

		#endregion
	}
}








Technical/StochasticDiNapoli.cs






namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Preferred Stochastic - DiNapoli")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StochasticDiNapoliDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602575")]
	public class StochasticDiNapoli : Indicator
	{
		#region Fields

		private readonly EMA _ema = new();
        private readonly KdFast _kdFast = new();
        private readonly KdSlow _kdSlow = new();

		private readonly ValueDataSeries _fastSeries = new("FastSeries", Strings.FastLine)
		{
			DescriptionKey = nameof(Strings.FastLineSettingsDescription)
		};

		private readonly ValueDataSeries _slowSeries = new("SlowSeries", Strings.SlowLine)
		{
            DescriptionKey = nameof(Strings.SlowLineSettingsDescription)
        };

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodK), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.ShortPeriodKDescription), Order = 100)]
		public int PeriodK
		{
			get => _kdFast.PeriodK;
			set
			{
				_kdFast.PeriodK = _kdSlow.PeriodK = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodD), GroupName = nameof(Strings.ShortPeriod), Description = nameof(Strings.ShortPeriodDDescription), Order = 110)]
		public int PeriodD
		{
			get => _kdFast.PeriodD;
			set
			{
				_kdFast.PeriodD = _kdSlow.PeriodD = _ema.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodD), GroupName = nameof(Strings.LongPeriod), Description = nameof(Strings.LongPeriodDDescription), Order = 110)]
		public int SlowPeriodD
		{
			get => _kdSlow.SlowPeriodD;
			set
			{
				_kdSlow.SlowPeriodD = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StochasticDiNapoli()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			_ema.Period = _kdFast.PeriodD;
			Add(_kdFast);
			Add(_kdSlow);

			_fastSeries.Color = DefaultColors.Blue.Convert();
			_slowSeries.Color = DefaultColors.Red.Convert();

			DataSeries[0] = _fastSeries;
			DataSeries.Add(_slowSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			_fastSeries[bar] = _ema.Calculate(bar, ((ValueDataSeries)_kdFast.DataSeries[0])[bar]);
			var prevSlowD = ((ValueDataSeries)_kdSlow.DataSeries[1])[bar - 1];
			var fastD = ((ValueDataSeries)_kdFast.DataSeries[1])[bar];

			_slowSeries[bar] = prevSlowD + (fastD - prevSlowD) / SlowPeriodD;
		}

		#endregion
	}
}








Technical/StochasticMomentum.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Stochastic Momentum")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StochasticMomentumDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602480")]
	public class StochasticMomentum : Indicator
	{
		#region Fields

		private readonly EMA _emaCloseRange1 = new() { Period = 10 };
		private readonly EMA _emaCloseRange2 = new() { Period = 10 };
        private readonly EMA _emaRange1 = new() { Period = 10 };
        private readonly EMA _emaRange2 = new() { Period = 10 };
        private readonly EMA _emaSmi = new() { Period = 15 };
        private readonly Highest _highest = new() { Period = 10 };
		private readonly Lowest _lowest = new() { Period = 10 };

        private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodK), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int PeriodK
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.PeriodD), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int PeriodD
		{
			get => _emaRange1.Period;
			set
			{
				_emaRange1.Period = _emaRange2.Period = _emaCloseRange1.Period = _emaCloseRange2.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription), Order = 120)]
		[Range(1, 10000)]
		public int EmaPeriod
		{
			get => _emaSmi.Period;
			set
			{
				_emaSmi.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StochasticMomentum()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			LineSeries.Add(new LineSeries("ZeroVal", Strings.ZeroValue) 
			{
				Color = System.Drawing.Color.Gray.Convert(),
				Value = 0, 
				Width = 2,
                DescriptionKey = nameof(Strings.ZeroLineDescription)
            });

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_highest.Calculate(bar, candle.High);
			_lowest.Calculate(bar, candle.Low);
			var range = _highest[bar] - _lowest[bar];
			var closeRange = candle.Close - (_highest[bar] + _lowest[bar]) / 2;

			_emaRange1.Calculate(bar, range);
			_emaRange2.Calculate(bar, _emaRange1[bar]);
			_emaCloseRange1.Calculate(bar, closeRange);
			_emaCloseRange2.Calculate(bar, _emaCloseRange1[bar]);

			var smi = 200 * _emaCloseRange2[bar] / _emaRange2[bar];
			_renderSeries[bar] = _emaSmi.Calculate(bar, smi);
		}

		#endregion
	}
}






Technical/StochasticRsi.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Stochastic RSI")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StochasticRsiDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602481")]
	public class StochasticRsi : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);
		private int _period = 10;
		private RSI _rsi = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RSI), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StochasticRsiRsiPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int RsiPeriod
		{
			get => _rsi.Period;
			set
			{
				_rsi.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StochasticRsiPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StochasticRsi()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_rsi.Calculate(bar, value);

			if (bar == 0)
				return;

			var maxRsi = ((ValueDataSeries)_rsi.DataSeries[0]).MAX(_period, bar);
			var minRsi = ((ValueDataSeries)_rsi.DataSeries[0]).MIN(_period, bar);

			if (maxRsi - minRsi == 0)
				_renderSeries[bar] = _renderSeries[bar - 1];
			else
				_renderSeries[bar] = (_rsi[bar] - minRsi) / (maxRsi - minRsi);

			_renderSeries[bar] = Math.Max(0.01m, _renderSeries[bar]);
		}

		#endregion
	}
}







Technical/StohasticPercentile.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Stochastic - Percentile")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.StohasticPercentileDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602479")]
	public class StohasticPercentile : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

		private readonly SMA _sma = new() { Period = 10 };
		private readonly List<decimal> _values = new();
		private int _lastBar = -1;
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(2, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int SmaPeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public StohasticPercentile()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_values.Clear();
				_renderSeries.Clear();
			}

			if (_values.Count > _period)
				_values.RemoveAt(0);

			if (bar == _lastBar)
				_values.RemoveAt(_values.Count - 1);

			_values.Add(value);

			var rankedValues = _values.OrderBy(x => x).ToList();

			var sp = 100m * rankedValues.IndexOf(value) / (_period - 1);

			_sma.Calculate(bar, sp);

			_renderSeries[bar] = (decimal)Math.Max(0.000001, (double)_sma[bar]);

			_lastBar = bar;
		}

		#endregion
	}
}








Technical/SuperTrend.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Super Trend")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.SuperTrendDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602482")]
public class SuperTrend : Indicator
{
	#region Fields

	private readonly ATR _atr = new() { Period = 14 };

	[Obsolete]
    private ValueDataSeries _upTrend = new("UpTrendId", "Up Trend")
    {
        Color = DefaultColors.Blue.Convert(),
        Width = 2,
        VisualType = VisualMode.Square,
        ShowZeroValue = false,
        DescriptionKey = nameof(Strings.UpTrendSettingsDescription)
    };

	[Obsolete]
    private ValueDataSeries _dnTrend = new("DnTrend", "Down Trend")
	{
		VisualType = VisualMode.Square,
		Color = DefaultColors.Maroon.Convert(),
		Width = 2,
		ShowZeroValue = false,
        DescriptionKey = nameof(Strings.DownTrendSettingsDescription)
    };

	private int _lastAlert;
	private decimal _lastPrice;
	private decimal _multiplier = 1.7m;
	private string _tickFormat;

	#endregion

	#region Properties

	[Parameter]
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 20)]
	[Range(1, 10000)]
	public int Period
	{
		get => _atr.Period;
		set
		{
			_atr.Period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription), Order = 30)]
	public decimal Multiplier
	{
		get => _multiplier;
		set
		{
			_multiplier = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertDescription), Order = 100)]
	public bool UseAlert { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 110)]
	public string AlertFile { get; set; } = "alert1";

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertPerBar), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertPerBarDescription), Order = 120)]
	public bool AlertPerBar { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Drawing),
		Description = nameof(Strings.BullishColorDescription), Order = 200)]
	public Color UpColor
	{
		get => _upTrend.RenderColor;
		set
		{
			_upTrend.RenderColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearishColor), GroupName = nameof(Strings.Drawing),
		Description = nameof(Strings.BearishColorDescription), Order = 210)]
	public Color DownColor
	{
		get => _dnTrend.RenderColor;
		set
		{
			_dnTrend.RenderColor = value; 
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public SuperTrend()
		: base(true)
	{
		DenyToChangePanel = true;
		var series = (ValueDataSeries)DataSeries[0];
		series.VisualType = VisualMode.Square;
		series.Width = 2;
		series.ShowZeroValue = false;
		DataSeries.Add(_upTrend);
		DataSeries.Add(_dnTrend);
		Add(_atr);
	}

	#endregion

	#region Protected methods

	protected override void OnInitialize()
	{
		_upTrend.IsHidden = _dnTrend.IsHidden = true;
		_upTrend.VisualType = _dnTrend.VisualType = VisualMode.Hide;
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var series = (ValueDataSeries)DataSeries[0];
		
		if (bar == 0)
		{
			_tickFormat = "{0:0.";

			for (var i = 0; i < InstrumentInfo.TickSize.Scale; i++)
				_tickFormat += "#";

			_tickFormat += "}";

			series.SetPointOfEndLine(bar);
			return;
		}

		var candle = GetCandle(bar);
		var prevCandle = GetCandle(bar - 1);
		var median = (candle.Low + candle.High) / 2;
		var atr = _atr[bar];
		var dUpperLevel = median + atr * Multiplier;
		var dLowerLevel = median - atr * Multiplier;

		// Set supertrend levels
		if (candle.Close > this[bar - 1] && prevCandle.Close <= this[bar - 1])
			this[bar] = dLowerLevel;
		else if (candle.Close < this[bar - 1] && prevCandle.Close >= this[bar - 1])
			this[bar] = dUpperLevel;
		else if (this[bar - 1] < dLowerLevel)
			this[bar] = dLowerLevel;
		else if (this[bar - 1] > dUpperLevel)
			this[bar] = dUpperLevel;
		else
			this[bar] = this[bar - 1];
		
        if (candle.Close > this[bar] || (candle.Close == this[bar] && prevCandle.Close > this[bar - 1]))
        {
	        series.Colors[bar] = UpColor;
        }
		else if (candle.Close < this[bar] || (candle.Close == this[bar] && prevCandle.Close < this[bar - 1]))
		{
			series.Colors[bar] = DownColor;
        }

		if (bar != CurrentBar - 1 || !UseAlert)
			return;

		if (_lastPrice == 0)
		{
			_lastPrice = candle.Close;
			return;
		}

		var brake = (_lastPrice < this[bar - 1] && candle.Close >= this[bar - 1]) || 
			(_lastPrice > this[bar - 1] && candle.Close <= this[bar - 1]);
		
		if (brake && (_lastAlert != bar || !AlertPerBar))
		{
			var breakLevel = this[bar - 1];

			AddAlert(AlertFile, InstrumentInfo.Instrument, "Supertrend level break: " + string.Format(_tickFormat, breakLevel),
				System.Drawing.Color.Black.Convert(), System.Drawing.Color.White.Convert());

			_lastAlert = bar;
		}

		_lastPrice = candle.Close;
	}

	#endregion
}







Technical/SwingHighLow.cs





namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
	
    [DisplayName("Swing High and Low")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SwingHighLowDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602483")]
	public class SwingHighLow : Indicator
	{
		#region Fields

		private int _lastHighAlert;
		private int _lastLowAlert;

		private CrossColor _fontColor = System.Drawing.Color.White.Convert();
		private CrossColor _backgroundColor = System.Drawing.Color.Black.Convert();

		private readonly Highest _highest = new() { Period = 10 };
		private readonly Lowest _lowest = new() { Period = 10 };

		private readonly ValueDataSeries _shSeries = new("ShSeries", Strings.Highest)
		{
			Color = DefaultColors.Green.Convert(),
			VisualType = VisualMode.DownArrow
		};
		private readonly ValueDataSeries _slSeries = new("SlSeries", Strings.Lowest)
		{
			Color = DefaultColors.Red.Convert(),
			VisualType = VisualMode.UpArrow
		};
        private bool _includeEqual = true;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IncludeEqualHighLow), GroupName = nameof(Strings.Settings), Description = nameof(Strings.IncludeEqualsValuesDescription), Order = 110)]
		public bool IncludeEqual
		{
			get => _includeEqual;
			set
			{
				_includeEqual = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), 
			Name = nameof(Strings.UseAlert), 
			GroupName = nameof(Strings.ApproximationAlert), 
			Description = nameof(Strings.UseAlertDescription), 
			Order = 200)]
		public bool UseAlerts { get; set; }


		[Display(ResourceType = typeof(Strings), 
			Name = nameof(Strings.AlertFile), 
			GroupName = nameof(Strings.ApproximationAlert), 
			Description = nameof(Strings.AlertFileDescription), 
			Order = 210)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertTextColorDescription),
			Order = 340)]
		public System.Drawing.Color FontColor
		{
			get => _fontColor.Convert();
			set => _fontColor = value.Convert();
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFillColorDescription),
			Order = 350)]
		public System.Drawing.Color BackgroundColor
		{
			get => _backgroundColor.Convert();
			set => _backgroundColor = value.Convert();
		}

        #endregion

        #region ctor

        public SwingHighLow() 
			: base(true)
		{
			DenyToChangePanel = true;
			
			DataSeries[0] = _shSeries;
			DataSeries.Add(_slSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				DataSeries.ForEach(x => x.Clear());

			var candle = GetCandle(bar);
			_highest.Calculate(bar, candle.High);
			_lowest.Calculate(bar, candle.Low);
			
			if (bar < Period * 2)
				return;

			var calcBar = bar - Period;
			var calcCandle = GetCandle(calcBar);

			if (_includeEqual)
			{
				if (calcCandle.High < (decimal)_highest.DataSeries[0][bar - Period - 1]
					||
					calcCandle.High < (decimal)_highest.DataSeries[0][bar])
					_shSeries[calcBar] = 0;
				else
					_shSeries[calcBar] = calcCandle.High + InstrumentInfo.TickSize * 2;

				if (calcCandle.Low > (decimal)_lowest.DataSeries[0][bar - Period - 1]
					||
					calcCandle.Low > (decimal)_lowest.DataSeries[0][bar])
					_slSeries[calcBar] = 0;
				else
					_slSeries[calcBar] = calcCandle.Low - InstrumentInfo.TickSize * 2;
            }
			else
			{
				if (calcCandle.High <= (decimal)_highest.DataSeries[0][bar - Period - 1]
					||
					calcCandle.High <= (decimal)_highest.DataSeries[0][bar])
					_shSeries[calcBar] = 0;
				else
					_shSeries[calcBar] = calcCandle.High + InstrumentInfo.TickSize * 2;

                if (calcCandle.Low >= (decimal)_lowest.DataSeries[0][bar - Period - 1]
					||
					calcCandle.Low >= (decimal)_lowest.DataSeries[0][bar])
					_slSeries[calcBar] = 0;
				else
					_slSeries[calcBar] = calcCandle.Low - InstrumentInfo.TickSize * 2;
            }

			if(!UseAlerts || bar < CurrentBar - 1)
				return;

			if (_slSeries[calcBar] is not 0 && _lastLowAlert != calcBar)
			{
				_lastLowAlert = calcBar;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Low swing triggered at {candle.Close}", _backgroundColor, _fontColor);
			}

			if (_shSeries[calcBar] is not 0 && _lastHighAlert != calcBar)
			{
				_lastHighAlert = calcBar;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"High swing triggered at {candle.Close}", _backgroundColor, _fontColor);
			}
        }

		#endregion
	}
}







Technical/SyntheticVix.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Synthetic VIX")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.SyntheticVixDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602484")]
	public class SyntheticVix : Indicator
	{
		#region Fields

		private readonly Highest _highest = new() { Period = 10 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization);

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _highest.Period;
			set
			{
				_highest.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public SyntheticVix()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_highest.Calculate(bar, candle.Close);
			var highestDataSeries = (ValueDataSeries)_highest.DataSeries[0];
            var maxClose = highestDataSeries.MAX(Period, bar);
			_renderSeries[bar] = 100 * (maxClose - candle.Low) / maxClose;
		}

		#endregion
	}
}








Technical/T3.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("T3")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.T3IndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000606641")]
	public class T3 : Indicator
	{
		#region Fields

		private readonly List<EMA> _emaSix = new();
		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			UseMinimizedModeIfEnabled = true
		};
		private decimal _multiplier = 1;
        private int _period = 10;
        private int _lastAlert;
        private bool _onLine;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				_emaSix.ForEach(x => x.Period = value);
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Multiplier), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription), Order = 110)]
        [Range(1,1000000)]
		public decimal Multiplier
		{
			get => _multiplier;
			set
			{
				_multiplier = value;
				RecalculateValues();
			}
		}

		#region Alert

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.UseAlertsDescription),
			Order = 300)]
		public bool UseAlerts { get; set; }


		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.RepeatAlertDescription),
			Order = 310)]
		[Range(0, 100000)]
		public bool RepeatAlert { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.ApproximationFilterDescription),
			Order = 320)]
		[Range(0, 100000)]
		public int AlertSensitivity { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFileDescription),
			Order = 330)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertTextColorDescription),
			Order = 340)]
		public CrossColor FontColor { get; set; } = System.Drawing.Color.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFillColorDescription),
			Order = 350)]
		public CrossColor BackgroundColor { get; set; } = System.Drawing.Color.DimGray.Convert();

		#endregion

		#endregion

        #region ctor

        public T3()
		{
			for (var i = 0; i < 6; i++)
			{
				_emaSix.Add(new EMA
					{ Period = _period });
			}

			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_emaSix[0].Calculate(bar, value);

			for (var i = 1; i < _emaSix.Count; i++)
				_emaSix[i].Calculate(bar, _emaSix[i - 1][bar]);

			_renderSeries[bar] = -(decimal)Math.Pow((double)_multiplier, 3) * _emaSix[5][bar] +
				3 * _multiplier * _multiplier * (1 + _multiplier) * _emaSix[4][bar] -
				3 * _multiplier * (1 + _multiplier) * (1 + _multiplier) * _emaSix[3][bar] +
				(decimal)Math.Pow(1 + (double)_multiplier, 3) * _emaSix[2][bar];

			if (bar != CurrentBar - 1 || !UseAlerts)
				return;

			if (_lastAlert == bar && !RepeatAlert)
				return;

			var close = GetCandle(bar).Close;
			var onLine = Math.Abs(this[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivity;

			if (onLine && !_onLine)
			{
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"T3 approximation alert: {this[bar]:0.#####}", BackgroundColor, FontColor);
				_lastAlert = bar;
			}

			_onLine = onLine;
		}

		#endregion
	}
}








Technical/TDSequential.cs






namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;

using ATAS.Indicators.Drawing;

using MoreLinq;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Settings;

[DisplayName("TD Sequential")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.TDSequentialDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619193")]
public class TDSequential : Indicator
{
	#region Static and constants

	private const int _barsNum = 4;
	private const int _maxSignalNum = 9;

	#endregion

	#region Fields

	private readonly PaintbarsDataSeries _colorBars = new("ColorBars", Strings.Candles) { IsHidden = true };
	private readonly ValueDataSeries _down = new("Down", Strings.Down) { ShowZeroValue = false, VisualType = VisualMode.UpArrow };

	private readonly ValueDataSeries _res = new("Res", Strings.ResistanceLevel)
	{
		ShowZeroValue = false,
		Width = 2,
		VisualType = VisualMode.Line,
		LineDashStyle = LineDashStyle.Dot,
		Color = System.Drawing.Color.Green.Convert()
	};

	private readonly ValueDataSeries _sup = new("Sup", Strings.SupportLevel)
	{
		ShowZeroValue = false,
		Width = 2,
		VisualType = VisualMode.Line,
		LineDashStyle = LineDashStyle.Dot,
		Color = System.Drawing.Color.Red.Convert()
	};

	private readonly ValueDataSeries _td = new("TdId", "TD") { ShowZeroValue = false, IsHidden = true };
	private readonly ValueDataSeries _ts = new("TsId", "TS") { ShowZeroValue = false, IsHidden = true };
	private readonly ValueDataSeries _up = new("Up", Strings.Up) { ShowZeroValue = false, VisualType = VisualMode.DownArrow };
	
	private CrossColor _buyBarsColor = DefaultColors.Green.Convert();
	private CrossColor _buyOvershoot = CrossColor.FromArgb(255, 214, 255, 92);
	private CrossColor _buyOvershoot1 = CrossColor.FromArgb(255, 209, 255, 71);
	private CrossColor _buyOvershoot2 = CrossColor.FromArgb(255, 184, 230, 46);
	private CrossColor _buyOvershoot3 = CrossColor.FromArgb(255, 143, 178, 36);
	private CrossColor _sellBarsColor = DefaultColors.Red.Convert();
	private CrossColor _sellOvershoot = CrossColor.FromArgb(255, 255, 102, 163);
	private CrossColor _sellOvershoot1 = CrossColor.FromArgb(255, 255, 51, 133);
	private CrossColor _sellOvershoot2 = CrossColor.FromArgb(255, 255, 0, 102);
	private CrossColor _sellOvershoot3 = CrossColor.FromArgb(255, 204, 0, 82);

	private bool _isBarColor = true;
	private bool _isNumbers = true;
	private bool _isSr = true;
	private int _labelTextSize = 10;

    #endregion

    #region Visualization

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowSignalNumbers), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.IsNeedShowLabelDescription))]
    public bool IsNumbers
    {
        get => _isNumbers;
        set
        {
            _isNumbers = value;
            _up.VisualType = value ? VisualMode.DownArrow : VisualMode.Hide;
            _down.VisualType = value ? VisualMode.UpArrow : VisualMode.Hide;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SRLevels), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ShowSupResLevelsDescription))]
    public bool IsSr
    {
        get => _isSr;
        set
        {
            _isSr = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighlightSignalBars), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.HighlightSignalBarsDescription))]
    public bool IsBarColor
    {
        get => _isBarColor;
        set
        {
            _isBarColor = value;
            RecalculateValues();
        }
    }

    [Range(7, 30)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.TextSizeDescription))]
    public int LabelTextSize
    {
        get => _labelTextSize;
        set
        {
            _labelTextSize = value;

            foreach (var label in Labels)
            {
                var textSize = GetTextSize(label.Value.Text);
                label.Value.FontSize = textSize;

                var condition = label.Value.Tag.Contains('+');
                var width = condition ? _up.Width : _down.Width;
                var offsetY = condition ? GetLabelOffsetY(true, (int)textSize) * width : GetLabelOffsetY(false, (int)textSize) * width;
                label.Value.YOffset = offsetY;
            }
        }
    }

    #endregion

    #region Candles

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyColor), GroupName = nameof(Strings.Candles), Description = nameof(Strings.BuySignalColorDescription))]
    public CrossColor BuyBarsColor
    {
        get => _buyBarsColor;
        set
        {
            _buyBarsColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyOvershootColor), GroupName = nameof(Strings.Candles), Description = nameof(Strings.BuySignalColorDescription))]
    public CrossColor BuyOvershoot
    {
        get => _buyOvershoot;
        set
        {
            _buyOvershoot = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyOvershoot1Color), GroupName = nameof(Strings.Candles), Description = nameof(Strings.BuySignalColorDescription))]
    public CrossColor BuyOvershoot1
    {
        get => _buyOvershoot1;
        set
        {
            _buyOvershoot1 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyOvershoot2Color), GroupName = nameof(Strings.Candles), Description = nameof(Strings.BuySignalColorDescription))]
    public CrossColor BuyOvershoot2
    {
        get => _buyOvershoot2;
        set
        {
            _buyOvershoot2 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyOvershoot3Color), GroupName = nameof(Strings.Candles), Description = nameof(Strings.BuySignalColorDescription))]
    public CrossColor BuyOvershoot3
    {
        get => _buyOvershoot3;
        set
        {
            _buyOvershoot3 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellColor), GroupName = nameof(Strings.Candles), Description = nameof(Strings.SellSignalColorDescription))]
    public CrossColor SellBarsColor
    {
        get => _sellBarsColor;
        set
        {
            _sellBarsColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellOvershootColor), GroupName = nameof(Strings.Candles), Description = nameof(Strings.SellSignalColorDescription))]
    public CrossColor SellOvershoot
    {
        get => _sellOvershoot;
        set
        {
            _sellOvershoot = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellOvershoot1Color), GroupName = nameof(Strings.Candles), Description = nameof(Strings.SellSignalColorDescription))]
    public CrossColor SellOvershoot1
    {
        get => _sellOvershoot1;
        set
        {
            _sellOvershoot1 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellOvershoot2Color), GroupName = nameof(Strings.Candles), Description = nameof(Strings.SellSignalColorDescription))]
    public CrossColor SellOvershoot2
    {
        get => _sellOvershoot2;
        set
        {
            _sellOvershoot2 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellOvershoot3Color), GroupName = nameof(Strings.Candles), Description = nameof(Strings.SellSignalColorDescription))]
    public CrossColor SellOvershoot3
    {
        get => _sellOvershoot3;
        set
        {
            _sellOvershoot3 = value;
            RecalculateValues();
        }
    }

    #endregion

    #region ctor

    public TDSequential()
		: base(true)
	{
		DenyToChangePanel = true;
		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).ShowZeroValue = false;
        ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

        _up.Color = _buyBarsColor;
		_down.Color = _sellBarsColor;
		DataSeries.Add(_colorBars);
		DataSeries.Add(_up);
		DataSeries.Add(_down);
		DataSeries.Add(_sup);
		DataSeries.Add(_res);

		_up.PropertyChanged += PropColorChanged;
		_down.PropertyChanged += PropColorChanged;
	}

	#endregion

	#region Protected Methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar < _barsNum)
			return;

		NumbersCalc(bar);
	}

	#endregion

	#region Private Methods

	#region Event Handlers

	private void PropColorChanged(object sender, PropertyChangedEventArgs e)
	{
		if ((ValueDataSeries)sender == _up)
		{
			var upLabels = Labels.Where(l => l.Value.Tag.Contains('+'));

			switch (e.PropertyName)
			{
				case "Color":
					var color = ((ValueDataSeries)sender).Color;
					upLabels.ForEach(l => l.Value.Textcolor = color.Convert());
					break;
				case "Width":
					var width = ((ValueDataSeries)sender).Width;

                    foreach (var upLabel in upLabels)
                    {
                        var textSize = GetTextSize(upLabel.Value.Text);
                        var offsetY = GetLabelOffsetY(true, (int)textSize) * width;
                        upLabel.Value.YOffset = offsetY;
                    }
                    break;
			}
		}

		if ((ValueDataSeries)sender == _down)
		{
			var upLabels = Labels.Where(l => !l.Value.Tag.Contains('+'));

			switch (e.PropertyName)
			{
				case "Color":
					var color = ((ValueDataSeries)sender).Color;
					upLabels.ForEach(l => l.Value.Textcolor = color.Convert());
					break;
				case "Width":
					var width = ((ValueDataSeries)sender).Width;
					
					foreach (var upLabel in upLabels)
					{
                        var textSize = GetTextSize(upLabel.Value.Text);
                        var offsetY = GetLabelOffsetY(false, (int)textSize) * width;
                        upLabel.Value.YOffset = offsetY;
                    }
					break;
			}
		}
	}

	#endregion

	#region Numbers

	private void NumbersCalc(int bar)
	{
		var curCandle = GetCandle(bar);
		var candle = GetCandle(bar - _barsNum);

		if (curCandle.Close > candle.Close)
			_td[bar] = _td[bar - 1] + 1;
		else
			_td[bar] = 0;

		if (curCandle.Close < candle.Close)
			_ts[bar] = _ts[bar - 1] + 1;
		else
			_ts[bar] = 0;

		var tdUp = _td[bar] - GetValueCurrentSmallerPrev(bar, _td, 2);
		var tdDown = _ts[bar] - GetValueCurrentSmallerPrev(bar, _ts, 2);

		SetSignal(bar, curCandle, tdUp, _up, _down, true);
		SetSignal(bar, curCandle, tdDown, _down, _up, false);

		if (_isBarColor)
		{
			SetBarsColor(tdUp, bar, _sellBarsColor, _sellOvershoot, _sellOvershoot1, _sellOvershoot2, _sellOvershoot3);
			SetBarsColor(tdDown, bar, _buyBarsColor, _buyOvershoot, _buyOvershoot1, _buyOvershoot2, _buyOvershoot3);
		}

		if (!_isSr)
			return;

		if (tdUp == _maxSignalNum)
		{
			_res.SetPointOfEndLine(bar - 1);
			_res[bar] = curCandle.High;
		}
		else
			_res[bar] = _res[bar - 1];

		if (tdDown == _maxSignalNum)
		{
			_sup.SetPointOfEndLine(bar - 1);
			_sup[bar] = curCandle.Low;
		}
		else
			_sup[bar] = _sup[bar - 1];
	}

	private void SetBarsColor(decimal td, int bar, CrossColor color9, CrossColor color13, CrossColor color14, CrossColor color15, CrossColor color16)
	{
        _colorBars[bar] = td switch
        {
            9 => color9,
            13 => color13,
            14 => color14,
            15 => color15,
            16 => color16,
            _ => _colorBars[bar]
        };
    }

	private void SetSignal(int bar, IndicatorCandle candle, decimal tdValue, ValueDataSeries series, ValueDataSeries altSeries, bool isUp)
	{
		if (tdValue is < 1 or > _maxSignalNum)
			return;

		var markerPlace = isUp ? candle.High + InstrumentInfo.TickSize : candle.Low - InstrumentInfo.TickSize;
		series[bar] = markerPlace;
		altSeries[bar] = 0;

		if (_isNumbers)
		{
			var color = isUp ? _up.Color.Convert() : _down.Color.Convert();
			var tag = isUp ? $"{bar}+" : $"{bar}";
			var textSize = GetTextSize(tdValue);
			var offsetY = GetLabelOffsetY(isUp, (int)textSize) * series.Width;
            var borderColor = tdValue == 9 ? color : System.Drawing.Color.Transparent;

            AddText(tag, tdValue.ToString(CultureInfo.InvariantCulture), !isUp, bar, markerPlace, offsetY, 0,
				 color, borderColor, System.Drawing.Color.Transparent, textSize, DrawingText.TextAlign.Center);
		}
	}

    private float GetTextSize(decimal tdValue)
    {
        return tdValue == _maxSignalNum ? _labelTextSize * 1.5f : _labelTextSize;
    }

    private float GetTextSize(string tdValue)
    {
		return GetTextSize(decimal.Parse(tdValue));
    }

    private int GetLabelOffsetY(bool isUp, int textSize)
	{
		return isUp ? -textSize * 3 : textSize * 3;
	}

	private decimal GetValueCurrentSmallerPrev(int bar, ValueDataSeries series, int amount)
	{
		var count = 0;

		for (var i = bar; i > 0; i--)
		{
			if (series[i] < series[i - 1])
			{
				count++;

				if (count == amount)
					return series[i];
			}
		}

		return series[0];
	}

	#endregion

	#endregion
}







Technical/TEMA.cs





namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Triple Exponential Moving Average")]
	[Display(ResourceType = typeof(Strings), Description = nameof(Strings.TEMADescription))]
	[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602492")]
	public class TEMA : Indicator
	{
		#region Fields

		private readonly EMA _emaFirst = new() { Period = 10 };
		private readonly EMA _emaSecond = new() { Period = 10 };
		private readonly EMA _emaThird = new() { Period = 10 };
		private int _lastAlert;
		private bool _onLine;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings),
			Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _emaFirst.Period;
			set
			{
				_emaFirst.Period = _emaSecond.Period = _emaThird.Period = value;
				RecalculateValues();
			}
		}

		#region Alert

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.UseAlertsDescription),
			Order = 300)]
		public bool UseAlerts { get; set; }


		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.RepeatAlertDescription),
			Order = 310)]
		[Range(0, 100000)]
		public bool RepeatAlert { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.ApproximationFilterDescription),
			Order = 320)]
		[Range(0, 100000)]
		public int AlertSensitivity { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFileDescription),
			Order = 330)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertTextColorDescription),
			Order = 340)]
		public CrossColor FontColor { get; set; } = System.Drawing.Color.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFillColorDescription),
			Order = 350)]
		public CrossColor BackgroundColor { get; set; } = System.Drawing.Color.DimGray.Convert();

		#endregion

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_emaFirst.Calculate(bar, value);
			_emaSecond.Calculate(bar, _emaFirst[bar]);
			_emaThird.Calculate(bar, _emaSecond[bar]);
			this[bar] = 3 * _emaFirst[bar] - 3 * _emaSecond[bar] + _emaThird[bar];

			if (bar != CurrentBar - 1 || !UseAlerts)
				return;

			if (_lastAlert == bar && !RepeatAlert)
				return;

			var close = GetCandle(bar).Close;
			var onLine = Math.Abs(this[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivity;

			if (onLine && !_onLine)
			{
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Triple EMA approximation alert: {this[bar]:0.#####}", BackgroundColor, FontColor);
				_lastAlert = bar;
			}

			_onLine = onLine;
		}

		#endregion
	}
}








Technical/TMA.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Triangular Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.TMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602233")]
	public class TMA : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _sma1 = new("Sma1Id", "Sma1");
		private readonly ValueDataSeries _sma2 = new("Sma2Id", "Sma2");
		private int _period = 10;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			var n1 = (int)Math.Ceiling(_period / 2m);
			var n2 = _period % 2 == 1 ? n1 : n1 + 1;

			_sma1[bar] = DynamicSma(bar, n1, SourceDataSeries);
			_sma2[bar] = DynamicSma(bar, n2, _sma1);
			this[bar] = _sma2[bar];
		}

		#endregion

		#region Private methods

		private decimal DynamicSma(int bar, int period, IDataSeries series)
		{
			var sum = 0m;

			for (var i = Math.Max(0, bar - period); i < bar; i++)
				sum += (decimal)series[i];

			return sum / period;
		}

		#endregion
	}
}







Technical/TRIX.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("TRIX")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.TRIXDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602493")]
	public class TRIX : Indicator
	{
		#region Fields

		private readonly EMA _emaFirst = new() { Period = 10 };
		private readonly EMA _emaSecond = new() { Period = 10 };
        private readonly EMA _emaThird = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _emaFirst.Period;
			set
			{
				_emaFirst.Period = _emaSecond.Period = _emaThird.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public TRIX()
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_emaFirst.Calculate(bar, value);
			_emaSecond.Calculate(bar, value);
			_emaThird.Calculate(bar, value);

			if (bar == 0)
				return;

			this[bar] = 100 * (_emaThird[bar] - _emaThird[bar - 1]) / _emaThird[bar - 1];
		}

		#endregion
	}
}







Technical/TSI.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("True Strength Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.TSIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602631")]	
	public class TSI : Indicator
	{
		#region Fields

		private readonly EMA _absEma = new() { Period = 13 };
        private readonly EMA _absSecEma = new() { Period = 25 };
        private readonly EMA _ema = new() { Period = 13 };

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Values)
		{
			Color = DefaultColors.Blue.Convert(),
			VisualType = VisualMode.Histogram
		};
		private readonly ValueDataSeries _renderSmoothedSeries = new("RenderSmoothedSeries", Strings.Smooth)
		{
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.SmoothLineSettingsDescription)
		};

		private readonly EMA _secEma = new() { Period = 25 };
        private readonly EMA _smoothEma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
		[Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod1), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		public int EmaPeriod
		{
			get => _ema.Period;
			set
			{
				_ema.Period = _absEma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EmaPeriod2), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		public int EmaSecPeriod
		{
			get => _secEma.Period;
			set
			{
				_secEma.Period = _absSecEma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Range(1, 10000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Smooth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.EMAPeriodDescription), Order = 120)]
		public int SmoothPeriod
		{
			get => _smoothEma.Period;
			set
			{
				_smoothEma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public TSI()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _renderSeries;
			DataSeries.Add(_renderSmoothedSeries);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var diff = candle.Close - prevCandle.Close;
			_ema.Calculate(bar, diff);
			_secEma.Calculate(bar, _ema[bar]);

			_absEma.Calculate(bar, Math.Abs(diff));
			_absSecEma.Calculate(bar, _absEma[bar]);

			_renderSeries[bar] = 100 * _secEma[bar] / _absSecEma[bar];
			_renderSmoothedSeries[bar] = _smoothEma.Calculate(bar, _renderSeries[bar]);
		}

		#endregion
	}
}







Technical/TVI.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Trade Volume Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.TVIDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602296")]
	public class TVI : Indicator
	{
		#region ctor

		public TVI()
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var volume = GetCandle(bar).Volume;

			if (value - (decimal)SourceDataSeries[bar - 1] > InstrumentInfo.TickSize)
				this[bar] = this[bar - 1] + volume;
			else if (value - (decimal)SourceDataSeries[bar - 1] == InstrumentInfo.TickSize)
				this[bar] = this[bar - 1];
			else
				this[bar] = this[bar - 1] - volume;
		}

		#endregion
	}
}







Technical/TapePattern.cs






namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading;

using ATAS.Indicators.Technical.Extensions;

using OFT.Attributes;
using OFT.Localization;
using Utils.Common;
using Utils.Common.Logging;

[Category(IndicatorCategories.VolumeOrderFlow)]
[DisplayName("Tape Patterns")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.TapePatternDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602248")]
public class TapePattern : Indicator
{
	#region Nested types

	public enum TicksType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Any))]
		Any,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
		Bid,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
		Ask,											
														
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Between))]
		Between,										
														
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidOrAsk))]
		BidOrAsk,										
														
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BidAndAsk))]
		BidAndAsk
	}

	internal class CumTradeExtended
	{
		public CumulativeTrade Owner { get; }
        public decimal FirstPrice { get; set; }
        public decimal Lastprice { get; set; }
        public decimal Volume { get; set; }
        public DateTime FirstTime { get; set; }
        public DateTime LastTime { get; set; }
        public TradeDirection Direction { get; set; }
        public List<decimal> TicksVolumes { get; set; }

		public CumTradeExtended(CumulativeTrade owner)
		{
			Owner = owner;
		}

        public override string ToString()
        {
            return $"{FirstTime:yyyy-MM-dd HH:mm:ss,fff} {Direction} at {FirstPrice} vol {Volume}/";
        }
    }

    internal class MinimizedVolumeString
    {
        private int _digits;

		private string _format;
		internal bool Minimize { get; set; } = true;
        internal int Digits
        {
            get => _digits;
            set
            {
                if (value < 0)
                    return;

                _digits = value;
                var s = "{0:0";
                s = string.Concat(s, ".", string.Join("", Enumerable.Repeat("#", value)));
                _format = string.Concat(s, "}");
            }
        }

        internal string TryGetString(decimal value)
        {
            var absValue = Math.Abs(value);

            if (Minimize && absValue > 1000)
            {
                if (absValue < 1000000)
                {
                    return string.Format(_format + "K", value / 1000);
                }
                else
                {
                    return string.Format(_format + "M", value / 1000000);
                }
            }
            else
            {
                return string.Format(_format, value);
            }
        }
    }

    #endregion

    #region Static and constants

    private const decimal _clusterStepSize = 0.03m;

	#endregion

	#region Fields

	private readonly List<TradeDirection> _directions = new();
	private readonly PriceSelectionDataSeries _renderSeries = new("RenderSeries", "TapePrice");
	private readonly BlockingCollection<object> _tradesQueue = new();
	private readonly SortedDictionary<decimal, int> _volumesBySize = new();

	private readonly MinimizedVolumeString _minimizer = new() { Digits = 3 };

    private TicksType _calcMode;
	private CrossColor _clusterBetween;
	private CrossColor _clusterBuy;
	private CrossColor _clusterSell;
	private int _clusterTransparency;
	private int _count;
	private decimal _cumulativeVol;

	private PriceSelectionValue _currentTick;
	private decimal _delta;
	private DateTime _firstTime;
	private bool _fixedSizes;
	private bool _historyCalculated;
	private CumulativeTrade _lastRenderedTrade;
    private CumTradeExtended _lastRenderedTradeExt;
    private int _lastSession;
	private List<PriceSelectionValue> _lastTick = new();
	private DateTime _lastTime;

	private int _maxCount;
	private decimal _maxCumVol;
	private decimal _maxPrice;
	private int _maxSize;
	private decimal _maxVol;
	private int _minCount;
	private decimal _minCumVol;
	private decimal _minPrice;
	private int _minSize;
	private decimal _minVol;
	private CrossColor _objectBetween;
	private CrossColor _objectBuy;
	private CrossColor _objectSell;
	private int _objectTransparency;
	private int _rangeFilter;
	private bool _requestFailed;
	private bool _requestWaiting;
	private bool _searchPrintsInsideTimeFilter;
	private CrossColor _sellColor;
    private CrossColor _betweenColor;
    private CrossColor _buyColor;
    private int _size;
	private int _timeFilter;
	private TimeSpan _timeFrom;
	private TimeSpan _timeTo;
	private CancellationTokenSource _tokenSource;
	private Thread _tradesThread;
	private bool _useCumulativeTrades;
	private bool _useTimeFilter;
	private ObjectType _visualType;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseTimeFilter), GroupName = nameof(Strings.TimeFiltration), Description = nameof(Strings.UseTimeFilterDescription), Order = 100)]
	public bool UseTimeFilter
	{
		get => _useTimeFilter;
		set
		{
			_useTimeFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFrom), GroupName = nameof(Strings.TimeFiltration), Description = nameof(Strings.TimeFromDescription), Order = 110)]
	public TimeSpan TimeFrom
	{
		get => _timeFrom;
		set
		{
			_timeFrom = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeTo), GroupName = nameof(Strings.TimeFiltration), Description = nameof(Strings.TimeToDescription), Order = 120)]
	public TimeSpan TimeTo
	{
		get => _timeTo;
		set
		{
			_timeTo = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CumulativeTrades), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.CumulativeTradesModeDescription), Order = 200)]
	public bool CumulativeTrades
	{
		get => _useCumulativeTrades;
		set
		{
			_useCumulativeTrades = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinPrintVolume), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MinVolumeFilterCommonDescription), Order = 210)]
	public decimal MinVol
	{
		get => _minVol;
		set
		{
			if (value < 0)
				return;

			_minVol = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxPrintVolume), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MaxVolumeFilterCommonDescription), Order = 220)]
	public decimal MaxVol
	{
		get => _maxVol;
		set
		{
			if (value < 0)
				return;

			_maxVol = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumCount), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MinimumTradesCountDescription), Order = 230)]
	public int MinCount
	{
		get => _minCount;
		set
		{
			if (value < 0)
				return;

			_minCount = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumCount), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MaximumTradesCountDescription), Order = 240)]
	public int MaxCount
	{
		get => _maxCount;
		set
		{
			if (value < 0)
				return;

			_maxCount = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinCumulativeVolume), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MinCumulativeVolumeDescription), Order = 250)]
	public decimal MinCumulativeVolume
	{
		get => _minCumVol;
		set
		{
			if (value < 0)
				return;

			_minCumVol = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxCumulativeVolume), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MaxCumulativeVolumeDescription), Order = 260)]
	public decimal MaxCumulativeVolume
	{
		get => _maxCumVol;
		set
		{
			if (value < 0)
				return;

			_maxCumVol = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFilter), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MaxTimeFilterDescription), Order = 270)]
	public int TimeFilter
	{
		get => _timeFilter;
		set
		{
			if (value < 0)
				return;

			_timeFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SearchPrintsInsideTimeFilter), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.UseCumTradesTimeFilterDescription), Order = 280)]
	public bool SearchPrintsInsideTimeFilter
	{
		get => _searchPrintsInsideTimeFilter;
		set
		{
			_searchPrintsInsideTimeFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.RangeFilter), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MaxPriceLevelsCountDescription), Order = 290)]
	public int RangeFilter
	{
		get => _rangeFilter;
		set
		{
			if (value < 0)
				return;

			_rangeFilter = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.SourceTypeDescription), Order = 295)]
	public TicksType CalculationMode
	{
		get => _calcMode;
		set
		{
			_calcMode = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualObjectsTransparency), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualObjectsTransparency), Order = 300)]
	public int ObjectTransparency
	{
		get => _objectTransparency;
		set
		{
			if (value < 0)
				return;

			_objectTransparency = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ClusterSelectionTransparency), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PriceSelectionTransparencyDescription), Order = 305)]
	public int ClusterTransparency
	{
		get => _clusterTransparency;
		set
		{
			if (value < 0)
				return;

			_clusterTransparency = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.FixedSizes), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.FixedSizesDescription), Order = 310)]
	public bool FixedSizes
	{
		get => _fixedSizes;
		set
		{
			_fixedSizes = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Size), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.SizeDescription), Order = 320)]
	public int Size
	{
		get => _size;
		set
		{
			if (value <= 0)
				return;

			_size = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaximumSize), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.MaximumSizeDescription), Order = 330)]
	public int MaxSize
	{
		get => _maxSize;
		set
		{
			if (value <= 0)
				return;

			_maxSize = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.MinimumSize), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.MinimumSizeDescription), Order = 340)]
	public int MinSize
	{
		get => _minSize;
		set
		{
			if (value <= 0)
				return;

			_minSize = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VisualMode), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.VisualModeDescription), Order = 350)]
	public ObjectType VisualType
	{
		get => _visualType;
		set
		{
			_visualType = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BetweenColor), GroupName = nameof(Strings.Colors), Description = nameof(Strings.BetweenColorDescription), Order = 400)]
	public CrossColor BetweenColor
	{
		get => _betweenColor;
		set
		{
			_betweenColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Buys), GroupName = nameof(Strings.Colors), Description = nameof(Strings.BuySignalColorDescription), Order = 410)]
	public CrossColor BuyColor
	{
		get => _buyColor;
		set
		{
			_buyColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Sells), GroupName = nameof(Strings.Colors), Description = nameof(Strings.SellSignalColorDescription), Order = 420)]
	public CrossColor SellColor
	{
		get => _sellColor;
		set
		{
			_sellColor = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription), Order = 500)]
	public bool UseAlerts { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription), Order = 510)]
	public string AlertFile { get; set; } = "alert1";

	#endregion

	#region ctor

	public TapePattern()
		: base(true)

	{
		DenyToChangePanel = true;

		_minCumVol = 100;
		_timeFilter = 1000;
		_rangeFilter = 1;
		_calcMode = TicksType.Any;
		_objectTransparency = 70;
		_clusterTransparency = 40;
		_size = 10;
		_maxSize = 50;
		_minSize = 5;
		_visualType = ObjectType.Rectangle;
		_betweenColor = CrossColorExtensions.FromRgb(128, 128, 128);
		_buyColor = System.Drawing.Color.Green.Convert();
		_sellColor = System.Drawing.Color.Red.Convert();
		_renderSeries.IsHidden = true;

		DataSeries[0] = _renderSeries;
		_renderSeries.Changed += SeriesUpdate;
    }

	#endregion

	#region Protected methods

	protected override void OnApplyDefaultColors()
	{
		if (ChartInfo is null)
			return;

		BuyColor = ChartInfo.ColorsStore.FootprintAskColor.Convert();
		SellColor = ChartInfo.ColorsStore.FootprintBidColor.Convert();
		BetweenColor = ChartInfo.ColorsStore.BarBorderPen.Color.Convert();
	}

	protected override void OnDispose()
	{
		StopProcessQueueThread();
	}

	protected override void OnRecalculate()
	{
		while (_tradesQueue.TryTake(out _))
		{
		}
	}

	protected override void OnInitialize()
	{
		StartProcessQueueThread();
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		if (ChartInfo is null || InstrumentInfo is null)
			return;

		var totalBars = CurrentBar - 1;

		if (bar != 0 && bar != totalBars)
			return;

		if (bar == 0)
		{
			_historyCalculated = false;
			_renderSeries.Clear();
			_volumesBySize.Clear();
			_delta = 0;
			_minPrice = _maxPrice = 0;
			_cumulativeVol = 0;
			_count = 0;
			SetClusterColors();

			_lastSession = 0;

			try
			{
				if (IsNewSession(totalBars))
					_lastSession = totalBars;
				else
				{
					for (var i = totalBars; i >= 0; i--)
					{
						if (IsNewSession(i))
						{
							_lastSession = i;
							break;
						}
					}
				}
			}
			catch (ArgumentOutOfRangeException)
			{
				//Old instrument exception
				return;
			}

			if (!_requestWaiting)
			{
				_requestWaiting = true;
				RequestForCumulativeTrades(new CumulativeTradesRequest(GetCandle(_lastSession).Time));
			}
			else
				_requestFailed = true;
		}
		else
		{
			lock (_renderSeries[bar].SyncRoot)
				_lastTick = _renderSeries[bar].ToList();
		}
	}

	protected override void OnCumulativeTradesResponse(CumulativeTradesRequest request, IEnumerable<CumulativeTrade> cumulativeTrades)
	{
		_requestWaiting = false;

		if (!_requestFailed)
		{
			var trades = cumulativeTrades.ToList();

			GetTradesHistory(trades);
		}
		else
		{
			_requestFailed = false;
			Calculate(0, 0);
		}
	}

	protected override void OnCumulativeTrade(CumulativeTrade trade)
	{
		var totalBars = ChartInfo.PriceChartContainer.TotalBars;

		if (totalBars < 0)
			return;

		if (!_useCumulativeTrades)
			return;

		_tradesQueue.TryAdd(GetCumTradeExtended(trade));

    }

	protected override void OnUpdateCumulativeTrade(CumulativeTrade trade)
	{
		var totalBars = ChartInfo.PriceChartContainer.TotalBars;

		if (totalBars < 0)
			return;

		if (!_useCumulativeTrades)
			return;

        _tradesQueue.TryAdd(GetCumTradeExtended(trade));
    }

	protected override void OnNewTrade(MarketDataArg trade)
	{
		var totalBars = ChartInfo.PriceChartContainer.TotalBars;

		if (totalBars < 0)
			return;

		if (_useCumulativeTrades)
			return;

		_tradesQueue.TryAdd(trade);
	}

	#endregion

	#region Private methods

	private void StartProcessQueueThread()
	{
		if (_tradesThread != null)
			return;

		_tokenSource = new CancellationTokenSource();

		_tradesThread = new Thread(ProcessQueue)
		{
			Name = "TapePattern",
			IsBackground = true
		};
		_tradesThread.Start();
	}

	private void StopProcessQueueThread()
	{
		_tokenSource?.Cancel();
		_tradesThread = null;
	}

	private void ProcessQueue()
	{
		var token = _tokenSource.Token;

		while (!token.IsCancellationRequested)
		{
			try
			{
				if (ChartInfo == null || !_historyCalculated)
				{
					Thread.Sleep(10);
					continue;
				}

				if (_tradesQueue.TryTake(out var item, 200, token))
				{
                    var isUpdate = false;

                    switch (item)
					{
						case CumTradeExtended cTadeExt:
							if (_lastRenderedTradeExt != null)
								isUpdate = _lastRenderedTradeExt.Owner.IsEqual(cTadeExt.Owner);

							ProcessCumulativeTickExtended(cTadeExt, CurrentBar - 1, isUpdate);

                            break;
						case MarketDataArg mdArg:
							ProcessTickTrade(mdArg);

							break;
						default:
							throw new ArgumentOutOfRangeException(nameof(item), item, null);
					}
				}
			}
			catch (OperationCanceledException)
			{
				break;
			}
			catch (Exception e)
			{
				this.LogError("Trades processing error.", e);
			}
		}
	}

	private void ProcessTickTrade(MarketDataArg trade)
	{
		ProcessTick(trade.Time.AddHours(InstrumentInfo.TimeZone), trade.Price, trade.Volume, trade.Direction, CurrentBar - 1);
	}

    private void SeriesUpdate(int bar)
	{
		RedrawChart();
	}

	private void SetClusterColors()
	{
		var alphaCluster = (byte)Math.Floor(255 * (1 - _clusterTransparency * 0.01m));
		var alphaObject = (byte)Math.Floor(255 * (1 - _objectTransparency * 0.01m));
		_clusterBuy = CrossColor.FromArgb(alphaCluster, BuyColor.R, BuyColor.G, BuyColor.B);
		_clusterSell = CrossColor.FromArgb(alphaCluster, SellColor.R, SellColor.G, SellColor.B);
		_clusterBetween = CrossColor.FromArgb(alphaCluster, BetweenColor.R, BetweenColor.G, BetweenColor.B);

		_objectBuy = CrossColor.FromArgb(alphaObject, BuyColor.R, BuyColor.G, BuyColor.B);
		_objectSell = CrossColor.FromArgb(alphaObject, SellColor.R, SellColor.G, SellColor.B);
		_objectBetween = CrossColor.FromArgb(alphaObject, BetweenColor.R, BetweenColor.G, BetweenColor.B);
	}

	private void ProcessTick(DateTime time, decimal price, decimal volume, TradeDirection direction, int bar)
	{
		if (_useTimeFilter)
		{
			if (_timeFrom < _timeTo)
			{
				if (time < time.Date + _timeFrom || time > time.Date + _timeTo)
					return;
			}
			else
			{
				var condition = time >= time.Date + _timeFrom || time <= time.Date + _timeTo;

				if (!condition)
					return;
			}
		}

		if (volume < _minVol || (volume > _maxVol && _maxVol != 0)) 
			return;

		switch (_calcMode)
		{
			case TicksType.Bid:
				if (direction != TradeDirection.Sell)
					return;

				break;
			case TicksType.Ask:
				if (direction != TradeDirection.Buy)
					return;

				break;
			case TicksType.Between:
				if (direction != TradeDirection.Between)
					return;

				break;
			case TicksType.BidOrAsk:
				if (direction == TradeDirection.Between)
					return;

				break;
		}

		if (_volumesBySize.Count == 0)
			_firstTime = time;

		if (_searchPrintsInsideTimeFilter)
		{
			if (_timeFilter == 0)
			{
				if (time.Second != _firstTime.Second)
				{
					ClearValues();
					_firstTime = time;
					_minPrice = _maxPrice = price;
				}
			}
			else if (time - _firstTime > TimeSpan.FromMilliseconds(_timeFilter))
			{
				ClearValues();
				_firstTime = time;
				_minPrice = _maxPrice = price;
			}
		}
		else if (time - _lastTime > TimeSpan.FromMilliseconds(_timeFilter))
		{
			ClearValues();
			_firstTime = time;
			_minPrice = _maxPrice = price;
		}

		var min = _minPrice;
		var max = _maxPrice;

		if (min == 0 || price < min)
			min = price;

		if (price > max)
			max = price;

		var tickSize = InstrumentInfo.TickSize;

		if (max - min + tickSize > _rangeFilter * tickSize)
		{
			ClearValues();
			_firstTime = time;
			_minPrice = _maxPrice = price;
		}
		else
		{
			_minPrice = min;
			_maxPrice = max;
		}

		_lastTime = time;

		if (direction == TradeDirection.Buy)
			_delta += volume;

		if (direction == TradeDirection.Sell)
			_delta -= volume;

		_cumulativeVol += volume;

		if (!_directions.Contains(direction))
			_directions.Add(direction);

		_count++;

		if (!_volumesBySize.ContainsKey(volume))
			_volumesBySize.Add(volume, 1);
		else
			_volumesBySize[volume]++;

		if (_cumulativeVol < _minCumVol)
			return;

		if (_cumulativeVol > _maxCumVol && _maxCumVol != 0)
		{
			_firstTime = time;
			_minPrice = _maxPrice = price;
			return;
		}

		if (_count < _minCount)
			return;

		if (_calcMode == TicksType.BidAndAsk && _count < 2)
			return;

		if (_count > _maxCount && _maxCount != 0)
		{
			_firstTime = time;
			_minPrice = _maxPrice = price;
			return;
		}

		var clusterSize = _fixedSizes ? _size : (int)Math.Round(_clusterStepSize * _size * _cumulativeVol);
		clusterSize = Math.Min(clusterSize, _maxSize);
		clusterSize = Math.Max(clusterSize, _minSize);

		var objectColor = _delta > 0
			? _objectBuy
			: _delta < 0
				? _objectSell
				: _objectBetween;

		var clusterColor = _delta > 0
			? _clusterBuy
			: _delta < 0
				? _clusterSell
				: _clusterBetween;

		if (_currentTick == null)
		{
			_currentTick = new PriceSelectionValue(price)
			{
				Size = clusterSize,
				VisualObject = VisualType,
				ObjectColor = objectColor,
				PriceSelectionColor = clusterColor,
				MaximumPrice = _maxPrice,
				MinimumPrice = _minPrice,
				Context = direction
			};

			_renderSeries[bar].Add(_currentTick);

			if (bar == ChartInfo.PriceChartContainer.TotalBars && UseAlerts && _historyCalculated
			    &&
			    !_lastTick.Any(x =>
				    (x.MaximumPrice == price || x.MinimumPrice == price) && (TradeDirection)x.Context == direction)
			   )
			{
				var bgColor = _delta > 0
					? _buyColor
					: _delta < 0
						? _sellColor
						: _betweenColor;
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"{price} {direction.GetDisplayName()}", bgColor, CrossColorExtensions.FromRgb(0, 0, 0));
			}
		}

		var printList = () =>
		{
            foreach (var (key, value) in _volumesBySize.Reverse())
                _currentTick.Tooltip += $"{_minimizer.TryGetString(key)} lots x {value}{Environment.NewLine}";
        };

        SetCurrentTickTooltipHead(_delta, _cumulativeVol, _firstTime, printList);
	}

	private void ClearValues()
	{
		_directions.Clear();
		_cumulativeVol = 0;
		_delta = 0;
		_volumesBySize.Clear();
		_count = 0;
		_currentTick = null;
	}

	private void GetTradesHistory(List<CumulativeTrade> trades)
	{
		foreach (var trade in trades.OrderBy(x => x.Time))
		{
			var time = trade.Time;

			for (var i = _lastSession; i <= ChartInfo.PriceChartContainer.TotalBars; i++)
			{
				var candle = GetCandle(i);

				if (candle.Time > time || candle.LastTime < time)
					continue;

				if (_useCumulativeTrades)
				{
					// ProcessCumulativeTick(trade, i, false);

					var cumTradeExt = GetCumTradeExtended(trade);
					ProcessCumulativeTickExtended(cumTradeExt, i, false);
                }
				else
				{
					foreach (var tick in trade.Ticks)
						ProcessTick(tick.Time.AddHours(InstrumentInfo.TimeZone), tick.Price, tick.Volume, tick.Direction, i);
				}

				break;
			}
		}

		_historyCalculated = true;
		RedrawChart();
	}

    private void ProcessCumulativeTickExtended(CumTradeExtended cumTradeExt, int bar, bool isUpdate)
    {
        var time = cumTradeExt.FirstTime.AddHours(InstrumentInfo.TimeZone);
        var direction = cumTradeExt.Direction;
        var price = cumTradeExt.FirstPrice;

        if (_useTimeFilter)
        {
            if (_timeFrom < _timeTo)
            {
                if (time < time.Date + _timeFrom || time > time.Date + _timeTo)
                    return;
            }
            else
            {
                var condition = time >= time.Date + _timeFrom || time <= time.Date + _timeTo;

                if (!condition)
                    return;
            }
        }

        switch (_calcMode)
        {
            case TicksType.Bid:
                if (direction != TradeDirection.Sell)
                    return;

                break;
            case TicksType.Ask:
                if (direction != TradeDirection.Buy)
                    return;

                break;
            case TicksType.Between:
                if (direction != TradeDirection.Between)
                    return;

                break;
            case TicksType.BidOrAsk:
                if (direction == TradeDirection.Between)
                    return;

                break;
        }

		List<decimal> tradeTicks = cumTradeExt.TicksVolumes;

        if (tradeTicks.Any(x => x < _minVol) || (_maxVol != 0 && tradeTicks.Any(x => x > _maxVol)))
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        if (_searchPrintsInsideTimeFilter)
        {
            if (_timeFilter == 0)
            {
                if (cumTradeExt.FirstTime.Second != cumTradeExt.LastTime.Second)
                {
                    TryRemoveCurrentTick(bar, isUpdate);

                    return;
                }
            }
            else if ((cumTradeExt.LastTime - cumTradeExt.FirstTime) > TimeSpan.FromMilliseconds(_timeFilter))
            {
                TryRemoveCurrentTick(bar, isUpdate);

                return;
            }
        }

        var min = Math.Min(cumTradeExt.FirstPrice, cumTradeExt.Lastprice);
        var max = Math.Max(cumTradeExt.FirstPrice, cumTradeExt.Lastprice);
        var tickSize = InstrumentInfo.TickSize;

        if (_rangeFilter > 0 && (Math.Abs(cumTradeExt.FirstPrice - cumTradeExt.Lastprice) / tickSize + 1) > _rangeFilter)
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        if (cumTradeExt.Volume < _minCumVol)
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        if (cumTradeExt.Volume > _maxCumVol && _maxCumVol != 0)
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        if (cumTradeExt.TicksVolumes.Count < _minCount)
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        if (_calcMode == TicksType.BidAndAsk && _count < 2)
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        if (cumTradeExt.TicksVolumes.Count > _maxCount && _maxCount != 0)
        {
            TryRemoveCurrentTick(bar, isUpdate);

            return;
        }

        var clusterSize = _fixedSizes ? _size : (int)Math.Round(_clusterStepSize * _size * cumTradeExt.Volume);
        clusterSize = Math.Min(clusterSize, _maxSize);
        clusterSize = Math.Max(clusterSize, _minSize);

        var delta = cumTradeExt.Volume * (cumTradeExt.Direction is TradeDirection.Buy ? 1 : -1);

        var objectColor = delta > 0
            ? _objectBuy
            : delta < 0
                ? _objectSell
                : _objectBetween;

        var clusterColor = delta > 0
            ? _clusterBuy
            : delta < 0
                ? _clusterSell
                : _clusterBetween;

        if (isUpdate)
        {
            _currentTick.MinimumPrice = min;
            _currentTick.MaximumPrice = max;
        }
        else
        {
            _currentTick = new PriceSelectionValue(price)
            {
                Size = clusterSize,
                VisualObject = VisualType,
                ObjectColor = objectColor,
                PriceSelectionColor = clusterColor,
                MaximumPrice = max,
                MinimumPrice = min,
                Context = direction
            };

            lock (_renderSeries[bar].SyncRoot)
            {
                _renderSeries[bar].Add(_currentTick);
            }

            _lastRenderedTradeExt = cumTradeExt;
        }

        _currentTick.Tooltip = string.Empty;

        var printList = () =>
        {
            foreach (var volTick in tradeTicks.GroupBy(x => x))
                _currentTick.Tooltip += $"{_minimizer.TryGetString(volTick.Key)} lots x {volTick.Count()}{Environment.NewLine}";
        };

        SetCurrentTickTooltipHead(delta, cumTradeExt.Volume, time, printList);

        if (bar == ChartInfo.PriceChartContainer.TotalBars && UseAlerts && _historyCalculated
            &&
            !_lastTick.Any(x =>
                (x.MaximumPrice == price || x.MinimumPrice == price) && (TradeDirection)x.Context == direction)
           )
        {
            var bgColor = _delta > 0
                ? _buyColor
                : _delta < 0
                    ? _sellColor
                    : _betweenColor;
            AddAlert(AlertFile, InstrumentInfo.Instrument, $"{price} {direction.GetDisplayName()}", bgColor, CrossColorExtensions.FromRgb(0, 0, 0));
        }
    }

    private void TryRemoveCurrentTick(int bar, bool isUpdate)
    {
        if (!isUpdate)
            return;

        var result = false;

        lock (_renderSeries[bar].SyncRoot)
        {
            result = _renderSeries[bar].Remove(_currentTick);
        }

        if (!result && bar > 0) // Если не получилось удалить _currentTick, значит он был добавлен на предыдущей свече.
            _ = _renderSeries[bar - 1].Remove(_currentTick); // пробуем удалить его из предыдущей свечи.

        _currentTick = null;
    }

    private void SetCurrentTickTooltipHead(decimal delta, decimal tradeVolume, DateTime time, Action action)
    {
        var newLine = Environment.NewLine;
        var deltaPerc = 0m;

        if (delta != 0)
            deltaPerc = delta * 100 / tradeVolume;
		
        _currentTick.Tooltip = "Tape Patterns" + newLine;
        _currentTick.Tooltip += $"Volume = {_minimizer.TryGetString(tradeVolume)}{newLine}";
        _currentTick.Tooltip += $"Delta = {_minimizer.TryGetString(delta)} [{deltaPerc:F}%]{newLine}";
        _currentTick.Tooltip += $"Time: {time}{newLine}";
        _currentTick.Tooltip += $"Ticks:{newLine}";
        action();
        _currentTick.Tooltip += $"{new string('-', 20)}{newLine}";
    }

    private CumTradeExtended GetCumTradeExtended(CumulativeTrade trade)
    {
		var cumTradeExt = new CumTradeExtended(trade)
		{
			FirstPrice = trade.FirstPrice,
			Lastprice = trade.Lastprice,
			FirstTime = trade.Time,
			LastTime = trade.Ticks.Last().Time,
			Volume = trade.Volume,
			Direction = trade.Direction,
			TicksVolumes = trade.Ticks.Select(t => t.Volume).ToList()
		};

		return cumTradeExt;
    }

    #endregion
}






Technical/Technical.csproj







<Project>

  <PropertyGroup>
    <TargetFramework>net46</TargetFramework>
    <RootNamespace>ATAS.Indicators.Technical</RootNamespace>
    <AssemblyName>ATAS.Indicators.Technical</AssemblyName>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    <LangVersion>latest</LangVersion>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk.WindowsDesktop" />
  <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk.WindowsDesktop" />
  <ItemGroup>
    <Compile Remove="Resources\**" />
    <EmbeddedResource Remove="Resources\**" />
    <None Remove="Resources\**" />
    <Page Remove="Resources\**" />
  </ItemGroup>


  <ItemGroup>
    <Reference Include="Newtonsoft.Json">
      <HintPath>C:\Program Files (x86)\ATAS Platform\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="OFT.Attributes">
      <HintPath>C:\Program Files (x86)\ATAS Platform\OFT.Attributes.dll</HintPath>
    </Reference>
    <Reference Include="OFT.Editors">
      <HintPath>C:\Program Files (x86)\ATAS Platform\OFT.Editors.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.DataAnnotations" />

    <Reference Include="ATAS.DataFeedsCore">
      <HintPath>C:\Program Files (x86)\ATAS Platform\ATAS.DataFeedsCore.dll</HintPath>
    </Reference>
    <Reference Include="ATAS.Indicators">
      <HintPath>C:\Program Files (x86)\ATAS Platform\ATAS.Indicators.dll</HintPath>
    </Reference>
    <Reference Include="OFT.Rendering">
      <HintPath>C:\Program Files (x86)\ATAS Platform\OFT.Rendering.dll</HintPath>
    </Reference>
    <Reference Include="Utils.Common">
      <HintPath>C:\Program Files (x86)\ATAS Platform\Utils.Common.dll</HintPath>
    </Reference>
  </ItemGroup>

  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>PublicResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>







Technical/TradesOnChart.cs






namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Linq;
using ATAS.DataFeedsCore;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Tools;

using Color = System.Drawing.Color;
using DashStyle = System.Drawing.Drawing2D.DashStyle;
using Pen = OFT.Rendering.Tools.RenderPen;

[HelpLink("https://help.atas.net/en/support/solutions/articles/72000633119")]
[Category(IndicatorCategories.Trading)]
[DisplayName("Trades On Chart")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.TradesOnChartDescription))]
public class TradesOnChart : Indicator
{
    #region Nested Types

    internal class TradeObj
    {
        internal int OpenBar { get; set; }
        internal decimal OpenPrice { get; set; }
        internal int CloseBar { get; set; }
        internal decimal ClosePrice { get; set; }
        internal OrderDirections Direction { get; set; }
		internal decimal PnL { get; set; }
		internal decimal PnLTicks { get; set; }
		internal DateTime OpenTime { get; set; }
		internal DateTime CloseTime { get; set; }
        internal decimal Volume { get; set; }
        internal string Security { get; set; }


		public TradeObj(HistoryMyTrade trade)
		{
			OpenPrice = trade.OpenPrice;
			ClosePrice = trade.ClosePrice;
			Direction = trade.OpenVolume > 0 ? OrderDirections.Buy : OrderDirections.Sell;
			PnL = trade.PnL;
			PnLTicks = trade.TicksPnL;
			OpenTime = trade.OpenTime;
			CloseTime = trade.CloseTime;
			Volume = Math.Abs(trade.OpenVolume);
			Security = trade.Security.Code;
		}
    }

    #endregion

    #region Fields

    private RenderFont _font = new RenderFont("Arial", 10F, FontStyle.Regular, GraphicsUnit.Point, 204);
    private RenderStringFormat _stringFormat = new RenderStringFormat() { Alignment = StringAlignment.Near, LineAlignment = StringAlignment.Center };
    private readonly List<TradeObj> _trades = new();
    private Pen _buyPen;
    private Pen _sellPen;
    private Color _buyColor;
    private Color _sellColor;
    private float _lineWidth = 2f;
    private DashStyle _lineStyle = DashStyle.Dash;

    #endregion

    #region Properties

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowLines), GroupName = nameof(Strings.Visualization))]
    public bool ShowLine { get; set; } = true;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDescription), GroupName = nameof(Strings.Visualization))]
    public bool ShowTooltip { get; set; } = true;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BuyColor), GroupName = nameof(Strings.Visualization))]
    public Color BuyColor 
    {
        get => _buyColor;
        set
        {
            _buyColor = value;
            _buyPen = GetNewPen(_buyColor, _lineWidth, _lineStyle);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SellColor), GroupName = nameof(Strings.Visualization))]
    public Color SellColor 
    { 
        get => _sellColor;
        set
        {
            _sellColor = value;
            _sellPen = GetNewPen(_sellColor, _lineWidth, _lineStyle);
        }
    }

    [Range(1, 20)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Visualization))]
    public float LineWidth 
    { 
        get => _lineWidth; 
        set
        {
            _lineWidth = value;
            _buyPen = GetNewPen(_buyColor, _lineWidth, _lineStyle);
            _sellPen = GetNewPen(_sellColor, _lineWidth, _lineStyle);
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DashStyle), GroupName = nameof(Strings.Visualization))]
    public DashStyle LineStyle 
    {
        get => _lineStyle;
        set
        {
            _lineStyle = value;
            _buyPen = GetNewPen(_buyColor, _lineWidth, _lineStyle);
            _sellPen = GetNewPen(_sellColor, _lineWidth, _lineStyle);
        }
    }

    [Range(1, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Size), GroupName = nameof(Strings.Visualization))]
    public int MarkerSize { get; set; } = 2;

    #endregion

    #region ctor

    public TradesOnChart() : base(true)
    {
        DenyToChangePanel = true;
        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

        SubscribeToDrawingEvents(DrawingLayouts.Final);
        EnableCustomDrawing = true;
    }

    #endregion

    #region Protected Methods

    protected override void OnInitialize()
    {
        TradingStatisticsProvider.Realtime.HistoryMyTrades.Added += OnTradeAdded;
        TradingManager.PortfolioSelected += TradingManager_PortfolioSelected;

        OnRecalculate();
    }

    private void TradingManager_PortfolioSelected(Portfolio obj)
    {
	    OnRecalculate();
    }

    protected override void OnApplyDefaultColors()
    {
        if (ChartInfo is null) return;

        BuyColor = ChartInfo.ColorsStore.BuyOrdersColor;
        SellColor = ChartInfo.ColorsStore.SellOrdersColor;
    }

    protected override void OnRecalculate()
    {
        _buyPen = GetNewPen(_buyColor, _lineWidth, _lineStyle);
        _sellPen = GetNewPen(_sellColor, _lineWidth, _lineStyle);

        _trades.Clear();
        AddHistoryMyTrade();
    }

    protected override void OnCalculate(int bar, decimal value)
    {
       
    }

    #region Rendering

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
        if (ChartInfo is null) return;

        DrawTrades(context);
    }

    private void DrawTrades(RenderContext context)
    {
        List<(string Text, Color FillColor)> tooltips = new();

	    foreach (var trade in _trades)
	    {
	        if (trade.OpenBar > LastVisibleBarNumber || trade.CloseBar < FirstVisibleBarNumber)
                continue;

            var x1 = ChartInfo.GetXByBar(trade.OpenBar, false);
            var y1 = ChartInfo.GetYByPrice(trade.OpenPrice, false);
            var x2 = ChartInfo.GetXByBar(trade.CloseBar, false);
            var y2 = ChartInfo.GetYByPrice(trade.ClosePrice, false);
            var pen = GetPenByDirection(trade.Direction);

            if(ShowLine)
				context.DrawLine(pen, x1, y1, x2, y2);

            var mouseOver = DrawMarker(context, new Point(x1, y1), trade.Direction, true);

            var mouseOver2 = DrawMarker(context, new Point(x2, y2), trade.Direction, false);

            if (ShowTooltip && (mouseOver || mouseOver2))
            {
                var cl = trade.PnL > 0 ? _buyColor : _sellColor;

                var text = (trade.Direction == OrderDirections.Buy ? "Long" : "Short") + " " +
                    trade.Volume.ToString() + " " + trade.Security + Environment.NewLine + Environment.NewLine;

                text += $"Entry\t:  {ChartInfo.GetPriceString(trade.OpenPrice)} | {trade.OpenTime:dd MMM HH:mm:ss}{Environment.NewLine}";
                text += $"Exit\t:  {ChartInfo.GetPriceString(trade.ClosePrice)} | {trade.CloseTime:dd MMM HH:mm:ss}{Environment.NewLine}{Environment.NewLine}";
                text += $"Result\t: {(trade.PnL > 0 ? "+" : "")}{trade.PnL} ({trade.PnLTicks} ticks)";

                tooltips.Add((text, cl));
            }
        }

	    if (tooltips.Any())
	    {
		    var size = context.MeasureString(tooltips.First().Text, _font);
		    size = new Size(size.Width + 20, size.Height + 20);
		    var totalHeight = tooltips.Count * (size.Height + 5);

		    var y = MouseLocationInfo.LastPosition.Y;

            if(y + totalHeight> Container.Region.Height)
                y = Container.Region.Height- totalHeight;

            foreach (var tooltip in tooltips)
		    {
			    size = context.MeasureString(tooltip.Text, _font);
			    size = new Size(size.Width + 20, size.Height + 20);
			    var rectangle = new Rectangle(MouseLocationInfo.LastPosition.X, y, size.Width, size.Height);
			    context.FillRectangle(tooltip.FillColor, rectangle, 10);
			    rectangle.X += 10;
			    context.DrawString(tooltip.Text, _font, Color.AliceBlue, rectangle, _stringFormat);

			    y += size.Height + 5;
		    }
        }
    }

    private bool DrawMarker(RenderContext context, Point point, OrderDirections direction, bool isOpen)
    {
        var shift = MarkerSize * 4;
        var dir = direction == OrderDirections.Buy ? 1 : -1;
        var y2 = isOpen ? (point.Y + shift * dir) : (point.Y + shift * (-dir));
        var point2 = new Point(point.X - shift, y2);
        var point3 = new Point(point2.X + shift * 2, point2.Y);
        var color = GetMarkerColor(direction, isOpen);

        var points = new Point[] { point, point2, point3 };

        context.FillPolygon(color, points);

        context.DrawPolygon(ChartInfo.ColorsStore.Grid, points);

        if (IsPointInTriangle(MouseLocationInfo.LastPosition, point, point2, point3))
        {
            return true;
        }

        return false;
    }

    #endregion

    #endregion

    #region Private Methods

    private void AddHistoryMyTrade()
    {
	    if (TradingManager?.Portfolio == null|| TradingManager?.Security == null)
            return;

	    var allTrades = TradingStatisticsProvider?.Realtime?.HistoryMyTrades
		    .Where(t => 
                t.AccountID == TradingManager.Portfolio.AccountID && 
                t.Security.SecurityId.Equals(TradingManager.Security.SecurityId, StringComparison.InvariantCultureIgnoreCase));

	    foreach (var trade in allTrades)
	    {
		    CreateTradePair(trade);
	    }
    }

    private void OnTradeAdded(HistoryMyTrade trade)
    {
	    if (TradingManager?.Portfolio == null || TradingManager?.Security == null)
		    return;

        if (trade.AccountID == TradingManager.Portfolio.AccountID && trade.Security.Instrument == TradingManager.Security.Instrument)
		    CreateTradePair(trade);        
    }

    private void CreateTradePair(HistoryMyTrade trade)
    {
        var enterBar = GetBarByTime(trade.OpenTime);

        if (enterBar < 0) return;

        var exitBar = GetBarByTime(trade.CloseTime);

        var tradeObj = new TradeObj(trade)
        {
            OpenBar = enterBar,
            CloseBar = exitBar,
        };

        _trades.Add(tradeObj);
    }

    private int GetBarByTime(DateTime time)
    {
        for (int i = CurrentBar - 1; i >= 0; i--) 
        {
            var candle = GetCandle(i);

            if (candle.Time <= time)
                return i;
        }

        return -1;
    }

    private bool IsPointInTriangle(Point p, Point p0, Point p1, Point p2)
    {
	    double area = TriangleArea(p0, p1, p2);
	    double area1 = TriangleArea(p, p0, p1);
	    double area2 = TriangleArea(p, p1, p2);
	    double area3 = TriangleArea(p, p2, p0);

	    return Math.Abs(area - (area1 + area2 + area3)) < 0.001;
    }

    private double TriangleArea(Point p0, Point p1, Point p2)
    {
	    return Math.Abs((p0.X * (p1.Y - p2.Y) + p1.X * (p2.Y - p0.Y) + p2.X * (p0.Y - p1.Y)) / 2.0);
    }

    private Color GetMarkerColor(OrderDirections direction, bool isOpen)
    {
        return direction switch
        {
            OrderDirections.Buy => isOpen ? _buyColor : _sellColor,
            OrderDirections.Sell => isOpen ? _sellColor : _buyColor,
            _ => Color.Transparent
        };
    }

    private Pen GetPenByDirection(OrderDirections directions)
    {
        return directions switch
        {
            OrderDirections.Buy => _buyPen,
            _ => _sellPen,
        };
    }

    private Pen GetNewPen(Color color, float lineWidth, DashStyle lineStyle)
    {
        return new Pen(color, lineWidth) { DashStyle = lineStyle };
    }

    #endregion
}








Technical/TrueRange.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("True Range")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.TrueRangeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602234")]
	public class TrueRange : Indicator
	{
		#region ctor

		public TrueRange()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var highLow = candle.High - candle.Low;
			var highCloseDiff = Math.Abs(candle.High - prevCandle.Close);
			var lowCloseDiff = Math.Abs(candle.Low - prevCandle.Close);

			var trueRange = Math.Max(highLow, highCloseDiff);
			trueRange = Math.Max(trueRange, lowCloseDiff);

			this[bar] = trueRange;
		}

		#endregion
	}
}








Technical/UltimateOscillator.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Ultimate Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.UltimateOscillatorDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602494")]
	public class UltimateOscillator : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _closeLowSeries = new("CloseLow");
		private readonly ValueDataSeries _highLowSeries = new("HighLow");

		private int _period1 = 5;
        private int _period2 = 10;
        private int _period3 = 15;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period1), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period1
		{
			get => _period1;
			set
			{
				_period1 = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period2), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int Period2
		{
			get => _period2;
			set
			{
				_period2 = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period3), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 120)]
		[Range(1, 10000)]
        public int Period3
		{
			get => _period3;
			set
			{
				_period3 = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public UltimateOscillator()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			var th = candle.High > prevCandle.Close
				? candle.High
				: prevCandle.Close;

			var tl = candle.Low < prevCandle.Close
				? candle.Low
				: prevCandle.Close;

			_closeLowSeries[bar] = candle.Close - tl;
			_highLowSeries[bar] = th - tl;

			var closeLow1 = _closeLowSeries.CalcSum(_period1, bar);
			var highLow1 = _highLowSeries.CalcSum(_period1, bar);

			var closeLow2 = _closeLowSeries.CalcSum(_period2, bar);
			var highLow2 = _highLowSeries.CalcSum(_period2, bar);

			var closeLow3 = _closeLowSeries.CalcSum(_period3, bar);
			var highLow3 = _highLowSeries.CalcSum(_period3, bar);

			this[bar] = 100 / 7m * (4 * closeLow1 / highLow1 + 2 * closeLow2 / highLow2 + closeLow3 / highLow3);
		}

		#endregion
	}
}







Technical/UnfinishedAuction.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;
	using System.Linq;

	using ATAS.Indicators.Drawing;
	using ATAS.Indicators.Technical.Extensions;

	using OFT.Attributes;
    using OFT.Localization;
    using Pen = System.Drawing.Pen;
	
    [DisplayName("Unfinished Auction")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.UnfinishedAuctionModDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602495")]
	public class UnfinishedAuctionMod : Indicator
	{
		#region Fields

		private readonly PriceSelectionDataSeries _priceSelectionSeries = new("PriceSelectionSeries", "Clusters Selection");
		private int _askFilter = 20;

		private int _bidFilter = 20;
		private int _days;
		private CrossColor _highColor = System.Drawing.Color.Red.Convert();
		private CrossColor _highLineColor = System.Drawing.Color.Crimson.Convert();
		private int _lastAlert;
		private int _lastBar;
		private int _lineWidth;
		private CrossColor _lowColor = System.Drawing.Color.Blue.Convert();

		private CrossColor _lowLineColor = System.Drawing.Color.Aqua.Convert();
		private int _targetBar;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.BidFilter), Description = nameof(Strings.MinBidVolumeFilterCommonDescription))]
        [Range(0, 1000000)]
        public int BidFilter
        {
            get => _bidFilter;
            set
            {
                _bidFilter = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.AskFilter), Description = nameof(Strings.MinAskVolumeFilterCommonDescription))]
        [Range(0, 1000000)]
        public int AskFilter
        {
            get => _askFilter;
            set
            {
                _askFilter = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        public int Days
		{
			get => _days;
			set
			{
				if (value < 0)
					return;

				_days = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LineWidthDescription))]
		[Range(1, 1000)]
		public int LineWidth
		{
			get => _lineWidth;
			set
			{
				_lineWidth = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LowLineColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LineColorDescription))]

		public CrossColor LowLineColor
		{
			get => _lowLineColor;
			set
			{
				_lowLineColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighLineColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.LineColorDescription))]
		public CrossColor HighLineColor
		{
			get => _highLineColor;
			set
			{
				_highLineColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.LowColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PriceSelectionColorDescription))]
		public CrossColor LowColor
		{
			get => _lowColor;
			set
			{
				_lowColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HighColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.PriceSelectionColorDescription))]
		public CrossColor HighColor
		{
			get => _highColor;
			set
			{
				_highColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertsDescription), Order = 300)]
		public bool UseAlerts { get; set; }

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription),  Order = 310)]
		public string AlertFile { get; set; } = "alert1";

		#endregion

		#region ctor

		public UnfinishedAuctionMod()
			: base(true)
		{
			DataSeries[0]          = _priceSelectionSeries;
			DataSeries[0].IsHidden = true;
			const byte alpha = 150;

			_highLineColor.SetAlpha(alpha);
			_highColor.SetAlpha(alpha);
			_lowLineColor.SetAlpha(alpha);
			_lowColor.SetAlpha(alpha);

			_lineWidth        = 10;
			_days             = 20;
			DenyToChangePanel = true;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				TrendLines.Clear();
				DataSeries.ForEach(x => x.Clear());
				_targetBar = 0;

				if (_days <= 0)
					return;

				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}

				return;
			}

			if (bar - 1 < _targetBar || _lastBar == bar)
				return;

			if (bar == CurrentBar - 1 && HorizontalLinesTillTouch.Count is not 0)
			{
				for (var i = HorizontalLinesTillTouch.Count - 1; i >= 0; i--)
				{
					var line = HorizontalLinesTillTouch[i];

					if (line.FirstBar < bar - 1)
						break;

					HorizontalLinesTillTouch.RemoveAt(i);
				}
			}

			CalculateAuctionAt(bar - 1);
			_lastBar = bar;
		}

		#endregion

		#region Private methods

		private void SendAlert(TradeDirection dir, decimal price)
		{
			if (_lastAlert == CurrentBar - 1)
				return;

			var alertText = dir != TradeDirection.Between
				? $"Unfinished Auction ({(dir == TradeDirection.Buy ? "Low" : "High")} Zone on {price:0.######})"
				: $"Unfinished Auction Zone closed on {price:0.######}";

			AddAlert(AlertFile, alertText);
			_lastAlert = CurrentBar - 1;
		}

		private void CalculateAuctionAt(int bar)
		{
			var candle = GetCandle(bar);

			var priceSelectionValues = _priceSelectionSeries[bar];
			priceSelectionValues.Clear();

			for (var i = HorizontalLinesTillTouch.Count - 1; i >= 0; i--)
			{
				var line = HorizontalLinesTillTouch[i];

				if (candle.High >= line.FirstPrice && candle.Low <= line.FirstPrice)
				{
					line.SecondBar = bar;
					line.IsRay = false;

					if (UseAlerts && bar == CurrentBar - 2)
						SendAlert(TradeDirection.Between, line.FirstPrice);

					TrendLines.Add(line);
					HorizontalLinesTillTouch.RemoveAt(i);

					var value = line.FirstPrice;
					var cl = System.Drawing.Color.Black.Convert();

					if (line.FirstBar == bar)
						cl = value == candle.Low ? _lowColor : _highColor;
					else
					{
						var val = _priceSelectionSeries[line.FirstBar].FirstOrDefault(t => t.MinimumPrice == value);

						if (val != null)
							cl = val.ObjectColor;
					}

					priceSelectionValues.Add(new PriceSelectionValue(value)
					{
						VisualObject = ObjectType.OnlyCluster,
						ObjectColor = cl,
						Size = 100,
						PriceSelectionColor = cl
					});
				}
			}

			//Ищем новые начала трендовых
			var candlePvLow = candle.GetPriceVolumeInfo(candle.Low);
			var candlePvHigh = candle.GetPriceVolumeInfo(candle.High);

			if ((candlePvLow?.Ask ?? 0) > 0 && candlePvLow.Bid > _bidFilter)
			{
				var lowPenColor = System.Drawing.Color.FromArgb(_lowLineColor.A, _lowLineColor.R, _lowLineColor.G, _lowLineColor.B);

				var lowPen = new Pen(lowPenColor)
				{
					Width = _lineWidth
				};

				var tt = new LineTillTouch(bar, candle.Low, lowPen)
				{
					IsRay = true
				};

				HorizontalLinesTillTouch.Add(tt);

				if (UseAlerts && bar == CurrentBar - 2)
					SendAlert(TradeDirection.Buy, candle.Low);
			}

			if (candlePvHigh != null && candlePvHigh.Ask > _askFilter && candlePvHigh.Bid > 0)
			{
				var highPenColor = System.Drawing.Color.FromArgb(_highLineColor.A, _highLineColor.R, _highLineColor.G, _highLineColor.B);

				var highPen = new Pen(highPenColor)
				{
					Width = _lineWidth
				};

				var tt = new LineTillTouch(bar, candle.High, highPen)
				{
					IsRay = true
				};

				HorizontalLinesTillTouch.Add(tt);

				if (UseAlerts && bar == CurrentBar - 2)
					SendAlert(TradeDirection.Sell, candle.High);
			}

			for (var i = HorizontalLinesTillTouch.Count - 1; i >= 0; i--)
			{
				var trendLine = HorizontalLinesTillTouch[i];

				if (trendLine.FirstBar < bar)
					break;

				var value = trendLine.FirstPrice;
				var cl = value == candle.Low ? _lowColor : _highColor;

				priceSelectionValues.Add(new PriceSelectionValue(value)
				{
					VisualObject = ObjectType.OnlyCluster,
					ObjectColor = cl,
					Size = 100,
					PriceSelectionColor = cl
				});
			}
		}

		#endregion
	}
}






Technical/UpDownVolumeRatio.cs









using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;
using Color = System.Drawing.Color;


namespace ATAS.Indicators.Technical
{
    [DisplayName("Up/Down Volume Ratio")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.UpDownVolumeRatioDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000619242")]
    public class UpDownVolumeRatio : Indicator
    {
        #region Nested Types

        public enum CalculationMode
        {
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UpDownVolume))]
            UpDownVolume,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AskBidVolume))]
            AskBidVolume
        }

        public enum MovingType
        {
            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.EMA))]
            Ema,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LinearReg))]
            LinReg,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WMA))]
            Wma,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA))]
            Sma,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.WWMA))]
            Wwma,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SZMA))]
            Szma,

            [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMMA))]
            Smma
        }

        #endregion

        #region Fields

        private readonly ValueDataSeries _data = new("Data", Strings.Volume)
        {
            IsHidden = true,
            VisualType = VisualMode.Histogram,
            ShowZeroValue = false
        };

        private EMA _ema;
        private LinearReg _linReg;
        private WMA _wma;
        private SMA _sma;
        private WWMA _wwma;
        private SZMA _szma;
        private SMMA _smma;
        private Color _histogramColor = DefaultColors.Blue;

        private CalculationMode _calcMode;
        private int _period = 10;
        private MovingType _movType;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.CalculationModeDescription))]
        public CalculationMode CalcMode
        {
            get => _calcMode;
            set
            {
                _calcMode = value;
                RecalculateValues();
            }
        }

        [Parameter]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.PeriodDescription))]
        public int Period
        {
            get => _period;
            set
            {
                _period = value;
                SetPeriod(value);
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MovingType), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.MovingTypeDescription))]
        public MovingType MovType
        {
            get => _movType;
            set
            {
                _movType = value;
                RecalculateValues();
            }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColorDescription))]
        public Color HistogramColor
        {
            get => _histogramColor;
            set
            {
                _histogramColor = value;
                _data.Color = value.Convert();
            }
        }

        #endregion

        #region ctor

        public UpDownVolumeRatio() : base(true)
        {
            Panel = IndicatorDataProvider.NewPanel;
            DenyToChangePanel = true;

            DataSeries[0] = _data;
            _data.Color = _histogramColor.Convert();

        }

        #endregion

        #region Protected Methods

        protected override void OnRecalculate()
        {
            switch (_movType)
            {
                case MovingType.Ema:
                    _ema = new();
                    _ema.Period = _period;
                    break;
                case MovingType.LinReg:
                    _linReg = new();
                    _linReg.Period = _period;
                    break;
                case MovingType.Wma:
                    _wma = new();
                    _wma.Period = _period;
                    break;
                case MovingType.Sma:
                    _sma = new();
                    _sma.Period = _period;
                    break;
                case MovingType.Wwma:
                    _wwma = new();
                    _wwma.Period = _period;
                    break;
                case MovingType.Szma:
                    _szma = new();
                    _szma.Period = _period;
                    break;
                case MovingType.Smma:
                    _smma = new();
                    _smma.Period = _period;
                    break;
            }
        }

        protected override void OnCalculate(int bar, decimal value)
        {
            var candle = GetCandle(bar);
            var udRatio = GetUDRatio(candle);
            SetMovingAverage(bar, udRatio);
        }

        #endregion

        #region Private Methods

        private void SetMovingAverage(int bar, decimal ratio)
        {
            switch (_movType)
            {
                case MovingType.Ema:
                    _data[bar] = _ema.Calculate(bar, ratio);
                    break;
                case MovingType.LinReg:
                    _data[bar] = _linReg.Calculate(bar, ratio);
                    break;
                case MovingType.Wma:
                    _data[bar] = _wma.Calculate(bar, ratio);
                    break;
                case MovingType.Sma:
                    _data[bar] = _sma.Calculate(bar, ratio);
                    break;
                case MovingType.Wwma:
                    _data[bar] = _wwma.Calculate(bar, ratio);
                    break;
                case MovingType.Szma:
                    _data[bar] = _szma.Calculate(bar, ratio);
                    break;
                case MovingType.Smma:
                    _data[bar] = _smma.Calculate(bar, ratio);
                    break;
            }
        }

        private decimal GetUDRatio(IndicatorCandle candle)
        {
            var udr = 0m;

            switch (_calcMode)
            {
                case CalculationMode.UpDownVolume:
                    udr = UpDownVolumeCalc(candle);
                    break;
                case CalculationMode.AskBidVolume:
                    udr = AskBidVolumeCalc(candle); 
                    break;
            }

            return udr;
        }

        private decimal AskBidVolumeCalc(IndicatorCandle candle)
        {
            var ascs = candle.Ask;
            var bids = candle.Bid;

            return ascs + bids == 0
                 ? 0
                 : 100 * (ascs - bids) / (ascs + bids);
        }

        private decimal UpDownVolumeCalc(IndicatorCandle candle)
        {
            var upVolume = candle.Open < candle.Close ? candle.Volume : 0;
            var downVolume = candle.Open > candle.Close ? candle.Volume : 0;

            return upVolume + downVolume == 0
                 ? 0
                 : 100 * (upVolume - downVolume) / (upVolume + downVolume);
        }

        private void SetPeriod(int period)
        {
            switch (_movType)
            {
                case MovingType.Ema:
                    if (_ema != null)
                        _ema.Period = period;
                    break;
                case MovingType.LinReg:
                    if (_linReg != null)
                        _linReg.Period = period;
                    break;
                case MovingType.Wma:
                    if (_wma != null)
                        _wma.Period = period;
                    break;
                case MovingType.Sma:
                    if (_sma != null) 
                        _sma.Period = period;
                    break;
                case MovingType.Wwma:
                    if (_wma != null)
                        _wwma.Period = period;
                    break;
                case MovingType.Szma:
                    if (_szma != null)
                        _szma.Period = period;
                    break;
                case MovingType.Smma:
                    if (_smma != null)
                        _smma.Period = period;
                    break;
            }
        }

        #endregion
    }
}








Indicators/Technical
/VBRR.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Volume Bar Range Ratio")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VBRRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602499")]
	public class VBRR : Indicator
	{
		#region ctor

		public VBRR()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			if (bar == 0)
				return;

			this[bar] = candle.High != candle.Low
				? candle.Volume / (candle.High - candle.Low)
				: this[bar - 1];
		}

		#endregion
	}
}








Technical/VPF.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using Utils.Common.Logging;

[DisplayName("Voss Predictive Filter")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VPFDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602500")]
public class VPF : Indicator
{
	#region Fields

	private readonly ValueDataSeries _flit = new("FlitId", "Flit")
	{
		Color = System.Drawing.Color.DodgerBlue.Convert(),
		Width = 2,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
        DescriptionKey = nameof(Strings.EstimatorLineSettingsDescription)
    };

	private readonly ValueDataSeries _voss = new("VossId", "Voss")
	{
		Color = System.Drawing.Color.Red.Convert(),
		Width = 2,
		ShowZeroValue = false,
		UseMinimizedModeIfEnabled = true,
        DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
    };

	private decimal _bandWidth = 0.25m;
	private int _order;

	private int _period = 20;
	private int _predict = 3;

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
	[Range(1, 100000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Predict), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PredictBarsCountDescription))]
	[Range(1, 1000000)]
	public int Predict
	{
		get => _predict;
		set
		{
			_predict = value;
			_order = _predict * 3;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BBandsWidth), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MultiplierDescription))]
	[Range(0, 4)]
	public decimal BandsWidth
	{
		get => _bandWidth;
		set
		{
			_bandWidth = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public VPF()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;
		DenyToChangePanel = true;

		DataSeries[0] = _voss;
		DataSeries.Add(_flit);
		LineSeries.Add(new LineSeries("ZeroLineId", "ZeroLine")
		{
			Value = 0,
			Color = DefaultColors.Silver.Convert(),
			DescriptionKey = nameof(Strings.ZeroLineDescription)
		});
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		if (bar == 0)
		{
			_voss.Clear();
			_flit.Clear();
		}

		if (bar < _order)
			return;

		var f1 = Math.Cos(2.0 * Math.PI / Period);
		var g1 = Math.Cos(Convert.ToDouble(BandsWidth) * 2.0 * Math.PI / Period);

		var s1 = 1.0 / g1 - Math.Sqrt(1.0 / (g1 * g1) - 1.0);
		var s2 = 1.0 + s1;
		var s3 = 1.0 - s1;

		var x1 = GetCandle(bar).Close - GetCandle(bar - 2).Close;
		var x2 = (3.0 + _order) / 2.0;

		var sumC = 0.0;

		for (var i = 0; i < _order; i++)
			sumC += (i + 1.0) / _order * Convert.ToDouble(_voss[bar - _order + i]);

		try
		{
			var flitValue = Math.Round(
				0.5 * s3 * (double)x1 + f1 * s2 * (double)_flit[bar - 1] - s1 * (double)_flit[bar - 2],
				5);
			_flit[bar] = (decimal)flitValue;

			var vossValue = x2 * flitValue - sumC;
			_voss[bar] = (decimal)vossValue;
		}
		catch (Exception e)
		{
			this.LogError($"{e.Message}", e);
		}
	}

	#endregion
}







Technical/VWAP.cs







namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("VWAP/TWAP")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VWAPDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602503")]
public class VWAP : Indicator
{
    #region Nested types

    public enum VWAPMode
    {
        VWAP = 0,
        TWAP = 1
    }

    public enum VWAPPeriodType
    {
        M15,
        M30,
        Hourly,
        H4,
        Daily,
        Weekly,
        Monthly,
        All,
        Custom
    }

    public enum VolumeType
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Total))]
        Total,
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
        Bid,
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
        Ask
    }

    #endregion

    #region Fields

    private static readonly VisualMode _upperLowerDefaultMode = VisualMode.Hide;
    private static readonly CrossColor _upperLowerDefaultColor = GetColorFromHex("#FF00BCD4");
    private static readonly CrossColor _upperFillDefaultColor = GetColorFromHex("#40C30101");
    private static readonly CrossColor _middleFillDefaultColor = GetColorFromHex("#40808080");
    private static readonly CrossColor _lowerFillDefaultColor = GetColorFromHex("#4000FF00");

    private readonly ValueDataSeries _lower = new("Lower", Strings.LowerStd1) 
    {
        Color = _upperLowerDefaultColor,
        VisualType = _upperLowerDefaultMode
    };

    private readonly ValueDataSeries _lower1 = new("Lower1", Strings.LowerStd2) 
    {
        Color = _upperLowerDefaultColor,
        VisualType = _upperLowerDefaultMode
    };

    private readonly ValueDataSeries _lower2 = new("Lower2", Strings.LowerStd3)
    { 
        Color = _upperLowerDefaultColor, 
        VisualType = _upperLowerDefaultMode
    };

    private readonly ValueDataSeries _upper = new("Upper", Strings.UpperStd1)
    {
        Color = _upperLowerDefaultColor,
        VisualType = _upperLowerDefaultMode
    };

    private readonly ValueDataSeries _upper1 = new("Upper1", Strings.UpperStd2)
    {
        Color = _upperLowerDefaultColor,
        VisualType = _upperLowerDefaultMode
    };

    private readonly ValueDataSeries _upper2 = new("Upper2", Strings.UpperStd3)
    {
        Color = _upperLowerDefaultColor,
        VisualType = _upperLowerDefaultMode
    };

    private readonly RangeDataSeries _lower2Background = new("Lower2Background", Strings.LowerFill2)
    {
        RangeColor = _lowerFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false
    };

    private readonly RangeDataSeries _lower2BackgroundRes = new("Lower2BackgroundRes", "Lower Fill 2 res")
    {
        RangeColor = _lowerFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
        IsHidden = true
    };

    private readonly RangeDataSeries _lowerBackground = new("LowerBackground", Strings.LowerFill)
    {
        RangeColor = _lowerFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false
    };

    private readonly RangeDataSeries _lowerBackgroundRes = new("LowerBackgroundRes", "Lower Fill res")
    {
        RangeColor = _lowerFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
        IsHidden = true
    };

    private readonly RangeDataSeries _midDownBackground = new("MidDownBackground", Strings.MiddleFillDown)
    {
        RangeColor = _middleFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false
    };

    private readonly RangeDataSeries _midDownBackgroundRes = new("MidDownBackgroundRes", "Middle Fill Down res")
    {
        RangeColor = _middleFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
        IsHidden = true
    };

    private readonly RangeDataSeries _midUpBackground = new("MidUpBackground", Strings.MiddleFillUp)
    {
        RangeColor = _middleFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
    };

    private readonly RangeDataSeries _midUpBackgroundRes = new("MidUpBackgroundRes", "Middle Fill Up Res")
    {
        RangeColor = _middleFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
        IsHidden = true
    };

    private readonly RangeDataSeries _upper2Background = new("Upper2Background", Strings.UpperFill2)
    {
        RangeColor = _upperFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false
    };

    private readonly RangeDataSeries _upper2BackgroundRes = new("Upper2BackgroundRes", "Upper Fill 2 res")
    {
        RangeColor = _upperFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
        IsHidden = true
    };

    private readonly RangeDataSeries _upperBackground = new("UpperBackground", Strings.UpperFill)
    {
        RangeColor = _upperFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false
    };

    private readonly RangeDataSeries _upperBackgroundRes = new("UpperBackgroundRes", "Upper Fill res")
    {
        RangeColor = _upperFillDefaultColor,
        DrawAbovePrice = false,
        Visible = false,
        IsHidden = true
    };

    private readonly ValueDataSeries _prevNegValueSeries = new("PrevNegValueSeries", "Previous lower value")
    {
        Color = GetColorFromHex("#FFCD5C5C"),
        VisualType = VisualMode.Cross,
        ShowZeroValue = false,
        Width = 5
    };

    private readonly ValueDataSeries _prevPosValueSeries = new("PrevPosValueSeries", "Previous upper value")
    {
        Color = GetColorFromHex("#FF4CAF50"),
        VisualType = VisualMode.Cross,
        ShowZeroValue = false,
        Width = 5
    };

    private readonly ValueDataSeries _sumSrcSrcVol = new("sumSrcSrcVol");
    private readonly ValueDataSeries _totalVolToClose = new("volToClose");
    private readonly ValueDataSeries _totalVolume = new("totalVolume");
    private readonly ValueDataSeries _vwapTwap = new("VwapTwap", "VWAP|TWAP") 
    {
        Width = 3,
        Color = GetColorFromHex("#FFFF5252"),
        DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
    };

    private bool _allowCustomStartPoint;
    private bool _calcStarted;
    private int _days;
    private bool _isReserved;

    private int _period = 300;
    private VWAPPeriodType _periodType = VWAPPeriodType.Daily;
    private bool _showFirstPeriod;
    private decimal _stdev = 1;
    private decimal _stdev1 = 2;
    private decimal _stdev2 = 3;
    private int _targetBar;
    private VWAPMode _twapMode = VWAPMode.VWAP;
    private bool _userCalculation;
    private int _zeroBar;
    private VolumeType _volumeMode = VolumeType.Total;
    private System.Drawing.Color _bullishColor = GetColorFromHex("#FF2196F3").Convert();
    private System.Drawing.Color _bearishColor = GetColorFromHex("#FFB22222").Convert();
    private bool _coloredDirection = true;
    private TimeSpan _customSessionEnd = new(23, 59, 59);
    private TimeSpan _customSessionStart;
    private bool _vWAPOnly = true;

    #endregion

    #region Properties

    [Browsable(false)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AllowCustomStartPoint), GroupName = nameof(Strings.CustomVWAP), Description = nameof(Strings.AllowCustomStartPointDescription), Order = 1001)]
    public bool AllowCustomStartPoint
    {
        get => _allowCustomStartPoint;
        set
        {
            _allowCustomStartPoint = value;
            StartKeyFilter.Enabled = DeleteKeyFilter.Enabled = SavePointFilter.Enabled = ResetOnSessionFilter.Enabled = value;

            if (!_allowCustomStartPoint)
                StartBar = _targetBar = 0;

            RecalculateValues();
        }
    }

    [Browsable(false)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SetStartPoint), GroupName = nameof(Strings.CustomVWAP), Description = nameof(Strings.SetStartPointKeyFilterDescription), Order = 1010)]
    public FilterKey StartKeyFilter { get; set; } = new(false) { Value = CrossKey.F };

    [Browsable(false)]
    public CrossKey StartKey 
    { 
        get => StartKeyFilter.Value; 
        set => StartKeyFilter.Value = value;
    }

    [Browsable(false)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DeleteStartPoint), GroupName = nameof(Strings.CustomVWAP), Description = nameof(Strings.DeleteStartPointKeyFilterDescription), Order = 1020)]
    public FilterKey DeleteKeyFilter { get; set; } = new(false) { Value = CrossKey.G };

    [Browsable(false)]
    public CrossKey DeleteKey
    {
        get => DeleteKeyFilter.Value;
        set => DeleteKeyFilter.Value = value;
    }

    [Browsable(false)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SaveStartPoint), GroupName = nameof(Strings.CustomVWAP), Description = nameof(Strings.SaveCustomStartingPointDescription), Order = 1030)]
    public FilterBool SavePointFilter { get; set; } = new(false);

    [Browsable(false)]
    public bool SavePoint 
    { 
        get => SavePointFilter.Value;
        set => SavePointFilter.Value = value;
    }

    [Browsable(false)]
    public DateTime StartDate { get; set; }

    [Browsable(false)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ResetOnSession), GroupName = nameof(Strings.CustomVWAP), Description = nameof(Strings.ResetOnSessionFilterDescription), Order = 1040)]
    public FilterBool ResetOnSessionFilter { get; set; } = new(false);

    [Browsable(false)]
    public bool ResetOnSession
    {
        get => ResetOnSessionFilter.Value;
        set => ResetOnSessionFilter.Value = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ColoredDirection), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColoredDirectionDescription), Order = 200)]
    [Range(1, 10000)]
    public bool ColoredDirection
    {
        get => _coloredDirection;
        set
        {
            _coloredDirection = value;

            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BullishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BullishColorDescription), Order = 210)]
    public CrossColor BullishColor
    {
        get => _bullishColor.Convert();
        set
        {
            _bullishColor = value.Convert();
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BearlishColor), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.BearishColorDescription), Order = 220)]
    public CrossColor BearishColor
    {
        get => _bearishColor.Convert();
        set
        {
            _bearishColor = value.Convert();
            RecalculateValues();
        }
    }

    [Browsable(false)]
    public int StartBar { get; set; }

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodTypeDescription), Order = 10)]
    public VWAPPeriodType Type
    {
        get => _periodType;
        set
        {
            _periodType = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Mode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 20)]
    public VWAPMode TWAPMode
    {
        get => _twapMode;
        set
        {
            _twapMode = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VolumeType), GroupName = nameof(Strings.Settings), Description = nameof(Strings.VolumeTypeDescription), Order = 25)]
    public VolumeType VolumeMode
    {
        get => _volumeMode;
        set
        {
            _volumeMode = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TwapPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 30)]
    [Range(1, 10000)]
    public int Period
    {
        get => _period;
        set
        {
            _period = Math.Max(value, 1);
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.FirstDev), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StdDevPeriodDescription), Order = 40)]
    [Range(0.0000001, 10000)]
    public decimal StDev
    {
        get => _stdev;
        set
        {
            _stdev = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SecondDev), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StdDevPeriodDescription), Order = 50)]
    [Range(0.0000001, 10000)]
    public decimal StDev1
    {
        get => _stdev1;
        set
        {
            _stdev1 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ThirdDev), GroupName = nameof(Strings.Settings), Description = nameof(Strings.StdDevPeriodDescription), Order = 60)]
    [Range(0.0000001, 10000)]
    public decimal StDev2
    {
        get => _stdev2;
        set
        {
            _stdev2 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionBegin), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SessionBeginDescription), Order = 70)]
    public TimeSpan CustomSessionStart
    {
	    get => _customSessionStart;
	    set
	    {
		    _customSessionStart = value;
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SessionEnd), GroupName = nameof(Strings.Settings), Description = nameof(Strings.SessionEndDescription), Order = 80)]
    public TimeSpan CustomSessionEnd
    {
	    get => _customSessionEnd;
	    set
	    {
		    _customSessionEnd = value;
		    RecalculateValues();
	    }
    }

    [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
    [Range(0, 1000)]
    public int Days
    {
        get => _days;
        set
        {
            _days = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowFirstPartialPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowFirstPeriodDescription), Order = 90)]
    public bool ShowFirstPeriod
    {
        get => _showFirstPeriod;
        set
        {
            _showFirstPeriod = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.VWAPOnly), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShowBaseElementOnlyDescription), Order = 100)]
    public bool VWAPOnly
    { 
        get => _vWAPOnly;
        set
        {
            _vWAPOnly = value;
            SetVWAPOnly(_vWAPOnly);
        }
    }

    #endregion

    #region ctor

    public VWAP() 
	    : base(DataSeriesType.HLC3)
    {
        _days = 20;

        DataSeries[0] = _vwapTwap;

        DataSeries.Add(_lower2);
        DataSeries.Add(_upper2);
        DataSeries.Add(_lower1);
        DataSeries.Add(_upper1);
        DataSeries.Add(_lower);
        DataSeries.Add(_upper);
        DataSeries.Add(_prevPosValueSeries);
        DataSeries.Add(_prevNegValueSeries);

        _upper2Background.PropertyChanged += Upper2Changed;
        DataSeries.Add(_upper2Background);
        DataSeries.Add(_upper2BackgroundRes);

        _upperBackground.PropertyChanged += UpperChanged;
        DataSeries.Add(_upperBackground);
        DataSeries.Add(_upperBackgroundRes);

        _midUpBackground.PropertyChanged += MidUpChanged;
        DataSeries.Add(_midUpBackground);
        DataSeries.Add(_midUpBackgroundRes);

        _midDownBackground.PropertyChanged += MidDownChanged;
        DataSeries.Add(_midDownBackground);
        DataSeries.Add(_midDownBackgroundRes);

        _lowerBackground.PropertyChanged += LowerChanged;
        DataSeries.Add(_lowerBackground);
        DataSeries.Add(_lowerBackgroundRes);

        _lower2Background.PropertyChanged += Lower2Changed;
        DataSeries.Add(_lower2Background);
        DataSeries.Add(_lower2BackgroundRes);

        ResetOnSessionFilter.PropertyChanged += ResetOnSessionFilter_PropertyChanged;
    }

    private void ResetOnSessionFilter_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == "Value")
            RecalculateValues();
    }

    #endregion

    #region Protected methods

    protected override void OnInitialize()
    {
	    _prevNegValueSeries.ShowZeroValue = false;
	    _prevPosValueSeries.ShowZeroValue = false;
    }

    protected override void OnRecalculate()
    {
        _upper2BackgroundRes.Visible = _upper2Background.Visible;
        _upper2BackgroundRes.DrawAbovePrice = _upper2Background.DrawAbovePrice;

        _upperBackgroundRes.Visible = _upperBackground.Visible;
        _upperBackgroundRes.DrawAbovePrice = _upperBackground.DrawAbovePrice;

        _midUpBackgroundRes.Visible = _midUpBackground.Visible;
        _midUpBackgroundRes.DrawAbovePrice = _midUpBackground.DrawAbovePrice;

        _midDownBackgroundRes.Visible = _midDownBackground.Visible;
        _midDownBackgroundRes.DrawAbovePrice = _midDownBackground.DrawAbovePrice;

        _lowerBackgroundRes.Visible = _lowerBackground.Visible;
        _lowerBackgroundRes.DrawAbovePrice = _lowerBackground.DrawAbovePrice;

        _lower2BackgroundRes.Visible = _lower2Background.Visible;
        _lower2BackgroundRes.DrawAbovePrice = _lower2Background.DrawAbovePrice;
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (bar == 0)
        {
            _calcStarted = false;

            if (SavePointFilter.Enabled && SavePointFilter.Value)
                _targetBar = BarFromDate(StartDate);

            DataSeries.ForEach(x => x.Clear());
            _totalVolToClose.Clear();
            _totalVolume.Clear();

            if (_userCalculation && SavePointFilter.Enabled && SavePointFilter.Value)
            {
                if (_targetBar > 0)
                {
                    DataSeries.ForEach(x =>
                    {
                        if (x is ValueDataSeries series)
                            series.SetPointOfEndLine(_targetBar - 1);
                    });
                }
            }
            else
            {
                _targetBar = 0;

                if (_days > 0)
                {
                    var days = 0;

                    for (var i = CurrentBar - 1; i >= 0; i--)
                    {
                        _targetBar = i;

                        if (!IsNewSession(i))
                            continue;

                        days++;

                        if (days == _days)
                            break;
                    }

                    if (_targetBar > 0)
                    {
                        DataSeries.ForEach(x =>
                        {
                            if (x is ValueDataSeries series)
                                series.SetPointOfEndLine(_targetBar - 1);
                        });
                    }
                }
            }
        }

        if (bar < _targetBar)
            return;

        if (Type is VWAPPeriodType.Custom && !InsideSession(bar))
        {
	        DataSeries.ForEach(x =>
	        {
		        if (x is ValueDataSeries series)
			        series.SetPointOfEndLine(bar - 1);
	        });
	        return;
        }

        if (!ShowFirstPeriod && !AllowCustomStartPoint && !_calcStarted
            && Type is VWAPPeriodType.Weekly or VWAPPeriodType.Monthly or VWAPPeriodType.Custom)
        {
	        if (bar == 0 && Type is not VWAPPeriodType.Custom)
		        return;

	        switch (Type)
	        {
		        case VWAPPeriodType.Weekly:
			        _calcStarted = IsNewWeek(bar);
			        break;
		        case VWAPPeriodType.Monthly:
			        _calcStarted = IsNewMonth(bar);
			        break;
		        case VWAPPeriodType.Custom:
			        _calcStarted = IsNewCustomSession(bar);
			        break;
	        }

	        if (!_calcStarted)
		        return;
        }

        var needReset = false;
        var candle = GetCandle(bar);

        var volume = VolumeMode switch
        {
            VolumeType.Total => candle.Volume,
            VolumeType.Bid => candle.Bid,
            VolumeType.Ask => candle.Ask,
            _ => candle.Volume
        };

        var typical = value;

        if (bar == _targetBar)
        {
            _zeroBar = bar;
            _totalVolume[bar] = volume;
            _sumSrcSrcVol[bar] = volume * typical * typical;

            if (_twapMode == VWAPMode.TWAP)
                _vwapTwap[bar] = _totalVolToClose[bar] = _upper[bar] = _lower[bar] = _upper1[bar] = _lower1[bar] = _upper2[bar] = _lower2[bar] = typical;
            else
            {
                _totalVolToClose[bar] = typical * volume;

                _vwapTwap[bar] = _upper[bar] =
                    _lower[bar] = _upper1[bar] = _lower1[bar] = _upper2[bar] = _lower2[bar] = _totalVolToClose[bar] / _totalVolume[bar];
            }


			return;
		}

		var prevCandle = GetCandle(bar - 1);

		switch (Type)
		{
			case VWAPPeriodType.M15 when PeriodNumber(prevCandle.Time, TimeSpan.FromMinutes(15)) != PeriodNumber(candle.Time, TimeSpan.FromMinutes(15)):
			case VWAPPeriodType.M30 when PeriodNumber(prevCandle.Time, TimeSpan.FromMinutes(30)) != PeriodNumber(candle.Time, TimeSpan.FromMinutes(30)):
            case VWAPPeriodType.Hourly when prevCandle.Time.Hour != candle.Time.Hour:
            case VWAPPeriodType.H4 when PeriodNumber(prevCandle.Time, TimeSpan.FromHours(4)) != PeriodNumber(candle.Time, TimeSpan.FromHours(4)):
            case VWAPPeriodType.Daily when IsNewSession(bar):
			case VWAPPeriodType.Weekly when IsNewWeek(bar):
			case VWAPPeriodType.Monthly when IsNewMonth(bar):
			case VWAPPeriodType.Custom when IsNewCustomSession(bar):
				needReset = true;
                break;
		}

		var setStartOfLine = needReset;

		if (setStartOfLine && Type == VWAPPeriodType.Daily && ChartInfo.TimeFrame == "Daily")
			setStartOfLine = false;

		if (needReset && ((AllowCustomStartPoint && ResetOnSessionFilter.Enabled && ResetOnSessionFilter.Value) || !AllowCustomStartPoint))
		{
			_zeroBar = bar;
			_totalVolume[bar] = volume;
			_totalVolToClose[bar] = _twapMode == VWAPMode.TWAP ? typical : typical * volume;
			_sumSrcSrcVol[bar] = volume * typical * typical;

			if (setStartOfLine)
			{
				if (!_upper1.IsThisPointOfStartBar(bar - 1))
					_isReserved = !_isReserved;

				((ValueDataSeries)DataSeries[0]).SetPointOfEndLine(bar - 1);
				_upper.SetPointOfEndLine(bar - 1);
				_lower.SetPointOfEndLine(bar - 1);
				_upper1.SetPointOfEndLine(bar - 1);
				_lower1.SetPointOfEndLine(bar - 1);
				_upper2.SetPointOfEndLine(bar - 1);
				_lower2.SetPointOfEndLine(bar - 1);
			}
		}
		else
		{
			_totalVolume[bar] = _totalVolume[bar - 1] + volume;
			_totalVolToClose[bar] = _totalVolToClose[bar - 1] + (_twapMode == VWAPMode.TWAP ? typical : typical * volume);

			if (_twapMode is VWAPMode.VWAP)
			{
				var barVariance = volume * typical * typical;
				_sumSrcSrcVol[bar] = _sumSrcSrcVol[bar - 1] + barVariance;
			}
		}

		decimal stdDev = 0m, currentValue, lastValue;

		if (_twapMode == VWAPMode.TWAP)
		{
			_vwapTwap[bar] = _totalVolToClose[bar] / (bar - _zeroBar + 1);
			currentValue = _vwapTwap[bar];
			lastValue = _vwapTwap[bar - 1];

			if (bar != _zeroBar)
			{
				var period = Math.Min(bar - _zeroBar, Period);
				var average = _vwapTwap.CalcAverage(period, bar);
				var sqrSum = 0m;

				for (var i = bar - period; i <= bar; i++)
				{
					var diff = average - _vwapTwap[i];
					sqrSum += diff * diff;
				}

				stdDev = (decimal)Math.Sqrt((double)sqrSum / period);
			}
		}
		else
		{
			_vwapTwap[bar] = _totalVolToClose[bar] / _totalVolume[bar];
			currentValue = _vwapTwap[bar];
			lastValue = _vwapTwap[bar - 1];

			var variance = _sumSrcSrcVol[bar] / _totalVolume[bar] - currentValue * currentValue;
			variance = variance < 0 ? 0 : variance;
			stdDev = (decimal)Math.Sqrt((double)variance);
		}

		if (bar - _zeroBar > 1) //temp solution, colored series point bug
		{
			if (ColoredDirection && bar != 0)
			{
				_vwapTwap.Colors[bar] = _vwapTwap[bar] > _vwapTwap[bar - 1]
					? _bullishColor
					: _bearishColor;
			}
		}

		var std = stdDev * _stdev;
		var std1 = stdDev * _stdev1;
		var std2 = stdDev * _stdev2;

		_upper[bar] = currentValue + std;
		_lower[bar] = currentValue - std;
		_upper1[bar] = currentValue + std1;
		_lower1[bar] = currentValue - std1;
		_upper2[bar] = currentValue + std2;
		_lower2[bar] = currentValue - std2;

		SetBackgroundValues(bar, currentValue);

		if (bar == 0)
			return;

		if (needReset)
		{
			if (lastValue < currentValue)
				_prevPosValueSeries[bar] = lastValue;
			else
				_prevNegValueSeries[bar] = lastValue;
		}
		else
		{
			var prevValue = _prevPosValueSeries[bar - 1] != 0
				? _prevPosValueSeries[bar - 1]
				: _prevNegValueSeries[bar - 1];

			if (candle.Close >= prevValue)
				_prevPosValueSeries[bar] = prevValue;
			else
				_prevNegValueSeries[bar] = prevValue;
		}

        if (_prevNegValueSeries[bar] is 0)
            _prevNegValueSeries.SetPointOfEndLine(bar);

        if (_prevPosValueSeries[bar] is 0)
	        _prevPosValueSeries.SetPointOfEndLine(bar);
	}

    #endregion

    #region Private methods

    private static long PeriodNumber(DateTime time, TimeSpan period) => time.Ticks / period.Ticks;

    private void SetVWAPOnly(bool toHideAll)
    {
        _upperBackground.Visible = !toHideAll;
        _lowerBackground.Visible = !toHideAll;
        _upper2Background.Visible = !toHideAll;
        _lower2Background.Visible = !toHideAll;
        _midUpBackground.Visible = !toHideAll;
        _midDownBackground.Visible = !toHideAll;

        if (toHideAll)
        {
            _upper.VisualType = VisualMode.Hide;
            _upper1.VisualType = VisualMode.Hide;
            _upper2.VisualType = VisualMode.Hide;
            _lower.VisualType = VisualMode.Hide;
            _lower1.VisualType = VisualMode.Hide;
            _lower2.VisualType = VisualMode.Hide;
        }
        else
        {
            _upper.VisualType = VisualMode.Line;
            _upper1.VisualType = VisualMode.Line;
            _upper2.VisualType = VisualMode.Line;
            _lower.VisualType = VisualMode.Line;
            _lower1.VisualType = VisualMode.Line;
            _lower2.VisualType = VisualMode.Line;
        }
    }

    private void SetBackgroundValues(int bar, decimal value)
	{
		if (_isReserved)
		{
			_upper2BackgroundRes[bar].Upper = _upper2[bar];
			_upper2BackgroundRes[bar].Lower = _upper1[bar];

			_upperBackgroundRes[bar].Upper = _upper1[bar];
			_upperBackgroundRes[bar].Lower = _upper[bar];

			_midUpBackgroundRes[bar].Upper = _upper[bar];
			_midUpBackgroundRes[bar].Lower = value;

			_midDownBackgroundRes[bar].Upper = value;
			_midDownBackgroundRes[bar].Lower = _lower[bar];

			_lowerBackgroundRes[bar].Upper = _lower[bar];
			_lowerBackgroundRes[bar].Lower = _lower1[bar];

			_lower2BackgroundRes[bar].Upper = _lower1[bar];
			_lower2BackgroundRes[bar].Lower = _lower2[bar];
		}
		else
		{
			_upper2Background[bar].Upper = _upper2[bar];
			_upper2Background[bar].Lower = _upper1[bar];

			_upperBackground[bar].Upper = _upper1[bar];
			_upperBackground[bar].Lower = _upper[bar];

			_midUpBackground[bar].Upper = _upper[bar];
			_midUpBackground[bar].Lower = value;

			_midDownBackground[bar].Upper = value;
			_midDownBackground[bar].Lower = _lower[bar];

			_lowerBackground[bar].Upper = _lower[bar];
			_lowerBackground[bar].Lower = _lower1[bar];

			_lower2Background[bar].Upper = _lower1[bar];
			_lower2Background[bar].Lower = _lower2[bar];
		}
	}

	private void Lower2Changed(object sender, PropertyChangedEventArgs e)
	{
		var value = _lower2Background.GetType().GetProperty(e.PropertyName)?.GetValue(_lower2Background, null);
		_lower2BackgroundRes.GetType().GetProperty(e.PropertyName)?.SetValue(_lower2BackgroundRes, value);
	}

	private void LowerChanged(object sender, PropertyChangedEventArgs e)
	{
		var value = _lowerBackground.GetType().GetProperty(e.PropertyName)?.GetValue(_lowerBackground, null);
		_lowerBackgroundRes.GetType().GetProperty(e.PropertyName)?.SetValue(_lowerBackgroundRes, value);
	}

	private void MidDownChanged(object sender, PropertyChangedEventArgs e)
	{
		var value = _midDownBackground.GetType().GetProperty(e.PropertyName)?.GetValue(_midDownBackground, null);
		_midDownBackgroundRes.GetType().GetProperty(e.PropertyName)?.SetValue(_midDownBackgroundRes, value);
	}

	private void MidUpChanged(object sender, PropertyChangedEventArgs e)
	{
		var value = _midUpBackground.GetType().GetProperty(e.PropertyName)?.GetValue(_midUpBackground, null);
		_midUpBackgroundRes.GetType().GetProperty(e.PropertyName)?.SetValue(_midUpBackgroundRes, value);
	}

	private void UpperChanged(object sender, PropertyChangedEventArgs e)
	{
		var value = _upperBackground.GetType().GetProperty(e.PropertyName)?.GetValue(_upperBackground, null);
		_upperBackgroundRes.GetType().GetProperty(e.PropertyName)?.SetValue(_upperBackgroundRes, value);
	}

	private void Upper2Changed(object sender, PropertyChangedEventArgs e)
	{
		var value = _upper2Background.GetType().GetProperty(e.PropertyName)?.GetValue(_upper2Background, null);
		_upper2BackgroundRes.GetType().GetProperty(e.PropertyName)?.SetValue(_upper2BackgroundRes, value);
	}

	private int BarFromDate(DateTime date)
	{
		var bar = CurrentBar - 1;

		for (var i = CurrentBar - 1; i >= 0; i--)
		{
			var candle = GetCandle(i);
			bar = i;

			if (candle.Time <= date && candle.LastTime >= date)
				break;
		}

		return bar;
	}

	private bool IsNewCustomSession(int bar)
	{
		var currentBar = GetCandle(bar);
		var previousBar = bar > 0 ? GetCandle(bar - 1) : null;

		var startTime = currentBar.Time.AddHours(InstrumentInfo.TimeZone);
		var endTime = currentBar.LastTime.AddHours(InstrumentInfo.TimeZone);

		var prevEndTime = previousBar?.LastTime.AddHours(InstrumentInfo.TimeZone) ?? default;

		var sessionCrossesMidnight = _customSessionStart > _customSessionEnd;

		var isFirstBarNewSession = bar == 0 && (
			sessionCrossesMidnight
				? startTime.TimeOfDay <= _customSessionStart || endTime.TimeOfDay > _customSessionStart
				: startTime.TimeOfDay <= _customSessionStart && endTime.TimeOfDay > _customSessionStart
		);

		if (isFirstBarNewSession)
		{
			return true;
		}

		bool newSessionInCurrentBar;
		
		if (sessionCrossesMidnight)
		{
			newSessionInCurrentBar = (startTime.TimeOfDay <= _customSessionStart && endTime.TimeOfDay > _customSessionStart) ||
				(startTime.TimeOfDay > endTime.TimeOfDay && (endTime.TimeOfDay > _customSessionStart || startTime.TimeOfDay <= _customSessionStart));
		}
		else
		{
			newSessionInCurrentBar = startTime.TimeOfDay <= _customSessionStart && endTime.TimeOfDay > _customSessionStart;
		}

		var newSessionBetweenBars = previousBar != null && (
			sessionCrossesMidnight
				? (prevEndTime.TimeOfDay <= _customSessionStart && startTime.TimeOfDay > _customSessionStart) ||
				(prevEndTime.TimeOfDay > prevEndTime.TimeOfDay && _customSessionStart <= startTime.TimeOfDay)
				: prevEndTime.TimeOfDay <= _customSessionStart && startTime.TimeOfDay > _customSessionStart
		);

		return newSessionInCurrentBar || newSessionBetweenBars;
	}

    private bool InsideSession(int bar)
	{
		var currentBar = GetCandle(bar);

		var startTime = currentBar.Time.AddHours(InstrumentInfo.TimeZone);
		var endTime = currentBar.LastTime.AddHours(InstrumentInfo.TimeZone);

		var sessionCrossesMidnight = _customSessionStart > _customSessionEnd;

		bool isInSession;
		if (sessionCrossesMidnight)
		{
			isInSession = (startTime.TimeOfDay >= _customSessionStart || startTime.TimeOfDay <= _customSessionEnd) ||
				(endTime.TimeOfDay >= _customSessionStart || endTime.TimeOfDay <= _customSessionEnd) ||
				(startTime.TimeOfDay <= _customSessionEnd && endTime.TimeOfDay >= _customSessionStart);
		}
		else
		{
			isInSession = (startTime.TimeOfDay >= _customSessionStart && startTime.TimeOfDay <= _customSessionEnd) ||
				(endTime.TimeOfDay >= _customSessionStart && endTime.TimeOfDay <= _customSessionEnd) ||
				(startTime.TimeOfDay <= _customSessionEnd && endTime.TimeOfDay >= _customSessionStart);
		}

		return isInSession;
    }

    private static CrossColor GetColorFromHex(string hexString)
    {
        return (CrossColor)TypeDescriptor.GetConverter(typeof(CrossColor)).ConvertFromString(hexString);
    }

    #endregion
}






Technical/VerticalGrid.cs







namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators.Drawing;

using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

[DisplayName("Vertical Grid")]
public class VerticalGrid : Indicator
{
	#region Nested types

	public enum PeriodMode
	{
		Seconds,
		Minutes,
		Hours,
		Days
	}

	#endregion

	#region Fields

	private readonly RenderFont _font = new("Arial", 9);

	private RenderStringFormat _format = new()
	{
		Alignment = StringAlignment.Center,
		LineAlignment = StringAlignment.Center
	};

	private List<int> _gridBars = new();
	private object _gridLocker = new();
	private int _period = 10;
	private TimeSpan _periodTime;
	private PeriodMode _periodType = PeriodMode.Minutes;

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.SubPeriodsMode), GroupName = nameof(Strings.Settings), Order = 100)]
	public PeriodMode PeriodType
	{
		get => _periodType;
		set
		{
			_periodType = value;
			CalcGridPeriod();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings),
		Description = nameof(Strings.PeriodDescription), Order = 110)]
	[Range(1, 10000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			CalcGridPeriod();
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.GridStyle), GroupName = nameof(Strings.VisualSettings), Order = 200)]
	public PenSettings GridPen { get; set; } = new()
	{
		Color = DefaultColors.Gray.Convert()
	};

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.VisualSettings), Order = 210)]
	public Color TextColor { get; set; } = DefaultColors.Black;

	#endregion

	#region ctor

	public VerticalGrid()
		: base(true)
	{
		DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Historical | DrawingLayouts.LatestBar);

		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
		DataSeries[0].IsHidden = true;

		DrawAbovePrice = false;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		lock (_gridLocker)
		{
			if (bar == 0)
			{
				_gridBars.Clear();
				_gridBars.Add(bar);
				return;
			}

			var lastGridBar = _gridBars[^1];

			if (lastGridBar == bar)
				return;

			var candle = GetCandle(bar);
			var lastGridCandle = GetCandle(lastGridBar);

			var timeDiff = candle.LastTime - lastGridCandle.Time;

			if (timeDiff < _periodTime && !IsNewSession(bar))
				return;

			_gridBars.Add(bar);
		}
	}

	protected override void OnRender(RenderContext g, DrawingLayouts layout)
	{
		if (ChartInfo is null)
			return;

		var yTop = Container.Region.Y;
		var yBot = Container.Region.Bottom;

		lock (_gridLocker)
		{
			foreach (var bar in _gridBars)
			{
				if (bar < FirstVisibleBarNumber || bar > LastVisibleBarNumber)
					continue;

				var x = ChartInfo.GetXByBar(bar, false);
				g.DrawLine(GridPen.RenderObject, x, yTop, x, yBot);
			}

			var lastLabelX = 0;

			foreach (var bar in _gridBars)
			{
				if (bar < FirstVisibleBarNumber || bar > LastVisibleBarNumber)
					continue;

				var x = ChartInfo.GetXByBar(bar, false);
				var timeStr = ToTimeString(GetCandle(bar).Time);

				var strSize = g.MeasureString(timeStr, _font);

				var leftX = x - strSize.Width / 2;

				if (leftX < lastLabelX)
					continue;

				var rect = new Rectangle(leftX - 3, yBot - strSize.Height, strSize.Width + 6, strSize.Height);

				g.FillRectangle(GridPen.Color.Convert(), rect, 3);
				g.DrawString(timeStr, _font, TextColor, rect, _format);

				lastLabelX = rect.Right;
			}
		}
	}

	#endregion

	#region Private methods

	private string ToTimeString(DateTime time)
	{
		var format = ChartInfo.TimeFrame switch
		{
			"Weekly" => "dd.MM.yyyy",
			"Daily" => @"dd MMM",
			_ => ChartInfo.TimeFrame[0] switch
			{
				'M' or 'H' => "HH:mm",
				_ => "HH:mm:ss"
			}
		};

		return time.ToString(format);
	}

	private void CalcGridPeriod()
	{
		_periodTime = PeriodType switch
		{
			PeriodMode.Seconds => TimeSpan.FromSeconds(_period),
			PeriodMode.Minutes => TimeSpan.FromMinutes(_period),
			PeriodMode.Hours => TimeSpan.FromHours(_period),
			_ => TimeSpan.FromDays(_period)
		};
	}

	#endregion
}







Indicators/Technical
/VerticalHorizontalFilter.cs





namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;
using OFT.Attributes;
using OFT.Localization;

[DisplayName("Vertical Horizontal Filter")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VerticalHorizontalFilterDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619282")]
public class VerticalHorizontalFilter : Indicator
{
    #region Nested Types

    public enum InputType
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
        Volume,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
        Ticks,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
        Asks,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
        Bids,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Open))]
        Open,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.High))]
        High,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Low))]
        Low,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Close))]
        Close,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.OHLCAverage))]
        OHLCAverage,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HLCAverage))]
        HLCAverage,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.HLAverage))]
        HLAverage
    }

    #endregion

    #region Fields

    private readonly ValueDataSeries _volume = new("Volume", Strings.Volume)
    {
        IsHidden = true,
        VisualType = VisualMode.Histogram,
        ShowZeroValue = false
    };

    private readonly ValueDataSeries _data = new("Data")
    {
        IsHidden = true,
        VisualType = VisualMode.Hide,
    };

    private int _period = 10;
    private InputType _type;
    private CrossColor _histogramColor = DefaultColors.Blue.Convert();

    #endregion

    #region Properties

    [Parameter]
    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.PeriodDescription))]
    public int Period 
    { 
        get => _period; 
        set
        {
            _period = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Type), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.SourceTypeDescription))]
    public InputType Type 
    {
        get => _type; 
        set
        {
            _type = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Visualization), Description = nameof(Strings.ColorDescription))]
    public CrossColor HistogramColor 
    {
        get => _histogramColor;
        set
        {
            _histogramColor = value;
            _volume.Color = value;
        }
    }

    #endregion

    #region ctor

    public VerticalHorizontalFilter() : base(true)
    {
        Panel = IndicatorDataProvider.NewPanel;
        DenyToChangePanel = true;

        DataSeries[0] = _volume;
        _volume.Color = _histogramColor;
    }

    #endregion

    #region Protected Methods

    protected override void OnCalculate(int bar, decimal value)
    {
        _data[bar] = GetSource(bar);
        var sum = _data.CalcSum(_period, bar);

        if (sum != 0)
            _volume[bar] = (_data.MAX(_period, bar) - _data.MIN(_period, bar)) / sum;
    }

    #endregion

    #region Private Methods

    private decimal GetSource(int bar)
    {
        var candle = GetCandle(bar);

        return _type switch
        {
            InputType.Volume => candle.Volume,
            InputType.Ticks => candle.Ticks,
            InputType.Asks => candle.Ask,
            InputType.Bids => candle.Bid,
            InputType.Open => candle.Open,
            InputType.High => candle.High,
            InputType.Low => candle.Low,
            InputType.Close => candle.Close,
            InputType.OHLCAverage => (candle.Open + candle.High + candle.Low + candle.Close) / 4,
            InputType.HLCAverage => (candle.High + candle.Low + candle.Close) / 3,
            InputType.HLAverage => (candle.High + candle.Low) / 2,
            _ => 0,
        };
    }

    #endregion
}







Technical/VolatilityChaikins.cs








namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Volatility - Chaikins")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolatilityChaikinsDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602497")]
	public class VolatilityChaikins : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public VolatilityChaikins()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				Clear();

			var candle = GetCandle(bar);
			_ema.Calculate(bar, candle.High - candle.Low);

			if (bar < Period)
				return;

			if (_ema[bar] != 0)
				this[bar] = 100 * (_ema[bar] - _ema[bar - Period]) / _ema[bar - Period];
		}

		#endregion
	}
}







Technical/VolatilityHist.cs








namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Volatility - Historical")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolatilityHistDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602266")]
	public class VolatilityHist : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _diffSquareSeries = new("Diff");
		private readonly SMA _sma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings),Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(2, 10000)]
		public int Period
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public VolatilityHist()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				Clear();
				_sma.Calculate(bar, 0);
				return;
			}

			var lr = (decimal)Math.Log((double)(value / (decimal)SourceDataSeries[bar - 1]));
			_sma.Calculate(bar, lr);

			var diff = lr - _sma[bar];
			_diffSquareSeries[bar] = diff * diff;

			if (bar < Period)
				return;

			this[bar] = 100 * (decimal)(Math.Sqrt(CurrentBar) * Math.Sqrt((double)_diffSquareSeries.CalcSum(Period, bar) / (Period - 1)));
		}

		#endregion
	}
}







Technical/VolatilityTrend.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Volatility Trend")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolatilityTrendDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602267")]
	public class VolatilityTrend : Indicator
	{
		#region Fields

		private readonly ATR _atr = new() { Period = 10 };
		private readonly ValueDataSeries _dirSeries = new("Dir");
		private readonly ValueDataSeries _dplSeries = new("DPL");
		private int _maxDynamicPeriod = 15;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int Period
		{
			get => _atr.Period;
			set
			{
				_atr.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.MaxDynamicPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MaxPeriodDescription), Order = 100)]
		[Range(1, 10000)]
        public int MaxDynamicPeriod
		{
			get => _maxDynamicPeriod;
			set
			{
				_maxDynamicPeriod = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public VolatilityTrend()
		{
            DenyToChangePanel = true;
			Add(_atr);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				Clear();
				_dplSeries.Clear();
				return;
			}

			_dirSeries[bar] = value > this[bar - 1] ? 1 : -1;

			var dynamicPeriod = _dplSeries[bar - 1];
			var dynamicPeriod2 = _dirSeries[bar] == _dirSeries[bar - 1] ? dynamicPeriod : 0;
			var dynamicPeriod3 = dynamicPeriod2 < _maxDynamicPeriod ? dynamicPeriod2 + 1 : dynamicPeriod2;

			_dplSeries[bar] = dynamicPeriod3;

			if (_dirSeries[bar] == 1)
			{
				var max = SourceDataSeries.MAX((int)dynamicPeriod3, bar);
				this[bar] = max - _atr[bar];
			}
			else
			{
				var min = SourceDataSeries.MIN((int)dynamicPeriod3, bar);
				this[bar] = min - _atr[bar];
			}
		}

		#endregion
	}
}






Technical/Volume.cs







namespace ATAS.Indicators.Technical;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

using Color = System.Drawing.Color;

[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumeIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602498")]
public class Volume : Indicator
{
	#region Nested types

	public enum InputType
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Volume))]
		Volume,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
		Ticks,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ask))]
		Asks,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Bid))]
		Bids
	}

	public enum Location
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up))]
		Up,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Middle))]
		Middle,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Down))]
		Down
	}

	#endregion

	#region Fields

	private bool _deltaColored;
	private decimal _filter;
	private Color _filterColor = Color.LightBlue;
	private InputType _input = InputType.Volume;
	private int _lastReverseAlert;
	private int _lastVolumeAlert;
	private Color _negColor = Color.Red;
	private Color _neutralColor = Color.Gray;
	private Color _posColor = Color.Green;

    #region Legacy Series

	//For old templates
	private readonly ValueDataSeries _negative = new("NegativeId", "Negative")
    {
	    VisualType = VisualMode.Hide,
		IsHidden = true
    };

    private readonly ValueDataSeries _neutral = new("NeutralId", "Neutral")
    {
	    VisualType = VisualMode.Hide,
		Color = Color.Gray.Convert(),
	    IsHidden = true
    };

    private readonly ValueDataSeries _positive = new("PositiveId", "Positive")
    {
	    VisualType = VisualMode.Hide,
	    Color = Color.Green.Convert(),
        IsHidden = true
    };

	#endregion

    private ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
    {
	    VisualType = VisualMode.Histogram,
	    ShowZeroValue = false,
	    UseMinimizedModeIfEnabled = true,
	    ResetAlertsOnNewBar = true
    };

    private bool _useFilter;

	protected RenderStringFormat Format = new() { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center };

	protected Highest HighestVol = new();
	protected ValueDataSeries MaxVolSeries;
	protected Color TextColor = DefaultColors.Blue;

    #endregion

    #region Properties

    #region Calculation

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Type), GroupName = nameof(Strings.Calculation), Description = nameof(Strings.SourceTypeDescription))]
	public InputType Input
	{
		get => _input;
		set
		{
			_input = value;
			RaisePropertyChanged(nameof(Input));
			RecalculateValues();
		}
	}

    #endregion

    #region Filter

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseFilter), GroupName = nameof(Strings.Filter), Description = nameof(Strings.UseFilterDescription))]
    public bool UseFilter
    {
        get => _useFilter;
        set
        {
            _useFilter = value;
            RaisePropertyChanged(nameof(UseFilter));
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Filter), Description = nameof(Strings.MinVolumeFilterCommonDescription))]
    public decimal FilterValue
    {
        get => _filter;
        set
        {
            _filter = value;
            RaisePropertyChanged(nameof(FilterValue));
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Filter), Description = nameof(Strings.FilterColorDescription))]
    public CrossColor FilterColor
    {
        get => _filterColor.Convert();
        set
        {
            _filterColor = value.Convert();

            RaisePropertyChanged(nameof(FilterColor));
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlerts), GroupName = nameof(Strings.Filter), Description = nameof(Strings.UseAlertsDescription))]
    public bool UseVolumeAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Filter), Description = nameof(Strings.AlertFileDescription))]
    public string AlertVolumeFile { get; set; } = "alert1";

    #endregion

    #region MaximumVolume

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.MaximumVolume), Description = nameof(Strings.MaximumVolumeDescription))]
    public bool ShowMaxVolume
    {
        get => MaxVolSeries.VisualType is not VisualMode.Hide;
        set => MaxVolSeries.VisualType = value ? VisualMode.Line : VisualMode.Hide;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.MaximumVolume), Description = nameof(Strings.MaximumVolumePeriodDescription))]
    [Range(1, 100000)]
    public int HiVolPeriod
    {
        get => HighestVol.Period;
        set => HighestVol.Period = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.MaximumVolume), Description = nameof(Strings.ColorDescription))]
    public CrossColor LineColor
    {
        get => MaxVolSeries.Color;
        set => MaxVolSeries.Color = value;
    }

    #endregion

    #region Volume label

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.VolumeLabelDescription))]
    public bool ShowVolume { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.LabelTextColorDescription))]
    public CrossColor FontColor
    {
        get => TextColor.Convert();
        set => TextColor = value.Convert();
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Location), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.LabelLocationDescription))]
    public Location VolLocation { get; set; } = Location.Middle;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.VolumeLabel), Description = nameof(Strings.FontSettingDescription))]
    public FontSetting Font { get; set; } = new("Arial", 10);

    #endregion

    #region Divergence alert

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Enabled), GroupName = nameof(Strings.ReverseAlert), Description = nameof(Strings.ReverseAlertDescription))]
    public bool UseReverseAlerts { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.ReverseAlert), Description = nameof(Strings.AlertFileDescription))]
    public string AlertReverseFile { get; set; } = "alert1";

    #endregion

    #region Drawing

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DeltaColored), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.DeltaColoredDescription))]
	public bool DeltaColored
	{
		get => _deltaColored;
		set
		{
			_deltaColored = value;
			RaisePropertyChanged(nameof(DeltaColored));
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.PositiveValueColorDescription))]
	public CrossColor PosColor
	{
		get => _posColor.Convert();
		set
		{
			_positive.Color = value;
			RaisePropertyChanged(nameof(PosColor));
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NegativeValueColorDescription))]
	public CrossColor NegColor
	{
		get => _negColor.Convert();
		set
		{
            _negative.Color = value;
			RaisePropertyChanged(nameof(NegColor));
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Neutral), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.NeutralColorDescription))]
	public CrossColor NeutralColor
	{
		get => _neutralColor.Convert();
        set
		{
            _neutral.Color = value;
			RaisePropertyChanged(nameof(NeutralColor));
			RecalculateValues();
		}
	}

    #endregion

    #endregion

    #region ctor

    public Volume()
		: base(true)
	{
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Final);

		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

		MaxVolSeries = (ValueDataSeries)HighestVol.DataSeries[0];
		MaxVolSeries.IsHidden = true;
		MaxVolSeries.VisualType = VisualMode.Hide;
		MaxVolSeries.UseMinimizedModeIfEnabled = true;
		MaxVolSeries.IgnoredByAlerts = true;
		DataSeries[0] = _renderSeries;
		DataSeries.Add(MaxVolSeries);
		DataSeries[1].IgnoredByAlerts = true;

		//Legacy templates
		DataSeries.Add(_positive);
		DataSeries.Add(_negative);
		DataSeries.Add(_neutral);
		_positive.PropertyChanged += PositiveChanged;
		_negative.PropertyChanged += NegativeChanged;
		_neutral.PropertyChanged += NeutralChanged;
    }

    #endregion

    protected override void OnApplyDefaultColors()
    {
	    if (ChartInfo != null)
	    {
		    PosColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
		    NegColor = ChartInfo.ColorsStore.DownCandleColor.Convert();
		    NeutralColor = ChartInfo.ColorsStore.UpCandleColor.Convert();
	    }
    }

    #region Public methods

    public override string ToString()
	{
		return "Volume";
	}

    #endregion

    #region Protected methods

    protected override void OnInitialize()
    {
		_positive.VisualType = VisualMode.Hide;
		_negative.VisualType = VisualMode.Hide;
		_neutral.VisualType = VisualMode.Hide;
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		if (!ShowVolume || ChartInfo.ChartVisualMode != ChartVisualModes.Clusters || Panel == IndicatorDataProvider.CandlesPanel)
			return;

		var minWidth = GetMinWidth(context, FirstVisibleBarNumber, LastVisibleBarNumber);
		var barWidth = ChartInfo.GetXByBar(1) - ChartInfo.GetXByBar(0);

		if (minWidth > barWidth)
			return;

		var strHeight = context.MeasureString("0", Font.RenderObject).Height;

		var y = VolLocation switch
		{
			Location.Up => Container.Region.Y,
			Location.Down => Container.Region.Bottom - strHeight,
			_ => Container.Region.Y + (Container.Region.Bottom - Container.Region.Y) / 2
		};

		for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
		{
			var value = _renderSeries[i];
			var renderText = ChartInfo.TryGetMinimizedVolumeString(value);

			var strRect = new Rectangle(ChartInfo.GetXByBar(i),
				y,
				barWidth,
				strHeight);
			context.DrawString(renderText, Font.RenderObject, TextColor, strRect, Format);
		}
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		var val = Input switch
		{
			InputType.Ticks => candle.Ticks,
			InputType.Asks => candle.Ask,
			InputType.Bids => candle.Bid,
			_ => candle.Volume
		};
		_renderSeries[bar] = val;

		if (bar == CurrentBar - 1)
		{
			if (UseVolumeAlerts && _lastVolumeAlert != bar && val >= _filter && _filter != 0)
			{
				AddAlert(AlertVolumeFile, $"Candle volume: {val}");
				_lastVolumeAlert = bar;
			}

			if (UseReverseAlerts && _lastReverseAlert != bar)
			{
				if ((candle.Delta < 0 && candle.Close > candle.Open) || (candle.Delta > 0 && candle.Close < candle.Open))
				{
					AddAlert(AlertReverseFile, $"Candle volume: {val} (Reverse alert)");
					_lastReverseAlert = bar;
				}
			}
		}

		HighestVol.Calculate(bar, candle.Volume);

		if (_useFilter && val > _filter)
		{
			_renderSeries.Colors[bar] = _filterColor;
			return;
		}

		if (_deltaColored)
		{
			if (candle.Delta > 0)
				_renderSeries.Colors[bar] = _posColor;
			else if (candle.Delta < 0)
				_renderSeries.Colors[bar] = _negColor;
			else
				_renderSeries.Colors[bar] = _neutralColor;
		}
		else
		{
			if (candle.Close > candle.Open)
				_renderSeries.Colors[bar] = _posColor;
			else if (candle.Close < candle.Open)
				_renderSeries.Colors[bar] = _negColor;
			else
				_renderSeries.Colors[bar] = _neutralColor;
		}
	}

	#endregion

	#region Private methods

	private int GetMinWidth(RenderContext context, int startBar, int endBar)
	{
		var maxLength = 0;

		for (var i = startBar; i <= endBar; i++)
		{
			var value = _renderSeries[i];
			var length = $"{value:0.#####}".Length;

			if (length > maxLength)
				maxLength = length;
		}

		var sampleStr = "";

		for (var i = 0; i < maxLength; i++)
			sampleStr += '0';

		return context.MeasureString(sampleStr, Font.RenderObject).Width;
	}

	private void NeutralChanged(object sender, PropertyChangedEventArgs e)
	{
		_neutralColor = _neutral.Color.Convert();
	}

	private void NegativeChanged(object sender, PropertyChangedEventArgs e)
	{
		_negColor = _negative.Color.Convert();
	}

	private void PositiveChanged(object sender, PropertyChangedEventArgs e)
	{
		_posColor = _positive.Color.Convert();
	}

    #endregion
}






Technical/VolumeIndex.cs





namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Positive/Negative Volume Index")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumeIndexDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602304")]
	public class VolumeIndex : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Positive))]
			Positive,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Negative))]
			Negative
		}

		#endregion

		#region Fields
		
        private Mode _calcMode;
		private decimal _startPrice;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CalculationModeDescription), Order = 100)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

        [Range(0, 100000000)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.CustomStartPrice), GroupName = nameof(Strings.Settings), Description = nameof(Strings.CustomStartPriceFilterDescription), Order = 210)]
        public Filter StartPriceFilter { get; set; }

		[Browsable(false)]
		[Obsolete]
		public bool PriceMod
		{
			get => !StartPriceFilter.Enabled;
			set => StartPriceFilter.Enabled = !value;
        }

        [Browsable(false)]
        [Obsolete]
        public decimal StartPrice
		{
            get => StartPriceFilter.Value;
            set => StartPriceFilter.Value = value;
        }

        #endregion

        #region ctor

        public VolumeIndex()
        {
			StartPriceFilter = new(true);
        }

        #endregion

        #region Protected methods

        protected override void OnInitialize()
        {
			StartPriceFilter.PropertyChanged += (_, _) =>
			{
				RecalculateValues();
				RedrawChart();
			};
        }

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				if (!StartPriceFilter.Enabled)
					_startPrice = ((decimal)SourceDataSeries[0] + (decimal)SourceDataSeries[CurrentBar - 1]) / 2;
				else
					_startPrice = StartPriceFilter.Value;

				this[bar] = _startPrice;
				return;
			}

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			if (candle.Volume < prevCandle.Volume && _calcMode == Mode.Negative || candle.Volume > prevCandle.Volume && _calcMode == Mode.Positive)
			{
				var prevValue = (decimal)SourceDataSeries[bar - 1];
				this[bar] = this[bar - 1] + (value - prevValue) * this[bar - 1] / prevValue;
				return;
			}

			if (candle.Volume >= prevCandle.Volume && _calcMode == Mode.Negative || candle.Volume <= prevCandle.Volume && _calcMode == Mode.Positive)
				this[bar] = this[bar - 1];
		}

		#endregion
	}
}







Technical/VolumeOnChart.cs






namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;

[DisplayName("Volume On The Chart")]
[Category(IndicatorCategories.VolumeOrderFlow)]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumeOnChartDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619334")]
public class VolumeOnChart : Volume
{
	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Height), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PanelHeightDescription))]
	[Range(10, 100)]
	public decimal Height { get; set; } = 15;

	[Browsable(false)]
	public new bool ShowMaxVolume { get; set; }

	[Browsable(false)]
	public new int HiVolPeriod { get; set; }

	[Browsable(false)]
	public new CrossColor LineColor { get; set; }

	#endregion

	#region ctor

	public VolumeOnChart()
	{
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.LatestBar);
		Panel = IndicatorDataProvider.CandlesPanel;
		DenyToChangePanel = true;
		MaxVolSeries.VisualType = VisualMode.Hide;
		DataSeries.ForEach(x => x.IsHidden = true);
	}

	#endregion

	#region Public methods

	public override string ToString()
	{
		return "Volume on the chart";
	}

	#endregion

	#region Protected methods

	protected override void OnRecalculate()
	{
		DataSeries.ForEach(x => x.Clear());
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
		((ValueDataSeries)DataSeries[1]).VisualType = VisualMode.Hide;
	}

	protected override void OnCalculate(int bar, decimal value)
	{
		HighestVol.Calculate(bar, GetCandle(bar).Volume);
		base.OnCalculate(bar, value);
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		var maxValue = 0m;

		var maxHeight = Container.Region.Height * Height / 100m;
		var barsWidth = Math.Max(1, (int)ChartInfo.PriceChartContainer.BarsWidth);

		var strHeight = context.MeasureString("0", Font.RenderObject).Height;

        var textY = VolLocation switch
		{
			Location.Up => (int)(Container.Region.Bottom - maxHeight),
			Location.Down => Container.Region.Bottom - strHeight,
			_ => (int)(Container.Region.Bottom - maxHeight / 2)
        };

        for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
		{
			var candle = GetCandle(i);
			var volumeValue = Input == InputType.Volume ? candle.Volume : candle.Ticks;

			maxValue = Math.Max(volumeValue, maxValue);
		}

		for (var i = FirstVisibleBarNumber; i <= LastVisibleBarNumber; i++)
		{
			var candle = GetCandle(i);
			var volumeValue = Input == InputType.Volume ? candle.Volume : candle.Ticks;

			var volumeColor = ((ValueDataSeries)DataSeries[0]).Colors[i];

			var x = ChartInfo.GetXByBar(i);
			var height = (int)(maxHeight * volumeValue / maxValue);

			var rectangle = new Rectangle(x, Container.Region.Bottom - height, barsWidth, height);
			context.FillRectangle(volumeColor, rectangle);

			if (!ShowVolume || ChartInfo.ChartVisualMode != ChartVisualModes.Clusters)
				continue;

			var renderText = ChartInfo.TryGetMinimizedVolumeString(volumeValue);
            var textSize = context.MeasureString(renderText, Font.RenderObject);

			var strRect = new Rectangle(ChartInfo.GetXByBar(i),
				textY,
				Math.Max(barsWidth, textSize.Width),
				textSize.Height);
			context.DrawString(renderText, Font.RenderObject, TextColor, strRect, Format);
		}
	}

	#endregion
}







Technical/VolumePerTrade.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("Volume Per Trade")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumePerTradeIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000619357")]
    public class VolumePerTrade : Indicator
    {
	    private ValueDataSeries _renderSeries = new("RenderSeries", Strings.Values)
	    {
			UseMinimizedModeIfEnabled = true,
			VisualType = VisualMode.Histogram,
			ResetAlertsOnNewBar = true
	    };

	    public VolumePerTrade()
		    :base(true)
	    {
		    DenyToChangePanel = true;
		    Panel = IndicatorDataProvider.NewPanel;
		    DataSeries[0] = _renderSeries;
	    }
	    
	    protected override void OnCalculate(int bar, decimal value)
	    {
		    var candle = GetCandle(bar);
		    this[bar] = candle.Volume / candle.Ticks;
	    }
    }
}






Technical/VolumeSupResZones.cs






namespace ATAS.Indicators.Technical;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using Rectangle = System.Drawing.Rectangle;

[DisplayName("Volume-based Support & Resistance Zones")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumeSupResZonesDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619397")]
public class VolumeSupResZones : Indicator
 {
    #region Nested Types

    public enum LabelLocations
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Left))]
        Left,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Right))]
        Right
    }

    public enum DisplayMode
    {
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Zone))]
        Zone,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Line))]
        Line,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Disabled))]
        Disabled
    }

    public enum TimeFrameScale
    {
        M1 = 1,
        M5 = 5,
        M10 = 10,
        M15 = 15,
        M30 = 30,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Hourly))]
        Hourly = 60,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H2))]
        H2 = 120,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H4))]
        H4 = 240,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.H6))]
        H6 = 360,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Daily))]
        Daily = 1440,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Weekly))]
        Weekly = 10080,

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Monthly))]
        Monthly = 0
    }

    internal class TFPeriod
    {
        private int _startBar;
        private int _endBar;
        private decimal _open;
        private decimal _high = decimal.MinValue;
        private decimal _low = decimal.MaxValue;
        private decimal _close;
        private decimal _volume;
        private decimal _curBarVolume; 
        private int _highBar;
        private int _lowBar;
        private int _lastBar = -1;
        private bool _isNewPeriod;

        internal int StartBar => _startBar;
        internal int EndBar => _endBar;
        internal decimal Open => _open;
        internal decimal High => _high;
        internal decimal Low => _low;
        internal decimal Close => _close;
        internal decimal Volume => _volume + _curBarVolume;
        internal int HighBar => _highBar;
        internal int LowBar => _lowBar;
        internal bool IsNewPeriod => _isNewPeriod;

        internal TFPeriod(int bar, IndicatorCandle candle)
        {
            _startBar = bar;
            _open = candle.Open;
            AddCandle(bar, candle);
        }

        internal void AddCandle(int bar, IndicatorCandle candle)
        {
            if (candle.High > _high)
            {
                _high = candle.High;
                _highBar = bar;
            }

            if (candle.Low < _low)
            {
                _low = candle.Low;
                _lowBar = bar;
            }

            _close = candle.Close;
            _endBar = bar;
            _isNewPeriod = false;

            if (bar != _lastBar)
            {
                _volume += _curBarVolume;
                _isNewPeriod = true;
            }

            _curBarVolume = candle.Volume;

            _lastBar = bar;
        }
    }

    internal class Signal
    {
        internal int StartBar { get; set; }
        internal int StartBarNext { get; set; }
        internal int EndBar { get; set; }
        internal decimal HighPrice { get; set; }
        internal decimal LowPrice { get; set; }
    }

    internal class TimeFrameObj
    {
        private readonly List<TFPeriod> _periods = new();
        private readonly TimeFrameScale _timeFrame;
        private readonly int _secondsPerTframe;
        private readonly Func<int, bool> IsNewSession;
        private readonly Func<int, bool> IsNewWeek;
        private readonly Func<int, bool> IsNewMonth;
        private readonly Func<int, IndicatorCandle> GetCandle;
        private readonly int _smaPeriod;

        internal readonly List<Signal> _upperSignals = new();
        internal readonly List<Signal> _lowerSignals = new();
        private readonly string _name;

        private DateTime _firstCandleTime = new();
        private bool _isNewPeriod;

        internal TFPeriod this[int index]
        {
            get => _periods[Count - 1 - index];
            set => _periods[Count - 1 - index] = value;
        }

        internal string Name => _name;
        internal int Count => _periods.Count;
        internal bool IsNewPeriod => _isNewPeriod;
        internal int SecondsPerTframe => _secondsPerTframe;

        internal TimeFrameObj(TimeFrameScale timeFrame, 
                            int smaPeriod,
                            string name,
                            Func<int, bool> isNewSession,
                            Func<int, bool> isNewWeek,
                            Func<int, bool> isNewMonth,
                            Func<int, IndicatorCandle> getCandle)
        {
            _timeFrame = timeFrame;
            _secondsPerTframe = 60 * (int)timeFrame;
            IsNewSession = isNewSession;
            IsNewWeek = isNewWeek;
            IsNewMonth = isNewMonth;
            GetCandle = getCandle;
            _smaPeriod = smaPeriod;
            _name = name;           
        }

        internal decimal GetSmaVolume(int index) 
        {
            var sum = 0m;
            var start = Math.Max(0, Count - _smaPeriod - index);
            var realSmaPeriod = Math.Min(Count, _smaPeriod);

            for (int i = start; i < (start + realSmaPeriod); i++)
            {
                sum += _periods[i].Volume / realSmaPeriod;
            }

            return sum;
        }

        internal void AddBar(int bar)
        {
            _isNewPeriod = false;
            var candle = GetCandle(bar);

            if (bar == 0)
            {
                CreateNewPeriod(bar, candle);
                _firstCandleTime = candle.Time;
            }

            var beginTime = GetBeginTime(candle.Time, _timeFrame);
            var isNewBar = false;
            var isCustomPeriod = false;
            var endBar = _periods.Last().EndBar;

            if (_timeFrame == TimeFrameScale.Weekly)
            {
                isCustomPeriod = true;
                isNewBar = IsNewWeek(bar);
            }
            else if (_timeFrame == TimeFrameScale.Monthly)
            {
                isCustomPeriod = true;
                isNewBar = IsNewMonth(bar);
            }
            else if (_timeFrame == TimeFrameScale.Daily)
            {
                isCustomPeriod = true;
                isNewBar = IsNewSession(bar);
            }

            if (isNewBar || !isCustomPeriod && (beginTime >= GetCandle(endBar).LastTime))
            {
                if (!_periods.Exists(p => p.StartBar == bar))
                    CreateNewPeriod(bar, candle);
            }
            else
                _periods.Last().AddCandle(bar, candle);
        }

        private void CreateNewPeriod(int bar, IndicatorCandle candle)
        {
            _periods.Add(new TFPeriod(bar, candle));
            _isNewPeriod = true;
        }

        private DateTime GetBeginTime(DateTime time, TimeFrameScale period)
        {
            if (period == TimeFrameScale.Monthly)
                return new DateTime(time.Year, time.Month, 1);

            var tim = time;
            tim = tim.AddMilliseconds(-tim.Millisecond);
            tim = tim.AddSeconds(-tim.Second);

            var begin = (tim - _firstCandleTime).TotalMinutes % (int)period;
            var res = tim.AddMinutes(-begin);
            return res;
        }
    }

    #endregion

    #region Fields

    private readonly int _shift = 5;
    private readonly FontSetting _labelFont = new() { FontFamily = "Arial", Size = 10 };
    private readonly PenSettings _pen = new();

    private TimeFrameObj _tfObj1;
    private TimeFrameObj _tfObj2;
    private TimeFrameObj _tfObj3;
    private TimeFrameObj _tfObj4;

    private System.Drawing.Color _resColorTransp1;
    private System.Drawing.Color _supColorTransp1;
    private System.Drawing.Color _resColorTransp2;
    private System.Drawing.Color _supColorTransp2;
    private System.Drawing.Color _resColorTransp3;
    private System.Drawing.Color _supColorTransp3;
    private System.Drawing.Color _resColorTransp4;
    private System.Drawing.Color _supColorTransp4;

    private bool _isFixedTimeFrame;
    private int _secondsPerCandle;
   
    private TimeFrameScale _timeFrameType1;
    private int _smaPeriod1 = 6;
    private TimeFrameScale _timeFrameType2;
    private int _smaPeriod2 = 6;
    private TimeFrameScale _timeFrameType3;
    private int _smaPeriod3 = 6;
    private TimeFrameScale _timeFrameType4;
    private int _smaPeriod4 = 6;
    private CrossColor _resColor1 = System.Drawing.Color.Red.Convert();
    private CrossColor _supColor1 = System.Drawing.Color.Green.Convert();
    private int _zoneTransparency1 = 5;
    private CrossColor _resColor2 = System.Drawing.Color.Red.Convert();
    private CrossColor _supColor2 = System.Drawing.Color.Green.Convert();
    private int _zoneTransparency2 = 5;
    private CrossColor _resColor3 = System.Drawing.Color.Red.Convert();
    private CrossColor _supColor3 = System.Drawing.Color.Green.Convert();
    private int _zoneTransparency3 = 5;
    private CrossColor _resColor4 = System.Drawing.Color.Red.Convert();
    private CrossColor _supColor4 = System.Drawing.Color.Green.Convert();
    private int _zoneTransparency4 = 5;
    private CrossColor _alertForeColor = CrossColor.FromArgb(255, 247, 249, 249);
    private CrossColor _alertBackgroundColor = CrossColor.FromArgb(255, 75, 72, 72);

    #endregion

    #region Properties

    #region General

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ExtendPrevious), GroupName = nameof(Strings.General), Description = nameof(Strings.ExtendPreviousDescription))]
    public bool ExtendPrevious { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ExtendLast), GroupName = nameof(Strings.General), Description = nameof(Strings.ExtendLastDescription))]
    public bool ExtendLast { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTimeFrameLabel), GroupName = nameof(Strings.General), Description = nameof(Strings.IsNeedShowLabelDescription))]
    public bool ShowTimeFrameLabel { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LabelLocation), GroupName = nameof(Strings.General), Description = nameof(Strings.LabelLocationDescription))]
    public LabelLocations LabelLocation { get; set; }

    [Range(1, 50)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize), GroupName = nameof(Strings.General), Description = nameof(Strings.TextSizeDescription))]
    public int LabelTextSize 
    {
        get => _labelFont.Size;
        set => _labelFont.Size = value;
    }

    #endregion

    #region HighLow

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowLines), GroupName = nameof(Strings.HighLow), Description = nameof(Strings.IsNeedShowLinesDescription))]
    public bool ShowHLLines { get; set; } = true;

    [Range(1, 20)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.HighLow), Description = nameof(Strings.LineWidthDescription))]
    public int HLLineWidth { get; set; } = 2;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineStyle), GroupName = nameof(Strings.HighLow), Description = nameof(Strings.LineDashStyleDescription))]
    public LineDashStyle HLLineStyle { get; set; } = LineDashStyle.Solid;

    #endregion

    #region OpenClose

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowLines), GroupName = nameof(Strings.OpenClose), Description = nameof(Strings.IsNeedShowLinesDescription))]
    public bool ShowOCLines { get; set; } = true;

    [Range(1, 20)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineWidth), GroupName = nameof(Strings.OpenClose), Description = nameof(Strings.LineWidthDescription))]
    public int OCLineWidth { get; set; } = 2;

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LineStyle), GroupName = nameof(Strings.OpenClose), Description = nameof(Strings.LineDashStyleDescription))]
    public LineDashStyle OCLineStyle { get; set; } = LineDashStyle.Solid;

    #endregion

    #region TimeFrame1

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFrame), GroupName = nameof(Strings.TimeFrame1), Description = nameof(Strings.SelectTimeframeDescription))]
    public TimeFrameScale TimeFrameType1
    { 
        get => _timeFrameType1;
        set
        {
            _timeFrameType1 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DisplayMode), GroupName = nameof(Strings.TimeFrame1), Description = nameof(Strings.ElementDisplayModeDescription))]
    public DisplayMode DisplayMode1 { get; set; }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.TimeFrame1), Description = nameof(Strings.PeriodDescription))]
    public int SmaPeriod1
    {
        get => _smaPeriod1; 
        set
        {
            _smaPeriod1 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ResistanceColor), GroupName = nameof(Strings.TimeFrame1), Description = nameof(Strings.ResistanceColorDescription))]
    public CrossColor ResColor1 
    { 
        get => _resColor1;
        set
        {
            _resColor1 = value;
            _resColorTransp1 = GetColorTransparency(_resColor1, _zoneTransparency1).Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SupportColor), GroupName = nameof(Strings.TimeFrame1), Description = nameof(Strings.SupportColorDescription))]
    public CrossColor SupColor1 
    {
        get => _supColor1;
        set
        {
            _supColor1 = value;
            _supColorTransp1 = GetColorTransparency(_supColor1, _zoneTransparency1).Convert();
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.TimeFrame1), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int ZoneTransparency1 
    { 
        get => _zoneTransparency1; 
        set
        {
            _zoneTransparency1 = value;
            _resColorTransp1 = GetColorTransparency(_resColor1, _zoneTransparency1).Convert();
            _supColorTransp1 = GetColorTransparency(_supColor1, _zoneTransparency1).Convert();
        }
    }

    #endregion

    #region TimeFrame2

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFrame), GroupName = nameof(Strings.TimeFrame2), Description = nameof(Strings.SelectTimeframeDescription))]
    public TimeFrameScale TimeFrameType2 
    { 
        get => _timeFrameType2;
        set
        {
            _timeFrameType2 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DisplayMode), GroupName = nameof(Strings.TimeFrame2), Description = nameof(Strings.ElementDisplayModeDescription))]
    public DisplayMode DisplayMode2 { get; set; }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.TimeFrame2), Description = nameof(Strings.PeriodDescription))]
    public int SmaPeriod2 
    { 
        get => _smaPeriod2; 
        set
        {
            _smaPeriod2 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ResistanceColor), GroupName = nameof(Strings.TimeFrame2), Description = nameof(Strings.ResistanceColorDescription))]
    public CrossColor ResColor2 
    {
        get => _resColor2; 
        set
        {
            _resColor2 = value;
            _resColorTransp2 = GetColorTransparency(_resColor2, _zoneTransparency2).Convert();
        } 
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SupportColor), GroupName = nameof(Strings.TimeFrame2), Description = nameof(Strings.SupportColorDescription))]
    public CrossColor SupColor2 
    { 
        get => _supColor2; 
        set
        {
            _supColor2 = value;
            _supColorTransp2 = GetColorTransparency(_supColor2, _zoneTransparency2).Convert();
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.TimeFrame2), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int ZoneTransparency2 
    {
        get => _zoneTransparency2;
        set
        {
            _zoneTransparency2 = value;
            _resColorTransp2 = GetColorTransparency(_resColor2, _zoneTransparency2).Convert();
            _supColorTransp2 = GetColorTransparency(_supColor2, _zoneTransparency2).Convert();
        }
    }

    #endregion

    #region TimeFrame3

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFrame), GroupName = nameof(Strings.TimeFrame3), Description = nameof(Strings.SelectTimeframeDescription))]
    public TimeFrameScale TimeFrameType3 
    {
        get => _timeFrameType3;
        set
        {
            _timeFrameType3 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DisplayMode), GroupName = nameof(Strings.TimeFrame3), Description = nameof(Strings.ElementDisplayModeDescription))]
    public DisplayMode DisplayMode3 { get; set; }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.TimeFrame3), Description = nameof(Strings.PeriodDescription))]
    public int SmaPeriod3 
    {
        get => _smaPeriod3; 
        set
        {
            _smaPeriod3 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ResistanceColor), GroupName = nameof(Strings.TimeFrame3), Description = nameof(Strings.ResistanceColorDescription))]
    public CrossColor ResColor3 
    { 
        get => _resColor3;
        set
        {
            _resColor3 = value;
            _resColorTransp3 = GetColorTransparency(_resColor3, _zoneTransparency3).Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SupportColor), GroupName = nameof(Strings.TimeFrame3), Description = nameof(Strings.SupportColorDescription))]
    public CrossColor SupColor3 
    { 
        get => _supColor3;
        set
        {
            _supColor3 = value;
            _supColorTransp3 = GetColorTransparency(_supColor3, _zoneTransparency3).Convert();
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.TimeFrame3), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int ZoneTransparency3 
    {
        get => _zoneTransparency3; 
        set
        {
            _zoneTransparency3 = value;
            _resColorTransp3 = GetColorTransparency(_resColor3, _zoneTransparency3).Convert();
            _supColorTransp3 = GetColorTransparency(_supColor3, _zoneTransparency3).Convert();
        }
    }

    #endregion

    #region TimeFrame4

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.TimeFrame), GroupName = nameof(Strings.TimeFrame4), Description = nameof(Strings.SelectTimeframeDescription))]
    public TimeFrameScale TimeFrameType4 
    { 
        get => _timeFrameType4;
        set
        {
            _timeFrameType4 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.DisplayMode), GroupName = nameof(Strings.TimeFrame4), Description = nameof(Strings.ElementDisplayModeDescription))]
    public DisplayMode DisplayMode4 { get; set; }

    [Range(1, int.MaxValue)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMAPeriod), GroupName = nameof(Strings.TimeFrame4), Description = nameof(Strings.PeriodDescription))]
    public int SmaPeriod4 
    { 
        get => _smaPeriod4; 
        set
        {
            _smaPeriod4 = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ResistanceColor), GroupName = nameof(Strings.TimeFrame4), Description = nameof(Strings.ResistanceColorDescription))]
    public CrossColor ResColor4 
    { 
        get => _resColor4; 
        set
        {
            _resColor4 = value;
            _resColorTransp4 = GetColorTransparency(_resColor4, _zoneTransparency4).Convert();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SupportColor), GroupName = nameof(Strings.TimeFrame4), Description = nameof(Strings.SupportColorDescription))]
    public CrossColor SupColor4 
    {
        get => _supColor4;
        set
        {
            _supColor4 = value;
            _supColorTransp4 = GetColorTransparency(_supColor4, _zoneTransparency4).Convert();
        }
    }

    [Range(0, 10)]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Transparency), GroupName = nameof(Strings.TimeFrame4), Description = nameof(Strings.VisualObjectsTransparencyDescription))]
    public int ZoneTransparency4 
    { 
        get => _zoneTransparency4;
        set
        {
            _zoneTransparency4 = value;
            _resColorTransp4 = GetColorTransparency(_resColor4, _zoneTransparency4).Convert();
            _supColorTransp4 = GetColorTransparency(_supColor4, _zoneTransparency4).Convert();
        }
    }

    #endregion

    #region Alerts

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.UseAlert), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.UseAlertDescription))]
    public bool UseAlert { get; set; }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.AlertFile), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFileDescription))]
    public string AlertFile { get; set; } = "alert1";

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Foreground), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertTextColorDescription))]
    [DataMember]
    public CrossColor AlertForeColor
    {
        get => _alertForeColor;
        set => _alertForeColor = value;
    }

    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.BackGround), GroupName = nameof(Strings.Alerts), Description = nameof(Strings.AlertFillColorDescription))]
    [DataMember]
    public CrossColor AlertBGColor
    {
        get => _alertBackgroundColor;
        set => _alertBackgroundColor = value;
    }

    #endregion

    #endregion

    #region ctor

    public VolumeSupResZones() : base(true)
    {
        DenyToChangePanel = true;
        DataSeries[0].IsHidden = true;
        ((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;
        EnableCustomDrawing = true;
        SubscribeToDrawingEvents(DrawingLayouts.Final);

        _resColorTransp1 = GetColorTransparency(_resColor1, _zoneTransparency1).Convert();
        _supColorTransp1 = GetColorTransparency(_supColor1, _zoneTransparency1).Convert();
        _resColorTransp2 = GetColorTransparency(_resColor2, _zoneTransparency2).Convert();
        _supColorTransp2 = GetColorTransparency(_supColor2, _zoneTransparency2).Convert();
        _resColorTransp3 = GetColorTransparency(_resColor3, _zoneTransparency3).Convert();
        _supColorTransp3 = GetColorTransparency(_supColor3, _zoneTransparency3).Convert();
        _resColorTransp4 = GetColorTransparency(_resColor4, _zoneTransparency4).Convert();
        _supColorTransp4 = GetColorTransparency(_supColor4, _zoneTransparency4).Convert();
    }

    #endregion

    #region Protected Methods

    protected override void OnRecalculate()
    {
        SetCandleSeconds();
        _tfObj1 = new(TimeFrameType1, _smaPeriod1, "Time frame 1", IsNewSession, IsNewWeek, IsNewMonth, GetCandle);
        _tfObj2 = new(TimeFrameType2, _smaPeriod2, "Time frame 2", IsNewSession, IsNewWeek, IsNewMonth, GetCandle);
        _tfObj3 = new(TimeFrameType3, _smaPeriod3, "Time frame 3", IsNewSession, IsNewWeek, IsNewMonth, GetCandle);
        _tfObj4 = new(TimeFrameType4, _smaPeriod4, "Time frame 4", IsNewSession, IsNewWeek, IsNewMonth, GetCandle);
    }

    protected override void OnCalculate(int bar, decimal value)
    {
        if (!_isFixedTimeFrame) return;

        TimeFrameObjCalculate(bar, _tfObj1);
        TimeFrameObjCalculate(bar, _tfObj2);
        TimeFrameObjCalculate(bar, _tfObj3);
        TimeFrameObjCalculate(bar, _tfObj4);
    }

    protected override void OnRender(RenderContext context, DrawingLayouts layout)
    {
        if (ChartInfo == null) return;

        DrawSupportResistance(context, _tfObj1, DisplayMode1, _supColor1, _resColor1, _supColorTransp1, _resColorTransp1, _timeFrameType1);
        DrawSupportResistance(context, _tfObj2, DisplayMode2, _supColor2, _resColor2, _supColorTransp2, _resColorTransp2, _timeFrameType2);
        DrawSupportResistance(context, _tfObj3, DisplayMode3, _supColor3, _resColor3, _supColorTransp3, _resColorTransp3, _timeFrameType3);
        DrawSupportResistance(context, _tfObj4, DisplayMode4, _supColor4, _resColor4, _supColorTransp4, _resColorTransp4, _timeFrameType4);
    }

    #endregion

    #region Private Methods

    private void DrawSupportResistance(RenderContext context, TimeFrameObj tfObj, DisplayMode displayMode,
                                       CrossColor supColor, CrossColor resColor,
                                       System.Drawing.Color supColorTransp, System.Drawing.Color resColorTransp, 
                                       TimeFrameScale tfType)
    {
        if(displayMode == DisplayMode.Disabled) return;

        var upper = tfObj._upperSignals;
        DrawSignals(context, upper, displayMode, resColor, resColorTransp, tfType, true);

        var lower = tfObj._lowerSignals;
        DrawSignals(context, lower, displayMode, supColor, supColorTransp, tfType, false);
    }

    private void DrawSignals(RenderContext context, List<Signal> signals, DisplayMode displayMode,
                             CrossColor color, System.Drawing.Color colorTransp, TimeFrameScale tfType, bool isUpper)
    {
        foreach (var signal in signals)
        {
            var endBar = ExtendPrevious
                ? signal == signals.Last()
                  ? signal.EndBar
                  : signal.StartBarNext
                : signal.EndBar;

            if (signal == signals.Last() && ExtendLast)
                endBar = CurrentBar - 1;

            if (signal.StartBar > LastVisibleBarNumber || endBar < FirstVisibleBarNumber)
                continue;

            var x1 = ChartInfo.GetXByBar(signal.StartBar);
            var x2 = ChartInfo.GetXByBar(endBar);

            if (signal == signals.Last() && ExtendLast)
                x2 = ChartInfo.Region.Width;

            var highY = ChartInfo.GetYByPrice(signal.HighPrice, false);
            var lowY = ChartInfo.GetYByPrice(signal.LowPrice, false);
            _pen.Color = color;

            if (ShowHLLines && ShowOCLines && displayMode == DisplayMode.Zone)
            {
                var rec = new Rectangle(x1, highY, x2 - x1, lowY - highY);
                context.FillRectangle(colorTransp, rec);
            }

            if (ShowHLLines)
            {
                _pen.Width = HLLineWidth;
                _pen.LineDashStyle = HLLineStyle;
                context.DrawLine(_pen.RenderObject, x1, highY, x2, highY);
            }

            if (ShowOCLines)
            {
                _pen.Width = OCLineWidth;
                _pen.LineDashStyle = OCLineStyle;
                context.DrawLine(_pen.RenderObject, x1, lowY, x2, lowY);
            }

            if (signal == signals.Last() && ShowTimeFrameLabel)
            {
                var zoneType = isUpper ? "R" : "S";
                var lText = $"{tfType} ({zoneType})";
                var labelSize = context.MeasureString(lText, _labelFont.RenderObject);
                var lX = LabelLocation == LabelLocations.Left ? x1 - labelSize.Width : ChartInfo.GetXByBar(endBar);
                var lY = isUpper ? highY - _shift - labelSize.Height : lowY + _shift;
                var rec = new Rectangle(lX, lY, labelSize.Width, labelSize.Height);
                context.DrawString(lText, _labelFont.RenderObject, color.Convert(), rec);
            } 
        }
    }

    private CrossColor GetColorTransparency(CrossColor color, int tr = 5)
    {
        var alfa = Math.Max(color.A - tr * 25, 0);
        return CrossColor.FromArgb((byte)(alfa), color.R, color.G, color.B);
    }

    private void TimeFrameObjCalculate(int bar, TimeFrameObj tfObj)
    {
        if (_secondsPerCandle > tfObj.SecondsPerTframe) return;

        tfObj.AddBar(bar);

        if (tfObj.IsNewPeriod && tfObj.Count > 5)
        {
            if (tfObj[3].High > tfObj[4].High && tfObj[4].High > tfObj[5].High
                && tfObj[3].High > tfObj[2].High && tfObj[2].High > tfObj[1].High
                && tfObj[3].Volume > tfObj.GetSmaVolume(3))
            {
                if (tfObj._upperSignals.Count > 0)
                    tfObj._upperSignals[^1].StartBarNext = tfObj[3].HighBar;

                var signal = new Signal()
                {
                    StartBar = tfObj[3].HighBar,
                    EndBar = tfObj[0].StartBar,
                    HighPrice = tfObj[3].High,
                    LowPrice = Math.Max(tfObj[3].Open, tfObj[3].Close)
                };

                tfObj._upperSignals.Add(signal);
                TrySetAlert(bar, tfObj, true);
            }
            else if (tfObj[3].Low < tfObj[4].Low && tfObj[4].Low < tfObj[5].Low
                && tfObj[3].Low < tfObj[2].Low && tfObj[2].Low < tfObj[1].Low
                && tfObj[3].Volume > tfObj.GetSmaVolume(3))
            {
                if (tfObj._lowerSignals.Count > 0)
                    tfObj._lowerSignals[^1].StartBarNext = tfObj[3].LowBar;

                var signal = new Signal()
                {
                    StartBar = tfObj[3].LowBar,
                    EndBar = tfObj[0].StartBar,
                    LowPrice = tfObj[3].Low,
                    HighPrice = Math.Min(tfObj[3].Open, tfObj[3].Close)
                };

                tfObj._lowerSignals.Add(signal);
                TrySetAlert(bar, tfObj, false);
            }
        }
    }

    private void TrySetAlert(int bar, TimeFrameObj tfObj, bool isUpper)
    {
        if (bar != CurrentBar - 1 || !UseAlert)
            return;

        var dir = isUpper ? "upper" : "lower";
        var endLine = Environment.NewLine;
        var message = $"New Zone appeared!{endLine}" +
                      $"{tfObj.Name} {dir}{endLine}";

        AddAlert(AlertFile, InstrumentInfo.Instrument, message, _alertBackgroundColor, _alertForeColor);
    }

    private void SetCandleSeconds()
    {
        if (ChartInfo is null) return;

        var timeFrame = ChartInfo.TimeFrame;

        if (ChartInfo.ChartType == "Seconds")
        {
            _isFixedTimeFrame = true;

            _secondsPerCandle = ChartInfo.TimeFrame switch
            {
                "5" => 5,
                "10" => 10,
                "15" => 15,
                "30" => 30,
                _ => 0
            };

            if (_secondsPerCandle == 0)
            {
                if (int.TryParse(Regex.Match(timeFrame, @"\d{1,}$").Value, out var periodSec))
                {
                    _secondsPerCandle = periodSec;
                    return;
                }
            }
        }

        if (ChartInfo.ChartType != "TimeFrame")
            return;

        _isFixedTimeFrame = true;

        _secondsPerCandle = ChartInfo.TimeFrame switch
        {
            "M1" => 60 * (int)TimeFrameScale.M1,
            "M5" => 60 * (int)TimeFrameScale.M5,
            "M10" => 60 * (int)TimeFrameScale.M10,
            "M15" => 60 * (int)TimeFrameScale.M15,
            "M30" => 60 * (int)TimeFrameScale.M30,
            "H1" => 60 * (int)TimeFrameScale.Hourly,
            "H2" => 60 * (int)TimeFrameScale.H2,
            "H4" => 60 * (int)TimeFrameScale.H4,
            "H6" => 60 * (int)TimeFrameScale.H6,
            "Daily" => 60 * (int)TimeFrameScale.Daily,
            "Weekly" => 60 * (int)TimeFrameScale.Weekly,
            _ => 0
        };

        if (_secondsPerCandle != 0)
            return;

        if (!int.TryParse(Regex.Match(timeFrame, @"\d{1,}$").Value, out var period))
            return;

        if (timeFrame.Contains('M'))
        {
            _secondsPerCandle = 60 * (int)TimeFrameScale.M1 * period;
            return;
        }

        if (timeFrame.Contains('H'))
        {
            _secondsPerCandle = 60 * (int)TimeFrameScale.Daily * period;
            return;
        }

        if (timeFrame.Contains('D'))
            _secondsPerCandle = 60 * (int)TimeFrameScale.Daily * period;
    }

    #endregion
}








Technical/VolumeTrend.cs








namespace ATAS.Indicators.Technical
{
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
   
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Price Volume Trend")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumeTrendDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602450")]
	public class VolumeTrend : Indicator
	{
		#region ctor

		public VolumeTrend()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			LineSeries.Add(new LineSeries("ZeroVal", Strings.ZeroValue) { Color = System.Drawing.Color.Gray.Convert(), Value = 0, Width = 2 });
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			this[bar] = candle.Close != 0
				? (candle.Close - prevCandle.Close) / candle.Close * candle.Volume + this[bar - 1]
				: this[bar - 1];
		}

		#endregion
	}
}







Technical/VolumeZone.cs







namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Volume Zone Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VolumeZoneIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602268")]
	public class VolumeZone : Indicator
	{
		#region Fields

		private readonly EMA _emaTv = new();
		private readonly EMA _emaVp = new();
		private LineSeries _overboughtLine1 = new("OverboughtLine1", Strings.Overbought1)
		{
			Value = 50,
			Color = System.Drawing.Color.LawnGreen.Convert(),
			IsHidden = true,
		};
		private LineSeries _overboughtLine2 = new("OverboughtLine2", Strings.Overbought2)
		{
			Value = 75,
			Color = System.Drawing.Color.LimeGreen.Convert(),
			IsHidden = true,
        };
		private LineSeries _overboughtLine3 = new("OverboughtLine3", Strings.Overbought3)
		{
			Value = 90,
			Color = System.Drawing.Color.DarkGreen.Convert(),
			IsHidden = true,
        };
		private LineSeries _oversoldLine1 = new("OversoldLine1", Strings.Oversold1)
		{
			Value = -50,
			Color = System.Drawing.Color.IndianRed.Convert(),
			IsHidden = true,
        };
		private LineSeries _oversoldLine2 = new("OversoldLine2", Strings.Oversold2)
		{
			Value = -75,
			Color = System.Drawing.Color.Red.Convert(),
			IsHidden = true,
        };
		private LineSeries _oversoldLine3 = new("OversoldLine3", Strings.Oversold3)
		{
			Value = -90,
			Color = System.Drawing.Color.DarkRed.Convert(),
			IsHidden = true,
        };
		
		private bool _drawLines = true;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 10)]
		[Range(1, 10000)]
		public int Period
		{
			get => _emaVp.Period;
			set
			{
				_emaVp.Period = _emaTv.Period = value;
				RecalculateValues();
			}
		}
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Show),
			GroupName = nameof(Strings.Line),
			Order = 30)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if (LineSeries.Contains(_overboughtLine3))
						return;

					LineSeries.Add(_overboughtLine3);
					LineSeries.Add(_overboughtLine2);
					LineSeries.Add(_overboughtLine1);
					LineSeries.Add(_oversoldLine1);
					LineSeries.Add(_oversoldLine2);
					LineSeries.Add(_oversoldLine3);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Overbought3),
			GroupName = nameof(Strings.Line),
			Description = nameof(Strings.OverboughtLimitDescription),
            Order = 40)]
		public LineSeries OverboughtLine3
		{
			get=> _overboughtLine3;
			set=> _overboughtLine3 = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Overbought2),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OverboughtLimitDescription),
            Order = 50)]
		public LineSeries OverboughtLine2
		{
			get=> _overboughtLine2;
			set=> _overboughtLine2 = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Overbought1),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OverboughtLimitDescription),
            Order = 60)]
		public LineSeries OverboughtLine1
		{
			get=> _overboughtLine1;
			set=> _overboughtLine1 = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Oversold1),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OversoldLimitDescription),
            Order = 70)]
		public LineSeries OversoldLine1
        {
			get=> _oversoldLine1;
			set=> _oversoldLine1 = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Oversold2),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OversoldLimitDescription),
            Order = 80)]
		public LineSeries OversoldLine2
        {
			get=> _oversoldLine2;
			set=> _oversoldLine2 = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Oversold3),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OversoldLimitDescription),
            Order = 90)]
		public LineSeries OversoldLine3
        {
			get=> _oversoldLine3;
			set=> _oversoldLine3 = value;
		}

        #endregion

        #region ctor

        public VolumeZone()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
            LineSeries.Add(_overboughtLine1);
			LineSeries.Add(_overboughtLine2);
			LineSeries.Add(_overboughtLine3);
			LineSeries.Add(_oversoldLine1);
			LineSeries.Add(_oversoldLine2);
			LineSeries.Add(_oversoldLine3);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			if (bar == 0)
			{
				_emaVp.Calculate(bar, candle.Volume);
				_emaTv.Calculate(bar, candle.Volume);
				return;
			}

			var prevCandle = GetCandle(bar - 1);

			var rVolume = candle.Close > prevCandle.Close ? candle.Volume : -candle.Volume;

			_emaVp.Calculate(bar, rVolume);
			_emaTv.Calculate(bar, candle.Volume);

			this[bar] = _emaTv[bar] != 0
				? _emaVp[bar] / _emaTv[bar] * 100
				: this[bar - 1];
		}

		#endregion
	}
}






Technical/Vortex.cs





namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;

[DisplayName("Vortex")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.VortexIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000619446")]
public class Vortex : Indicator
{
	#region Fields

	private int _period = 10;

	private ValueDataSeries _trueRange = new("TrueRange");
	private ValueDataSeries _vortexMoveDown = new("MoveDown");
	private ValueDataSeries _vortexMoveUp = new("MoveUp");

	private ValueDataSeries _vortexNeg = new("VortexNeg", "Vortex-")
	{
		DescriptionKey = nameof(Strings.NegativeLineSettingsDescription)
	};

	private ValueDataSeries _vortexPos = new("VortexPos", "Vortex+")
	{
		Color = DefaultColors.Green.Convert(),
        DescriptionKey = nameof(Strings.PositiveLineSettingsDescription)
    };

    #endregion

    #region Properties

    [Parameter]
    [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
	[Range(1, 10000)]
	public int Period
	{
		get => _period;
		set
		{
			_period = value;
			RecalculateValues();
		}
	}

	#endregion

	#region ctor

	public Vortex()
		: base(true)
	{
		Panel = IndicatorDataProvider.NewPanel;

		DataSeries[0] = _vortexPos;
		DataSeries.Add(_vortexNeg);
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
		var candle = GetCandle(bar);

		if (bar == 0)
		{
			_trueRange[bar] = candle.High - candle.Low;
			_vortexMoveUp[bar] = Math.Abs(candle.High - candle.Low);
			_vortexMoveDown[bar] = Math.Abs(candle.Low - candle.High);

			DataSeries.ForEach(x => ((ValueDataSeries)x).SetPointOfEndLine(0));
			return;
		}

		var prevCandle = GetCandle(bar - 1);

		var highLow = candle.High - candle.Low;
		var highCloseDiff = Math.Abs(candle.High - prevCandle.Close);
		var lowCloseDiff = Math.Abs(candle.Low - prevCandle.Close);

		var trueRange = Math.Max(highLow, highCloseDiff);
		trueRange = Math.Max(trueRange, lowCloseDiff);

		_trueRange[bar] = trueRange;

		_vortexMoveUp[bar] = Math.Abs(candle.High - prevCandle.Low);
		_vortexMoveDown[bar] = Math.Abs(candle.Low - prevCandle.High);

		var trueRangeSum = _trueRange.CalcSum(Period, bar);

		var moveUpSum = _vortexMoveUp.CalcSum(Period, bar);

		_vortexPos[bar] = trueRangeSum == 0
			? _vortexMoveUp[bar - 1]
			: moveUpSum / trueRangeSum;

		var moveDownSum = _vortexMoveDown.CalcSum(Period, bar);

		_vortexNeg[bar] = trueRangeSum == 0
			? _vortexMoveDown[bar - 1]
			: moveDownSum / trueRangeSum;
	}

	#endregion
}





Technical/VsaBetterVolume.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using Color = System.Drawing.Color;
	
    [DisplayName("VSA Better Volume")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VsaBetterVolumeDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602502")]
	public class VsaBetterVolume : Indicator
	{
        #region Fields

        private int _period = 14;
		private decimal _tickSize;
		
		private readonly Highest _highestAbs = new() { Period = 20 };
		private readonly Highest _highestComp = new() { Period = 20 };

		private readonly Lowest _lowest = new() { Period = 20 };
		private readonly Highest _lowestComp = new() { Period = 20 };

		private readonly ValueDataSeries _volume = new("Volume");
        private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Volume)
		{
			Color = System.Drawing.Color.DodgerBlue.Convert(),
			Width = 2,
			VisualType = VisualMode.Histogram,
			ShowZeroValue = false,
			UseMinimizedModeIfEnabled = true,
			ResetAlertsOnNewBar = true,
            DescriptionKey = nameof(Strings.VolumeHistSettingsDescription)
        };

		private readonly ValueDataSeries _v4Series = new("V4Series", "V4")
		{
			Color = System.Drawing.Color.LightSeaGreen.Convert(),
			Width = 1,
			VisualType = VisualMode.Line,
			UseMinimizedModeIfEnabled = true,
			IgnoredByAlerts = true,
			DescriptionKey = nameof(Strings.AvgVolumeLineSettingsDescription)
		};

		private Color _yellowColor = Color.Orange;
		private Color _whiteColor = Color.LightGray;
		private Color _redColor = DefaultColors.DarkRed;
		private Color _magentaColor = Color.DarkMagenta;
		private Color _greenColor = DefaultColors.Green;
		private Color _blueColor = Color.DodgerBlue;

		#endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = "Blue", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 610)]
        public CrossColor BlueColor
        {
	        get => _blueColor.Convert();
	        set
	        {
		        _blueColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = "Green", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 620)]
        public CrossColor GreenColor
        {
	        get => _greenColor.Convert();
	        set
	        {
		        _greenColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = "Magenta", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 625)]
        public CrossColor MagentaColor
        {
	        get => _magentaColor.Convert();
	        set
	        {
		        _magentaColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = "Red", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 630)]
        public CrossColor RedColor
        {
	        get => _redColor.Convert();
	        set
	        {
		        _redColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = "White", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 650)]
        public CrossColor WhiteColor
        {
	        get => _whiteColor.Convert();
	        set
	        {
		        _whiteColor = value.Convert();
		        RecalculateValues();
	        }
        }
        [Display(ResourceType = typeof(Strings), Name = "Yellow", GroupName = nameof(Strings.Drawing), Description = nameof(Strings.ColorDescription), Order = 660)]
        public CrossColor YellowColor
        {
	        get => _yellowColor.Convert();
	        set
	        {
		        _yellowColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 0)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.RetrospectiveAnalysis), GroupName = nameof(Strings.Settings), Description = nameof(Strings.HighestLowestPeriodDescription), Order = 1)]
		[Range(1, 10000)]
        public int LookBack
		{
			get => _highestAbs.Period;
			set
			{
				_highestAbs.Period = _highestComp.Period = value;
				_lowestComp.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public VsaBetterVolume()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _renderSeries;
			DataSeries.Add(_v4Series);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				DataSeries.ForEach(x => x.Clear());
				_tickSize = ChartInfo.PriceChartContainer.Step;
			}

			var candle = GetCandle(bar);
			_volume[bar] = candle.Volume;

			var volLowest = _lowest.Calculate(bar, candle.Volume);
			_renderSeries[bar] = candle.Volume;

			_renderSeries.Colors[bar] = candle.Volume == volLowest ? _yellowColor : _blueColor;
			
			var range = (candle.High - candle.Low) / _tickSize;
			var value2 = candle.Volume * range;

			var value3 = 0.0m;

			if (range != 0)
				value3 = candle.Volume / range;

			var sumVolume = _volume.CalcSum(Period, bar);

			_v4Series[bar] = sumVolume / Period;

			var hiValue2 = _highestAbs.Calculate(bar, value2);

			if (value2 != 0)
				_highestComp.Calculate(bar, value3);

			if (value2 == hiValue2 && candle.Close > (candle.High + candle.Low) / 2.0m && candle.Close >= candle.Open)
				_renderSeries.Colors[bar] = _redColor;

			if (value3 == _highestComp[bar])
				_renderSeries.Colors[bar] = _greenColor;

			if (value2 == hiValue2 && value3 == _highestComp[bar])
				_renderSeries.Colors[bar] = _magentaColor;

			if (value2 == hiValue2 && candle.Close <= (candle.High + candle.Low) / 2.0m && candle.Close <= candle.Open)
				_renderSeries.Colors[bar] = _whiteColor;
		}

		#endregion
	}
}








Technical/VsaWsd.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("VSA – WSD Histogram")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.VsaWsdDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602501")]
	public class VsaWsd : Indicator
	{
        #region Fields

		private decimal _tickSize;
        private readonly EMA _ema = new() { Period = 100 };

        private readonly ValueDataSeries _avgVolume = new("AvgVolumeId", "AvgVolume")
		{
			Color = System.Drawing.Color.Goldenrod.Convert(),
			LineDashStyle = LineDashStyle.Dash,
			UseMinimizedModeIfEnabled = true,
            DescriptionKey = nameof(Strings.AvgVolumeLineSettingsDescription)
        };
        private readonly ValueDataSeries _dotsBuy = new("DotsBuyId", "DotsBuy")
		{
			Color = DefaultColors.Lime.Convert(),
			VisualType = VisualMode.Dots,
			LineDashStyle = LineDashStyle.Dot,
			Width = 5,
            ShowTooltip = false,
			ShowCurrentValue = false,
			ShowZeroValue = false,
			IgnoredByAlerts = true,
			ResetAlertsOnNewBar = true,
            DescriptionKey = nameof(Strings.BuySignalSettingsDescription)
        };
        private readonly ValueDataSeries _dotsNeutral = new("DotsNeutralId", "DotsNeutral")
        {
			Color = System.Drawing.Color.Gray.Convert(),
			VisualType = VisualMode.Dots,
			LineDashStyle = LineDashStyle.Dot,
			Width = 5,
            ShowTooltip = false,
			ShowCurrentValue = false,
			ShowZeroValue = false,
			IgnoredByAlerts = true,
			ResetAlertsOnNewBar = true
        };
		private readonly ValueDataSeries _dotsSell = new("DotsSellId", "DotsSell")
		{
			Color = DefaultColors.Red.Convert(),
			VisualType = VisualMode.Dots,
			LineDashStyle = LineDashStyle.Dot,
			Width = 5,
			ShowTooltip = false,
			ShowCurrentValue = false,
			ShowZeroValue = false,
			IgnoredByAlerts = true,
			ResetAlertsOnNewBar = true,
            DescriptionKey = nameof(Strings.SellSignalSettingsDescription)
        };
		private readonly ValueDataSeries _highLow = new("HighLowId", "HighLow")
		{
			Color = DefaultColors.Blue.Convert(),
			VisualType = VisualMode.Histogram,
			Width = 2,
            UseMinimizedModeIfEnabled = true,
            IgnoredByAlerts = true,
            ResetAlertsOnNewBar = true,
            DescriptionKey = nameof(Strings.CandleSizeSettingsDescription)
        };
		private readonly ValueDataSeries _lowerWick = new("LowerWickId", "LowerWick")
		{
			Color = DefaultColors.Red.Convert(),
			VisualType = VisualMode.Histogram,
			Width = 2,
            UseMinimizedModeIfEnabled = true,
            IgnoredByAlerts = true,
            ResetAlertsOnNewBar = true,
            DescriptionKey = nameof(Strings.LowerWickSettingsDescription)            
        };
		private readonly ValueDataSeries _upperWick = new("UpperWickId", "UpperWick")
		{
			Color = DefaultColors.Lime.Convert(),
			VisualType = VisualMode.Histogram,
			Width = 2,
			UseMinimizedModeIfEnabled = true,
			IgnoredByAlerts = true,
			ResetAlertsOnNewBar = true,
            DescriptionKey = nameof(Strings.UpperWickSettingsDescription)
        };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 1)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public VsaWsd()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			
			DataSeries[0] = _highLow;
			DataSeries.Add(_upperWick);
			DataSeries.Add(_lowerWick);
			DataSeries.Add(_avgVolume);
			DataSeries.Add(_dotsBuy);
			DataSeries.Add(_dotsSell);
			DataSeries.Add(_dotsNeutral);
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_dotsBuy.Clear();
				_dotsSell.Clear();
				_dotsNeutral.Clear();
				_tickSize = ChartInfo.PriceChartContainer.Step;
			}

			var candle = GetCandle(bar);
			var result = candle.High - candle.Low;

			_highLow[bar] = result / _tickSize;

			var dResult1 = candle.Open > candle.Close
				? candle.High - candle.Open
                : candle.High - candle.Close;
			
			var dResult2 = candle.Open > candle.Close
				? candle.Low - candle.Close
				: candle.Low - candle.Open;
			
			_upperWick[bar] = dResult1 / _tickSize;
			_lowerWick[bar] = dResult2 / _tickSize;

			var volume = (candle.High - candle.Low) / _tickSize;
			_avgVolume[bar] = _ema.Calculate(bar, volume);

			if (bar == 0)
				return;

			var prevCandle = GetCandle(bar - 1);

			if (candle.Close > prevCandle.Open && _highLow[bar] < _highLow[bar - 1])
			{
				_dotsBuy[bar] = _highLow[bar];
				_dotsSell[bar] = _dotsNeutral[bar] = 0;
			}
			else if (candle.Close < prevCandle.Open && _highLow[bar] < _highLow[bar - 1])
			{
				_dotsSell[bar] = _highLow[bar];
				_dotsBuy[bar] = _dotsNeutral[bar] = 0;
			}
			else
			{
				_dotsNeutral[bar] = _highLow[bar];
				_dotsBuy[bar] = _dotsSell[bar] = 0;
			}
		}

		#endregion
	}
}







Technical/WAD.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Accumulation / Distribution - Williams")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WADDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602568")]
	public class WAD : Indicator
	{
		#region ctor

		public WAD()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
				return;

			var candle = GetCandle(bar);
			var prevCandle = GetCandle(bar - 1);

			if (candle.Close > prevCandle.Close)
				this[bar] = this[bar - 1] + candle.Close - Math.Min(candle.Low, prevCandle.Close);
			else if (candle.Close < prevCandle.Close)
				this[bar] = this[bar - 1] + candle.Close - Math.Max(candle.High, prevCandle.Close);
			else
				this[bar] = this[bar - 1];
		}

		#endregion
	}
}






Technical/WAO.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Weighted Average Oscillator")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WAODescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602506")]
	public class WAO : Indicator
	{
		#region Fields

		private readonly WMA _longWma = new() { Period = 30 };
		private readonly WMA _shortWma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShortPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.ShortPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int ShortPeriod
		{
			get => _shortWma.Period;
			set
			{
				_shortWma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.LongPeriod), GroupName = nameof(Strings.Settings), Description = nameof(Strings.LongPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int LongPeriod
		{
			get => _longWma.Period;
			set
			{
				_longWma.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public WAO()
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0].UseMinimizedModeIfEnabled = true;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			this[bar] = _shortWma.Calculate(bar, value) - _longWma.Calculate(bar, value);
		}

		#endregion
	}
}






Technical/WMA.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

	[DisplayName("WMA")]
	[Display(ResourceType = typeof(Strings), Description = nameof(Strings.WMADescription))]
	[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602622")]
	public class WMA : Indicator
	{
		#region Fields

		private int _lastBar = -1;
		private int _myPeriod;
		private int _period = 10;
		private decimal _priorSum;
		private decimal _priorWsum;
		private decimal _sum;
		private decimal _wsum;
		private int _lastAlert;
		private bool _onLine;

		#endregion

		#region Properties

		[Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Common),
			Description = nameof(Strings.PeriodDescription),
			Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _period;
			set
			{
				_period = value;
				RecalculateValues();
			}
		}


		#region Alert

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.UseAlerts),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.UseAlertsDescription),
			Order = 300)]
		public bool UseAlerts { get; set; }


		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.RepeatAlert),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.RepeatAlertDescription),
			Order = 310)]
		[Range(0, 100000)]
		public bool RepeatAlert { get; set; }

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.ApproximationFilter),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.ApproximationFilterDescription),
			Order = 320)]
		[Range(0, 100000)]
		public int AlertSensitivity { get; set; } = 1;

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.AlertFile),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFileDescription),
			Order = 330)]
		public string AlertFile { get; set; } = "alert1";

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.FontColor),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertTextColorDescription),
			Order = 340)]
		public CrossColor FontColor { get; set; } = System.Drawing.Color.White.Convert();

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.BackGround),
			GroupName = nameof(Strings.ApproximationAlert),
			Description = nameof(Strings.AlertFillColorDescription),
			Order = 350)]
		public CrossColor BackgroundColor { get; set; } = System.Drawing.Color.DimGray.Convert();

		#endregion


		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar < _lastBar)
			{
				_wsum = 0;
				_sum = 0;
			}

			if (bar != _lastBar)
			{
				_lastBar = bar;
				_priorWsum = _wsum;
				_priorSum = _sum;
				_myPeriod = Math.Min(bar + 1, Period);
			}

			_wsum = _priorWsum - (bar >= Period ? _priorSum : 0) + _myPeriod * value;
			_sum = _priorSum + value - (bar >= Period ? (decimal)SourceDataSeries[bar - Period] : 0);
			this[bar] = _wsum / (0.5m * _myPeriod * (_myPeriod + 1));


			if (bar != CurrentBar - 1 || !UseAlerts)
				return;

			if (_lastAlert == bar && !RepeatAlert)
				return;

			var close = GetCandle(bar).Close;
			var onLine = Math.Abs(this[bar] - close) / InstrumentInfo.TickSize <= AlertSensitivity;

			if (onLine && !_onLine)
			{
				AddAlert(AlertFile, InstrumentInfo.Instrument, $"Triple EMA approximation alert: {this[bar]:0.#####}", BackgroundColor, FontColor);
				_lastAlert = bar;
			}

			_onLine = onLine;
		}

		#endregion
	}
}






Technical/WPR.cs







namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;

	[DisplayName("WPR")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WPRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602249")]
	public class WPR : Indicator
	{
		#region Fields

		private readonly Highest _highest = new() { Period = 14 };
		private readonly Lowest _lowest = new() { Period = 14 };
        
		private LineSeries _line80 = new("Line80", "-80") 
		{ 
			Color = System.Drawing.Color.Gray.Convert(),
			Width = 1,
			LineDashStyle = LineDashStyle.Dot,
			Value = -80,
			IsHidden = true 
		};

		private LineSeries _line20 = new("Line20", "-20") 
		{ 
			Color = System.Drawing.Color.Gray.Convert(),
			Width = 1, 
			LineDashStyle = LineDashStyle.Dot, 
			Value = -20, 
			IsHidden = true 
		};
		
        private bool _drawLines = true;

		#endregion

        #region Properties

        [Parameter]
		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Period),
			GroupName = nameof(Strings.Settings),
            Description = nameof(Strings.PeriodDescription),
            Order = 20)]
		[Range(1, 10000)]
		public int Period
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.Show),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.DrawLinesDescription),
            Order = 30)]
		public bool DrawLines
		{
			get => _drawLines;
			set
			{
				_drawLines = value;

				if (value)
				{
					if(LineSeries.Contains(_line20))
						return;

					LineSeries.Add(_line20);
					LineSeries.Add(_line80);
				}
				else
				{
					LineSeries.Clear();
				}

				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.minus20),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OverboughtLimitDescription),
            Order = 30)]
		public LineSeries Line20
		{
			get => _line20;
			set => _line20 = value;
		}

		[Display(ResourceType = typeof(Strings),
			Name = nameof(Strings.minus80),
			GroupName = nameof(Strings.Line),
            Description = nameof(Strings.OversoldLimitDescription),
            Order = 30)]
		public LineSeries Line80
        {
			get => _line80;
			set => _line80 = value;
        }

		#endregion

		#region ctor

		public WPR()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			LineSeries.Add(_line20);
			LineSeries.Add(_line80);
        }

		#endregion

		#region Protected methods
		
		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);

			var highest = _highest.Calculate(bar, candle.High);
			var lowest = _lowest.Calculate(bar, candle.Low);

			if (highest - lowest != 0)
				this[bar] = -100 * (highest - candle.Close) / (highest - lowest);
			else
				this[bar] = bar > 0 ? this[bar - 1] : 0;
		}

		#endregion
	}
}







Technical/WWMA.cs





namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Welles Wilders Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WWMADescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602508")]
	public class WWMA : Indicator
	{
		#region Fields
		
		private readonly SZMA _szma = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _szma.Period;
			set
			{
				_szma.Period = value;
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			_szma.Calculate(bar, value);

			if (bar == 0)
			{
				this[bar] = value;
				return;
			}
			
			this[bar] = this[bar - 1] == 0
				? _szma[bar]
				: this[bar - 1] + (value - this[bar - 1]) / Period;
		}

		#endregion
	}
}






Technical/Watermark.cs






namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Context;
using OFT.Rendering.Settings;
using OFT.Rendering.Tools;

[DisplayName("Watermark")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.WatermarkIndDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602668")]
public class Watermark : Indicator
{
	#region Nested types

	public enum Location
	{
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Center))]
		Center,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopLeft))]
		TopLeft,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TopRight))]
		TopRight,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomLeft))]
		BottomLeft,

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.BottomRight))]
		BottomRight
	}

	#endregion

	#region Properties

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Color), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelTextColorDescription), Order = 10)]
	public CrossColor TextColor { get; set; } = CrossColor.FromArgb(255, 225, 225, 225);

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextLocation), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelLocationDescription), Order = 20)]
	public Location TextLocation { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.HorizontalOffset), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelOffsetXDescription), Order = 30)]
	[Range(-100000, 100000)]
	public int HorizontalOffset { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VerticalOffset), GroupName = nameof(Strings.Common), Description = nameof(Strings.LabelOffsetYDescription), Order = 40)]
	[Range(-100000, 100000)]
	public int VerticalOffset { get; set; }

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowInstrument), GroupName = nameof(Strings.FirstLine), Description = nameof(Strings.ShowCurrentParameterNameDescription), Order = 50)]
	public bool ShowInstrument { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowPeriod), GroupName = nameof(Strings.FirstLine), Description = nameof(Strings.ShowCurrentParameterNameDescription), Order = 60)]
	public bool ShowPeriod { get; set; } = true;

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.FirstLine), Description = nameof(Strings.FontSettingDescription), Order = 70)]
	public FontSetting Font { get; set; } = new()
		{ Size = 60, Bold = true };

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Text), GroupName = nameof(Strings.SecondLine), Description = nameof(Strings.LabelTextDescription), Order = 80)]
	public string AdditionalText { get; set; } = "";

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Font), GroupName = nameof(Strings.SecondLine), Description = nameof(Strings.FontSettingDescription), Order = 90)]
	public FontSetting AdditionalFont { get; set; } = new()
		{ Size = 55 };

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VerticalOffset), GroupName = nameof(Strings.SecondLine), Description = nameof(Strings.LabelOffsetYDescription), Order = 100)]
	[Range(-100000, 100000)]
	public int AdditionalTextYOffset { get; set; } = -40;

	#endregion

	#region ctor

	public Watermark()
		: base(true)
	{
		Font.PropertyChanged += (a, b) => RedrawChart();
		AdditionalFont.PropertyChanged += (a, b) => RedrawChart();

		DataSeries[0].IsHidden = true;
		((ValueDataSeries)DataSeries[0]).VisualType = VisualMode.Hide;

        DenyToChangePanel = true;
		EnableCustomDrawing = true;
		SubscribeToDrawingEvents(DrawingLayouts.Historical);
		DrawAbovePrice = false;
	}

	#endregion

	#region Protected methods

	protected override void OnCalculate(int bar, decimal value)
	{
	}

	protected override void OnRender(RenderContext context, DrawingLayouts layout)
	{
		var showSecondLine = !string.IsNullOrWhiteSpace(AdditionalText);

		if (!showSecondLine && !ShowInstrument && !ShowPeriod)
			return;

		var textColor = TextColor.Convert();
		var mainTextRectangle = new Rectangle();
		var additionalTextRectangle = new Rectangle();
		var firstLine = string.Empty;

		if (showSecondLine && !string.IsNullOrEmpty(AdditionalText))
		{
			var size = context.MeasureString(AdditionalText, AdditionalFont.RenderObject);
			additionalTextRectangle = new Rectangle(0, 0, size.Width, size.Height);
		}

		if (ShowInstrument || ShowPeriod)
		{
			if (ShowInstrument)
				firstLine = InstrumentInfo.Instrument;

			if (ShowPeriod)
			{
				var period = ChartInfo.ChartType == "TimeFrame" ? ChartInfo.TimeFrame : $"{ChartInfo.ChartType} {ChartInfo.TimeFrame}";

				if (ShowInstrument)
					firstLine += $", {period}";
				else
					firstLine += $"{period}";
			}

			var size = context.MeasureString(firstLine, Font.RenderObject);
			mainTextRectangle = new Rectangle(0, 0, size.Width, size.Height);
		}

		if (mainTextRectangle.Height > 0 && additionalTextRectangle.Height > 0)
		{
			int firstLineX;
			int secondLineX;
			var y = 0;

			var totalHeight = mainTextRectangle.Height + additionalTextRectangle.Height + AdditionalTextYOffset;

			switch (TextLocation)
			{
				case Location.Center:
				{
					firstLineX = ChartInfo.PriceChartContainer.Region.Width / 2 - mainTextRectangle.Width / 2 + HorizontalOffset;
					secondLineX = ChartInfo.PriceChartContainer.Region.Width / 2 - additionalTextRectangle.Width / 2 + HorizontalOffset;
					y = ChartInfo.PriceChartContainer.Region.Height / 2 - totalHeight / 2 + VerticalOffset;

					break;
				}
				case Location.TopLeft:
				{
					firstLineX = secondLineX = HorizontalOffset;
					break;
				}
				case Location.TopRight:
				{
					firstLineX = ChartInfo.PriceChartContainer.Region.Width - mainTextRectangle.Width + HorizontalOffset;
					secondLineX = ChartInfo.PriceChartContainer.Region.Width - additionalTextRectangle.Width + HorizontalOffset;

					break;
				}
				case Location.BottomLeft:
				{
					firstLineX = secondLineX = HorizontalOffset;
					y = ChartInfo.PriceChartContainer.Region.Height - totalHeight + VerticalOffset;

					break;
				}
				case Location.BottomRight:
				{
					firstLineX = ChartInfo.PriceChartContainer.Region.Width - mainTextRectangle.Width + HorizontalOffset;
					secondLineX = ChartInfo.PriceChartContainer.Region.Width - additionalTextRectangle.Width + HorizontalOffset;
					y = ChartInfo.PriceChartContainer.Region.Height - totalHeight + VerticalOffset;

					break;
				}
				default:
					throw new ArgumentOutOfRangeException();
			}

			context.DrawString(firstLine, Font.RenderObject, textColor, firstLineX, y);
			context.DrawString(AdditionalText, AdditionalFont.RenderObject, textColor, secondLineX, y + mainTextRectangle.Height + AdditionalTextYOffset);
		}
		else if (mainTextRectangle.Height > 0)
			DrawString(context, firstLine, Font.RenderObject, textColor, mainTextRectangle);
		else if (additionalTextRectangle.Height > 0)
			DrawString(context, AdditionalText, AdditionalFont.RenderObject, textColor, additionalTextRectangle);
	}

	#endregion

	#region Private methods

	private void DrawString(RenderContext context, string text, RenderFont font, System.Drawing.Color color, Rectangle rectangle)
	{
		switch (TextLocation)
		{
			case Location.Center:
			{
				context.DrawString(text, font, color, ChartInfo.PriceChartContainer.Region.Width / 2 - rectangle.Width / 2 + HorizontalOffset,
					ChartInfo.PriceChartContainer.Region.Height / 2 - rectangle.Height / 2 + VerticalOffset);
				break;
			}
			case Location.TopLeft:
			{
				context.DrawString(text, font, color, HorizontalOffset, VerticalOffset);
				break;
			}
			case Location.TopRight:
			{
				context.DrawString(text, font, color, ChartInfo.PriceChartContainer.Region.Width - rectangle.Width + HorizontalOffset, VerticalOffset);
				break;
			}
			case Location.BottomLeft:
			{
				context.DrawString(text, font, color, HorizontalOffset, ChartInfo.PriceChartContainer.Region.Height - rectangle.Height + VerticalOffset);
				break;
			}
			case Location.BottomRight:
			{
				context.DrawString(text, font, color, ChartInfo.PriceChartContainer.Region.Width - rectangle.Width + HorizontalOffset,
					ChartInfo.PriceChartContainer.Region.Height - rectangle.Height + VerticalOffset);
				break;
			}
			default:
				throw new ArgumentOutOfRangeException();
		}
	}

	#endregion
}








Technical/Wavetrend.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;
    using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;


	[DisplayName("Wavetrend")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WavetrendDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602505")]
	public class Wavetrend : Indicator
	{
		#region Static and constants

		private const int _avgSmaPeriod = 4;
        private const int _sellDefault = 60;
        private const int _buyDefault = -60;

		#endregion

		#region Fields

		private readonly LineSeries _sellUp = new("SellUpId", "SellUp")
		{
			Value = _sellDefault + 10,
			LineDashStyle = LineDashStyle.Dash,
			Color = System.Drawing.Color.Gray.Convert(),
			DescriptionKey = nameof(Strings.OversoldLimitDescription)
		};

        private readonly LineSeries _sellDown = new("SellDownId", "SellDown")
        {
            Value = _sellDefault,
            LineDashStyle = LineDashStyle.Dash,
            Color = DefaultColors.Red.Convert(),
            DescriptionKey = nameof(Strings.OversoldLimitDescription)
        };

        private readonly LineSeries _buyUp = new("BuyUpId", "BuyUp")
        {
            Value = _buyDefault,
            LineDashStyle = LineDashStyle.Dash,
            Color = DefaultColors.Green.Convert(),
            DescriptionKey = nameof(Strings.OverboughtLimitDescription)
        };

        private readonly LineSeries _buyDown = new("BuyDownId", "BuyDown")
        {
            Value = _buyDefault - 10,
            LineDashStyle = LineDashStyle.Dash,
            Color = System.Drawing.Color.Gray.Convert(),
            DescriptionKey = nameof(Strings.OverboughtLimitDescription)
        };

		private readonly ValueDataSeries _bullLine = new("BullLineId", "BullLine")
		{
			Color = DefaultColors.Green.Convert(),
            DescriptionKey = nameof(Strings.BullishMovementSettingsDescription)
        };

		private readonly ValueDataSeries _bearLine = new("BearLineId", "BearLine")
		{
			Color = DefaultColors.Red.Convert(),
            DescriptionKey = nameof(Strings.BearishMovementSettingsDescription)
        };

        private readonly ValueDataSeries _buyDots = new("BuyDotsId", "BuyDots")
		{
			ShowZeroValue = false,
			Color = DefaultColors.Aqua.Convert(),
			LineDashStyle = LineDashStyle.Solid,
			VisualType = VisualMode.Dots,
			Width = 5,
            DescriptionKey = nameof(Strings.BuySignalSettingsDescription)
        };
        private readonly ValueDataSeries _sellDots = new("SellDotsId", "SellDots")
        {
	        ShowZeroValue = false,
	        Color = DefaultColors.Yellow.Convert(),
	        LineDashStyle = LineDashStyle.Solid,
	        VisualType = VisualMode.Dots,
	        Width = 5,
            DescriptionKey = nameof(Strings.SellSignalSettingsDescription)
        };

        private readonly EMA _bullEma = new() { Period = 21 };
        private readonly EMA _waveEmaPrice = new() { Period = 10 };
        private readonly EMA _waveEmaVolatility = new() { Period = 10 };
        private SMA _avgSma = new() { Period = 4 };

		private int _overbought = _sellDefault;
        private int _oversold = -_buyDefault;
		private int _sellUpCache;
        private int _buyDownCache;

        #endregion

        #region Properties

        [Browsable(false)]
        [Parameter]
		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Overbought), Order = 1)]
		public int Overbought
		{
			get => _overbought;
			set
			{
				if (Math.Abs(value) > 100 || value < Oversold)
					return;

				_overbought = value;
			}
		}

        [Browsable(false)]
        [Parameter]
		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.Oversold), Order = 2)]
		public int Oversold
		{
			get => _oversold;
			set
			{
				if (Math.Abs(value) > 100 || value > Overbought)
					return;

				_oversold = value;
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.AveragePeriod), Description = nameof(Strings.PeriodDescription), Order = 3)]
		[Range(1, 10000)]
		public int AvgPeriod
		{
			get => _bullEma.Period;
			set
			{
				_bullEma.Period = value;
				RecalculateValues();
			}
		}

		[Parameter]
		[Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Settings), Name = nameof(Strings.WavePeriod), Description = nameof(Strings.PeriodDescription), Order = 4)]
		[Range(1, 10000)]
        public int WavePeriod
		{
			get => _waveEmaPrice.Period;
			set
			{
				_waveEmaPrice.Period = value;
				_waveEmaVolatility.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Wavetrend()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DenyToChangePanel = true;

			_avgSma.Period = _avgSmaPeriod;
			
			DataSeries[0] = _buyDots;
			DataSeries.Add(_sellDots);
			DataSeries.Add(_bullLine);
			DataSeries.Add(_bearLine);

			LineSeries.Add(_sellUp);
            LineSeries.Add(_sellDown);
            LineSeries.Add(_buyUp);
            LineSeries.Add(_buyDown);

            _sellUp.PropertyChanged += LineSeriesPropertyChanged;
            _sellDown.PropertyChanged += LineSeriesPropertyChanged;
            _buyUp.PropertyChanged += LineSeriesPropertyChanged;
            _buyDown.PropertyChanged += LineSeriesPropertyChanged;

            _sellUpCache = (int)_sellUp.Value; 
            _buyDownCache = (int)_buyDown.Value;
        }

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				_buyDots.Clear();
				_sellDots.Clear();
				_bullLine.Clear();
				_bearLine.Clear();

				_avgSma = new SMA
					{ Period = _avgSmaPeriod };
			}
			else
			{
				var candle = GetCandle(bar);

				var avgPrice = Math.Abs(candle.High + candle.Close + candle.Low) / 3.0m;

				var waveMa = _waveEmaPrice.Calculate(bar, avgPrice);

				var waveVolatilityEma = _waveEmaVolatility.Calculate(bar, Math.Abs(avgPrice - waveMa));

				var ci = (avgPrice - waveMa) / (0.015m * waveVolatilityEma);

				var tci = _bullEma.Calculate(bar, ci);

				var wt = _avgSma.Calculate(bar, tci);

				_bullLine[bar] = tci;
				_bearLine[bar] = wt;

				if (_bullLine[bar] <= _bearLine[bar]
					&& _bullLine[bar - 1] >= _bearLine[bar - 1]
					&& _bullLine[bar] >= _overbought)
					_sellDots[bar] = _bullLine[bar];

				if (_bullLine[bar] >= _bearLine[bar]
					&& _bullLine[bar - 1] <= _bearLine[bar - 1]
					&& _bearLine[bar] <= _oversold)
					_buyDots[bar] = _bullLine[bar];
			}
		}

        #endregion

        #region Private methods

        private void LineSeriesPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
			if (e.PropertyName != "Value")
				return;

			if (sender.Equals(_sellUp))
                CheckAndSetValue(_sellUp, ref _sellUpCache, _sellUp.Value < _sellDown.Value);

			if (sender.Equals(_sellDown))
				CheckAndSetValue(_sellDown, ref _overbought, _sellDown.Value < _oversold);

            if (sender.Equals(_buyDown))
                CheckAndSetValue(_buyDown, ref _buyDownCache, _buyDown.Value > _buyUp.Value);

            if (sender.Equals(_buyUp))
                CheckAndSetValue(_buyUp, ref _oversold, _buyUp.Value > _overbought);
        }

        private void CheckAndSetValue(LineSeries line, ref int val, bool falseCondition)
        {
			if (line.Value < -100 || line.Value > 100 || falseCondition)
				line.Value = val;
			else
				val = (int)line.Value;
        }

        #endregion
    }
}








Technical/WeissWave.cs





namespace ATAS.Indicators.Technical
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    using ATAS.Indicators.Drawing;

    using OFT.Attributes;
    using OFT.Localization;
    using Color = System.Drawing.Color;

    [DisplayName("Weis Wave")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WeissWaveDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602507")]
	public class WeissWave : Indicator
	{
		#region Fields

		private readonly ValueDataSeries _renderSeries = new("RenderSeries", Strings.Visualization)
		{
			VisualType = VisualMode.Histogram,
			ShowZeroValue = false,
			UseMinimizedModeIfEnabled = true,
			ResetAlertsOnNewBar = true
		};

		private int _filter;
		private Color _filterColor = Color.LightBlue;
		private Color _negColor = DefaultColors.Red;
		private Color _posColor = DefaultColors.Green;

		#endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Up), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.BullishColorDescription), Order = 610)]
        public CrossColor PosColor
        {
	        get => _posColor.Convert();
	        set
	        {
		        _posColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Down), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.BearishColorDescription), Order = 620)]
        public CrossColor NegColor
        {
	        get => _negColor.Convert();
	        set
	        {
		        _negColor = value.Convert();
		        RecalculateValues();
	        }
        }

        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Drawing), Description = nameof(Strings.FilterColorDescription), Order = 630)]
        public CrossColor FilterColor
        {
	        get => _filterColor.Convert();
	        set
	        {
		        _filterColor = value.Convert();
		        RecalculateValues();
	        }
        }

		[Range(0, int.MaxValue)]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Filter), GroupName = nameof(Strings.Settings), Description = nameof(Strings.MaximumFilterDescription))]
        public int Filter
		{
			get => _filter;
			set
			{
				_filter = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public WeissWave()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
			DataSeries[0] = _renderSeries;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
            if (bar == 0)
			{
				_renderSeries[bar] = candle.Volume;
				_renderSeries.Colors[bar] = candle.Open < candle.Close ? _posColor : _negColor;
			}
			else
            {
	            var prevCandle = GetCandle(bar - 1);

	            var renderValue = Math.Sign(candle.Open - candle.Close) == Math.Sign(prevCandle.Open - prevCandle.Close) 
					? _renderSeries[bar - 1] + candle.Volume
					: candle.Volume;

	            _renderSeries[bar] = renderValue;
	            _renderSeries.Colors[bar] = candle.Open < candle.Close
		            ? _posColor
		            : _negColor;
            }

            if (_filter <= 0)
	            return;

            if (_renderSeries[bar] > _filter)
				_renderSeries.Colors[bar] = _filterColor;
		}

		#endregion
	}
}






Technical/WilliamsR.cs






namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Williams' %R")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.WilliamsRDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602308")]
	public class WilliamsR : Indicator
	{
		#region Fields

		private readonly Highest _highest = new() { Period = 10 };
		private readonly Lowest _lowest = new() { Period = 10 };
		
		private bool _invertOutput;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _highest.Period;
			set
			{
				_highest.Period = _lowest.Period = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.InvertOutput), GroupName = nameof(Strings.Settings), Description = nameof(Strings.InvertOutputDescription), Order = 110)]
		public bool InvertOutput
		{
			get => _invertOutput;
			set
			{
				_invertOutput = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public WilliamsR()
			: base(true)
		{
			Panel = IndicatorDataProvider.NewPanel;
            _highest.Period = _lowest.Period = 10;
		}

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			var candle = GetCandle(bar);
			_highest.Calculate(bar, candle.High);
			_lowest.Calculate(bar, candle.Low);

			var renderValue = _highest[bar] != _lowest[bar]
				? 100 * (_highest[bar] - candle.Close) / (_highest[bar] - _lowest[bar])
				: 0m;
			
			this[bar] = _invertOutput
				? -renderValue
				: renderValue;
		}

		#endregion
	}
}






Technical/WoodiesCCI.cs








namespace ATAS.Indicators.Technical;

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;

using ATAS.Indicators.Drawing;

using OFT.Attributes;
using OFT.Localization;
using OFT.Rendering.Settings;

using Color = System.Drawing.Color;

[DisplayName("Woodies CCI")]
[Display(ResourceType = typeof(Strings), Description = nameof(Strings.WoodiesCCIDescription))]
[HelpLink("https://help.atas.net/en/support/solutions/articles/72000602565")]
public class WoodiesCCI : Indicator
{
	#region Fields

	private readonly ValueDataSeries _cciSeries = new("CciSeries", "CCI")
	{
		VisualType = VisualMode.Histogram, 
		ShowCurrentValue = false, 
		Width = 2
	};
	
	private readonly CCI _entryCci = new() { Name = "Entry CCI" };

	private readonly ValueDataSeries _lsmaSeries = new("LsmaSeries", "LSMA")
	{
		VisualType = VisualMode.Block, 
		ShowCurrentValue = false, 
		ScaleIt = false, 
		Width = 2, 
		IgnoredByAlerts = true,
		ShowTooltip = false
	};
	
	private readonly CCI _trendCci = new() { Name = "Trend CCI" };

	private LineSeries _line100 = new("Line100", "100")
	{
		Color = Color.Gray.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		Value = 100,
		Width = 1,
		IsHidden = true,
		DescriptionKey = nameof(Strings.OverboughtLimitDescription)
	};

	private LineSeries _line200 = new("Line200", "200")
	{
		Color = Color.Gray.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		Value = 200,
		Width = 1,
		IsHidden = true,
        DescriptionKey = nameof(Strings.OverboughtLimitDescription)
    };

	private LineSeries _line300 = new("Line300", "300")
	{
		Color = Color.Gray.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		Value = 300,
		Width = 1,
		IsHidden = true,
		UseScale = true,
        DescriptionKey = nameof(Strings.OverboughtLimitDescription)
    };

	private LineSeries _lineM100 = new("LineM100", "-100")
	{
		Color = Color.Gray.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		Value = -100,
		Width = 1,
		IsHidden = true,
        DescriptionKey = nameof(Strings.OversoldLimitDescription)
    };

	private LineSeries _lineM200 = new("LineM200", "-200")
	{
		Color = Color.Gray.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		Value = -200,
		Width = 1,
		IsHidden = true,
        DescriptionKey = nameof(Strings.OversoldLimitDescription)
    };

	private LineSeries _lineM300 = new("LineM300", "-300")
	{
		Color = Color.Gray.Convert(),
		LineDashStyle = LineDashStyle.Dash,
		Value = -300,
		Width = 1,
		UseScale = true,
		IsHidden = true,
        DescriptionKey = nameof(Strings.OversoldLimitDescription)
    };

	private bool _drawLines = true;
	private int _lsmaPeriod = 25;
	private int _trendPeriod = 5;

	private int _trendUp, _trendDown;
	private Color _trendUpColor = DefaultColors.Blue;
	private Color _trendDownColor = DefaultColors.Maroon;
	private	Color _noTrendColor = DefaultColors.Gray;
	private Color _timeBarColor = DefaultColors.Yellow;
	private Color _positiveLsmaColor = DefaultColors.Green;
	private Color _negativeLsmaColor = DefaultColors.Red;

	#endregion

	#region Properties

	[Parameter]
	[Display(ResourceType = typeof(Strings), Name = "LSMA Period", GroupName = nameof(Strings.Settings), Description = nameof(Strings.SMAPeriodDescription))]
	[Range(1, 10000)]
	public int LSMAPeriod
	{
		get => _lsmaPeriod;
		set
		{
			_lsmaPeriod = value;
			RecalculateValues();
		}
	}

	[Parameter]
	[Display(ResourceType = typeof(Strings), Name = "Trend Period", GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
	[Range(1, 10000)]
	public int TrendPeriod
	{
		get => _trendPeriod;
		set
		{
			_trendPeriod = value;
			RecalculateValues();
		}
	}

	[Parameter]
	[Display(ResourceType = typeof(Strings), Name = "Trend CCI Period", GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
	[Range(1, 10000)]
	public int TrendCCIPeriod
	{
		get => _trendCci.Period;
		set
		{
			_trendCci.Period = value;
			RecalculateValues();
		}
	}

	[Parameter]
	[Display(ResourceType = typeof(Strings), Name = "Entry CCI Period", GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription))]
	[Range(1, 10000)]
	public int EntryCCIPeriod
	{
		get => _entryCci.Period;
		set
		{
			_entryCci.Period = value;
			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Show), GroupName = nameof(Strings.Line), Description = nameof(Strings.DrawLinesDescription))]
	public bool DrawLines
	{
		get => _drawLines;
		set
		{
			_drawLines = value;

			if (value)
			{
				if (LineSeries.Any())
					return;

				LineSeries.Add(_line100);
				LineSeries.Add(_line200);
				LineSeries.Add(_line300);
				LineSeries.Add(_lineM100);
				LineSeries.Add(_lineM200);
				LineSeries.Add(_lineM300);
			}
			else
			{
				LineSeries.Clear();
			}

			RecalculateValues();
		}
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.p300), GroupName = nameof(Strings.Line), Description = nameof(Strings.OverboughtLimitDescription))]
	public LineSeries Line300
	{
		get => _line300;
		set => _line300 = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.p200), GroupName = nameof(Strings.Line), Description = nameof(Strings.OverboughtLimitDescription))]
	public LineSeries Line200
	{
		get => _line200;
		set => _line200 = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.p100), GroupName = nameof(Strings.Line), Description = nameof(Strings.OverboughtLimitDescription))]
	public LineSeries Line100
	{
		get => _line100;
		set => _line100 = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.m100), GroupName = nameof(Strings.Line), Description = nameof(Strings.OversoldLimitDescription))]
	public LineSeries LineM100
	{
		get => _lineM100;
		set => _lineM100 = value;
	}

	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.m200), GroupName = nameof(Strings.Line), Description = nameof(Strings.OversoldLimitDescription))]
	public LineSeries LineM200
	{
		get => _lineM200;
		set => _lineM200 = value;
	}
	
	[Display(ResourceType = typeof(Strings), Name = nameof(Strings.m300), GroupName = nameof(Strings.Line), Description = nameof(Strings.OversoldLimitDescription))]
	public LineSeries LineM300
	{
		get => _lineM300;
		set => _lineM300 = value;
	}

    [Display(ResourceType = typeof(Strings), Name = "CCI Trend Up", GroupName = nameof(Strings.Colors), Description = nameof(Strings.BullishColorDescription))]
    public Color TrendUpColor
    {
        get => _trendUpColor;
        set
        {
            _trendUpColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = "CCI Trend Down", GroupName = nameof(Strings.Colors), Description = nameof(Strings.BearishColorDescription))]
    public Color TrendDownColor
    {
        get => _trendDownColor;
        set
        {
            _trendDownColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = "No Trend", GroupName = nameof(Strings.Colors), Description = nameof(Strings.NeutralColorDescription))]
    public Color NoTrendColor
    {
        get => _noTrendColor;
        set
        {
            _noTrendColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = "Time Bar", GroupName = nameof(Strings.Colors), Description = nameof(Strings.NewTrendColorDescription))]
    public Color TimeBarColor
    {
        get => _timeBarColor;
        set
        {
            _timeBarColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = "Negative LSMA", GroupName = nameof(Strings.Colors), Description = nameof(Strings.NegativeValueColorDescription))]
    public Color NegativeLsmaColor
    {
        get => _negativeLsmaColor;
        set
        {
            _negativeLsmaColor = value;
            RecalculateValues();
        }
    }

    [Display(ResourceType = typeof(Strings), Name = "Positive LSMA", GroupName = nameof(Strings.Colors), Description = nameof(Strings.PositiveValueColorDescription))]
    public Color PositiveLsmaColor
    {
        get => _positiveLsmaColor;
        set
        {
            _positiveLsmaColor = value;
            RecalculateValues();
        }
    }

    #endregion

    #region ctor

    public WoodiesCCI() : base(true)
	{
        Panel = IndicatorDataProvider.NewPanel;
        DenyToChangePanel = true;

        TrendCCIPeriod = 14;
		EntryCCIPeriod = 6;

		var trendCciDataSeries = (ValueDataSeries)_trendCci.DataSeries[0];
		trendCciDataSeries.Id = "TrendCciDataSeries";
        trendCciDataSeries.Name = "Trend CCI";
		trendCciDataSeries.Width = 2;
		trendCciDataSeries.Color = DefaultColors.Purple.Convert();
		trendCciDataSeries.IgnoredByAlerts = true;

		var entryCciDataSeries = (ValueDataSeries)_entryCci.DataSeries[0];
		entryCciDataSeries.Id = "EntryCciDataSeries";
        entryCciDataSeries.Name = "Entry CCI";
		entryCciDataSeries.Color = DefaultColors.Orange.Convert();
		entryCciDataSeries.IgnoredByAlerts = true;

		var zeroLineDataSeries = (ValueDataSeries)DataSeries[0];
		zeroLineDataSeries.ShowCurrentValue = false;
		zeroLineDataSeries.Name = "Zero Line";
		zeroLineDataSeries.Color = Color.Gray.Convert();
		zeroLineDataSeries.VisualType = VisualMode.Hide;
		zeroLineDataSeries.IgnoredByAlerts = true;
		zeroLineDataSeries.DescriptionKey = Strings.ZeroLineDescription;


        DataSeries.Add(_cciSeries);
		DataSeries.Add(trendCciDataSeries);
		DataSeries.Add(entryCciDataSeries);
		DataSeries.Add(_lsmaSeries);

        LineSeries.Add(_line100);
		LineSeries.Add(_line200);
		LineSeries.Add(_line300);
		LineSeries.Add(_lineM100);
		LineSeries.Add(_lineM200);
		LineSeries.Add(_lineM300);

		Add(_trendCci);
		Add(_entryCci);
	}

	#endregion

	#region Protected methods
	
	protected override void OnCalculate(int bar, decimal value)
	{
		try
		{
			this[bar] = 0;

			if (_trendCci[bar] > 0 && _trendCci[bar - 1] < 0)
			{
				if (_trendDown > TrendPeriod)
					_trendUp = 0;
			}

			_cciSeries[bar] = _trendCci[bar];

			if (_trendCci[bar] > 0)
			{
				if (_trendUp < TrendPeriod)
				{
					_cciSeries.Colors[bar] = _noTrendColor;
					_trendUp++;
				}

				if (_trendUp == TrendPeriod)
				{
					_cciSeries.Colors[bar] = _timeBarColor;
					_trendUp++;
				}

				if (_trendUp > TrendPeriod)
					_cciSeries.Colors[bar] = _trendUpColor;
			}

			if (_trendCci[bar] < 0 && _trendCci[bar - 1] > 0)
			{
				if (_trendUp > TrendPeriod)
					_trendDown = 0;
			}

			if (_trendCci[bar] < 0)
			{
				if (_trendDown < TrendPeriod)
				{
					_cciSeries.Colors[bar] = _noTrendColor;
					_trendDown++;
				}

				if (_trendDown == TrendPeriod)
				{
					_cciSeries.Colors[bar] = _timeBarColor;
					_trendDown++;
				}

				if (_trendDown > TrendPeriod)
					_cciSeries.Colors[bar] = _trendDownColor;
			}

			decimal summ = 0;

			if (bar < LSMAPeriod + 2)
				return;

			var lengthvar = (decimal)((LSMAPeriod + 1) / 3.0);

			for (var i = LSMAPeriod; i >= 1; i--)
				summ += (i - lengthvar) * GetCandle(bar - LSMAPeriod + i).Close;

			var wt = summ * 6 / (LSMAPeriod * (LSMAPeriod + 1));
			_lsmaSeries[bar] = 0.00001m;

			_lsmaSeries.Colors[bar] = wt > GetCandle(bar).Close
									? _negativeLsmaColor
									: _positiveLsmaColor;
		}
		catch { }
	}
	
	#endregion
}







Technical/ZLEMA.cs







namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Zero Lag Exponential Moving Average")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ZLEMAIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602640")]
	public class ZLEMA : Indicator
	{
		#region Fields

		private readonly EMA _ema = new() { Period = 10 };
		private int _length = 4;

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.Period), GroupName = nameof(Strings.Settings), Description = nameof(Strings.PeriodDescription),Order = 100)]
		[Range(1, 10000)]
		public int Period
		{
			get => _ema.Period;
			set
			{
				_ema.Period = value;
				_length = (int)Math.Ceiling((value - 1) / 2m);
				RecalculateValues();
			}
		}

        #endregion

        #region Protected methods

        protected override void OnCalculate(int bar, decimal value)
		{
			var startBar = Math.Max(0, bar - _length);

			var deLagged = 2 * value - (decimal)SourceDataSeries[startBar];

			this[bar] = _ema.Calculate(bar, deLagged);
		}

		#endregion
	}
}








Indicators/Technical
/ZScore.cs








namespace ATAS.Indicators.Technical
{
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using OFT.Attributes;
    using OFT.Localization;

    [DisplayName("Z-Score")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ZScoreIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602269")]
	public class ZScore : Indicator
	{
		#region Fields

		private readonly SMA _sma = new() { Period = 10 };
		private readonly StdDev _stdDev = new() { Period = 10 };

        #endregion

        #region Properties

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.SMA), GroupName = nameof(Strings.Period), Description = nameof(Strings.SMAPeriodDescription), Order = 100)]
		[Range(1, 10000)]
		public int SmaPeriod
		{
			get => _sma.Period;
			set
			{
				_sma.Period = value;
				RecalculateValues();
			}
		}

        [Parameter]
        [Display(ResourceType = typeof(Strings), Name = nameof(Strings.StdDev), GroupName = nameof(Strings.Period), Description = nameof(Strings.StdDevPeriodDescription), Order = 110)]
		[Range(1, 10000)]
        public int StdPeriod
		{
			get => _stdDev.Period;
			set
			{
				_stdDev.Period = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public ZScore()
		{
			Panel = IndicatorDataProvider.NewPanel;
        }

		#endregion

		#region Protected methods

		protected override void OnCalculate(int bar, decimal value)
		{
			_sma.Calculate(bar, value);
			_stdDev.Calculate(bar, value);

			this[bar] = _stdDev[bar] != 0
				? (value - _sma[bar]) / _stdDev[bar]
				: 0;
		}

		#endregion
	}
}






Technical/Zigzag.cs






namespace ATAS.Indicators.Technical
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.DataAnnotations;

	using ATAS.Indicators.Drawing;

	using OFT.Attributes;
    using OFT.Localization;
    using OFT.Rendering.Settings;
	
    [DisplayName("ZigZag pro")]
    [Display(ResourceType = typeof(Strings), Description = nameof(Strings.ZigzagIndDescription))]
    [HelpLink("https://help.atas.net/en/support/solutions/articles/72000602632")]
	public class Zigzag : Indicator
	{
		#region Nested types

		public enum Mode
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.RelativeInPercent))]
			Relative = 0,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.AbsolutePrice))]
			Absolute = 1,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Ticks))]
			Ticks = 2
		}

		public enum TimeFormat
		{
			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.None))]
			None,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Days))]
			Days,

			[Display(ResourceType = typeof(Strings), Name = nameof(Strings.Exact))]
			Exact
		}

		#endregion

		#region Fields

		private readonly ValueDataSeries _data = new("Data", Strings.Data)
		{
			Color = DefaultColors.Red.Convert(),
			LineDashStyle = LineDashStyle.Dot,
			VisualType = VisualMode.Line,
			Width = 2,
			DescriptionKey = nameof(Strings.BaseLineSettingsDescription)
		};

		private Mode _calcMode = Mode.Ticks;
		private int _cumulativeBars;
		private decimal _cumulativeDelta;
		private decimal _cumulativeTicks;
		private decimal _cumulativeVolume;
		private int _days = 20;

        private int _direction;
		private bool _ignoreWicks = true;
		private int _lastBar = -1;
		private int _lastHighBar;
		private int _lastLowBar;

		private decimal _percentage = 30.0m;
		private bool _showBars = true;
		private bool _showDelta = true;
		private bool _showTicks = true;
		private TimeFormat _showTime = TimeFormat.Exact;
		private bool _showVolume = true;
		private int _targetBar;
		private CrossColor _textColor = DefaultColors.Red.Convert();
		private float _textSize = 15.0f;
		private TimeSpan _trendDuration;
		private int _verticalOffset = 1;

        #endregion

        #region Properties

        [Display(ResourceType = typeof(Strings), GroupName = nameof(Strings.Calculation), Name = nameof(Strings.DaysLookBack), Order = int.MaxValue, Description = nameof(Strings.DaysLookBackDescription))]
        [Range(0, 1000)]
		public int Days
		{
			get => _days;
			set
			{
				_days = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.CalculationMode), GroupName = nameof(Strings.CalculationSettings), Description = nameof(Strings.CalculationModeDescription), Order = 100)]
		public Mode CalcMode
		{
			get => _calcMode;
			set
			{
				_calcMode = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.IgnoreWicks), GroupName = nameof(Strings.CalculationSettings), Description = nameof(Strings.IgnoreWicksDescription), Order = 110)]
		public bool IgnoreWicks
		{
			get => _ignoreWicks;
			set
			{
				_ignoreWicks = value;
				RecalculateValues();
			}
		}

		[Range(0, int.MaxValue)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.RequiredChange), GroupName = nameof(Strings.CalculationSettings), Description = nameof(Strings.RequiredChangeValueDescription), Order = 120)]
		public decimal Percentage
		{
			get => _percentage;
			set
			{
				_percentage = value;
				RecalculateValues();
			}
		}

		[Range(1, 100)]
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextSize), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.FontSizeDescription), Order = 200)]
		public float TextSize
		{
			get => _textSize;
			set
			{
				_textSize = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.TextColor), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.LabelTextColorDescription), Order = 210)]
		public CrossColor TextColor
		{
			get => _textColor;
			set
			{
				_textColor = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowDelta), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.ShowCurrentParameterInfoDescription), Order = 220)]
		public bool ShowDelta
		{
			get => _showDelta;
			set
			{
				_showDelta = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowVolume), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.ShowCurrentParameterInfoDescription), Order = 230)]
		public bool ShowVolume
		{
			get => _showVolume;
			set
			{
				_showVolume = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTicks), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.ShowCurrentParameterInfoDescription), Order = 240)]
		public bool ShowTicks
		{
			get => _showTicks;
			set
			{
				_showTicks = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowBars), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.ShowCurrentParameterInfoDescription), Order = 250)]
		public bool ShowBars
		{
			get => _showBars;
			set
			{
				_showBars = value;
				RecalculateValues();
			}
		}

		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.ShowTime), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.ShowCurrentParameterInfoDescription), Order = 260)]
		public TimeFormat ShowTime
		{
			get => _showTime;
			set
			{
				_showTime = value;
				RecalculateValues();
			}
		}
		
		[Display(ResourceType = typeof(Strings), Name = nameof(Strings.VerticalOffset), GroupName = nameof(Strings.TextSettings), Description = nameof(Strings.LabelOffsetYDescription), Order = 270)]
		[Range(0, 1000)]
		public int VerticalOffset
		{
			get => _verticalOffset;
			set
			{
				_verticalOffset = value;
				RecalculateValues();
			}
		}

		#endregion

		#region ctor

		public Zigzag()
			: base(true)
		{
			DataSeries[0].IsHidden = true;
			DenyToChangePanel = true;

			DataSeries.Add(_data);
		}

		#endregion

		#region Protected methods

		protected override void OnRecalculate()
		{
			_direction = 0;
			_cumulativeVolume = 0;
			_cumulativeDelta = 0;
			_cumulativeTicks = 0;
			_cumulativeBars = 0;
			base.OnRecalculate();
		}

		protected override void OnCalculate(int bar, decimal value)
		{
			if (bar == 0)
			{
				AddText("LastText", "", true, CurrentBar - 1, 0, TextColor.Convert(),
					System.Drawing.Color.Transparent, System.Drawing.Color.Transparent, _textSize,
					DrawingText.TextAlign.Center);

				_targetBar = 0;

				if (_days <= 0)
					return;

				var days = 0;

				for (var i = CurrentBar - 1; i >= 0; i--)
				{
					_targetBar = i;

					if (!IsNewSession(i))
						continue;

					days++;

					if (days == _days)
						break;
				}

				_lastHighBar = _targetBar;
				_lastLowBar = _targetBar;

				if (_targetBar > 0)
					_data.SetPointOfEndLine(_targetBar - 1);
				return;
			}

			if (bar < _targetBar || bar < Math.Min(_lastHighBar, _lastLowBar) || bar == 0)
				return;

			var calcBar = bar - 1;

			var requiredChange = 0.0m;

			var candleHigh = GetCandle(calcBar).High;
			var candleLow = GetCandle(calcBar).Low;

			var lastHighBarMax = GetCandle(_lastHighBar).High;
			var lastLowBarMin = GetCandle(_lastLowBar).Low;

			if (IgnoreWicks)
			{
				candleHigh = Math.Max(GetCandle(calcBar).Open, GetCandle(calcBar).Close);
				candleLow = Math.Min(GetCandle(calcBar).Open, GetCandle(calcBar).Close);
				lastHighBarMax = Math.Max(GetCandle(_lastHighBar).Open, GetCandle(_lastHighBar).Close);
				lastLowBarMin = Math.Min(GetCandle(_lastLowBar).Open, GetCandle(_lastLowBar).Close);
			}

			if (bar != _lastBar)
			{
				if (_direction == 0)
				{
					var candleZeroHigh = GetCandle(0).High;
					var candleZeroLow = GetCandle(0).Low;

					if (IgnoreWicks)
					{
						candleZeroHigh = Math.Max(GetCandle(0).Open, GetCandle(0).Close);
						candleZeroLow = Math.Min(GetCandle(0).Open, GetCandle(0).Close);
					}

					if (candleHigh > candleZeroHigh && candleLow > candleZeroLow) //currently in an uptrend
					{
						_direction = 1;
						_lastHighBar = calcBar;
					}
					else if (candleLow < candleZeroLow && candleHigh < candleZeroLow) //currently in a downtrend
					{
						_direction = -1;
						_lastLowBar = calcBar;
					}
				}
				else if (_direction == 1)
				{
					if (_calcMode == Mode.Relative)
						requiredChange = lastHighBarMax * _percentage / 100;
					else if (_calcMode == Mode.Absolute)
						requiredChange = _percentage;
					else if (_calcMode == Mode.Ticks)
						requiredChange = _percentage * InstrumentInfo.TickSize;

					if (candleHigh > lastHighBarMax) //continue uptrend
						_lastHighBar = calcBar;

					else if (candleHigh < lastHighBarMax && lastHighBarMax - requiredChange >= candleLow
					        ) //uptrend ended
					{
						_direction = -1;
						_cumulativeVolume = 0;
						_cumulativeDelta = 0;

						for (var i = _lastLowBar; i <= _lastHighBar; i++)
						{
							var candle = GetCandle(i);
							_cumulativeVolume += candle.Volume;
							_cumulativeDelta += candle.Delta;
							_cumulativeTicks += candle.Ticks;
							_data[i] = Linear(lastLowBarMin, lastHighBarMax, _lastHighBar - _lastLowBar + 1, i - _lastLowBar);
						}

						_trendDuration = GetCandle(_lastHighBar).Time - GetCandle(_lastLowBar).Time;
						_cumulativeTicks = Math.Abs((lastHighBarMax - lastLowBarMin) / InstrumentInfo.TickSize);
						_cumulativeBars = Math.Abs(_lastHighBar - _lastLowBar) + 1;
						var label = "";

						if (_showDelta)
							label += DecimalToShortString(_cumulativeDelta) + "Δ" + Environment.NewLine;

						if (_showVolume)
							label += DecimalToShortString(_cumulativeVolume) + Environment.NewLine;

						if (_showTicks)
							label += DecimalToShortString(_cumulativeTicks) + " Ticks" + Environment.NewLine;

						if (_showBars)
							label += DecimalToShortString(_cumulativeBars) + "Bars" + Environment.NewLine;

						if (_showTime == TimeFormat.Days)
							label += _trendDuration.ToString(@"d\d\a\y\s");

						if (_showTime == TimeFormat.Exact)
						{
							if (_trendDuration.Days > 0)
								label += _trendDuration.ToString(@"d\d\a\y\s\ hh\:mm\:ss");
							else
								label += _trendDuration.ToString(@"hh\:mm\:ss");
						}

                        AddText(_lastHighBar + value.ToString(), label.TrimEnd(), true, _lastHighBar, lastHighBarMax + InstrumentInfo.TickSize * VerticalOffset, 0, 0,
							ConvertColor(_textColor), System.Drawing.Color.Transparent, System.Drawing.Color.Transparent, _textSize,
							DrawingText.TextAlign.Center);
						_lastLowBar = calcBar;
					}
				}
				else if (_direction == -1)
				{
					if (_calcMode == Mode.Relative)
						requiredChange = lastLowBarMin * _percentage / 100;
					else if (_calcMode == Mode.Absolute)
						requiredChange = _percentage;
					else if (_calcMode == Mode.Ticks)
						requiredChange = _percentage * InstrumentInfo.TickSize;

					if (candleLow < lastLowBarMin) //continue downtrend
						_lastLowBar = calcBar;
					else if (candleLow > lastLowBarMin && lastLowBarMin + requiredChange <= candleHigh
					        ) //downtrend ended
					{
						_direction = 1;
						_cumulativeVolume = 0;
						_cumulativeDelta = 0;

						for (var i = _lastHighBar; i <= _lastLowBar; i++)
						{
							_cumulativeVolume += GetCandle(i).Volume;
							_cumulativeDelta += GetCandle(i).Delta;
							_data[i] = Linear(lastHighBarMax, lastLowBarMin, _lastLowBar - _lastHighBar + 1, i - _lastHighBar);
						}

						_trendDuration = GetCandle(_lastLowBar).Time - GetCandle(_lastHighBar).Time;
						_cumulativeTicks = Math.Abs((lastLowBarMin - lastHighBarMax) / InstrumentInfo.TickSize);
						_cumulativeBars = Math.Abs(_lastHighBar - _lastLowBar) + 1;
						var label = "";

						if (_showDelta)
						{
							label += DecimalToShortString(_cumulativeDelta) + "Δ" + Environment.NewLine;
						}

						if (_showVolume)
						{
							label += DecimalToShortString(_cumulativeVolume) + Environment.NewLine;
						}

						if (_showTicks)
						{
							label += DecimalToShortString(_cumulativeTicks) + " Ticks" + Environment.NewLine;
						}

						if (_showBars)
						{
							label += DecimalToShortString(_cumulativeBars) + "Bars" + Environment.NewLine;
						}

						if (_showTime == TimeFormat.Days)
						{
							label += _trendDuration.ToString(@"d\d\a\y\s");
						}

						if (_showTime == TimeFormat.Exact)
						{
							if (_trendDuration.Days > 0)
								label += _trendDuration.ToString(@"d\d\a\y\s\ hh\:mm\:ss");
							else
								label += _trendDuration.ToString(@"hh\:mm\:ss");
						}

						AddText(_lastLowBar + value.ToString(), label.TrimEnd(), false, _lastLowBar, lastLowBarMin - InstrumentInfo.TickSize * VerticalOffset, 0, 0,
							ConvertColor(_textColor), System.Drawing.Color.Transparent, System.Drawing.Color.Transparent, _textSize,
							DrawingText.TextAlign.Center);
						_lastHighBar = calcBar;
					}
				}
			}

			if (bar == SourceDataSeries.Count - 1)
			{
				var candle = GetCandle(bar);
				_cumulativeVolume = 0;
				_cumulativeDelta = 0;

				if (_direction == 1)
				{
					for (var i = _lastLowBar; i <= bar; i++)
					{
						_cumulativeVolume += GetCandle(i).Volume;
						_cumulativeDelta += GetCandle(i).Delta;
						_data[i] = Linear(lastLowBarMin, candle.Close, bar - _lastLowBar + 1, i - _lastLowBar);
					}
				}
				else if (_direction == -1)
				{
					for (var i = _lastHighBar; i <= bar; i++)
					{
						_cumulativeVolume += GetCandle(i).Volume;
						_cumulativeDelta += GetCandle(i).Delta;
						_data[i] = Linear(lastHighBarMax, candle.Close, bar - _lastHighBar + 1, i - _lastHighBar);
					}
				}

				DrawLastText();
			}

			_lastBar = bar;
		}

		#endregion

		#region Private methods

		private void DrawLastText()
		{
			var renderText = "";
			var lastWave = _direction == 1 ? _lastLowBar : _lastHighBar;

			if (_showDelta)
			{
				renderText += DecimalToShortString(_cumulativeDelta) + "Δ" + Environment.NewLine;
			}

			if (_showVolume)
			{
				renderText += DecimalToShortString(_cumulativeVolume) + Environment.NewLine;
			}

			if (_showTicks)
			{
				var ticks = Math.Abs(_data[CurrentBar - 1] - _data[lastWave]) / InstrumentInfo.TickSize;
				renderText += DecimalToShortString(ticks) + " Ticks" + Environment.NewLine;
			}

			if (_showBars)
			{
				renderText += DecimalToShortString(CurrentBar - lastWave) + "Bars" + Environment.NewLine;
			}

			var duration = GetCandle(CurrentBar - 1).Time - GetCandle(lastWave).Time;

			if (_showTime == TimeFormat.Days)
			{
				renderText += duration.ToString(@"d\d\a\y\s");
			}

			if (_showTime == TimeFormat.Exact)
			{
				if (duration.Days > 0)
					renderText += duration.ToString(@"d\d\a\y\s\ hh\:mm\:ss");
				else
					renderText += duration.ToString(@"hh\:mm\:ss");
			}

			Labels["LastText"].IsAbovePrice = _direction > 0;
			Labels["LastText"].Text = renderText.TrimEnd();
			Labels["LastText"].TextPrice = _data[CurrentBar - 1] + InstrumentInfo.TickSize * VerticalOffset * _direction;
			Labels["LastText"].Bar = CurrentBar - 1;
		}

		private decimal Linear(decimal start, decimal stop, int steps, int position)
		{
			if (steps > 1)
				return start + (stop - start) * position / (steps - 1);

			return start + (stop - start) * position / steps;
		}

		private string DecimalToShortString(decimal input)
		{
			if (Math.Abs(input) > 1000000)
			{
				input /= 1000000;
				return input.ToString("0.####") + "m";
			}

			if (Math.Abs(input) > 1000)
			{
				input /= 1000;
				return input.ToString("0.####") + "k";
			}

			return input.ToString();
		}

		private System.Drawing.Color ConvertColor(CrossColor input)
		{
			return System.Drawing.Color.FromArgb(input.A, input.R, input.G, input.B);
		}

		#endregion
	}
}

















